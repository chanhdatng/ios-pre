{
  "topic": "swift",
  "generated_at": "2026-01-13T04:04:10.582258+00:00",
  "cards": [
    {
      "id": "swift_5b8fc7f45dfe",
      "front": "Describe the internal mechanics of ARC, focusing on how `weak` references are managed and the role of side tables in the Swift runtime.",
      "back": "Automatic Reference Counting (ARC) is a compile-time feature that automates memory management by inserting `retain` (increment) and `release` (decrement) calls for reference types. When an object's reference count drops to zero, it is deallocated.\n\n**Core Concept: Reference Counts & Side Tables**\nEvery Swift class instance has a header containing metadata, including its reference counts. For performance, this header has a limited size. When an object's strong reference count exceeds what the inline header can store, or when the first `weak` reference to it is created, the Swift runtime allocates a **side table** for that object. This side table stores the overflowed strong reference count and, crucially, all weak references pointing to the object.\n\nWhen an object's strong reference count becomes zero, the deallocation process begins. Before freeing the memory, the runtime checks if a side table exists. If it does, it iterates through all the registered `weak` pointers in the table and sets them to `nil`. This mechanism is what makes `weak` references safely become `nil` instead of becoming dangling pointers.\n\n**Practical Code Example:**\n```swift\nclass Author {\n    let name: String\n    var book: Book?\n    init(name: String) { self.name = name; print(\"Author \\(name) initialized\") }\n    deinit { print(\"Author \\(name) deinitialized\") }\n}\n\nclass Book {\n    let title: String\n    // Using 'weak' prevents a retain cycle with the Author\n    weak var author: Author?\n    init(title: String) { self.title = title; print(\"Book \\(title) initialized\") }\n    deinit { print(\"Book \\(title) deinitialized\") }\n}\n\nvar author: Author? = Author(name: \"J.K. Rowling\") // Author RC = 1\nvar book: Book? = Book(title: \"Stone\") // Book RC = 1\n\n// Create the relationship\nauthor?.book = book // Book RC = 2\nbook?.author = author // 'weak' reference, Author RC remains 1\n\nprint(\"Setting author to nil...\")\nauthor = nil // Author RC becomes 0 and deinitializes\n\n// Because book.author is weak, the side table mechanism nils it out.\nif book?.author == nil {\n    print(\"The book's author is now nil, retain cycle avoided.\")\n}\n\nbook = nil // Book RC becomes 0 and deinitializes\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Retain Cycles:** The most common issue, where two objects hold strong references to each other, preventing either from being deallocated. This is solved by using `weak` or `unowned` on one side of the relationship.\n- **Misusing `unowned`:** Using `unowned` implies a guarantee that the referenced object will outlive the object holding the reference. If this guarantee is violated, accessing the `unowned` reference will cause a crash. It's a micro-optimization that should be used with caution; `weak` is safer.\n- **Performance of `weak`:** Accessing a `weak` reference is slightly more expensive than a strong or `unowned` one because it requires an atomic read-modify-write operation on the side table to safely retain the object before use and then release it.",
      "code_example": null,
      "tags": [
        "memory-management",
        "arc",
        "internals",
        "performance"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.swift.org/documentation/",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "swift_112850a42615",
      "front": "Describe how you'd implement Copy-on-Write (CoW) for a custom struct. What is the role of `isKnownUniquelyReferenced(_:)`, and what are the thread-safety implications to consider?",
      "back": "Copy-on-Write (CoW) is a performance optimization that gives value types (structs) the performance characteristics of reference types for assignment operations. Instead of performing a deep copy on every assignment, the underlying storage is shared until a mutation is attempted.\n\n**Core Concept:**\nA CoW type is a struct that wraps a private class instance (the storage). When the struct is assigned to a new variable, only the reference to the storage is copied, and its reference count is incremented. This is cheap. The 'copy' is deferred until one of the struct instances is about to be mutated. Before mutating, it checks if its reference to the storage is unique using `isKnownUniquelyReferenced(&storage)`. If it is (reference count is 1), it can mutate the storage in-place. If not, it creates a new, deep copy of the storage for itself before mutating, ensuring value semantics are preserved.\n\n**Practical Code Example:**\n```swift\n// 1. The storage is a class (reference type)\nprivate final class CoWStorage<T> {\n    var value: T\n    init(_ value: T) { self.value = value }\n}\n\n// 2. The public interface is a struct (value type)\nstruct CoWBox<T> {\n    private var storage: CoWStorage<T>\n\n    init(_ value: T) {\n        self.storage = CoWStorage(value)\n    }\n\n    var value: T {\n        get { storage.value }\n        set {\n            // 3. The CoW check-and-copy logic\n            if !isKnownUniquelyReferenced(&storage) {\n                print(\"Making a copy...\")\n                storage = CoWStorage(newValue)\n                return\n            }\n            print(\"Mutating in-place...\")\n            storage.value = newValue\n        }\n    }\n}\n\nvar box1 = CoWBox([1, 2, 3]) // Initial storage\nvar box2 = box1 // Shares storage, no copy occurs\n\n// Reading doesn't trigger a copy\nprint(box2.value) // [1, 2, 3]\n\n// Mutating box2 triggers a copy because storage is shared\nbox2.value.append(4) // Prints \"Making a copy...\"\n\n// Now they have separate storage\nprint(box1.value) // [1, 2, 3]\nprint(box2.value) // [1, 2, 3, 4]\n\n// Mutating box2 again happens in-place\nbox2.value.append(5) // Prints \"Mutating in-place...\"\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Thread Safety:** `isKnownUniquelyReferenced` is NOT thread-safe. If two threads check a shared reference simultaneously, both might see `false` and proceed. Worse, if they both see `true` in a race condition, one might mutate the data while the other is reading it, causing data corruption. A proper CoW implementation requires a lock (like `NSLock` or a serial `DispatchQueue`) around the uniqueness check and subsequent copy/mutation to ensure atomicity.\n- **Accidental Retention:** If you accidentally hold a strong reference to the internal storage object elsewhere in your code, `isKnownUniquelyReferenced` will always be false, forcing a copy on every mutation and negating the performance benefit.\n\n**When to Use vs. Alternatives:**\n- **Use CoW:** For custom value types that encapsulate large, heap-allocated data (e.g., custom collections, image buffers). It provides the safety and predictability of value semantics without the high cost of copying on every assignment.\n- **Alternative (Pure Struct):** For small types composed of other value types (Int, String, etc.), a simple struct is more efficient. The overhead of reference counting and uniqueness checks is unnecessary.\n- **Alternative (Class):** Use a class when you explicitly want shared state and identity semantics, where a change in one place should be visible everywhere that holds a reference to that object (e.g., a shared network client or database connection).",
      "code_example": null,
      "tags": [
        "swift",
        "memory management",
        "performance",
        "value types",
        "concurrency"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/16-swift/power-of-swift/"
      ]
    },
    {
      "id": "swift_69325e446d81",
      "front": "Describe the implementation of a custom Property Wrapper in Swift. Explain the roles of `wrappedValue` and `projectedValue`, and how to pass arguments to the wrapper itself.",
      "back": "A custom property wrapper is created by annotating a `struct`, `class`, or `enum` with the `@propertyWrapper` attribute. This type acts as a template for managing the storage and access of a property.\n\n**Core Concepts:**\n\n1.  **`@propertyWrapper`**: This attribute tells the Swift compiler that the type is a property wrapper. The compiler then synthesizes boilerplate code at the call site, creating a backing storage instance of the wrapper type.\n\n2.  **`wrappedValue`**: This is the only required property. Its type defines the type of the property being wrapped. When you access the property (e.g., `mySettings.username`), the compiler translates this into an access of the wrapper's `wrappedValue` (e.g., `_username.wrappedValue`).\n\n3.  **`projectedValue`**: An optional property that exposes additional functionality. It is accessed using a `$` prefix on the property name (e.g., `$mySettings.username`). This is commonly used to provide a binding (SwiftUI's `@State`), a publisher (Combine's `@Published`), or other control mechanisms.\n\n4.  **Initializer (`init`)**: Arguments passed to the wrapper at the declaration site (e.g., `@UserDefault(key: \"user_name\")`) are forwarded to the wrapper's initializer, allowing for configurable behavior.\n\n**Code Example:**\nA wrapper that trims whitespace from a String and provides a projected value to check if it was modified.\n\n```swift\n@propertyWrapper\nstruct Trimmed {\n    private var value: String = \"\"\n    private(set) var wasTrimmed: Bool = false\n\n    var wrappedValue: String {\n        get { value }\n        set {\n            let trimmed = newValue.trimmingCharacters(in: .whitespacesAndNewlines)\n            self.wasTrimmed = (trimmed != newValue)\n            self.value = trimmed\n        }\n    }\n\n    // The projected value provides a way to inspect the wrapper's state.\n    var projectedValue: Bool {\n        return wasTrimmed\n    }\n\n    init(wrappedValue: String) {\n        // This init is called by the compiler.\n        self.wrappedValue = wrappedValue\n    }\n}\n\nstruct UserForm {\n    @Trimmed var username: String\n}\n\nvar form = UserForm(username: \"  ada.lovelace  \")\nprint(form.username) // \"ada.lovelace\"\nprint($form.username) // true (projectedValue reports it was trimmed)\n```\n\n**Common Pitfalls & Edge Cases:**\n\n*   **Value vs. Reference Semantics**: If the wrapper is a `struct`, it has value semantics. If it's a `class`, it has reference semantics, meaning multiple properties could share and mutate the same wrapper instance. Choose based on whether state should be shared.\n*   **Actor Isolation**: Before Swift 6, a property wrapper using `@MainActor` would implicitly make the containing type `@MainActor`. This inference is removed in Swift 6 (SE-0401), requiring explicit annotation on the containing type.\n*   **Initialization**: The wrapper is initialized *before* `self` is available in the containing type's `init`, so the wrapper's `init` cannot depend on other instance properties.\n\n**When to Use vs. Alternatives:**\n\n*   **Use When**: You need to abstract away common get/set logic, like data persistence (`UserDefaults`), validation (clamping, formatting), or thread safety. They reduce boilerplate and make intent clear at the declaration site.\n*   **Alternatives**: A computed property with a private backing store is the manual equivalent. It's more verbose but offers total control if a wrapper feels too \"magic\" or restrictive for a specific use case.",
      "code_example": null,
      "tags": [
        "swift",
        "architecture",
        "language features",
        "concurrency"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "swift_76ae4455ed48",
      "front": "How do Swift Macros transform code at compile-time, and what are the key architectural considerations when implementing one, such as its lifecycle and interaction with the Swift compiler?",
      "back": "Swift Macros provide a type-safe way to perform metaprogramming by transforming source code at compile time, eliminating boilerplate without sacrificing safety.\n\n**Core Concept & Lifecycle:**\nUnlike C-style preprocessor macros that perform simple text substitution, Swift Macros are deeply integrated with the compiler. The process is:\n1.  **Parsing:** The compiler encounters a macro usage (e.g., `@MyMacro` or `#myMacro`).\n2.  **Expansion:** It sends the relevant Abstract Syntax Tree (AST) node to a separate, sandboxed compiler plugin process.\n3.  **Transformation:** The macro implementation, using the SwiftSyntax library, analyzes the input AST and generates a new AST representing the expanded code.\n4.  **Integration:** This new AST is returned to the compiler, which replaces the original macro call and continues compilation. This sandboxed execution prevents side effects like network or file system access, ensuring build reliability.\n\n**Practical Code Example:**\nAn attached macro that adds `@Published` to all stored properties of an `ObservableObject`.\n\n```swift\n// 1. Macro Definition (in your app target)\n@attached(memberAttribute)\npublic macro AllPublished() = #externalMacro(module: \"MyMacrosPlugin\", type: \"AllPublishedMacro\")\n\n// 2. Macro Implementation (in a separate '.macro' SPM target)\nimport SwiftSyntax\nimport SwiftSyntaxMacros\n\npublic struct AllPublishedMacro: MemberAttributeMacro {\n    // Called for each member within the type decorated with @AllPublished\n    public static func expansion(\n        of node: AttributeSyntax,\n        providingAttributesFor member: some DeclSyntaxProtocol,\n        in context: some MacroExpansionContext\n    ) throws -> [AttributeSyntax] {\n        // Ensure we only apply this to stored properties, not funcs or computed vars.\n        guard member.is(VariableDeclSyntax.self) else {\n            return []\n        }\n        // Return the AST for the '@Published' attribute.\n        return [\"@Published\"]\n    }\n}\n\n// 3. Usage (in app target)\n@AllPublished\nfinal class UserViewModel: ObservableObject {\n    var username: String // -> Expands to @Published var username: String\n    var score: Int      // -> Expands to @Published var score: Int\n}\n```\n\n**Common Pitfalls:**\n*   **Non-Deterministic Output:** Creating macros with volatile output (e.g., embedding a build timestamp) can break incremental compilation. Macros should ideally be pure functions of their input AST.\n*   **Incorrect Module Setup:** Forgetting that the macro implementation must live in a separate SPM target of type `.macro`, while the definition and usage are in your main application target.\n\n**When to Use vs. Alternatives:**\n*   **Use Macros:** For complex, repetitive boilerplate that requires awareness of code structure (e.g., custom `Codable` synthesis, generating memberwise initializers, or creating type-safe URL builders).\n*   **Alternatives:**\n    *   **Functions/Generics:** The default choice for reusable logic that doesn't require syntax manipulation.\n    *   **Source Code Generation (e.g., Sourcery):** These tools run as a separate build phase and generate entire files. Macros offer better IDE integration, type safety, and more precise, localized code transformations directly within the compiler.",
      "code_example": null,
      "tags": [
        "swift",
        "macros",
        "metaprogramming",
        "compiler",
        "architecture"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "swift_3264a6b95015",
      "front": "Describe the difference in how the compiler handles `some Protocol` and `any Protocol`. How does this affect type preservation, performance, and API flexibility?",
      "back": "The core difference lies in when the concrete type is known: compile-time for `some` vs. runtime for `any`.\n\n**Core Concept: Opaque vs. Existential**\n\n`some Protocol` (Opaque Type): This is a compile-time concept. It acts as a \"reverse generic,\" where the function implementation chooses a specific, concrete return type, but hides it from the caller behind a protocol interface. The key is that for any given call, the type is static and unchanging. The compiler knows the exact underlying type, enabling direct function calls (static dispatch) and optimizations. It preserves type identity.\n\n`any Protocol` (Existential Type): This is a runtime concept. It's a special wrapper, an \"existential box,\" that can hold *any* value of *any* type conforming to the protocol. The concrete type is determined at runtime and can vary. This type erasure prevents the compiler from making optimizations, forcing it to use dynamic dispatch (v-table lookups) to call methods, which incurs a performance penalty.\n\n**Practical Code Example**\n```swift\nprotocol Vehicle {\n    func startEngine() -> String\n}\nstruct Car: Vehicle {\n    func startEngine() -> String { \"Vroom!\" }\n}\nstruct ElectricScooter: Vehicle {\n    func startEngine() -> String { \"(silent)\" }\n}\n\n// OPAQUE: Compiler knows this *always* returns a Car.\n// The return type is specific and consistent.\nfunc getCompanyCar() -> some Vehicle {\n    return Car()\n}\n\n// EXISTENTIAL: Can return different concrete types at runtime.\n// The return type is dynamic, wrapped in an 'any' box.\nfunc getRental(isEco: Bool) -> any Vehicle {\n    if isEco {\n        return ElectricScooter()\n    } else {\n        return Car()\n    }\n}\n\nlet myCar = getCompanyCar() // Type is 'some Vehicle', compiler optimizes for Car.\nlet rental = getRental(isEco: true) // Type is 'any Vehicle', calls are dynamic.\n\n// A key use case for 'any': heterogeneous collections.\nlet fleet: [any Vehicle] = [Car(), ElectricScooter()]\n```\n\n**Common Pitfalls**\n- **`some` with Conditionals**: A function returning `some Vehicle` cannot return a `Car` in one branch and an `ElectricScooter` in another. The compiler must be able to infer a single concrete return type for the entire function body.\n- **Performance**: Overusing `any` where `some` or generics would suffice leads to unnecessary dynamic dispatch and heap allocation for the existential container, impacting performance.\n- **Associated Types**: Protocols with `Self` or associated type requirements (like `Equatable`) can be difficult or impossible to use with `any` because the compiler loses the concrete type information needed to satisfy those requirements. `some` handles this perfectly.\n\n**When to Use vs. Alternatives**\n- **`some Protocol`**: Ideal for return types when you want to hide implementation details from an API consumer while guaranteeing a specific underlying type and preserving performance (e.g., SwiftUI's `some View`).\n- **`any Protocol`**: Use when you need true runtime polymorphism and type erasure, such as storing heterogeneous elements in a collection (`[any MyProtocol]`).\n- **Generics (`<T: P>`)**: The preferred choice for function *parameters*. It provides static dispatch and full type information within the function, offering the best performance and type safety.",
      "code_example": null,
      "tags": [
        "swift",
        "protocols",
        "generics",
        "type-system",
        "opaque-types",
        "existentials"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "swift_5efaf49e1e55",
      "front": "Explain how Swift's Result Builders transform a sequence of statements into a single combined value, and what key `build...` methods are required to implement a custom builder for constructing an `NSAttributedString`.",
      "back": "Result Builders are a powerful Swift feature that enables the creation of Domain-Specific Languages (DSLs) by transforming a sequence of expressions within a closure into a single combined value. The compiler achieves this by rewriting the code block into a series of calls to static methods defined on the builder type. This abstracts away the boilerplate of combining individual components, leading to cleaner, more declarative APIs, as famously seen in SwiftUI's `ViewBuilder`.\n\n**Core Concept:**\nWhen you apply a `@resultBuilder` attribute to a type, you're telling the compiler to use that type's static methods to process closures. The most fundamental method is `buildBlock(_:)`, which takes a variadic list of components and combines them. Other methods handle control flow: `buildOptional(_:)` for `if` statements without an `else`, and `buildEither(first:)`/`buildEither(second:)` for `if-else` constructs.\n\n**Practical Code Example:**\nHere\u2019s a simplified `AttributedStringBuilder` to combine strings and images.\n\n```swift\n@resultBuilder\nstruct AttributedStringBuilder {\n    // Combines multiple attributed strings into one.\n    static func buildBlock(_ components: NSAttributedString...) -> NSAttributedString {\n        let result = NSMutableAttributedString()\n        components.forEach { result.append($0) }\n        return result\n    }\n\n    // Converts a simple String into an NSAttributedString.\n    static func buildExpression(_ expression: String) -> NSAttributedString {\n        return NSAttributedString(string: expression)\n    }\n\n    // Converts a UIImage into an NSAttributedString with an attachment.\n    static func buildExpression(_ expression: UIImage) -> NSAttributedString {\n        let attachment = NSTextAttachment(image: expression)\n        return NSAttributedString(attachment: attachment)\n    }\n\n    // Handles `if` conditions without an `else`.\n    static func buildOptional(_ component: NSAttributedString?) -> NSAttributedString {\n        return component ?? NSAttributedString()\n    }\n}\n\n// Usage of the builder\nfunc makeMessage(@AttributedStringBuilder _ content: () -> NSAttributedString) -> NSAttributedString {\n    return content()\n}\n\nlet userIsLoggedIn = true\nlet profileImage = UIImage(systemName: \"person.circle.fill\")!\n\nlet message = makeMessage {\n    \"Welcome! \"\n    if userIsLoggedIn {\n        profileImage\n        \" You are logged in.\"\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Imperative Code:** You cannot place arbitrary imperative code (e.g., `let x = 5`, `for` loops with `break`) inside a result builder block. The block must consist only of expressions that the builder can process.\n- **Type Mismatches:** All `buildExpression` and `buildBlock` components must ultimately produce the same type (or a type that can be converted), otherwise, the compiler will fail with often cryptic errors.\n\n**When to use vs Alternatives:**\n- **Use When:** Creating a declarative API for building complex, hierarchical objects like UI layouts (SwiftUI), attributed strings, HTML documents, or autolayout constraints. It significantly improves readability by hiding the manual composition logic.\n- **Alternatives:**\n  - **Standard Builder Pattern:** A class-based builder with chaining methods (e.g., `builder.addText(\"...\").addImage(...)`). This is more flexible for complex logic but more verbose.\n  - **Direct Instantiation:** Manually creating an `NSMutableAttributedString` and calling `append()` repeatedly. This is the most explicit and performant method but can become unwieldy and hard to read for complex structures.",
      "code_example": null,
      "tags": [
        "swift",
        "dsl",
        "result builders",
        "swiftui",
        "architecture"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/281/what-to-fix-in-ai-generated-swift-code",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.swift.org/documentation/"
      ]
    },
    {
      "id": "swift_32865dacda56",
      "front": "Explain the fundamental trade-offs between using a generic constraint (`<T: P>`) and an existential type (`any P`). When is the dynamic dispatch and type erasure of `any P` a necessary or better choice?",
      "back": "This question probes the core difference between static and dynamic polymorphism in Swift.\n\n**Core Concept Explanation**\n\n- **Generics (`<T: P>`)**: This is *static polymorphism*. The compiler generates specialized code for each concrete type (`T`) that conforms to protocol `P` at compile time. The actual type is always known, enabling *static dispatch*. This is highly performant because the compiler can often inline method calls directly, avoiding runtime lookups. The full type information, including associated types, is preserved.\n\n- **Existential Types (`any P`)**: This is *dynamic polymorphism*. An `any P` is an existential container (a 'box') that can hold any value of any type conforming to `P`. The concrete type is not known at compile time; it's erased. To call a method, the system performs *dynamic dispatch* at runtime, using a witness table to look up the correct implementation for the stored type. This introduces a minor performance overhead and can involve heap allocation.\n\n**Practical Code Example**\n\n```swift\nprotocol Drawable {\n    func draw()\n}\n\nstruct Circle: Drawable { func draw() { print(\"Drawing a circle.\") } }\nstruct Square: Drawable { func draw() { print(\"Drawing a square.\") } }\n\n// 1. Generic Function (Static Dispatch)\n// Specialized versions for Circle and Square are created at compile time.\nfunc drawItem<T: Drawable>(_ item: T) {\n    item.draw() // Direct, performant call.\n}\ndrawItem(Circle())\n\n// 2. Existential Type (Dynamic Dispatch)\n// A heterogeneous array where concrete types are erased.\nlet shapes: [any Drawable] = [Circle(), Square()]\n\nfor shape in shapes {\n    // Runtime lookup is needed to find the correct `draw()` implementation.\n    shape.draw()\n}\n```\n\n**Common Pitfalls or Edge Cases**\n\n1.  **Performance**: The overhead of dynamic dispatch is often negligible, but in performance-critical code (e.g., a rendering loop), preferring generics can be a significant optimization.\n2.  **Associated Types & Self Requirements**: Protocols with `associatedtype` or `Self` requirements historically couldn't be used as existential types. While Swift 5.7+ has improved this, it can still be a limitation. Generics handle these constraints seamlessly because the concrete type `T` is known.\n3.  **Loss of Type Information**: When you have a value of type `any Drawable`, you can only access the members defined in the `Drawable` protocol. You lose access to `Circle`-specific properties without performing a potentially failing type cast (`if let circle = shape as? Circle`).\n\n**When to Use vs. Alternatives**\n\n- **Use Generics (`<T: P>`) when:**\n  - Performance is critical.\n  - You are working with a single, specific (though generic) conforming type at a time.\n  - The protocol has associated types or `Self` requirements.\n  - You want to preserve the full static type information.\n\n- **Use Existentials (`any P`) when:**\n  - You need to store multiple, different conforming types in a single collection (heterogeneous storage). This is the canonical use case.\n  - You need to return different concrete types conforming to a protocol from a single API endpoint, and an opaque type (`some P`) is too restrictive.",
      "code_example": null,
      "tags": [
        "swift",
        "generics",
        "protocols",
        "type erasure",
        "architecture",
        "performance"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6"
      ]
    }
  ]
}