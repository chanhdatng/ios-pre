{
  "topic": "swift",
  "generated_at": "2026-01-14T04:19:33.241959+00:00",
  "cards": [
    {
      "id": "swift_76ae4455ed48",
      "front": "How do Swift Macros differ from C-style preprocessor macros, and what are the implications for type safety, debugging, and build performance?",
      "back": "Swift Macros represent a fundamental shift from C-style preprocessor macros by operating on a structured, type-safe representation of code rather than performing raw text substitution.\n\n### Core Concept\nUnlike C macros that manipulate text before compilation, Swift Macros are a first-class language feature integrated with the compiler. They are executed in a sandbox during the build process and receive a portion of your code's Abstract Syntax Tree (AST) via the SwiftSyntax library. This allows a macro to intelligently inspect the code it's attached to\u2014understanding types, modifiers, and structure\u2014and generate new Swift code that is syntactically correct and type-checked by the compiler. This AST-level manipulation prevents entire classes of bugs common with C macros, such as variable capture, unexpected operator precedence, and generating invalid code.\n\n### Practical Code Example\nHere's an `AddAsync` macro that creates an `async` version of a function that uses a completion handler. This demonstrates a complex transformation.\n\n```swift\n// 1. Macro Definition (in your app target)\n@attached(peer, names: overloaded)\npublic macro AddAsync() = #externalMacro(module: \"MyMacrosPlugin\", type: \"AddAsyncMacro\")\n\n// 2. Macro Implementation (in a separate Swift package module)\npublic struct AddAsyncMacro: PeerMacro {\n  public static func expansion(\n    of node: AttributeSyntax,\n    providingPeersOf declaration: some DeclSyntaxProtocol,\n    in context: some MacroExpansionContext\n  ) throws -> [DeclSyntax] {\n    guard let funcDecl = declaration.as(FunctionDeclSyntax.self),\n          let completion = funcDecl.signature.input.parameterList.last,\n          // ... complex parsing logic to find completion handler ...\n    else { throw SomeError() } // Error handling is crucial\n\n    // Simplified for clarity: logic to transform params and return type\n    let newSignature = \"async throws -> String\"\n    let functionName = funcDecl.name.text\n    \n    return [\n      \"\"\"\n      func \\(raw: functionName)() \\(raw: newSignature) {\n        await withCheckedThrowingContinuation { continuation in\n          self.\\(raw: functionName) { result, error in\n            if let error { continuation.resume(throwing: error) }\n            else if let result { continuation.resume(returning: result) }\n          }\n        }\n      }\n      \"\"\"\n    ]\n  }\n}\n\n// 3. Usage\nclass NetworkService {\n  @AddAsync\n  func fetchData(completion: @escaping (String?, Error?) -> Void) {\n    // Original implementation\n  }\n  // Macro expands to add:\n  // func fetchData() async throws -> String { ... }\n}\n```\n\n### Common Pitfalls & Edge Cases\n- **Debugging:** Debugging macro expansion logic is complex. The primary tool is Xcode\u2019s \"Expand Macro\" feature to see the generated code. Writing unit tests for the macro itself is essential.\n- **Non-Determinism:** Macros should be pure functions (same input yields same output). A macro that embeds the build time, for example, can break incremental compilation by causing files to be recompiled unnecessarily on every build.\n- **Overuse:** Creating too much \"magic\" can obscure logic and increase cognitive overhead for the team. Macros are best for eliminating mechanical, repetitive boilerplate.\n\n### When to Use vs. Alternatives\n- **Use Macros When:** You need to reduce boilerplate by introspecting existing code to add new functions, conformances, or members (e.g., generating `Codable` implementations, creating `async` wrappers).\n- **Property Wrappers:** Use for augmenting the storage and access of a single property (e.g., `@Published`, `@EnvironmentObject`). They cannot add new methods to the enclosing type.\n- **Result Builders:** Ideal for creating Domain-Specific Languages (DSLs) for building complex objects from a sequence of expressions, like `ViewBuilder` in SwiftUI.\n- **External Code Generation (e.g., Sourcery):** Macros are a fully integrated alternative. They provide better diagnostics, are type-safe, and don't require configuring a separate build phase.",
      "code_example": null,
      "tags": [
        "swift",
        "macros",
        "metaprogramming",
        "compiler",
        "swiftsyntax"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "swift_5efaf49e1e55",
      "front": "Beyond SwiftUI, explain how a custom Result Builder works. Describe the compiler transformation process and the essential `build...` static methods required to support control flow statements like `if` and `if-else`.",
      "back": "A Result Builder is a type annotated with `@resultBuilder` that provides a set of static methods the Swift compiler uses to transform a sequence of expressions inside a closure into a single combined value. This syntactic sugar enables the creation of Domain-Specific Languages (DSLs).\n\n**Core Concept:**\nThe compiler rewrites the body of a closure marked with a result builder attribute into a series of calls to the builder's static methods. The most fundamental method is `buildBlock(_ components:...)`, which gathers the individual expressions into a single result. To support standard language features, other `build...` methods are required. For example, `if` statements without an `else` are transformed into a call to `buildOptional(_:)`, and `if-else` statements are transformed into calls to `buildEither(first:)` and `buildEither(second:)`.\n\n**Practical Code Example:**\nHere's a simple `AttributedStringBuilder`:\n```swift\n@resultBuilder\nstruct AttributedStringBuilder {\n    // Combines multiple attributed strings into one.\n    static func buildBlock(_ components: NSAttributedString...) -> NSAttributedString {\n        let result = NSMutableAttributedString()\n        components.forEach { result.append($0) }\n        return result\n    }\n\n    // Handles `if` statements without an `else`.\n    static func buildOptional(_ component: NSAttributedString?) -> NSAttributedString {\n        return component ?? NSAttributedString()\n    }\n\n    // Handles the `if` part of an `if-else` statement.\n    static func buildEither(first component: NSAttributedString) -> NSAttributedString {\n        return component\n    }\n\n    // Handles the `else` part of an `if-else` statement.\n    static func buildEither(second component: NSAttributedString) -> NSAttributedString {\n        return component\n    }\n}\n\nfunc makeString(isBold: Bool, @AttributedStringBuilder content: () -> NSAttributedString) -> NSAttributedString {\n    return content()\n}\n\nlet labelContent = makeString(isBold: true) {\n    NSAttributedString(string: \"Hello, \")\n    if isBold {\n        NSAttributedString(string: \"World!\", attributes: [.font: UIFont.boldSystemFont(ofSize: 12)])\n    } else {\n        NSAttributedString(string: \"World!\")\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Missing Control Flow Support:** Forgetting to implement `buildOptional`, `buildEither`, or `buildArray` (for loops) will result in compiler errors when those control flow statements are used within the builder closure.\n- **Type Mismatches:** All `build...` methods must agree on the `Component` and `FinalResult` types. Complex builders can lead to confusing type inference errors.\n- **Debugging Complexity:** The code you write is not what is executed. Debugging requires understanding the compiler transformation and stepping through the generated static method calls, which can be non-intuitive.\n\n**When to Use vs. Alternatives:**\n- **Use Result Builders:** When creating a declarative API for constructing complex, hierarchical objects (like UI views, attributed strings, or HTML documents). It improves readability by hiding boilerplate composition logic.\n- **Alternatives:**\n  - **Fluent Interface (Chaining):** `builder.add(...) .with(...)`. More explicit and better when intermediate configuration steps are needed.\n  - **Array Literals:** `[item1, item2]`. Use for simple, homogenous collections without conditional logic. A result builder is overkill here.",
      "code_example": null,
      "tags": [
        "swift",
        "dsl",
        "result builders",
        "compiler",
        "api design"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.swift.org/documentation/",
        "https://www.hackingwithswift.com/articles/281/what-to-fix-in-ai-generated-swift-code",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    },
    {
      "id": "swift_69325e446d81",
      "front": "Describe the implementation of a custom Swift Property Wrapper. Explain the roles of `wrappedValue` and `projectedValue`, and how the compiler synthesizes property access.",
      "back": "A Property Wrapper is a type that adds a layer of separation between the code that manages how a property is stored and the code that defines a property. You implement one by creating a struct, class, or enum marked with the `@propertyWrapper` attribute.\n\n**Core Concepts:**\n- `wrappedValue`: This required computed property is the core of the wrapper. Its type defines the type of the property being wrapped, and its `get` and `set` accessors contain the custom logic. When you access the property directly (e.g., `myInstance.myProperty`), you are interacting with `wrappedValue`.\n- `projectedValue`: An optional computed property that exposes additional functionality. It is accessed by prefixing the property name with a dollar sign (`$`), for example, `myInstance.$myProperty`. This is famously used by SwiftUI's `@State` to provide a `Binding`.\n\n**Compiler Synthesis:**\nWhen you declare `@MyWrapper var value: Int`, the compiler transforms it. It creates a private, backing storage property of the wrapper type (e.g., `private var _value: MyWrapper`) and synthesizes a computed property that routes access through the wrapper's `wrappedValue`.\n\n**Practical Example:**\n```swift\n// A wrapper to clamp a numeric value within a given range.\n@propertyWrapper\nstruct Clamped<Value: Comparable> {\n    private var value: Value\n    private let range: ClosedRange<Value>\n\n    init(wrappedValue: Value, _ range: ClosedRange<Value>) {\n        self.range = range\n        self.value = min(max(wrappedValue, range.lowerBound), range.upperBound)\n    }\n\n    var wrappedValue: Value {\n        get { value }\n        set { value = min(max(newValue, range.lowerBound), range.upperBound) }\n    }\n    \n    // The projected value exposes whether the current value is at its limit.\n    var projectedValue: Bool {\n        return value == range.lowerBound || value == range.upperBound\n    }\n}\n\nstruct PlayerStats {\n    // Health must be between 0 and 100.\n    @Clamped(0...100) var health: Int = 100\n}\n\nvar stats = PlayerStats()\nstats.health = 150 // Automatically clamped to 100\nprint(stats.health) // Prints \"100\"\nprint(stats.$health) // Prints \"true\", accessing the projectedValue\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Initialization:** Be mindful of initializer logic. If you provide arguments to the wrapper (e.g., `@Clamped(0...100)`), the compiler looks for a matching `init`. If you assign a default value (`var health: Int = 100`), it uses `init(wrappedValue:)`.\n- **Actor Isolation (Swift 6+):** Previously, a property wrapper using `@MainActor` (like `@StateObject`) would cause the entire enclosing type to infer `@MainActor` isolation. SE-0401 (enabled in Swift 6) removes this inference, requiring you to explicitly mark the enclosing type with `@MainActor` if needed.\n\n**When to Use vs. Alternatives:**\n- **Use When:** You have repetitive get/set logic that can be cleanly abstracted and reused across multiple properties or types (e.g., `UserDefaults` access, validation, thread-safe access).\n- **Alternatives:** For simple, non-reusable logic, a standard computed property is sufficient. For complex state management that involves more than just one property, a dedicated service or view model might be more appropriate.",
      "code_example": null,
      "tags": [
        "swift",
        "property-wrappers",
        "architecture",
        "concurrency"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    },
    {
      "id": "swift_112850a42615",
      "front": "Swift's value types (e.g., Array) exhibit reference-like performance. Explain the Copy-on-Write (CoW) mechanism that enables this, and demonstrate how you would implement it for a custom struct.",
      "back": "Copy-on-Write (CoW) is a performance optimization that gives value types the performance characteristics of reference types for read operations, while preserving value semantics. It avoids expensive deep copies by sharing the underlying data buffer between instances until one of them is mutated.\n\n**Core Concept:**\nA CoW-enabled struct wraps its storage in a private reference type (a class). When the struct is copied, only the reference to this storage is copied\u2014a cheap operation. All copies share the same underlying data. The critical logic happens just before a mutation: the struct checks if its storage reference is uniquely held using `isKnownUniquelyReferenced`. If it's not unique (i.e., it's shared), a new, deep copy of the storage is created and assigned to the current instance. The mutation then proceeds on this new, unique copy. If the reference was already unique, the data is mutated in place without any copying.\n\n**Practical Code Example:**\n```swift\n// The private reference type (Box) holding the actual data.\nprivate final class Box<T> {\n    var value: T\n    init(_ value: T) { self.value = value }\n}\n\nstruct CoWContainer<T> {\n    private var box: Box<T>\n    \n    init(_ value: T) {\n        self.box = Box(value)\n    }\n    \n    var value: T {\n        get { return box.value }\n        set {\n            // Before mutating, check if the box is uniquely referenced.\n            // If not, create a new box with a copy of the value.\n            if !isKnownUniquelyReferenced(&box) {\n                box = Box(newValue)\n                return\n            }\n            // If it is unique, mutate the value in place.\n            box.value = newValue\n        }\n    }\n}\n\n// --- Usage ---\nvar a = CoWContainer([1, 2, 3])\nvar b = a // Cheap copy: 'a' and 'b' share the same Box instance.\n\n// Mutating 'b' triggers the copy.\nb.value.append(4)\n\nprint(a.value) // Output: [1, 2, 3] (unaffected)\nprint(b.value) // Output: [1, 2, 3, 4] (has its own copy)\n```\n\n**Common Pitfalls:**\n- **Thread Safety:** `isKnownUniquelyReferenced` is NOT thread-safe. If a CoW type is used across multiple threads, you must implement your own locking (e.g., a serial queue or `NSLock`) around the uniqueness check and copy operation to prevent race conditions.\n- **Incorrect Implementation:** Forgetting to make the storage class `final` can allow subclassing, which may break assumptions about object identity. The check must happen inside a `mutating` method or a property's `set` or `_modify` accessor.\n\n**When to Use vs. Alternatives:**\n- **Use CoW:** For value types that hold large data (like collections) which are frequently read but infrequently modified. It provides the safety of value semantics without the performance cost of constant deep copying.\n- **Alternatives:** Use simple structs for small data where a direct copy is cheap. Use classes when you explicitly need reference semantics and shared mutable state.",
      "code_example": null,
      "tags": [
        "swift",
        "performance",
        "memory management",
        "value types",
        "structs"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6"
      ]
    },
    {
      "id": "swift_3264a6b95015",
      "front": "Contrast `some Protocol` (opaque types) and `any Protocol` (existential types) in Swift. Discuss their impact on type identity, compiler optimizations (static vs. dynamic dispatch), and their primary use cases.",
      "back": "### Core Concept\n`some Protocol` (Opaque Type) is a compile-time promise to return a value of a *single, consistent, concrete type* that conforms to the protocol. The specific type is hidden from the caller but known to the compiler and the function's implementation. This preserves type identity, allowing the compiler to perform optimizations like static dispatch and elide the need for a separate container.\n\n`any Protocol` (Existential Type) is a type-erased wrapper (an \"existential container\") that can hold a value of *any* concrete type conforming to the protocol. The specific underlying type is determined at runtime. This flexibility comes at a cost: it breaks type identity from the compiler's perspective, forcing dynamic dispatch (looking up the method implementation at runtime) and often requiring heap allocation for the container. The `any` keyword (explicit since Swift 5.6) makes this performance trade-off visible.\n\n### Practical Code Example\n```swift\nprotocol Shape {\n    func area() -> Double\n}\n\nstruct Square: Shape { func area() -> Double { return 4.0 } }\nstruct Circle: Shape { func area() -> Double { return 3.14 } }\n\n// OPAQUE TYPE: Guarantees ONE specific, concrete type is always returned.\n// The compiler knows the exact type, enabling static dispatch.\nfunc createSpecificShape() -> some Shape {\n    return Square()\n    // ERROR: if Bool.random() { return Square() } else { return Circle() }\n}\n\n// EXISTENTIAL TYPE: Can return ANY concrete type that conforms.\n// The compiler only knows it's a box holding a 'Shape', requiring dynamic dispatch.\nfunc createRandomShape() -> any Shape {\n    return Bool.random() ? Square() : Circle()\n}\n\n// Use case for 'any': Heterogeneous collections\nlet mixedShapes: [any Shape] = [Square(), Circle(), createRandomShape()]\n\n// This would be impossible with `some Shape` because the collection needs\n// to store elements of a single, uniform type.\n```\n\n### Common Pitfalls & Edge Cases\n- **Inconsistent `some` Returns**: A function returning `some Protocol` must return the exact same concrete type from all its exit points. The compiler enforces this.\n- **Performance Blindness**: Defaulting to `any Protocol` without considering the performance overhead of dynamic dispatch and heap allocation. Generics or `some` are often better.\n- **Associated Types**: Protocols with `associatedtype`s cannot be used as standalone existential types (`any P`) without further constraints, as the compiler doesn't know which concrete associated type to use.\n\n### When to Use vs. Alternatives\n- **`some Protocol`**: Primarily for return types to hide implementation details while maintaining performance and type safety. SwiftUI's `var body: some View` is the canonical example.\n- **`any Protocol`**: When you explicitly need runtime polymorphism, especially for storing different conforming types in a single heterogeneous collection (e.g., `[any Shape]`).\n- **Generics (`<T: P>`)**: The preferred choice for function inputs. It preserves the exact type, offers the best performance (static dispatch), and allows you to enforce relationships between parameters.",
      "code_example": null,
      "tags": [
        "swift",
        "protocols",
        "type-system",
        "generics",
        "performance",
        "some",
        "any"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6"
      ]
    },
    {
      "id": "swift_32865dacda56",
      "front": "Contrast a generic function `<T: P>(value: T)` with one using an existential `(value: any P)`. Discuss the trade-offs in performance, type safety, and API design, and when you'd choose one over the other.",
      "back": "Generics and existentials are two ways to write code against protocol abstractions, but they have fundamental differences in how they are handled by the compiler and at runtime.\n\n**Core Concept Explanation**\n- **Generics (`<T: P>`):** This is a compile-time mechanism. When you call a generic function, the compiler creates a specialized, concrete version of that function for the specific type `T` being used. This process allows for *static dispatch*, where the exact method implementation to be called is known at compile time. This is highly performant and preserves the full type information of `T` within the function's scope.\n\n- **Existential Types (`any P`):** An existential is a runtime concept. `any P` creates a special storage box called an \"existential container\" that can hold *any* value of a type conforming to protocol `P`. The compiler doesn't know the concrete type at compile time; this is determined at runtime. This necessitates *dynamic dispatch*, where the program must perform a lookup (e.g., via a v-table) to find the correct method implementation. This adds overhead and is less performant. The `any` keyword makes this type-erasure explicit.\n\n**Practical Code Example**\n```swift\nprotocol Shape {\n    func area() -> Double\n}\n\nstruct Circle: Shape {\n    var radius: Double\n    func area() -> Double { .pi * radius * radius }\n}\n\nstruct Square: Shape {\n    var side: Double\n    func area() -> Double { side * side }\n}\n\n// 1. Generic function (Static Dispatch, performant)\n// The compiler knows the exact type of 'shape'.\nfunc printArea<T: Shape>(of shape: T) {\n    print(\"Area (Generic): \\(shape.area())\")\n}\n\n// 2. Existential function (Dynamic Dispatch, flexible)\n// The compiler only knows 'shape' is 'some Shape', not its concrete type.\nfunc printAnyArea(of shape: any Shape) {\n    print(\"Area (Existential): \\(shape.area())\")\n}\n\nlet circle = Circle(radius: 10)\nprintArea(of: circle) // Specialized for Circle at compile time\n\n// The primary use case for existentials: heterogeneous collections\nlet shapes: [any Shape] = [circle, Square(side: 5)]\nfor s in shapes {\n    printAnyArea(of: s) // Required for mixed-type arrays\n    // printArea(of: s) // COMPILE ERROR: 's' is 'any Shape', not a specific 'T'\n}\n```\n\n**Common Pitfalls or Edge Cases**\n- **Performance Trap:** Overusing `any P` in performance-sensitive code can lead to significant slowdowns due to dynamic dispatch and allocation overhead for the existential container.\n- **Type Information Loss:** Inside a function accepting `any P`, you lose the specific type. You cannot access properties or methods unique to the concrete type (e.g., `circle.radius`) without a potentially failing cast (`if let c = shape as? Circle`).\n- **Protocols with Associated Types (PATs):** Until recently, PATs could not be used as a standalone existential type, requiring manual type erasure. While improved, they still have limitations compared to generics.\n\n**When to Use vs. Alternatives**\n- **Choose Generics:** This should be your default. Use them for performance-critical code, when working with homogeneous data, and when you need to maintain the concrete type identity within your logic.\n- **Choose Existentials:** Use them when you need to store different types that conform to the same protocol in a single collection (heterogeneous storage). This is their killer feature.\n- **Alternative (`some P`):** For return types, an opaque type `some P` is often better than `any P`. It still hides the concrete type from the caller but guarantees that for any given call, there is a *single, specific* underlying type, allowing the compiler to retain type identity and perform optimizations.",
      "code_example": null,
      "tags": [
        "generics",
        "protocols",
        "type-erasure",
        "performance",
        "architecture",
        "existentials"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6"
      ]
    },
    {
      "id": "swift_5b8fc7f45dfe",
      "front": "Explain how ARC manages memory for class instances, focusing on its compile-time and runtime behavior. How do closure capture lists, particularly `[weak self]`, interact with this mechanism to prevent retain cycles?",
      "back": "Automatic Reference Counting (ARC) is a compile-time feature that automates memory management for class instances in Swift. Its goal is to free developers from manual `retain` and `release` calls while providing deterministic and predictable performance, unlike traditional garbage collection.\n\n**Core Concept:**\nAt its core, ARC works by tracking the number of strong references to any given class instance. This is done via a reference count stored with the object's metadata on the heap.\n1.  **Compile-Time:** The Swift compiler analyzes your code to determine the lifetime of objects. It automatically inserts `swift_retain` (increment count) and `swift_release` (decrement count) calls into the compiled code. A retain is added when a new strong reference is created (e.g., assignment to a variable). A release is added when a reference goes out of scope.\n2.  **Runtime:** When an object's reference count drops to zero, no strong references are pointing to it. The object is immediately deallocated, and its `deinit` method is called. This deterministic behavior is a key advantage over garbage collectors, which can introduce unpredictable pauses.\n\nClosures are a common source of retain cycles because they can capture and store references to objects. If a class instance holds a strong reference to a closure, and that closure captures a strong reference back to the instance (`self`), neither can be deallocated.\n\n**Practical Code Example:**\n```swift\nclass NetworkManager {\n    var onDataReceived: ((Data) -> Void)?\n\n    func fetchData() {\n        // Simulating a network call\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in\n            // Use `guard let` to create a temporary strong reference to self.\n            // This prevents self from being deallocated mid-execution.\n            guard let self = self else { return }\n            \n            let data = Data()\n            // Without `[weak self]`, this closure would strongly capture `self`,\n            // creating a retain cycle: NetworkManager -> onDataReceived -> self.\n            self.onDataReceived?(data)\n        }\n    }\n\n    deinit {\n        print(\"NetworkManager deallocated\")\n    }\n}\n\n// Usage:\nvar manager: NetworkManager? = NetworkManager()\nmanager?.onDataReceived = { data in\n    print(\"Data received: \\(data.count) bytes\")\n}\nmanager?.fetchData()\nmanager = nil // Without `[weak self]`, deinit would not be called.\n```\n\n**Common Pitfalls:**\n- **Forgetting `[weak self]`:** This is the most common cause of retain cycles, especially in asynchronous callbacks or closures assigned to properties.\n- **Misusing `unowned`:** Using `unowned self` when `self` could become `nil` will lead to a runtime crash. `weak` is almost always the safer choice.\n- **Implicit `self`:** Forgetting that calling instance methods or properties inside a closure (e.g., `self.myMethod()` or just `myMethod()`) implicitly captures `self` strongly if not specified otherwise in a capture list.\n\n**When to Use:**\n- **`strong` (default):** For clear ownership hierarchies where one object's lifetime is meant to control another's.\n- **`[weak self]`:** When the captured object (`self`) has a shorter or independent lifetime than the closure. Essential for delegates, callbacks, and properties that are closures.\n- **`[unowned self]`:** Only when you can absolutely guarantee that `self` will outlive the closure. It provides a minor performance benefit by avoiding optional handling but is fundamentally unsafe if that guarantee is violated.",
      "code_example": null,
      "tags": [
        "swift",
        "memory management",
        "arc",
        "closures",
        "retain cycle"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.swift.org/documentation/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2"
      ]
    }
  ]
}