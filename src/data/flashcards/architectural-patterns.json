{
  "topic": "architectural-patterns",
  "title": "Architectural Patterns: Clean Architecture, VIPER & TCA",
  "description": "Advanced architecture patterns for large-scale iOS apps",
  "cards": [
    {
      "id": "arch_001",
      "front": "Compare MVVM, Clean Architecture, and The Composable Architecture (TCA). When would you use each?",
      "back": "**Architecture Comparison:**\n\n**MVVM (Model-View-ViewModel)**\n```swift\nclass ProfileViewModel: ObservableObject {\n    @Published var user: User?\n    @Published var isLoading = false\n    \n    func loadUser() {\n        isLoading = true\n        api.fetchUser { [weak self] user in\n            self?.user = user\n            self?.isLoading = false\n        }\n    }\n}\n\nstruct ProfileView: View {\n    @StateObject var viewModel = ProfileViewModel()\n    var body: some View {\n        if viewModel.isLoading { ProgressView() }\n        else { Text(viewModel.user?.name ?? \"\") }\n    }\n}\n```\n- **Complexity:** Low\n- **Testability:** Medium (mock dependencies)\n- **Best for:** Small-medium apps, rapid development\n- **Drawback:** Business logic can leak into ViewModel\n\n**Clean Architecture**\n```\n┌─────────────────────────────────────┐\n│           Presentation              │ ← ViewModels, Views\n├─────────────────────────────────────┤\n│            Use Cases                │ ← Business logic\n├─────────────────────────────────────┤\n│             Domain                  │ ← Entities, protocols\n├─────────────────────────────────────┤\n│              Data                   │ ← Repositories, API\n└─────────────────────────────────────┘\n```\n```swift\n// Use Case - Pure business logic\nclass FetchUserUseCase {\n    private let repository: UserRepositoryProtocol\n    \n    func execute(id: String) async throws -> User {\n        try await repository.getUser(id: id)\n    }\n}\n```\n- **Complexity:** High\n- **Testability:** Excellent (each layer testable)\n- **Best for:** Large enterprise apps, long-term maintenance\n- **Drawback:** Boilerplate, over-engineering for small apps\n\n**The Composable Architecture (TCA)**\n```swift\n@Reducer\nstruct ProfileFeature {\n    @ObservableState\n    struct State: Equatable {\n        var user: User?\n        var isLoading = false\n    }\n    \n    enum Action {\n        case loadUser\n        case userLoaded(User)\n    }\n    \n    @Dependency(\\.userClient) var userClient\n    \n    var body: some ReducerOf<Self> {\n        Reduce { state, action in\n            switch action {\n            case .loadUser:\n                state.isLoading = true\n                return .run { send in\n                    let user = try await userClient.fetch()\n                    await send(.userLoaded(user))\n                }\n            case .userLoaded(let user):\n                state.isLoading = false\n                state.user = user\n                return .none\n            }\n        }\n    }\n}\n```\n- **Complexity:** Medium-High (learning curve)\n- **Testability:** Excellent (deterministic, time-travel debugging)\n- **Best for:** Complex state management, SwiftUI apps\n- **Drawback:** Verbose, overkill for simple screens\n\n**Decision Matrix:**\n\n| Factor | MVVM | Clean Arch | TCA |\n|--------|------|------------|-----|\n| Team size | 1-5 | 5-20+ | 3-15 |\n| App complexity | Low-Med | High | Med-High |\n| SwiftUI focus | ✓ | ✓ | ✓✓✓ |\n| Testing priority | Med | High | High |\n| Learning curve | Low | Med | High |",
      "tags": ["mvvm", "clean-architecture", "tca", "architecture", "comparison"],
      "sources": ["https://www.pointfree.co/collections/composable-architecture"],
      "summary": "MVVM: simple, fast dev. Clean Architecture: enterprise, testable layers. TCA: SwiftUI, deterministic state, complex flows."
    },
    {
      "id": "arch_002",
      "front": "Design a complex multi-screen checkout flow using The Composable Architecture. Show how you'd handle state sharing between screens and navigation.",
      "back": "**TCA Checkout Flow:**\n\n```swift\n// MARK: - Parent Feature (Coordinator)\n@Reducer\nstruct CheckoutFeature {\n    @ObservableState\n    struct State: Equatable {\n        var cart: Cart\n        var path = StackState<Path.State>()\n        \n        // Shared state across screens\n        var shippingAddress: Address?\n        var paymentMethod: PaymentMethod?\n    }\n    \n    enum Action {\n        case path(StackAction<Path.State, Path.Action>)\n        case startCheckout\n        case completeOrder\n    }\n    \n    @Reducer\n    enum Path {\n        case address(AddressFeature)\n        case payment(PaymentFeature)\n        case review(ReviewFeature)\n    }\n    \n    var body: some ReducerOf<Self> {\n        Reduce { state, action in\n            switch action {\n            case .startCheckout:\n                state.path.append(.address(AddressFeature.State()))\n                return .none\n                \n            // Handle child completion\n            case .path(.element(id: _, action: .address(.addressConfirmed(let address)))):\n                state.shippingAddress = address\n                state.path.append(.payment(PaymentFeature.State()))\n                return .none\n                \n            case .path(.element(id: _, action: .payment(.paymentConfirmed(let method)))):\n                state.paymentMethod = method\n                state.path.append(.review(ReviewFeature.State(\n                    cart: state.cart,\n                    address: state.shippingAddress!,\n                    payment: state.paymentMethod!\n                )))\n                return .none\n                \n            case .path(.element(id: _, action: .review(.orderPlaced))):\n                return .send(.completeOrder)\n                \n            default:\n                return .none\n            }\n        }\n        .forEach(\\.path, action: \\.path)\n    }\n}\n\n// MARK: - Address Screen\n@Reducer\nstruct AddressFeature {\n    @ObservableState\n    struct State: Equatable {\n        var street = \"\"\n        var city = \"\"\n        var zip = \"\"\n        var isValid: Bool { !street.isEmpty && !city.isEmpty && zip.count == 5 }\n    }\n    \n    enum Action: BindableAction {\n        case binding(BindingAction<State>)\n        case confirmTapped\n        case addressConfirmed(Address)  // Sent to parent\n    }\n    \n    var body: some ReducerOf<Self> {\n        BindingReducer()\n        Reduce { state, action in\n            switch action {\n            case .confirmTapped:\n                let address = Address(street: state.street, city: state.city, zip: state.zip)\n                return .send(.addressConfirmed(address))\n            default:\n                return .none\n            }\n        }\n    }\n}\n\n// MARK: - View\nstruct CheckoutView: View {\n    @Bindable var store: StoreOf<CheckoutFeature>\n    \n    var body: some View {\n        NavigationStack(path: $store.scope(state: \\.path, action: \\.path)) {\n            CartView(cart: store.cart)\n                .toolbar {\n                    Button(\"Checkout\") { store.send(.startCheckout) }\n                }\n        } destination: { store in\n            switch store.case {\n            case .address(let store):\n                AddressView(store: store)\n            case .payment(let store):\n                PaymentView(store: store)\n            case .review(let store):\n                ReviewView(store: store)\n            }\n        }\n    }\n}\n```\n\n**Key Patterns:**\n1. **StackState** for navigation stack\n2. **Child actions bubble up** to parent for coordination\n3. **Shared state** lives in parent, passed to children\n4. **Each screen is isolated** but communicates via actions",
      "tags": ["tca", "navigation", "checkout", "state-management", "composable"],
      "sources": ["https://www.pointfree.co/collections/composable-architecture/navigation"],
      "summary": "Parent holds shared state + StackState navigation. Child actions bubble up. Parent coordinates flow. Each screen isolated with own reducer."
    },
    {
      "id": "arch_003",
      "front": "You're joining a team using Clean Architecture. A new feature requires coordinating three separate entities. How do you handle this without creating massive use cases?",
      "back": "**Coordinating Multiple Entities in Clean Architecture:**\n\n**Problem: Feature touches Order, Payment, Inventory**\n```swift\n// BAD: Massive use case\nclass ProcessOrderUseCase {\n    func execute() async throws {\n        // 200+ lines touching all three domains\n        let order = try await orderRepo.create(...)\n        let payment = try await paymentRepo.charge(...)\n        let inventory = try await inventoryRepo.reserve(...)\n        // Rollback logic, notifications, logging...\n    }\n}\n```\n\n**Solution 1: Orchestrator Pattern**\n```swift\n// Small, focused use cases\nclass CreateOrderUseCase {\n    func execute(cart: Cart) async throws -> Order { ... }\n}\n\nclass ProcessPaymentUseCase {\n    func execute(order: Order, method: PaymentMethod) async throws -> Payment { ... }\n}\n\nclass ReserveInventoryUseCase {\n    func execute(items: [CartItem]) async throws -> Reservation { ... }\n}\n\n// Orchestrator coordinates (lives in Application/Presentation layer)\nclass CheckoutOrchestrator {\n    private let createOrder: CreateOrderUseCase\n    private let processPayment: ProcessPaymentUseCase\n    private let reserveInventory: ReserveInventoryUseCase\n    \n    func checkout(cart: Cart, payment: PaymentMethod) async throws -> OrderResult {\n        // Step 1: Reserve inventory first (can fail gracefully)\n        let reservation = try await reserveInventory.execute(items: cart.items)\n        \n        do {\n            // Step 2: Create order\n            let order = try await createOrder.execute(cart: cart)\n            \n            // Step 3: Process payment\n            let payment = try await processPayment.execute(order: order, method: payment)\n            \n            return OrderResult(order: order, payment: payment)\n        } catch {\n            // Rollback: release inventory\n            try? await reserveInventory.release(reservation)\n            throw error\n        }\n    }\n}\n```\n\n**Solution 2: Domain Events**\n```swift\n// Use cases emit events, handlers react\nprotocol DomainEvent {}\n\nstruct OrderCreated: DomainEvent {\n    let order: Order\n}\n\nstruct PaymentProcessed: DomainEvent {\n    let payment: Payment\n    let orderId: String\n}\n\n// Event bus coordinates\nclass EventBus {\n    func publish<E: DomainEvent>(_ event: E) async {\n        for handler in handlers[E.self] ?? [] {\n            await handler.handle(event)\n        }\n    }\n}\n\n// Handlers are separate, focused\nclass InventoryHandler: EventHandler<OrderCreated> {\n    func handle(_ event: OrderCreated) async {\n        try? await inventoryService.reserve(event.order.items)\n    }\n}\n\nclass NotificationHandler: EventHandler<PaymentProcessed> {\n    func handle(_ event: PaymentProcessed) async {\n        await notificationService.sendReceipt(event.orderId)\n    }\n}\n```\n\n**Solution 3: Saga Pattern (for complex flows)**\n```swift\n// For long-running, multi-step processes with compensation\nclass CheckoutSaga {\n    enum Step { case reserveInventory, createOrder, processPayment, complete }\n    \n    private var currentStep: Step = .reserveInventory\n    private var completedSteps: [Step] = []\n    \n    func execute() async throws {\n        do {\n            try await executeStep(.reserveInventory)\n            try await executeStep(.createOrder)\n            try await executeStep(.processPayment)\n            currentStep = .complete\n        } catch {\n            await compensate()\n            throw error\n        }\n    }\n    \n    private func compensate() async {\n        // Rollback in reverse order\n        for step in completedSteps.reversed() {\n            await rollback(step)\n        }\n    }\n}\n```\n\n**Choose Based On:**\n- **Orchestrator:** Simple coordination, synchronous flow\n- **Domain Events:** Loose coupling, async reactions\n- **Saga:** Long-running, needs compensation/rollback",
      "tags": ["clean-architecture", "orchestrator", "domain-events", "saga", "use-cases"],
      "sources": ["https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"],
      "summary": "Keep use cases small. Use Orchestrator for coordination. Domain Events for loose coupling. Saga for complex flows with rollback."
    },
    {
      "id": "arch_004",
      "front": "VIPER has 7+ components. When does this become a liability instead of an asset? How would you know when to simplify?",
      "back": "**VIPER Components:**\n```\nView ← Presenter ← Interactor\n              ↓\n           Router\n              ↓\n           Entity\n```\n\n**Signs VIPER is Overkill:**\n\n**1. Simple CRUD Screen**\n```swift\n// VIPER for a static \"About\" screen?\n// 7 files for displaying 3 labels is madness\n\n// AboutView.swift\n// AboutPresenter.swift\n// AboutInteractor.swift\n// AboutRouter.swift\n// AboutProtocols.swift\n// AboutEntity.swift\n// AboutBuilder.swift\n\n// Just use a simple SwiftUI view!\nstruct AboutView: View {\n    var body: some View {\n        Text(\"Version 1.0\")\n    }\n}\n```\n\n**2. Metrics to Watch:**\n\n| Metric | Healthy VIPER | VIPER Overhead |\n|--------|---------------|----------------|\n| Files per feature | 5-7 | 10+ |\n| Lines in Presenter | 50-200 | 20 or 500+ |\n| Interactor has logic | Yes | Just passes data |\n| Router navigates | Yes | Single destination |\n\n**3. Red Flags:**\n```swift\n// Presenter just forwards to View\nclass ProfilePresenter: ProfilePresenterProtocol {\n    func viewDidLoad() {\n        let user = interactor.getUser()\n        view?.display(user)  // That's it?\n    }\n}\n\n// Interactor has no business logic\nclass ProfileInteractor: ProfileInteractorProtocol {\n    func getUser() -> User {\n        return repository.currentUser  // Just a getter?\n    }\n}\n```\n\n**When to Simplify:**\n\n**Option 1: MVVM for Simple Screens**\n```swift\n// Instead of 7 VIPER files:\nclass ProfileViewModel: ObservableObject {\n    @Published var user: User?\n    \n    func loadUser() {\n        user = repository.currentUser\n    }\n}\n```\n\n**Option 2: VIP (Clean Swift) - Lighter**\n```swift\n// Remove Router for single-screen features\n// Combine View+Presenter into ViewController\nclass ProfileViewController: UIViewController {\n    var interactor: ProfileInteractorProtocol!\n    \n    override func viewDidLoad() {\n        interactor.fetchUser()\n    }\n    \n    func display(user: User) {\n        nameLabel.text = user.name\n    }\n}\n```\n\n**Option 3: Hybrid Approach**\n```swift\n// VIPER for complex flows (checkout, onboarding)\n// MVVM for simple screens (settings, profile)\n// SwiftUI View for static content (about, help)\n\nstruct ArchitectureDecision {\n    static func choose(for feature: Feature) -> Architecture {\n        switch feature.complexity {\n        case .static: return .swiftUIView\n        case .simple: return .mvvm\n        case .medium: return .vip\n        case .complex: return .viper\n        }\n    }\n}\n```\n\n**Rule of Thumb:**\nIf your Interactor is just calling repository methods without transformation, and your Presenter is just forwarding to View, VIPER is too heavy.",
      "tags": ["viper", "architecture", "complexity", "simplification", "mvvm"],
      "sources": ["https://www.objc.io/issues/13-architecture/viper/"],
      "summary": "VIPER overhead: pass-through Presenter/Interactor, 10+ files for simple screen. Simplify: MVVM for simple, VIPER for complex flows only."
    },
    {
      "id": "arch_005",
      "front": "Design an app using Clean Architecture where business logic is framework-independent. How do you test a use case without mocking iOS-specific code?",
      "back": "**Framework-Independent Business Logic:**\n\n**Key Principle:** Domain layer has ZERO iOS imports\n\n```swift\n// MARK: - Domain Layer (Pure Swift)\n// NO: import UIKit, import SwiftUI, import Combine\n\n// Entity\nstruct User: Equatable {\n    let id: String\n    let name: String\n    let email: String\n}\n\n// Repository Protocol (Dependency Inversion)\nprotocol UserRepository {\n    func getUser(id: String) async throws -> User\n    func saveUser(_ user: User) async throws\n}\n\n// Use Case (Pure Business Logic)\nclass UpdateUserProfileUseCase {\n    private let repository: UserRepository\n    private let validator: ProfileValidator\n    \n    init(repository: UserRepository, validator: ProfileValidator = ProfileValidator()) {\n        self.repository = repository\n        self.validator = validator\n    }\n    \n    func execute(userId: String, newName: String, newEmail: String) async throws -> User {\n        // Business rules - no iOS code!\n        guard validator.isValidName(newName) else {\n            throw ProfileError.invalidName\n        }\n        guard validator.isValidEmail(newEmail) else {\n            throw ProfileError.invalidEmail\n        }\n        \n        var user = try await repository.getUser(id: userId)\n        user = User(id: user.id, name: newName, email: newEmail)\n        try await repository.saveUser(user)\n        \n        return user\n    }\n}\n\n// Validator (Also pure Swift)\nstruct ProfileValidator {\n    func isValidName(_ name: String) -> Bool {\n        name.count >= 2 && name.count <= 50\n    }\n    \n    func isValidEmail(_ email: String) -> Bool {\n        email.contains(\"@\") && email.contains(\".\")\n    }\n}\n```\n\n**Testing WITHOUT iOS:**\n```swift\n// MARK: - Tests (Pure Swift, no iOS mocking)\nimport XCTest\n\nclass UpdateUserProfileUseCaseTests: XCTestCase {\n    \n    // Simple mock - no iOS frameworks\n    class MockUserRepository: UserRepository {\n        var users: [String: User] = [:]\n        var saveCallCount = 0\n        \n        func getUser(id: String) async throws -> User {\n            guard let user = users[id] else {\n                throw RepositoryError.notFound\n            }\n            return user\n        }\n        \n        func saveUser(_ user: User) async throws {\n            users[user.id] = user\n            saveCallCount += 1\n        }\n    }\n    \n    func testUpdateProfile_ValidInput_SavesUser() async throws {\n        // Arrange\n        let repo = MockUserRepository()\n        repo.users[\"123\"] = User(id: \"123\", name: \"Old\", email: \"old@test.com\")\n        let useCase = UpdateUserProfileUseCase(repository: repo)\n        \n        // Act\n        let result = try await useCase.execute(\n            userId: \"123\",\n            newName: \"New Name\",\n            newEmail: \"new@test.com\"\n        )\n        \n        // Assert\n        XCTAssertEqual(result.name, \"New Name\")\n        XCTAssertEqual(result.email, \"new@test.com\")\n        XCTAssertEqual(repo.saveCallCount, 1)\n    }\n    \n    func testUpdateProfile_InvalidEmail_ThrowsError() async {\n        let repo = MockUserRepository()\n        repo.users[\"123\"] = User(id: \"123\", name: \"Test\", email: \"test@test.com\")\n        let useCase = UpdateUserProfileUseCase(repository: repo)\n        \n        do {\n            _ = try await useCase.execute(\n                userId: \"123\",\n                newName: \"Valid\",\n                newEmail: \"invalid-email\"  // No @ symbol\n            )\n            XCTFail(\"Should throw\")\n        } catch {\n            XCTAssertEqual(error as? ProfileError, .invalidEmail)\n        }\n    }\n}\n```\n\n**Data Layer (iOS-specific, separate)**\n```swift\n// MARK: - Data Layer (Can use iOS frameworks)\nimport Foundation\n\nclass APIUserRepository: UserRepository {\n    private let session: URLSession\n    \n    func getUser(id: String) async throws -> User {\n        let url = URL(string: \"https://api.example.com/users/\\(id)\")!\n        let (data, _) = try await session.data(from: url)\n        return try JSONDecoder().decode(User.self, from: data)\n    }\n    \n    func saveUser(_ user: User) async throws {\n        // URLSession implementation\n    }\n}\n```\n\n**Benefits:**\n- Use cases run in Xcode tests without simulator\n- Tests are fast (no network, no disk)\n- Business logic portable to other platforms\n- Easy to reason about (pure functions)",
      "tags": ["clean-architecture", "testing", "use-cases", "dependency-inversion", "pure-swift"],
      "sources": ["https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"],
      "summary": "Domain layer: zero iOS imports. Use protocols for dependencies. Tests use simple mocks, no iOS simulator needed. Fast, portable, pure Swift."
    }
  ]
}
