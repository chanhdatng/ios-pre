{
  "topic": "security",
  "generated_at": "2026-01-14T04:19:33.242034+00:00",
  "cards": [
    {
      "id": "security_b2f1eb5efae8",
      "front": "You're architecting an app that handles sensitive PII. Describe your end-to-end encryption strategy, covering data in transit and at rest. Detail which native iOS frameworks you'd use for each and why.",
      "back": "A robust encryption strategy must address data both as it moves across the network (in transit) and while it's stored on the device (at rest).\n\n**Data in Transit:**\nAll network communication must use HTTPS, enforced by App Transport Security (ATS). For high-security applications, I'd implement certificate pinning. This mitigates man-in-the-middle (MITM) attacks by ensuring the app only trusts a specific, hardcoded server certificate, rather than any certificate signed by a trusted CA.\n\n**Data at Rest:**\nThe approach depends on the data size.\n1.  **Small Secrets (Tokens, Passwords, Keys):** The iOS Keychain is the only appropriate place. It's a hardware-backed, encrypted database managed by the OS. I'd use specific accessibility attributes, like `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`, to ensure data is only available when the device is unlocked.\n\n2.  **Large Data (Files, Databases):** For large files or a Core Data store, I'd use `CryptoKit` for manual, file-level encryption. The process involves generating a unique symmetric key for each file, encrypting the file with it, and storing that symmetric key securely in the Keychain. This is a form of envelope encryption.\n\n**Practical Example (CryptoKit):**\n```swift\nimport CryptoKit\n\nfunc encrypt(data: Data) throws -> (sealedBox: AES.GCM.SealedBox, key: SymmetricKey) {\n    // 1. Generate a new, cryptographically secure symmetric key for this specific data.\n    let symmetricKey = SymmetricKey(size: .bits256)\n    \n    // 2. Encrypt the data using an authenticated encryption algorithm like AES-GCM.\n    // This provides both confidentiality and integrity.\n    let sealedBox = try AES.GCM.seal(data, using: symmetricKey)\n    \n    // 3. The key must now be stored securely (e.g., in the Keychain).\n    // The sealedBox (containing ciphertext, nonce, and tag) can be written to disk.\n    return (sealedBox, symmetricKey)\n}\n\nfunc decrypt(sealedBox: AES.GCM.SealedBox, key: SymmetricKey) throws -> Data {\n    // Decrypt using the same key that was used for encryption.\n    let decryptedData = try AES.GCM.open(sealedBox, using: key)\n    return decryptedData\n}\n```\n\n**Common Pitfalls:**\n*   **Storing keys in `UserDefaults` or hardcoding them in the source.** This is a critical vulnerability.\n*   **Rolling your own cryptography.** Always use standard, vetted libraries like CryptoKit.\n*   **Ignoring key management.** Keys should have a defined lifecycle, including rotation and revocation.\n\n**When to Use vs. Alternatives:**\n*   **`CryptoKit` vs. `CommonCrypto`:** Prefer `CryptoKit` for its modern, Swift-native, and safer APIs. Use `CommonCrypto` (a C-level API) only if you need algorithms not available in CryptoKit or for specific interoperability reasons.\n*   **Manual Encryption vs. `NSFileProtection`:** Apple's built-in file protection is easy to enable but ties encryption to the device passcode. Manual encryption with `CryptoKit` provides granular, application-level control, allowing encryption to be tied to app-specific logic or biometrics, independent of the device's lock state.",
      "code_example": null,
      "tags": [
        "security",
        "cryptography",
        "keychain",
        "cryptokit"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "Explain how to secure keychain data with biometrics. What happens to this data if the enrolled biometrics change (e.g., a new finger is added), and how should your app handle this domain state invalidation?",
      "back": "Securing keychain data with biometrics involves two frameworks: `LocalAuthentication` for user interaction and `Security` (Keychain) for secure storage.\n\n### Core Concept\nThe key is to not just authenticate the user, but to use that authentication to control access to a secret stored in the Keychain. We achieve this by creating a `SecAccessControl` object with specific protection flags. The most important flag is `kSecAccessControlBiometryCurrentSet`. This flag tells the Secure Enclave to encrypt the keychain item with a key that is tied to the *current set* of enrolled biometric identities.\n\nWhen a user tries to access this keychain item, the system automatically invokes the biometric prompt. If successful, the data is decrypted and returned. The `LocalAuthentication` framework is often used upfront to check if biometrics are available (`canEvaluatePolicy`) before attempting a keychain operation.\n\n### Biometric Invalidation\nIf the set of enrolled biometrics changes (a face/finger is added or removed), the private key used to protect the keychain item is securely discarded by the Secure Enclave. Any subsequent attempt to access that item will fail with an error like `errSecItemNotFound` or `errSecAuthFailed`. This is a critical security feature that prevents a new user from accessing the previous user's data.\n\nYour app must handle this failure gracefully. The correct flow is to catch the error, treat the stored data as inaccessible, remove the old keychain item, re-authenticate the user (e.g., with their login credentials), and then save the new secret in the keychain, which creates a new item protected by the new biometric set.\n\n### Code Example\n```swift\nimport LocalAuthentication\nimport Security\n\nfunc saveSecret(secret: String) async throws {\n    guard let data = secret.data(using: .utf8) else { return }\n    \n    // 1. Create access control flags tied to the current biometric set.\n    // This is the crucial step for automatic invalidation.\n    let access = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n        .biometryCurrentSet, // or .biometryCurrentSet and .devicePasscode\n        nil)! // Error handling omitted for brevity\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.myapp.user.token\",\n        kSecValueData as String: data,\n        kSecAttrAccessControl as String: access\n    ]\n    \n    // 2. Delete any old item before saving a new one.\n    SecItemDelete(query as CFDictionary)\n    \n    // 3. Add the new item to the keychain.\n    let status = SecItemAdd(query as CFDictionary, nil)\n    guard status == errSecSuccess else { throw MyError.keychainSaveFailed }\n}\n\n// Reading the item will automatically trigger the biometric prompt.\nfunc readSecret() async throws -> String? {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.myapp.user.token\",\n        kSecReturnData as String: true,\n        // Prompt the user for authentication if required.\n        kSecUseOperationPrompt as String: \"Authenticate to access your account\"\n    ]\n\n    var item: CFTypeRef?\n    let status = SecItemCopyMatching(query as CFDictionary, &item)\n    \n    // 4. Handle invalidation or other errors.\n    if status == errSecUserCanceled || status == errSecAuthFailed {\n        // Biometrics failed or were invalidated. The app should now trigger a full re-login flow.\n        print(\"Authentication failed or biometrics changed.\")\n        return nil\n    }\n    \n    guard status == errSecSuccess, let data = item as? Data else {\n        return nil\n    }\n    \n    return String(data: data, encoding: .utf8)\n}\n```\n\n### Common Pitfalls\n- **Using `biometryAny` vs. `biometryCurrentSet`**: `biometryAny` allows *any* enrolled biometric to access the data, even newly added ones. This is less secure and bypasses the invalidation mechanism. Always prefer `biometryCurrentSet` for sensitive data.\n- **Not Handling Invalidation**: Failing to catch keychain read errors after biometric changes leads to a broken state where the user is permanently locked out of their data until they reinstall the app. The only solution is to delete the old item and create a new one.\n- **Storing Secrets Elsewhere**: Storing the secret in `UserDefaults` after a successful biometric check completely defeats the purpose of keychain security. The secret should only exist in memory temporarily after being read from the keychain.",
      "code_example": null,
      "tags": [
        "security",
        "biometrics",
        "keychain",
        "localauthentication"
      ],
      "sources": [
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_a98037d94e1a",
      "front": "You're leading development for a new fintech app. How would you prioritize and implement defenses against the OWASP Mobile Top 10, focusing on the most critical risks for iOS?",
      "back": "The OWASP Mobile Top 10 is a framework for securing mobile apps, not just a checklist. For a high-risk fintech app, I'd prioritize threats based on impact and likelihood, focusing on data protection first.\n\n**Core Concept & Prioritization:**\n1.  **M2: Insecure Data Storage:** This is paramount. Any sensitive data (tokens, PII, credentials) stored on the device must be protected. The iOS Keychain is the standard solution, as it leverages the Secure Enclave. Data should never be stored in `UserDefaults`, Plists, or unencrypted local files.\n\n2.  **M3: Insecure Communication:** Protecting data in transit is equally critical. All network communication must use TLS 1.2+. However, standard TLS is vulnerable to man-in-the-middle (MitM) attacks if a device's trust store is compromised. For a fintech app, **Certificate Pinning** is non-negotiable. This involves hardcoding the server's public key or certificate hash in the app, ensuring it only communicates with our authentic server.\n\n3.  **M1: Improper Platform Usage:** This involves misusing platform features. For iOS, it means correctly using Touch ID/Face ID, setting appropriate Keychain accessibility attributes, and not exposing sensitive data through background snapshots or insecure logging.\n\n**Practical Code Example (Keychain Service):**\nHere\u2019s a simplified service for securely storing a user's API token.\n```swift\n// A simple service to interact with the iOS Keychain\nclass KeychainService {\n    static func save(token: String, for account: String) -> Bool {\n        guard let data = token.data(using: .utf8) else { return false }\n        \n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrAccount as String: account,\n            kSecValueData as String: data,\n            // CRITICAL: This attribute ensures the item is only accessible\n            // when the device is unlocked. It does not roam to other devices.\n            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n        ]\n        \n        // Clear any old item before saving\n        SecItemDelete(query as CFDictionary)\n        \n        let status = SecItemAdd(query as CFDictionary, nil)\n        return status == errSecSuccess\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Storing Secrets in `UserDefaults`:** The most common mistake. `UserDefaults` is an unencrypted plist file, easily readable on a jailbroken device.\n*   **Incorrect Keychain Accessibility:** Using `kSecAttrAccessibleAlways` makes the data accessible even on a locked device, defeating much of its security benefit.\n*   **Disabling App Transport Security (ATS):** Developers sometimes disable ATS globally in `Info.plist` for convenience during development and forget to re-enable it, allowing insecure HTTP connections.\n*   **Ignoring Certificate Pinning:** Forgetting to implement pinning leaves the app vulnerable to sophisticated MitM attacks, which are a major risk for financial applications.\n\n**When to Use vs. Alternatives:**\n*   **Certificate Pinning:** Essential for apps handling sensitive data (finance, health, private messaging). For apps with low-risk data (e.g., a public news reader), the maintenance overhead of updating pinned certs might outweigh the security benefit. Standard TLS with proper ATS configuration is sufficient there.\n*   **Additional Layers:** For maximum security, consider code obfuscation to make reverse-engineering harder and jailbreak detection to alter app behavior or disable functionality on a compromised device.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "keychain",
        "networking",
        "ats",
        "certificate pinning"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_a325baeb20c1",
      "front": "An Ad Hoc build fails to install on a new test device, but runs on the simulator and existing devices. Explain the chain of trust involved in code signing and how a provisioning profile links the app, developer identity, and device. Why did this failure occur?",
      "back": "The root cause is a broken link in Apple's security chain of trust. This system ensures that only trusted code from a verified developer runs on authorized devices. The simulator bypasses the device-specific checks, which is why it works there.\n\n**Core Concept: The Chain of Trust**\n\n1.  **Developer Certificate:** This is a public/private key pair. You generate a Certificate Signing Request (CSR) from your Mac's Keychain. Apple verifies it and issues a signed certificate. The private key remains securely on your Mac and is used by Xcode to cryptographically sign the application binary. This proves the code originates from you and hasn't been altered.\n\n2.  **App ID:** A unique identifier for your app (e.g., `com.company.AppName`) that also defines which app services (entitlements like Push Notifications, iCloud) it can use.\n\n3.  **Provisioning Profile:** This is the central piece that ties everything together. It's a `.mobileprovision` file containing:\n    *   The App ID the profile is for.\n    *   The certificate(s) allowed to sign the app.\n    *   For Ad Hoc/Development builds, a list of authorized device UDIDs.\n\n**Installation & Verification Process:**\nWhen an Ad Hoc build is installed, iOS performs these checks:\n1.  Verifies the provisioning profile is valid and signed by Apple.\n2.  Checks if the app's signature was created by the private key corresponding to a certificate in the profile.\n3.  Ensures the app's bundle ID matches the App ID in the profile.\n4.  Crucially, it checks if the current device's UDID is in the profile's list.\n\nThe failure occurred because the new device's UDID was not in the list (step 4), so iOS rejected the installation. The fix is to add the device's UDID in the Apple Developer portal, regenerate the Ad Hoc profile, and re-sign the app with it.\n\n**Practical Example: Entitlements**\nAn entitlements file declares capabilities the app requires. The provisioning profile must authorize these. If there's a mismatch, the app may build but crash on launch.\n\n```xml\n<!-- MyApp.entitlements -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <!-- This entitlement is granted by the provisioning profile -->\n    <key>aps-environment</key>\n    <string>development</string>\n    <!-- The profile must be linked to an App ID with iCloud enabled -->\n    <key>com.apple.developer.icloud-container-identifiers</key>\n    <array>\n        <string>iCloud.com.mycompany.myapp</string>\n    </array>\n</dict>\n</plist>\n```\n\n**Common Pitfalls:**\n*   **Missing Private Key:** Moving to a new machine without exporting your developer identity (`.p12` file) from the original Mac's Keychain. Xcode will show the certificate but can't sign with it.\n*   **Profile/Entitlement Mismatch:** Enabling a service in your App ID but using an old profile that doesn't include this new capability.\n*   **CI/CD Expiration:** Certificates and profiles have expiration dates. A common cause of CI/CD pipeline failures is an expired certificate that wasn't renewed.\n\n**Profile Types:**\n*   **Development:** For debugging on your team's registered devices.\n*   **Ad Hoc:** For distributing to a limited set of registered test devices (up to 100). Mimics a release environment.\n*   **App Store:** For final submission. Contains no device UDIDs.\n*   **Enterprise:** For in-house distribution within a large organization, bypassing the App Store.",
      "code_example": null,
      "tags": [
        "security",
        "xcode",
        "build process",
        "app store"
      ],
      "sources": [
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Secure coding practices",
      "back": "",
      "code_example": null,
      "tags": [
        "Secure coding practices"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "Explain the roles of `kSecAttrAccessible` and `kSecAttrAccessControl` in Keychain Services. How would you configure them to protect a token that must be accessible by background tasks, but only after biometric authentication when accessed in the foreground?",
      "back": "The Keychain is a secure, encrypted database managed by the OS for storing small secrets. `kSecAttrAccessible` and `kSecAttrAccessControl` are attributes that define the policies for accessing these secrets.\n\n**Core Concept:**\n- `kSecAttrAccessible`: This is the fundamental accessibility control. It dictates *when* an item is readable based on the device's lock state. For example, `kSecAttrAccessibleWhenUnlocked` means the item is only available when the device is unlocked. For background access, `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` is critical, as it allows access even if the device is currently locked, as long as it has been unlocked once since booting.\n\n- `kSecAttrAccessControl`: This provides a more advanced, granular layer of security. It's a `SecAccessControl` object that specifies user presence requirements, such as requiring a successful Face ID/Touch ID scan or passcode entry before the Keychain will yield the data. It works in tandem with the base accessibility. The accessibility level is defined *during the creation* of the `SecAccessControl` object.\n\nFor the specified scenario, you would create a `SecAccessControl` object with the `.userPresence` flag and an accessibility level of `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`. This ensures background tasks can access the data, while any attempt to read it (foreground or background) that triggers the `.userPresence` flag will require user authentication.\n\n**Practical Code Example:**\n```swift\nimport Security\n\nfunc saveToken(_ token: String) -> OSStatus {\n    guard let tokenData = token.data(using: .utf8) else { return errSecParam }\n\n    // 1. Create access control object.\n    var error: Unmanaged<CFError>?\n    // Base accessibility allows background access after first unlock.\n    // The .userPresence flag requires biometrics or passcode for access.\n    guard let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly,\n        .userPresence,\n        &error\n    ) else {\n        return errSecInternal\n    }\n\n    // 2. Define the query for saving the item.\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"com.myapp.api\",\n        kSecAttrAccount as String: \"authToken\",\n        kSecValueData as String: tokenData,\n        kSecAttrAccessControl as String: accessControl\n    ]\n\n    // 3. Atomically add/update the item.\n    SecItemDelete(query as CFDictionary) // Always clear previous item.\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls:**\n- **Conflicting Attributes:** When using `kSecAttrAccessControl`, the accessibility level is defined within the `SecAccessControl` object itself. Setting a separate `kSecAttrAccessible` attribute in the main query is redundant and can cause conflicts or be ignored.\n- **Wrong Accessibility for Background:** Choosing `kSecAttrAccessibleWhenUnlocked` will cause background operations to fail if the device is locked.\n- **Biometric Changes:** Use the `.biometryCurrentSet` flag (or `.biometryAny` on older OSs) to invalidate the keychain item if the user's enrolled biometrics change, preventing a potential security loophole.\n- **Simulator Testing:** Biometric and advanced Keychain features behave differently or are unavailable on the simulator. Always test on a physical device.\n\n**When to Use vs. Alternatives:**\n- **Keychain:** Ideal for small secrets: API tokens, passwords, cryptographic keys. Its primary benefits are OS-level security and data persistence across app uninstalls.\n- **Encrypted Database (e.g., SQLCipher):** Use for storing large amounts of sensitive data. A common, robust pattern is to store the database's encryption key in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "ios",
        "swift",
        "authentication"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_85b38a95715f",
      "front": "Your app must connect to a legacy internal server via HTTP. How do you configure App Transport Security (ATS) to permit this, and what are the critical security implications and best practices you must follow when adding such an exception?",
      "back": "App Transport Security (ATS) is an OS-level feature that enforces secure network connections over HTTPS with TLS v1.2+ and forward secrecy. It's enabled by default for all apps.\n\nTo connect to a legacy HTTP server, you must add a domain-specific exception in your app's `Info.plist`. This is vastly preferable to disabling ATS globally.\n\n**Core Concept:**\nThe goal is to create the most narrowly-scoped exception possible. Instead of turning off all protections, you specify that only a particular domain is exempt from the standard ATS rules. This maintains security for all other network requests, including those from third-party SDKs.\n\n**Practical Code Example (Info.plist source code):**\nThis example allows insecure HTTP connections specifically to `legacy-api.mycompany.com`.\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>legacy-api.mycompany.com</key>\n        <dict>\n            <!-- Set to false to prevent applying this rule to subdomains -->\n            <key>NSIncludesSubdomains</key>\n            <false/>\n            <!-- This key explicitly allows insecure HTTP connections -->\n            <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n            <!-- You can also specify an older TLS version if needed -->\n            <!--\n            <key>NSTemporaryExceptionMinimumTLSVersion</key>\n            <string>TLSv1.1</string>\n            -->\n        </dict>\n    </dict>\n</dict>\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **`NSAllowsArbitraryLoads`:** The most dangerous pitfall is setting `NSAllowsArbitraryLoads` to `true` at the top level. This globally disables ATS, making all network traffic vulnerable to man-in-the-middle attacks. It is an immediate red flag in a code review and requires strong justification for App Store approval (e.g., for a web browser app).\n2.  **Overly Broad Exceptions:** Using `NSIncludesSubdomains = true` when not strictly necessary widens the attack surface. If a non-critical subdomain is compromised, it could potentially be used to attack your app.\n3.  **App Store Review:** Apple requires a detailed justification for all ATS exceptions during the app submission process. You must clearly explain why the exception is necessary and cannot be resolved by upgrading the server.\n\n**When to Use vs. Alternatives:**\nUse domain exceptions as a last resort for servers you don't control or for legacy internal systems that are on a clear path to being upgraded. The use of \"`NSTemporary...`\" keys signals this intent.\n\nThe best alternative is always to **upgrade the server** to be ATS-compliant. A senior developer should advocate for this as the proper long-term solution, treating ATS exceptions as technical debt. For specific use cases like displaying user-generated web content, consider more targeted keys like `NSAllowsArbitraryLoadsInWebContent`, which limits the exception to `WKWebView` instances, providing a safer alternative to the global flag.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}