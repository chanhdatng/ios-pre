{
  "topic": "security",
  "generated_at": "2026-01-09T07:04:34.069307+00:00",
  "cards": [
    {
      "id": "security_199ddce13d96",
      "front": "How would you secure a user's API token using biometrics? Describe the Keychain integration, the choice of `LAPolicy`, and how you'd handle potential failures or changes in biometric data.",
      "back": "To secure an API token, you should leverage the synergy between the LocalAuthentication and Security (Keychain) frameworks, rather than just gating an action with `LAContext`.\n\n**Core Concept:**\nThe best practice is to store the sensitive data (the token) in the Keychain and protect it with an access control policy that requires biometric authentication. When your app attempts to read this data, iOS itself enforces the policy and presents the Face ID/Touch ID prompt. This is more secure than manually evaluating a policy and then fetching an unprotected item, as the data is encrypted at rest and is only decrypted by the Secure Enclave after a successful authentication.\n\nYou create a `SecAccessControl` object with flags like `kSecAccessControlBiometryCurrentSet`. This crucial flag ensures that if the user adds or removes a face/finger, the Keychain item is invalidated, forcing the user to re-authenticate with their primary credentials (e.g., password) to create a new token. This prevents unauthorized access if a new biometric identity is added without the user's consent.\n\n**Code Example:**\n```swift\nimport LocalAuthentication\nimport Security\n\nfunc saveToken(_ token: String) throws {\n    // 1. Define a unique key for the Keychain item.\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.myapp.authtoken\",\n        kSecValueData as String: token.data(using: .utf8)!,\n        kSecAttrAccessControl as String: createAccessControl()!,\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n    \n    // 2. Add or update the item in the Keychain.\n    let status = SecItemAdd(query as CFDictionary, nil)\n    if status == errSecDuplicateItem {\n        SecItemUpdate([kSecAttrAccount as String: \"com.myapp.authtoken\"] as CFDictionary, [kSecValueData as String: token.data(using: .utf8)!] as CFDictionary)\n    } else if status != errSecSuccess {\n        throw MyError.keychainError(status)\n    }\n}\n\nfunc loadToken() throws -> String? {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.myapp.authtoken\",\n        kSecReturnData as String: true,\n        // 3. This key triggers the OS-level biometric prompt if required by the access policy.\n        kSecUseAuthenticationUI as String: kSecUseAuthenticationUIAllow\n    ]\n    \n    var item: CFTypeRef?\n    let status = SecItemCopyMatching(query as CFDictionary, &item)\n    \n    // 4. Handle different statuses, including user cancellation.\n    guard status == errSecSuccess else { return nil }\n    guard let data = item as? Data, let token = String(data: data, encoding: .utf8) else { return nil }\n    return token\n}\n\n// Creates the access control policy\nprivate func createAccessControl() -> SecAccessControl? {\n    var error: Unmanaged<CFError>?\n    // kSecAccessControlBiometryCurrentSet invalidates the item if biometrics change.\n    return SecAccessControlCreateWithFlags(kCFAllocatorDefault,\n                                           kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                                           .biometryCurrentSet,\n                                           &error)\n}\n```\n\n**Common Pitfalls:**\n- **Not handling biometric changes:** Using `.biometryAny` instead of `.biometryCurrentSet` means the item remains accessible even if a new, unauthorized fingerprint/face is added.\n- **Unnecessary manual `evaluatePolicy`:** Manually calling `LAContext.evaluatePolicy` before a Keychain read is redundant. Let the Keychain's `kSecUseAuthenticationUI` handle it. The manual check is for gating UI actions, not for decrypting data.\n- **Choosing the wrong policy:** The code above uses `.biometryCurrentSet`, which allows only biometrics. If you need to allow fallback to the device passcode (a UX vs. security trade-off), you would use `.userPresence`, which combines biometrics and the passcode.\n- **Poor error handling:** Not distinguishing between `errSecUserCanceled`, `errSecAuthFailed`, and other `OSStatus` codes from Keychain operations leads to a poor user experience.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "biometrics",
        "localauthentication"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "How would you store a sensitive API token using Keychain Services to ensure it requires biometrics for access, is only available when the device is unlocked, and is never backed up or migrated to a new device?",
      "back": "Keychain Services provides a secure, encrypted database for storing small secrets. To achieve the specified security level, you must configure a query dictionary with precise access control attributes before adding the item.\n\n**Core Concept:**\nThe key is to combine two mechanisms: the accessibility attribute and an access control object.\n1.  **`kSecAttrAccessible`**: This attribute defines the conditions under which an item is readable. Setting it to `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` enforces two critical rules: the data can only be read while the device is unlocked, and it is not included in device backups, preventing it from being restored to another device.\n2.  **`SecAccessControl`**: This object provides fine-grained rules, including requiring user authentication. By creating it with `SecAccessControlCreateWithFlags` and specifying a protection level like `.userPresence`, you tell the system to require either a successful biometric scan (Face ID/Touch ID) or the device passcode before granting access to the keychain item. This is attached to the query via the `kSecAttrAccessControl` key.\n\n**Practical Code Example:**\nThis function demonstrates an \"upsert\" operation for securely storing a token.\n```swift\nimport Foundation\nimport LocalAuthentication\n\nfunc saveToken(_ token: String, service: String, account: String) -> Bool {\n    guard let tokenData = token.data(using: .utf8) else { return false }\n\n    // 1. Create the SecAccessControl object for biometrics\n    var error: Unmanaged<CFError>?\n    guard let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n        .userPresence, // Requires Face ID, Touch ID, or passcode\n        &error\n    ) else {\n        print(\"Failed to create SecAccessControl: \\(error.debugDescription)\")\n        return false\n    }\n\n    // 2. Form the query to add the item\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: service,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: tokenData,\n        kSecAttrAccessControl as String: accessControl\n    ]\n\n    // 3. Delete any existing item before adding the new one to prevent conflicts\n    SecItemDelete(query as CFDictionary)\n\n    // 4. Add the new item to the keychain\n    let status = SecItemAdd(query as CFDictionary, nil)\n    return status == errSecSuccess\n}\n```\n\n**Common Pitfalls:**\n*   **Simulator Limitations:** Biometric-protected keychain items behave unreliably on the simulator. Always test on a physical device.\n*   **Forgetting `errSecDuplicateItem`:** Simply calling `SecItemAdd` will fail if an item for the same service/account already exists. The robust approach is to either delete the old item first (as shown) or attempt an update via `SecItemUpdate`.\n*   **Incorrect Accessibility Type:** Using a less restrictive type like `kSecAttrAccessibleWhenUnlocked` allows the item to be included in encrypted backups and restored to new devices, which may violate security requirements.\n\n**When to Use vs. Alternatives:**\n*   **Use Keychain for:** Small, highly sensitive secrets like user credentials, API tokens, and cryptographic keys.\n*   **Alternatives:** For large amounts of sensitive data (e.g., a database of private notes), store the data in an encrypted file or database (like Core Data with encryption) and store only the encryption key in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "biometrics",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_b2f1eb5efae8",
      "front": "You're tasked with storing sensitive user data at rest: a small API auth token and a larger (1MB+) JSON file of user PII. How would you design a secure storage solution for both, and what are the trade-offs?",
      "back": "For a robust solution, we use different tools based on data size and sensitivity, following the principle of defense in depth.\n\n**1. API Auth Token (Small Secret): The Keychain**\n\nThe Keychain is the ideal place for small, critical secrets like auth tokens, passwords, and cryptographic keys. It's not just an encrypted database; it's a system-level service backed by the Secure Enclave on modern devices. This provides hardware-level security and process isolation.\n\n*   **Core Concept:** We store the token using `SecItemAdd` and retrieve it with `SecItemCopyMatching`. The most important choice is the accessibility attribute (`kSecAttrAccessible`). For an auth token, `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` is often the best choice, as it ensures the data is encrypted when the device is locked and cannot be restored to a different device from a backup.\n\n**2. User PII (Large Data): CryptoKit + File Protection**\n\nStoring large blobs in the Keychain is an anti-pattern that leads to poor performance. Instead, we encrypt the data ourselves using a modern, safe framework like CryptoKit and then leverage the OS's file-level encryption.\n\n*   **Core Concept:** The process is:\n    a. Generate a symmetric encryption key (`SymmetricKey`).\n    b. Store this key securely in the Keychain.\n    c. Use the key to encrypt the JSON data using an AEAD cipher like `AES.GCM`.\n    d. Write the resulting encrypted data (`SealedBox`) to a file in the app's sandboxed directory (e.g., Application Support).\n    e. When writing, specify a strong `Data.ProtectionType`, like `.completeUntilFirstUserAuthentication`. This ensures the file is protected by keys derived from the user's passcode and is inaccessible until they unlock their device for the first time after a reboot.\n\n```swift\nimport CryptoKit\nimport Security\n\n// Simplified example for demonstration\nstruct SecureFileStorage {\n    private let keychainService = \"com.yourapp.FileEncryptionKey\"\n\n    func save(data: Data, to url: URL) throws {\n        // 1. Get or create a secure key from Keychain\n        let key = try getSymmetricKey()\n\n        // 2. Encrypt the data using AES.GCM\n        let sealedBox = try AES.GCM.seal(data, using: key)\n\n        // 3. Write encrypted data to disk with strong protection\n        // This file is encrypted until the user unlocks their device once after boot.\n        try sealedBox.combined?.write(to: url, options: .completeFileProtectionUntilFirstUserAuthentication)\n    }\n\n    // Key management part (highly simplified)\n    private func getSymmetricKey() throws -> SymmetricKey {\n        // Query Keychain for the key\n        // ... if not found, generate a new one ...\n        let newKey = SymmetricKey(size: .bits256)\n        // ... and save it securely to the Keychain with a strong accessibility attribute ...\n        return newKey\n    }\n}\n```\n\n**Common Pitfalls & Trade-offs:**\n\n*   **Pitfall:** Storing the encryption key insecurely (e.g., in `UserDefaults` or hardcoded). The key *must* be stored in the Keychain.\n*   **Pitfall:** Forgetting to set a `Data.ProtectionType`. Without it, the file might use a weaker default protection level, exposing the encrypted data while the device is locked.\n*   **Trade-off:** This approach adds complexity over simply writing a file to disk. You are responsible for key management, encryption/decryption logic, and error handling. However, this complexity is necessary for securing sensitive data.\n\n**Alternatives:**\n\n*   **Core Data/Realm with Encryption:** For structured data, you can use a database. The underlying database file can be secured with `Data.ProtectionType`. For more granular control, individual fields can be encrypted using `ValueTransformer` (Core Data), but this is more complex.\n*   **SQLCipher:** A third-party library that provides a fully encrypted SQLite database. It's a good option if you need cross-platform compatibility or a drop-in encrypted database solution.",
      "code_example": null,
      "tags": [
        "security",
        "encryption",
        "cryptokit",
        "keychain",
        "data protection"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_85b38a95715f",
      "front": "Your app must connect to a legacy, non-HTTPS server for development, but enforce strict ATS for production. How do you configure this without maintaining separate Info.plist files? Describe the keys and build settings involved.",
      "back": "App Transport Security (ATS) is an OS-level feature enforcing secure network connections, requiring HTTPS with TLS v1.2 by default. To create environment-specific rules, we leverage Xcode's build configurations and the C preprocessor, which can process `Info.plist` files.\n\nFirst, in your project's Build Settings, find 'Active Compilation Conditions' (or 'Preprocessor Macros' for Objective-C). For your 'Debug' configuration, add a flag like `DEVELOPMENT=1`. This flag will not be present in the 'Release' configuration.\n\nNext, edit your `Info.plist` to conditionally include the ATS exceptions using this flag. This ensures the exceptions are compiled into the app only for Debug builds.\n\n**Practical Code Example (Info.plist source code):**\n```xml\n<!-- In Project > Build Settings > Active Compilation Conditions, add 'DEVELOPMENT' for the Debug configuration. -->\n\n<key>NSAppTransportSecurity</key>\n<dict>\n#if DEVELOPMENT\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>legacy-server.dev</key>\n        <dict>\n            <!-- Allows insecure HTTP loads for this specific domain. -->\n            <key>NSExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n            <!-- Optional: Include if you need to connect to subdomains. -->\n            <key>NSIncludesSubdomains</key>\n            <true/>\n        </dict>\n    </dict>\n#endif\n</dict>\n```\n\n**Common Pitfalls:**\n- **Global Override:** The most dangerous mistake is setting `NSAllowsArbitraryLoads` to `true`. This disables ATS for the entire app, is a major security risk, and requires strong justification for App Store review. Avoid it.\n- **Configuration Negligence:** Failing to test the Release configuration can lead to network requests failing in production because the exceptions are correctly excluded. Always test all build configurations before shipping.\n- **Overly Broad Exceptions:** Exceptions should be as specific as possible. Don't disable ATS for a whole TLD when you only need a single subdomain.\n\n**When to Use vs. Alternatives:**\nThis conditional approach is ideal for managing development servers, internal tools, or connecting to local network hardware that cannot be updated to support HTTPS. The primary alternative, and the best long-term solution, is to upgrade the server to be ATS-compliant. For API mocking and inspection, using a proxy tool like Charles or Proxyman is often a better choice than weakening the app's security model, even in development.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist",
        "build-configurations"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Beyond using Keychain, describe a multi-layered approach to securing sensitive data both at rest and in transit within an iOS application.",
      "back": "A multi-layered security approach, or 'defense in depth', ensures that a failure in one security control doesn't lead to a total compromise. For iOS, this involves securing data at rest, in transit, and within the app's memory.\n\n**Core Concepts:**\n1.  **Data at Rest:** This is data stored on the device's flash storage.\n    *   **Keychain Services:** The primary mechanism for securely storing small, critical secrets like auth tokens, passwords, and cryptographic keys. On modern devices, the Keychain is backed by the Secure Enclave, providing hardware-level protection.\n    *   **Data Protection API:** An iOS feature that encrypts files on a per-file basis using keys derived from the user's passcode and the device's UID. You should apply the strongest possible protection level (e.g., `complete`) to files containing sensitive PII.\n\n2.  **Data in Transit:** This is data moving between the app and a server.\n    *   **App Transport Security (ATS):** Enforces best practices for network connections, such as requiring HTTPS with TLS v1.2+ and forward secrecy. It is enabled by default.\n    *   **Certificate Pinning:** A technique to prevent man-in-the-middle (MITM) attacks by embedding (or 'pinning') the server's public key or certificate within the app. The app then validates the server's certificate against the pinned one during the TLS handshake, rejecting connections if they don't match.\n\n**Code Example (Keychain Helper):**\n```swift\n// A simplified example of saving a token to the Keychain\nfunc save(token: String, for account: String) -> OSStatus {\n    guard let data = token.data(using: .utf8) else { return errSecParam } // Ensure token is valid data\n\n    // kSecClass: Type of data (generic password)\n    // kSecAttrAccount: A unique identifier for the item\n    // kSecValueData: The actual secret to be stored\n    // kSecAttrAccessible: When the data should be accessible\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: data,\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n\n    // First, delete any existing item for this account to avoid duplicates\n    SecItemDelete(query as CFDictionary)\n\n    // Add the new item to the Keychain\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls:**\n*   **Storing Secrets in `UserDefaults`:** `UserDefaults` is a simple plist file in the app's sandbox, stored in plain text. It is trivial to extract from a device backup or a jailbroken device.\n*   **Hardcoding API Keys:** Never embed keys or secrets directly in source code. Use `.xcconfig` files combined with a script to inject them into `Info.plist` at build time, and ensure these files are in `.gitignore`.\n*   **Logging Sensitive Data:** Accidentally logging tokens, passwords, or PII to the console can expose them. Use build flags like `#if DEBUG` to ensure sensitive logs are stripped from release builds.\n*   **Disabling ATS Globally:** Instead of turning off ATS entirely, add specific, justified exceptions for domains that don't support it.\n\n**When to Use:**\n*   **Keychain:** Use for small secrets like auth tokens, API keys, and user credentials.\n*   **Data Protection API:** Use for larger sensitive files, like a database containing PII or downloaded user documents. Apply it by setting the `NSFileProtectionKey` attribute when writing a file.\n*   **Certificate Pinning:** Use for high-security apps (banking, healthcare) where the risk of a sophisticated MITM attack is high. Be aware of the maintenance overhead, as you must update the app if the server's certificate changes.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "app-transport-security",
        "data-protection",
        "cryptography"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}