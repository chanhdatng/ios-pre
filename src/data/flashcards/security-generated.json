{
  "topic": "security",
  "generated_at": "2026-01-17T03:55:34.001190+00:00",
  "cards": [
    {
      "id": "security_a98037d94e1a",
      "front": "Describe your strategy for mitigating the OWASP Mobile Top 10 risks in an iOS app, focusing specifically on M1 (Improper Platform Usage) and M2 (Insecure Data Storage).",
      "back": "My strategy is to implement a defense-in-depth approach, focusing on correctly leveraging platform security features (M1) and ensuring all sensitive data is encrypted at rest (M2).\n\n**Core Concept: M1 & M2 Mitigation**\n\n*   **M1 - Improper Platform Usage:** This risk involves misusing iOS security features. Key mitigations include:\n    *   **Keychain for Secrets:** Never store API keys, tokens, or passwords in `UserDefaults`, plists, or hardcoded in the source. The Keychain is the only appropriate place for small, critical secrets.\n    *   **App Transport Security (ATS):** Enforce ATS for all network connections. Avoid broad exceptions in `Info.plist`. If an exception is required, it must be for a specific domain with strong justification.\n    *   **Biometrics & Passcode:** Use `LocalAuthentication` correctly to protect access to sensitive features, but recognize it's for local convenience, not a replacement for robust server-side authentication.\n\n*   **M2 - Insecure Data Storage:** iOS provides file-level encryption when a device is locked, but this is insufficient. We must protect sensitive data even on an unlocked or jailbroken device.\n    *   **Encryption at Rest:** Any sensitive data written to disk (e.g., in caches, Core Data, SQLite, or flat files) must be encrypted first. Use robust, modern frameworks like Apple's CryptoKit.\n\n**Practical Code Example**\n\nThis shows using Keychain for a token (M1) and CryptoKit to encrypt a file (M2).\n```swift\nimport Foundation\nimport CryptoKit\nimport Security\n\n// M1 Mitigation: Using Keychain for an API token\nfunc saveTokenToKeychain(token: String) {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.myapp.authtoken\",\n        kSecValueData as String: token.data(using: .utf8)!,\n        // Strong protection: only available when unlocked, not in backups\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n    SecItemDelete(query as CFDictionary) // Ensure no duplicates\n    SecItemAdd(query as CFDictionary, nil)\n}\n\n// M2 Mitigation: Encrypting a file with CryptoKit\nfunc saveSensitiveData(_ data: Data, to url: URL) throws {\n    // 1. Use a symmetric key. NEVER hardcode this.\n    // A real app would generate and store this key securely in the Keychain.\n    let key = SymmetricKey(size: .bits256)\n\n    // 2. Encrypt the data using AES-GCM for authenticated encryption\n    let sealedBox = try AES.GCM.seal(data, using: key)\n\n    // 3. Write the encrypted data (which includes nonce + tag) to disk\n    try sealedBox.combined?.write(to: url)\n}\n```\n\n**Common Pitfalls & Edge Cases**\n\n*   **Keychain Accessibility:** Choosing the wrong `kSecAttrAccessible` attribute is a common error. Understand the tradeoffs between security and background accessibility.\n*   **Hardcoded Keys:** Never hardcode encryption keys in source code. They can be easily extracted. Keys must be generated at runtime and stored in the Keychain.\n*   **Logging:** Sensitive data (passwords, PII, tokens) often leaks through debug logs (`print`, `os.log`). Implement a logging system that redacts sensitive info in release builds.\n*   **UI Snapshots:** iOS snapshots the UI when the app backgrounds. If sensitive data is visible, it's saved to an unencrypted image. Obscure sensitive views in `applicationDidEnterBackground`.\n\n**When to Use vs. Alternatives**\n\n*   **Keychain:** Use for small secrets (tokens, passwords, encryption keys). For larger data, encrypt it with CryptoKit using a key stored in the Keychain.\n*   **UserDefaults:** Only for non-sensitive, simple user preferences (e.g., dark mode enabled). It's an unencrypted plist, easily readable on a compromised device.\n*   **Core Data/SQLite:** To secure sensitive fields, encrypt them individually using CryptoKit before saving them to the database. Don't rely solely on filesystem encryption.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "keychain",
        "cryptokit",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_a325baeb20c1",
      "front": "An ad-hoc build fails with a 'Could not be verified' error. Describe the cryptographic chain of trust from the developer's private key to the device, and pinpoint the common mismatches in this chain that cause such failures.",
      "back": "This error signals a break in the cryptographic chain of trust that Apple uses to ensure an app is authentic and authorized to run on a specific device.\n\n**Core Concept: The Chain of Trust**\n\nThe process relies on asymmetric cryptography and a series of linked assets:\n1.  **Private Key & Certificate:** You generate a key pair on your Mac. The private key remains secret in your Keychain. The public key is sent to Apple in a Certificate Signing Request (CSR). Apple's Worldwide Developer Relations (WWDR) authority signs this, creating your developer certificate. This certificate cryptographically links your identity to Apple.\n2.  **App ID:** An identifier in the Developer Portal that specifies a unique app or a group of apps (using a wildcard).\n3.  **Provisioning Profile:** This is the critical glue. It's a file that bundles the developer certificates authorized to sign the app (`Who`), the App ID (`What`), the list of device UDIDs it can run on (`Where`), and the enabled entitlements like Push Notifications (`Can`).\n4.  **Signing & Verification:** During the build process, Xcode (or a CI/CD tool) uses your private key to create a digital signature for the app binary. This signature, your certificate, and the provisioning profile are embedded in the `.ipa` file. When a device tries to install the app, iOS verifies this entire chain. It checks that the profile is valid, the device's UDID is listed, the App ID matches, and finally, uses the public key in your certificate to confirm the app's signature is valid. Any break in this chain results in a verification failure.\n\n**Practical Example (Fastlane `Fastfile`)**\nThis shows how signing is managed in an automated environment, abstracting away manual Xcode settings.\n```ruby\n# Fastfile for building and signing an ad-hoc build\nlane :adhoc_build do\n  # 'match' syncs certificates and profiles from a git repo\n  # ensuring the entire team uses the same signing assets.\n  match(type: \"adhoc\", readonly: true)\n\n  # 'gym' builds the app using the synced profile.\n  gym(\n    scheme: \"MyApp\",\n    export_method: \"ad-hoc\",\n    export_options: {\n      signingStyle: \"manual\",\n      provisioningProfiles: {\n        \"com.mycompany.myapp\": \"match AdHoc com.mycompany.myapp\"\n      }\n    }\n  )\nend\n```\n\n**Common Pitfalls (Points of Failure)**\n*   **Certificate/Key Mismatch:** The app was signed with a private key that does not correspond to the public-key certificate included in the provisioning profile.\n*   **Device Not Registered:** The UDID of the target device is not included in the ad-hoc provisioning profile's list.\n*   **App ID Mismatch:** The app's bundle identifier (e.g., `com.mycompany.app`) does not match the App ID specified in the provisioning profile (e.g., a typo or using `com.mycompany.*` where an explicit ID was needed for certain entitlements).\n*   **Entitlements Mismatch:** The app's `.entitlements` file declares a capability (e.g., HealthKit) that is not enabled for that App ID and included in the profile.\n*   **Expired Assets:** Either the developer certificate or the provisioning profile itself has expired.",
      "code_example": null,
      "tags": [
        "security",
        "build process",
        "xcode",
        "distribution"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Explain 'defense in depth' in iOS. Provide concrete examples of how you would apply this principle across the data, network, and UI layers to secure sensitive user information.",
      "back": "Defense in depth is a security principle that involves implementing multiple, redundant layers of security controls. The goal is to ensure that if one security mechanism fails or is compromised, other layers are still in place to protect sensitive data. It moves away from relying on a single point of security.\n\nIn iOS, this can be applied across different parts of the app:\n\n1.  **Data at Rest (Storage):**\n    *   **Layer 1: Keychain:** Use the system Keychain for storing small, critical secrets like auth tokens, passwords, and encryption keys. It provides hardware-backed, encrypted storage.\n    *   **Layer 2: File-level Encryption:** For larger files or databases containing PII, use the `DataProtection` API. Set the file's protection level attribute (e.g., `.completeUntilFirstUserAuthentication`) to ensure it's encrypted when the device is locked.\n    *   **Layer 3: Database Encryption:** For Core Data or Realm, use an additional layer of encryption like SQLCipher to encrypt the entire database file.\n\n2.  **Data in Transit (Networking):**\n    *   **Layer 1: TLS/HTTPS:** Always use TLS for network communication. App Transport Security (ATS) enforces this by default.\n    *   **Layer 2: Certificate Pinning:** To prevent man-in-the-middle (MITM) attacks, pin your server's public key or certificate. This ensures the app only communicates with your authentic server, even if a fraudulent certificate is trusted by the device's OS.\n\n```swift\n// Example: Basic Certificate Pinning in URLSessionDelegate\nclass NetworkService: NSObject, URLSessionDelegate {\n    // The hash of the server's public key\n    let pinnedPublicKeyHash = \"base64EncodedPublicKeyHash==\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge,\n                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        \n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust,\n              let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0) else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        // Extract public key from certificate\n        let publicKey = SecCertificateCopyKey(serverCertificate)!\n        let publicKeyData = SecKeyCopyExternalRepresentation(publicKey, nil)! as Data\n        \n        // Hash the public key and compare with the pinned hash\n        // In a real app, use a robust hashing function like SHA256\n        let localPublicKeyHash = sha256(data: publicKeyData).base64EncodedString()\n\n        if localPublicKeyHash == pinnedPublicKeyHash {\n            // Success: the key matches our pin\n            completionHandler(.useCredential, URLCredential(trust: serverTrust))\n        } else {\n            // Failure: key does not match, reject connection\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n    // sha256 helper function not shown for brevity\n}\n```\n\n3.  **UI Layer:**\n    *   **Layer 1: Obscuring Input:** Set `isSecureTextEntry = true` for password fields.\n    *   **Layer 2: Backgrounding:** Overlay a view or blur the screen when the app enters the background to prevent sensitive data from appearing in the app switcher snapshot.\n\n**Common Pitfalls:**\n*   **Hardcoding Secrets:** Never hardcode API keys, salts, or other secrets in the source code. They are easily extractable from the binary.\n*   **Brittle Pinning:** Certificate pinning must be managed carefully. If the server certificate expires or is rotated, the app will stop working unless the new pin is deployed beforehand.\n*   **Ignoring Jailbreak:** On a jailbroken device, many OS-level protections can be bypassed. Implement jailbreak detection as another (imperfect) layer for high-security apps.\n\n**When to Use:** This principle is fundamental for any application handling sensitive data (e.g., financial, health, PII). The number and strength of layers should be proportional to the data's sensitivity.",
      "code_example": null,
      "tags": [
        "security",
        "architecture",
        "networking",
        "keychain",
        "best-practices"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_85b38a95715f",
      "front": "Your app must connect to a legacy internal server via HTTP. Describe how you'd configure App Transport Security (ATS) to allow this, detailing the specific Info.plist keys and the security implications of your approach.",
      "back": "App Transport Security (ATS) is an OS-level feature that mandates secure network connections over HTTPS. By default, it blocks any connection that doesn't meet best-practice standards, including TLS v1.2+ and forward secrecy. To connect to a legacy HTTP server, you must configure an exception.\n\nThe best practice is to create a narrowly-scoped exception for the specific domain rather than disabling ATS globally. This is done in your app's `Info.plist` file.\n\n**Practical Code Example (`Info.plist`):**\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <!-- This is the top-level key for all ATS settings -->\n    <key>NSExceptionDomains</key>\n    <dict>\n        <!-- Define an exception for a specific domain -->\n        <key>your-legacy-server.com</key>\n        <dict>\n            <!-- Allows insecure HTTP loads for this domain -->\n            <key>NSExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n            <!-- Apply this rule to all subdomains (e.g., api.your-legacy-server.com) -->\n            <key>NSIncludesSubdomains</key>\n            <true/>\n        </dict>\n    </dict>\n</dict>\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Global Override:** The most common mistake is using `<key>NSAllowsArbitraryLoads</key><true/>` directly under `NSAppTransportSecurity`. This disables ATS for all network requests, significantly weakening your app's security and is a common reason for App Store rejection. It should only be used as a last resort during initial development and never in production code without a very strong justification.\n2.  **Forgetting Subdomains:** If you need to connect to `api.legacy.com` and only whitelist `legacy.com` without `NSIncludesSubdomains`, the connection will fail. Always consider the full scope of the domains you need to access.\n3.  **Mixed Content in WebViews:** If a `WKWebView` loads a secure HTTPS page that contains insecure HTTP resources (like images), those resources may be blocked. For this, you can use `NSAllowsArbitraryLoadsInWebContent` to create an exception specifically for web view content.\n\n**When to Use vs. Alternatives:**\nConfiguring an ATS exception should be a temporary measure or a last resort when you have no control over the server-side infrastructure. The primary and most secure solution is always to upgrade the server to support HTTPS. When an exception is necessary, it must be documented, justified, and scoped as narrowly as possible to minimize the attack surface. This demonstrates a senior developer's commitment to security hygiene and managing technical debt.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6"
      ]
    },
    {
      "id": "security_b2f1eb5efae8",
      "front": "Describe a comprehensive strategy for encrypting sensitive user data in an iOS app. Cover both data at rest and in transit, detailing the specific frameworks and best practices you would employ.",
      "back": "A robust encryption strategy addresses data in two states: in transit (over a network) and at rest (on the device's storage).\n\n**1. Data in Transit:**\nThis is primarily handled by using TLS (HTTPS). iOS enforces this through App Transport Security (ATS). For high-security applications, **Certificate Pinning** is crucial. It prevents man-in-the-middle (MITM) attacks by ensuring the app only communicates with servers presenting a specific, known certificate, rather than just any certificate signed by a trusted CA.\n\n**2. Data at Rest:**\nThis requires a two-part solution: secure key management and data encryption.\n   - **Key Management (Keychain):** Never hardcode encryption keys. Generate them at runtime and store them securely in the Keychain. The Keychain is an encrypted on-device database managed by the OS, ideal for small secrets like keys or tokens. Use the most restrictive `kSecAttrAccessible` attribute possible, such as `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`, to ensure the key is only available when the device is unlocked and is not migrated to new devices.\n   - **Data Encryption (CryptoKit):** For the actual data (e.g., files, database entries), use a strong, modern cryptographic library. `CryptoKit` is the preferred choice. It provides a safe, Swift-native API for symmetric and asymmetric encryption. AES.GCM is an excellent choice for symmetric encryption as it's an Authenticated Encryption with Associated Data (AEAD) cipher, providing both confidentiality and integrity (protection against tampering).\n\n**Practical Code Example (CryptoKit):**\n```swift\nimport CryptoKit\n\nfunc encryptAndDecrypt() throws {\n    // 1. In a real app, this key would be securely retrieved from Keychain.\n    let key = SymmetricKey(size: .bits256)\n\n    let sensitiveData = \"Secret user info\".data(using: .utf8)!\n\n    // 2. Encrypt using AES.GCM. It returns a 'SealedBox' containing\n    // the ciphertext, nonce, and an authentication tag.\n    let sealedBox = try AES.GCM.seal(sensitiveData, using: key)\n\n    // 3. The 'combined' property gives a single Data object for storage.\n    let encryptedData = sealedBox.combined!\n    // Now, 'encryptedData' can be safely written to a file or database.\n\n    // --- DECRYPTION ---\n\n    // 4. Recreate the SealedBox from the stored data.\n    let boxToOpen = try AES.GCM.SealedBox(combined: encryptedData)\n\n    // 5. Decrypt using the same key. This verifies the tag and will\n    // throw an error if the data was tampered with.\n    let decryptedData = try AES.GCM.open(boxToOpen, using: key)\n\n    print(String(data: decryptedData, encoding: .utf8)!) // \"Secret user info\"\n}\n```\n\n**Common Pitfalls:**\n- **Hardcoding Keys:** The biggest mistake. Keys can be extracted from the binary.\n- **Storing Keys Insecurely:** Using `UserDefaults` or plist files for keys is insecure as they are not encrypted.\n- **Using Keychain for Large Data:** Keychain is optimized for small secrets, not large data blobs. Storing large amounts of data will lead to poor performance.\n- **Rolling Your Own Crypto:** Never invent your own encryption algorithms. Use industry-standard, well-vetted libraries.\n\n**Alternatives:**\n- **CommonCrypto:** A lower-level C API. It's more flexible and available on older iOS versions but is more error-prone (manual memory management, requires managing IVs, padding, etc.). Prefer `CryptoKit` unless you need specific ciphers it doesn't offer or need to support iOS < 13.\n- **Data Protection API:** A system-level file encryption mechanism. You apply an attribute to a file, and the OS handles encryption based on the device's passcode. It's simple but offers less granular control than per-field encryption with `CryptoKit`.",
      "code_example": null,
      "tags": [
        "security",
        "encryption",
        "CryptoKit",
        "Keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "How would you securely store a JWT and its refresh token, ensuring they are only accessible when the device is unlocked and are synchronized across the user's iCloud devices? Describe the specific Keychain attributes and process.",
      "back": "To securely store tokens, you'd use Keychain Services, an encrypted database managed by the OS outside your app's sandbox. This ensures data persists even if the app is deleted and is protected by hardware-backed encryption.\n\n**Core Concept:**\nThe process involves creating a dictionary (a query) that describes the item to save. For a JWT, you'd use the `kSecClassGenericPassword` class. The key attributes are `kSecAttrAccessible` to define the item's protection level and `kSecAttrSynchronizable` to control iCloud sync.\n\n- `kSecAttrAccessibleWhenUnlocked`: This attribute ensures the data can only be read after the user has unlocked the device once. It remains accessible, even in the background, until the device is locked again. This is a good balance between security and user experience for tokens.\n- `kSecAttrSynchronizable`: Setting this to `kCFBooleanTrue` flags the item for synchronization across a user's devices via their iCloud Keychain. The user must have iCloud Keychain enabled.\n\n**Practical Code Example:**\nA robust save operation often involves deleting any existing item before adding the new one to handle updates gracefully.\n\n```swift\nimport Foundation\n\nfunc saveToken(_ token: String, for account: String) -> Bool {\n    guard let tokenData = token.data(using: .utf8) else { return false }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account, // e.g., \"com.myapp.refreshtoken\"\n        kSecAttrService as String: \"my-app-service\" // A unique service identifier\n    ]\n\n    // First, delete any existing item for this account to avoid duplicates.\n    SecItemDelete(query as CFDictionary)\n\n    // Now, create the query to add the new item.\n    let addQuery: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecAttrService as String: \"my-app-service\",\n        kSecValueData as String: tokenData,\n        // Item is accessible only when device is unlocked.\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked,\n        // Enable iCloud Keychain synchronization.\n        kSecAttrSynchronizable as String: kCFBooleanTrue\n    ]\n\n    let status = SecItemAdd(addQuery as CFDictionary, nil)\n    return status == errSecSuccess\n}\n```\n\n**Common Pitfalls:**\n- **Update vs. Add:** Calling `SecItemAdd` for an item that already exists will fail with `errSecDuplicateItem`. The delete-then-add pattern shown above is a simple way to handle this. Alternatively, one could use `SecItemUpdate`.\n- **Attribute Conflicts:** You cannot set `kSecAttrSynchronizable` to true if you use a `...ThisDeviceOnly` accessibility attribute, as they are mutually exclusive. This will cause the save operation to fail.\n- **Simulator Behavior:** Keychain on the simulator does not fully replicate device behavior, especially concerning locking and entitlements. Always test on a physical device.\n\n**When to use vs Alternatives:**\n- **Keychain:** Ideal for small, sensitive secrets like tokens, passwords, and cryptographic keys.\n- **UserDefaults:** Never use for sensitive data. It's stored in an unencrypted plist file.\n- **Encrypted Database (e.g., Core Data with encryption):** Use for storing large volumes of sensitive, structured data. The encryption key for this database should itself be stored in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "ios",
        "api",
        "authentication"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "Explain how to implement biometric authentication using `LAContext`. Contrast `LAPolicyDeviceOwnerAuthentication` and `...WithBiometrics`, detailing the security implications and appropriate use cases for each, including Keychain integration.",
      "back": "The `LocalAuthentication` framework provides the `LAContext` class to authenticate a user. The process involves two main steps: checking if a policy is available with `canEvaluatePolicy`, then executing it with `evaluatePolicy`.\n\n**Core Concepts:**\n- `LAPolicyDeviceOwnerAuthenticationWithBiometrics`: This is the stricter policy. It requires the user to authenticate using only biometrics (Face ID or Touch ID). If biometrics fail, there is no automatic fallback to the device passcode. This policy provides a higher level of assurance that the specific biological user is present.\n- `LAPolicyDeviceOwnerAuthentication`: This policy is more flexible. It first attempts biometrics, but if they are unavailable or fail, it allows the user to authenticate with their device passcode. This is convenient but less secure, as it only proves that someone who knows the device passcode is using the app, not necessarily the owner.\n\n**Code Example:**\n```swift\nimport LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, String) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n    // The reason string is mandatory and shown to the user.\n    let reason = \"Please authenticate to access sensitive data.\"\n\n    // 1. Check if the device is capable of biometric authentication.\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        // 2. Evaluate the policy.\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authError in\n            // 3. The callback is on a private queue; dispatch to main for UI updates.\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, \"Authentication successful.\")\n                } else {\n                    let message = authError?.localizedDescription ?? \"Failed to authenticate.\"\n                    completion(false, message)\n                }\n            }\n        }\n    } else {\n        // Device does not support biometrics or they are not enrolled.\n        let message = error?.localizedDescription ?? \"Biometrics not available.\"\n        completion(false, message)\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Missing Info.plist Key:** You must add the `NSFaceIDUsageDescription` key to your `Info.plist` file, or the app will crash when attempting to use Face ID.\n- **UI on Background Thread:** The completion handler for `evaluatePolicy` does not run on the main thread. All UI updates must be dispatched to `DispatchQueue.main`.\n- **Security Misconception:** Assuming `deviceOwnerAuthentication` is as secure as `...WithBiometrics`. A compromised passcode breaks the former's security.\n\n**When to use vs. Alternatives:**\n- **Action-based Auth:** Use `LAContext.evaluatePolicy` directly when you need to authorize a specific user *action*, like approving a payment or viewing a secure section.\n- **Data-based Auth (Keychain):** For protecting *data* at rest (e.g., API tokens), the more robust approach is to store the item in the Keychain with access control flags like `kSecAccessControlBiometryCurrentSet`. The OS then manages the authentication prompt when you try to access the item, tying data decryption directly to successful authentication. This is generally more secure than a simple `evaluatePolicy` check.",
      "code_example": null,
      "tags": [
        "security",
        "biometrics",
        "LocalAuthentication",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}