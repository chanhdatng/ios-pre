{
  "topic": "security",
  "generated_at": "2026-01-16T04:04:09.898376+00:00",
  "cards": [
    {
      "id": "security_85b38a95715f",
      "front": "Your app must connect to a modern API and a legacy partner API that only supports HTTP. How do you configure App Transport Security (ATS) to allow this while minimizing your app's security attack surface?",
      "back": "App Transport Security (ATS) is an iOS security feature that enforces best practices for network connections, requiring HTTPS with TLS v1.2+, forward secrecy, and strong cipher suites by default. The goal is to create the narrowest possible exception for the legacy service without weakening security for all other network traffic.\n\nThe correct approach is to use the `NSExceptionDomains` key within the `NSAppTransportSecurity` dictionary in your app's `Info.plist`. This allows you to specify per-domain configurations that override the global ATS policy. For the legacy partner API, you would create an entry for its domain and set `NSExceptionAllowsInsecureHTTPLoads` to true. This whitelists insecure HTTP connections for that specific domain only, while all other connections (e.g., to your modern API) remain fully protected by ATS.\n\n**`Info.plist` Example:**\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <!-- By not setting NSAllowsArbitraryLoads, we keep ATS enabled globally -->\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>legacy-partner-api.com</key>\n        <dict>\n            <!-- This key allows standard HTTP connections for this domain -->\n            <key>NSExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n            <!-- Recommended to include subdomains if they are also used -->\n            <key>NSIncludesSubdomains</key>\n            <true/>\n        </dict>\n    </dict>\n</dict>\n```\n\n**Common Pitfalls:**\n- **Using `NSAllowsArbitraryLoads`:** The most critical mistake is setting the global `NSAllowsArbitraryLoads` key to `true`. This disables ATS for your entire application, is a major security vulnerability, and requires strong justification during App Store review.\n- **Forgetting Subdomains:** If the API uses various subdomains, failing to set `NSIncludesSubdomains` to `true` will cause those connections to fail, as the exception won't apply to them.\n\n**When to Use vs. Alternatives:**\n- **Use Exceptions:** Per-domain exceptions are necessary when you must interact with a third-party server that you do not control and cannot be updated.\n- **Preferred Alternative:** The best long-term solution is to advocate for the third-party service to upgrade their server to be ATS-compliant. A client-side exception should be considered a temporary workaround, not a permanent solution.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "Describe how you'd implement a feature requiring biometric authentication to access sensitive data in the Keychain. Detail the `LAContext` evaluation and the necessary `SecAccessControl` flags.",
      "back": "Implementing biometric-protected Keychain access involves two core frameworks: `LocalAuthentication` for the user-facing prompt and `Security` for secure storage.\n\n### Core Concept\nThe process is to first save a secret to the Keychain, protecting it with an access control policy that requires biometrics. Later, to read the secret, you first authenticate the user with `LocalAuthentication`. If successful, you use the authenticated `LAContext` instance itself as a key to unlock the Keychain item for a single operation.\n\n1.  **Saving Data**: When saving to the Keychain, you create a `SecAccessControl` object. The flag `.biometryCurrentSet` is crucial for high security. It ensures that if the user adds or removes a finger/face, the Keychain item is invalidated, preventing access by a newly-enrolled, potentially unauthorized user. You then associate this access control object with your Keychain item using the `kSecAttrAccessControl` key.\n\n2.  **Reading Data**: To retrieve the data, you create an `LAContext` and call `evaluatePolicy`. If the evaluation succeeds, you then perform your Keychain query. The query *must* include the `kSecUseAuthenticationContext` key, with its value being the successfully authenticated `LAContext` instance. This tells the Keychain to use the context's short-lived authentication credential to unlock the item.\n\n### Practical Code Example\n```swift\nimport LocalAuthentication\nimport Security\n\nfunc accessSecretWithBiometrics(completion: @escaping (String?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // 1. Check if the device is capable of biometric authentication.\n    guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n        // Handle cases where biometrics are not available or not enrolled.\n        print(\"Biometrics not available: \\(error?.localizedDescription ?? \"N/A\")\")\n        completion(nil)\n        return\n    }\n\n    // 2. Trigger the biometric prompt.\n    let reason = \"Please authenticate to access your secure data.\"\n    context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authError in\n        DispatchQueue.main.async {\n            guard success else {\n                // Handle failed authentication (user cancelled, wrong finger, etc.)\n                print(\"Authentication failed: \\(authError?.localizedDescription ?? \"N/A\")\")\n                completion(nil)\n                return\n            }\n\n            // 3. On success, query the Keychain using the authenticated context.\n            let query: [String: Any] = [\n                kSecClass as String: kSecClassGenericPassword,\n                kSecAttrService as String: \"com.myapp.secretservice\",\n                kSecAttrAccount as String: \"user_api_token\",\n                kSecMatchLimit as String: kSecMatchLimitOne,\n                kSecReturnData as String: true,\n                kSecUseAuthenticationContext as String: context // CRITICAL STEP\n            ]\n\n            var item: CFTypeRef?\n            if SecItemCopyMatching(query as CFDictionary, &item) == errSecSuccess,\n               let data = item as? Data, let secret = String(data: data, encoding: .utf8) {\n                completion(secret)\n            } else {\n                completion(nil) // Item not found or another Keychain error.\n            }\n        }\n    }\n}\n\n// How you would save the item initially:\nfunc saveSecret(_ secret: String) {\n    guard let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault, \n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly, \n        .biometryCurrentSet, // Invalidates on new biometric enrollment\n        nil\n    ) else { return }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"com.myapp.secretservice\",\n        kSecAttrAccount as String: \"user_api_token\",\n        kSecValueData as String: secret.data(using: .utf8)!,\n        kSecAttrAccessControl as String: accessControl\n    ]\n\n    SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n### Common Pitfalls & Edge Cases\n*   **Forgetting `kSecUseAuthenticationContext`**: The most common mistake is successfully authenticating but failing to pass the `LAContext` to the Keychain query. This will result in an `errSecUserCanceled` (-128) error because the Keychain item requires authentication which wasn't provided to it.\n*   **`biometryCurrentSet` vs. `biometryAny`**: Using `.biometryAny` is less secure. It allows access even after new biometric data is enrolled. For financial or highly sensitive apps, `.biometryCurrentSet` is the correct choice.\n*   **Invalidating `LAContext`**: An `LAContext` instance is single-use for an evaluation. If an evaluation fails, you must create a new instance for the next attempt.\n*   **Error Handling**: Not handling the wide range of `LAError` codes (e.g., `.userFallback`, `.userCancel`, `.biometryLockout`) leads to a poor user experience. You should provide clear feedback for each case.\n\n### When to Use vs. Alternatives\n*   **Use For**: Storing highly sensitive, long-lived data like OAuth refresh tokens, API keys, or user credentials that you don't want to force the user to re-enter constantly.\n*   **Alternative**: Use `.deviceOwnerAuthentication` policy instead of `.deviceOwnerAuthenticationWithBiometrics`. This allows the user to fall back to the device passcode, offering more convenience at the cost of the specific security of biometrics.\n*   **Alternative**: For less sensitive data, use a simpler Keychain protection level like `kSecAttrAccessibleWhenUnlocked`, which doesn't require a separate authentication step each time but is still encrypted on disk.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "biometrics",
        "localauthentication"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Beyond just using Keychain, describe your strategy for securing sensitive user data within an iOS app. Cover data at rest, in transit, and in memory, and explain how the Principle of Least Privilege guides your architectural choices.",
      "back": "A comprehensive security strategy is multi-layered, addressing data in its three states: transit, rest, and in memory, all guided by the Principle of Least Privilege (PoLP).\n\n**Core Concept: Layered Defense**\n1.  **Data in Transit:** All network communication must use TLS. For high-security applications (finance, healthcare), this is augmented with SSL/Certificate Pinning. Pinning ensures the app only communicates with servers presenting a specific, whitelisted certificate, mitigating Man-in-the-Middle (MITM) attacks that could use a compromised or fraudulent certificate.\n\n2.  **Data at Rest:** Sensitive data should never be stored in plaintext (e.g., in `UserDefaults` or flat files). \n    *   **Secrets (Tokens, Passwords):** Use the **Keychain**. It's a hardware-backed secure enclave. Crucially, use the correct accessibility attribute, like `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`, to ensure data is only readable when the device is unlocked.\n    *   **Large Datasets (PII, etc.):** For larger data structures, encrypt them using **CryptoKit** before writing to disk (e.g., Core Data, Realm, or files). The encryption key itself should be securely generated and stored in the Keychain.\n\n3.  **Data in Memory:** Minimize the time sensitive data is held in memory. Use `autoreleasepool` for large data operations and explicitly nil out variables holding sensitive information once they are no longer needed.\n\n**Principle of Least Privilege (PoLP) in Practice:**\nPoLP dictates that a module or class should only have access to the data and resources necessary for its function. This is implemented through Swift's access control (`private`, `fileprivate`, `internal`) to hide implementation details and prevent unauthorized access to sensitive logic or data handlers.\n\n```swift\nimport Foundation\nimport Security\n\n// A class demonstrating secure storage, applying PoLP.\nfinal class SecureStore {\n    // Service name provides a unique namespace in the Keychain.\n    private let service = \"com.yourapp.credentials\"\n\n    // This method is private, enforcing PoLP. External callers\n    // use the public, purpose-built methods below.\n    private func save(key: String, data: Data) -> OSStatus {\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrAccount as String: key,\n            kSecAttrService as String: service,\n            kSecValueData as String: data,\n            // Most secure accessible attribute: only available when unlocked.\n            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n        ]\n        SecItemDelete(query as CFDictionary)\n        return SecItemAdd(query as CFDictionary, nil)\n    }\n\n    // Public API exposes only the necessary functionality.\n    public func setAuthToken(_ token: String) {\n        guard let tokenData = token.data(using: .utf8) else { return }\n        save(key: \"authToken\", data: tokenData)\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Logging:** Never log sensitive data. Production logs can be exfiltrated.\n*   **Background Snapshot:** The system takes a snapshot of your app's UI for the app switcher. If sensitive data is visible, it gets cached. In `applicationDidEnterBackground`, cover sensitive UI with a placeholder view.\n*   **Jailbreak:** On a jailbroken device, sandbox protections are weakened. While jailbreak detection is not foolproof, it can be a deterrent for high-security apps.\n*   **Incorrect Keychain Accessibility:** Using `kSecAttrAccessibleAlways` makes the secret available even on a locked device, defeating a major security feature.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "cryptokit",
        "networking",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "security_a325baeb20c1",
      "front": "Describe the complete chain of trust in iOS code signing, from the Apple Root CA to a running app on a device. How does a provisioning profile act as the bridge between your developer identity, your app, and the device itself?",
      "back": "The iOS code signing process establishes a chain of trust to ensure an app's origin and integrity.\n\n**Core Concept: The Chain of Trust**\n\n1.  **Apple Root Certificate:** This is the ultimate anchor of trust, pre-installed on every Apple device. iOS inherently trusts anything signed by this certificate or a certificate it has signed.\n2.  **WWDR Intermediate Certificate:** Apple signs this with its Root Certificate. Its purpose is to sign developer certificates. This intermediate layer allows Apple to revoke developer certificates without compromising the root.\n3.  **Developer Certificate:** You generate a Certificate Signing Request (CSR) in Keychain Access, which creates a public/private key pair. You submit the CSR (containing your public key) to Apple. They verify you and sign your public key with the WWDR certificate, creating your Developer Certificate.\n4.  **Code Signature:** During the build process, Xcode uses your private key (stored securely in your Keychain) to create a digital signature of your app's binary.\n\n**The Provisioning Profile's Role**\n\nThe provisioning profile (`.mobileprovision`) is a file signed by Apple that ties everything together. It contains:\n- **App ID:** The bundle identifier(s) the profile is valid for.\n- **Certificates:** The developer certificates authorized to sign the app.\n- **Device UDIDs:** A list of devices authorized to run the app (for Development/Ad Hoc).\n- **Entitlements:** A list of permissions and capabilities the app can use (e.g., Push Notifications, iCloud).\n\nWhen you install an app, iOS performs these checks:\n1.  Verifies the provisioning profile's signature from Apple.\n2.  Verifies the app's code signature using the public key from the developer certificate found within the profile.\n3.  Verifies the developer certificate chains up to the trusted Apple Root CA.\n4.  Ensures the app's bundle ID matches the App ID in the profile.\n5.  For non-App Store builds, confirms the device's UDID is in the profile's list.\nIf all checks pass, the app is trusted and allowed to launch.\n\n**Practical Example (Command Line Inspection):**\n```bash\n# Verify the signature of a compiled app\n# This checks the integrity and validity of the signature.\ncodesign --verify --deep --strict --verbose=2 /path/to/YourApp.app\n\n# Display the entitlements embedded in the signature\ncodesign -d --entitlements :- /path/to/YourApp.app\n\n# Inspect the contents of the embedded provisioning profile\nsecurity cms -D -i /path/to/YourApp.app/embedded.mobileprovision\n```\n\n**Common Pitfalls:**\n- **\"No valid signing identities found\":** The private key corresponding to the certificate is missing from your Mac's Keychain. This often happens when moving to a new machine without exporting your developer profile.\n- **Expired Certificates/Profiles:** The WWDR Intermediate, Developer Certificate, or Provisioning Profile can expire, breaking the chain of trust and causing build failures.\n- **Entitlement Mismatch:** The app's `Entitlements.plist` requests a capability that isn't enabled for the App ID and included in the provisioning profile.\n\n**When to Use vs. Alternatives:**\nThe core process is mandatory, but different profile types serve different purposes:\n- **Development:** For debugging on a limited set of registered devices.\n- **Ad Hoc:** For distributing to up to 100 registered test devices, simulating an App Store installation.\n- **App Store:** For submitting to the App Store. Does not contain a device list.\n- **Enterprise:** For distributing proprietary, in-house apps within an organization, bypassing the public App Store.",
      "code_example": null,
      "tags": [
        "security",
        "build-process",
        "xcode",
        "app-distribution",
        "provisioning"
      ],
      "sources": [
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_a98037d94e1a",
      "front": "You're architecting a new finance app. How would you apply the OWASP Mobile Top 10, and which 2-3 risks would you prioritize mitigating from day one? Justify your choices.",
      "back": "The OWASP Mobile Top 10 is a risk-awareness framework, not a rigid checklist. For a finance app, user trust is paramount, so protecting data integrity and confidentiality is the top priority. I'd focus on these three risks first:\n\n1.  **M2: Insecure Data Storage:** This is critical because it protects user data on a potentially compromised device. Sensitive information like auth tokens, PII, or account details must never be stored in `UserDefaults` or unencrypted files, which are easily accessible on a jailbroken device.\n    *   **Mitigation:** Use the system Keychain, which leverages the device's Secure Enclave. Data is encrypted and access can be restricted.\n\n2.  **M3: Insecure Communication:** Protects data in transit from Man-in-the-Middle (MITM) attacks. Standard TLS is a good start, but it's vulnerable if a user installs a malicious root certificate.\n    *   **Mitigation:** Enforce TLS 1.2+ and implement certificate pinning (or public key pinning) to ensure the app only communicates with your trusted server.\n\n3.  **M4: Insecure Authentication:** Weak session management can lead to account takeovers.\n    *   **Mitigation:** Implement short-lived JWTs with a secure refresh token mechanism, stored in the Keychain. Use Face ID/Touch ID for re-authentication, but validate the biometric check on the server, not just on the client.\n\n**Practical Code Example (Keychain Storage):**\n```swift\n// Good: Storing a sensitive API token securely in the Keychain\nimport Security\n\nfunc saveToken(_ token: String) {\n    guard let data = token.data(using: .utf8) else { return }\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword, // Store as a generic password\n        kSecAttrAccount as String: \"com.myapp.authtoken\", // Unique key for the data\n        kSecValueData as String: data,\n        // Most secure accessible attribute: only available when device is unlocked\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n\n    // Delete any old item before adding the new one to prevent duplicates\n    SecItemDelete(query as CFDictionary)\n\n    let status = SecItemAdd(query as CFDictionary, nil)\n    if status != errSecSuccess {\n        print(\"Error saving to Keychain: \\(status)\")\n    }\n}\n\n// Bad: Storing in UserDefaults is insecure as it's a plaintext plist file.\n// UserDefaults.standard.set(\"secret-token\", forKey: \"authToken\")\n```\n\n**Common Pitfalls:**\n*   **Hardcoding Secrets:** API keys or encryption keys compiled into the binary (M5: Insufficient Cryptography) are easily extracted.\n*   **Ignoring Code Obfuscation:** Attackers can easily reverse-engineer an unprotected app to understand its logic and find vulnerabilities (M7: Code Tampering).\n*   **Excessive Logging:** Logging sensitive data in production builds can leak information via device console logs.\n\n**When to Use:** The OWASP list should be a constant guide throughout the development lifecycle. It complements other security practices like **Threat Modeling (e.g., STRIDE)** during the design phase and **SAST/DAST** tools in the CI/CD pipeline for automated vulnerability scanning.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "architecture",
        "keychain",
        "networking"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_b2f1eb5efae8",
      "front": "You're tasked with storing a sensitive user authentication token at rest. Compare using the Keychain with encrypting a file in the app's sandbox using CryptoKit. What are the security implications and trade-offs of each approach?",
      "back": "Both Keychain Services and CryptoKit are essential tools for securing data at rest, but they serve different primary purposes and present different trade-offs.\n\n### Core Concept: Keychain vs. CryptoKit\n\n**Keychain Services** is a system-level, encrypted database designed specifically for securely storing small pieces of sensitive data like passwords, certificates, and authentication tokens. The OS manages the encryption, using hardware-backed security features like the Secure Enclave. You interact with it through a C-style API, defining access control policies (e.g., `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`) that dictate when the data can be read.\n\n**CryptoKit** is a modern Swift framework that provides direct access to cryptographic operations like hashing, key agreement, and authenticated encryption (e.g., AES-GCM). It gives you the power to encrypt any `Data` blob. However, CryptoKit does *not* manage key storage. The developer is fully responsible for generating, storing, and retrieving the encryption keys, which is a critical security responsibility.\n\n### Practical Example\n\n```swift\nimport Foundation\nimport CryptoKit\nimport Security\n\n// 1. Using Keychain for a small secret (the token)\nfunc saveTokenToKeychain(token: String) {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.myapp.authtoken\",\n        kSecValueData as String: token.data(using: .utf8)!,\n        // Most secure: only available when device is unlocked, not in backups\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n    SecItemDelete(query as CFDictionary) // Ensure no duplicates\n    SecItemAdd(query as CFDictionary, nil)\n}\n\n// 2. Using CryptoKit to encrypt larger data\n// The key itself MUST be stored securely, typically in the Keychain!\nfunc encryptSensitiveFile(data: Data, key: SymmetricKey) throws -> Data {\n    let sealedBox = try AES.GCM.seal(data, using: key)\n    return sealedBox.combined! // Contains nonce, ciphertext, and tag\n}\n```\n\n### Common Pitfalls & Trade-offs\n\n*   **Keychain Pitfall:** Using the wrong accessibility attribute. The default allows data to be restored to a new device from an unencrypted backup, which might be undesirable. Another pitfall is trying to store large amounts of data, which is inefficient and not its intended use.\n\n*   **CryptoKit Pitfall:** The most critical pitfall is **improper key management**. Storing your `SymmetricKey` in `UserDefaults` or a plain file completely negates the security of the encryption. The key becomes the new secret you must protect.\n\n### When to Use vs. Alternatives\n\n*   **Use Keychain:** For the auth token itself. It's a small secret, and you want the OS to provide the highest level of hardware-backed, managed security with minimal effort.\n\n*   **Use CryptoKit:** If you needed to encrypt a large file, like a cached user profile or a local database. The best practice is a hybrid approach: generate a `SymmetricKey` with CryptoKit to encrypt the file, and then **store that `SymmetricKey` in the Keychain**. This combines CryptoKit's flexibility for large data with the Keychain's robust security for key storage, giving you the best of both worlds.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "cryptokit",
        "encryption"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "You're tasked with storing a user's API token securely, requiring biometric authentication for access. How would you use Keychain Services to achieve this, and what are the critical `kSecAttr...` flags and potential error states you must handle?",
      "back": "### Core Concept\n\nKeychain Services provides a secure, on-device database for storing small secrets like passwords, keys, and tokens. To require biometric authentication (Face ID/Touch ID), you don't just store the data; you associate it with an Access Control List (ACL) that dictates the conditions for its retrieval.\n\nThe core mechanism is the `kSecAttrAccessControl` attribute. You create a `SecAccessControl` object defining your security policy and include it in the dictionary for your `SecItemAdd` call. This policy is created using `SecAccessControlCreateWithFlags`. The key parameters are the protection type (e.g., `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`) and the access control flags (e.g., `.biometryCurrentSet`).\n\nWhen you later try to read this item using `SecItemCopyMatching`, the system (Security Framework) enforces the policy. If the policy requires biometrics, iOS will automatically present the Face ID or Touch ID prompt to the user before returning the data.\n\n### Practical Code Example\n\n```swift\nimport Foundation\nimport LocalAuthentication\n\n// Saves a secret that requires biometrics to access.\nfunc saveSecretWithBiometrics(account: String, secret: String) -> OSStatus {\n    guard let secretData = secret.data(using: .utf8) else { return errSecParam }\n\n    // 1. Create the access control object.\n    // .biometryCurrentSet invalidates the item if biometrics are changed (e.g., a new finger is added).\n    // This is more secure than .biometryAny.\n    var error: Unmanaged<CFError>?\n    guard let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n        .biometryCurrentSet,\n        &error\n    ) else {\n        print(\"Failed to create access control: \\(error?.takeRetainedValue() as? Error)\")\n        return errSecAuthFailed\n    }\n\n    // 2. Formulate the query to add the item.\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: secretData,\n        kSecAttrAccessControl as String: accessControl\n    ]\n\n    // 3. Delete any existing item before adding to prevent errSecDuplicateItem.\n    SecItemDelete(query as CFDictionary)\n\n    // 4. Add the item to the keychain.\n    return SecItemAdd(query as CFDictionary, nil)\n}\n\n// Retrieves the secret, triggering a biometric prompt.\nfunc retrieveSecret(account: String) -> String? {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecReturnData as String: kCFBooleanTrue!,\n        kSecMatchLimit as String: kSecMatchLimitOne,\n        // Provide a reason for the biometric prompt.\n        kSecUseOperationPrompt as String: \"Access your secure API token\"\n    ]\n\n    var dataTypeRef: AnyObject?\n    let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)\n\n    if status == errSecSuccess,\n       let retrievedData = dataTypeRef as? Data,\n       let secret = String(data: retrievedData, encoding: .utf8) {\n        return secret\n    }\n    // Handle specific, expected non-success cases.\n    if status == errSecUserCanceled {\n        print(\"User cancelled the biometric prompt.\")\n    }\n    return nil\n}\n```\n\n### Common Pitfalls & Edge Cases\n\n1.  **Error Handling:** Don't treat all non-zero statuses as fatal errors. `errSecUserCanceled` is a common result when the user dismisses the prompt; your UI should handle this gracefully. `errSecItemNotFound` is expected on first-time access.\n2.  **`biometryCurrentSet` vs. `biometryAny`:** Using `.biometryAny` allows access even if a new fingerprint or face is added after the item was stored. `.biometryCurrentSet` is stricter and invalidates the item if the set of enrolled biometrics changes, preventing a potential attack vector on an unlocked device.\n3.  **Simulator Limitations:** Biometric enforcement can be faked on the simulator, but its behavior (especially around enrollment changes) differs from a real device. Always test on physical hardware.\n4.  **Pre-flight Check:** Before saving an item with a biometric policy, you should use `LAContext().canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, ...)` to ensure the device supports and has biometrics enrolled. Saving might succeed without this check, but retrieval will fail.\n\n### When to Use vs. Alternatives\n\n-   **Keychain:** The definitive choice for small, high-value secrets: API tokens, passwords, encryption keys. Its primary strength is hardware-backed security and system-managed UI for access control.\n-   **Encrypted Core Data/Realm:** For large sets of structured, sensitive data. The database should be encrypted using a key that is itself stored securely in the Keychain.\n-   **`UserDefaults`:** Never for secrets. It's stored in an unencrypted property list, making it trivial to read from a device backup or a jailbroken device.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "biometrics",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}