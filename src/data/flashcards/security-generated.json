{
  "topic": "security",
  "generated_at": "2026-01-10T03:57:26.895066+00:00",
  "cards": [
    {
      "id": "security_b2f1eb5efae8",
      "front": "How would you securely store sensitive user data at rest on an iOS device, such as API tokens or PII? Describe the frameworks, key management strategies, and potential pitfalls.",
      "back": "Securing data at rest on iOS requires a multi-layered strategy, leveraging platform features and application-level encryption. The goal is defense in depth, so a compromise of one layer doesn't expose the data.\n\n**Core Concept:**\n1.  **OS-Level (Data Protection API):** This is the baseline. iOS automatically encrypts all files on flash storage. By assigning a `FileProtectionType` attribute, you control *when* a file is readable (e.g., `.complete` makes it accessible only when the device is unlocked). This protects against physical theft of the device.\n\n2.  **Keychain Services:** This is the primary mechanism for storing small, critical secrets like API tokens, user credentials, and, most importantly, cryptographic keys. The Keychain is a secure, encrypted database managed by the OS, with data backed by the Secure Enclave. You must choose the correct accessibility attribute (e.g., `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`) to prevent background access.\n\n3.  **Application-Level (CryptoKit):** For larger data blobs, files, or database entries, you should not store them directly in the Keychain. Instead, generate a symmetric encryption key, use it to encrypt the data with a modern algorithm from CryptoKit (like AES-GCM or ChaChaPoly), and store the *encrypted data* in a file. The *encryption key* itself is then stored securely in the Keychain.\n\n**Practical Code Example (CryptoKit):**\n```swift\nimport CryptoKit\n\n// Assumes you have a helper to securely manage keys in the Keychain.\n// For this example, we generate a key in-memory.\nlet symmetricKey = SymmetricKey(size: .bits256)\n\nfunc encrypt(data: Data) throws -> Data {\n    // ChaChaPoly is a modern, fast, and secure authenticated encryption cipher.\n    // 'seal' encrypts and adds an authentication tag to prevent tampering.\n    let sealedBox = try ChaChaPoly.seal(data, using: symmetricKey)\n    \n    // The 'combined' property contains the nonce, ciphertext, and tag together.\n    return sealedBox.combined\n}\n\nfunc decrypt(encryptedData: Data) throws -> Data {\n    // Recreate the sealed box from the combined data.\n    let sealedBox = try ChaChaPoly.SealedBox(combined: encryptedData)\n    \n    // 'open' verifies the authentication tag and decrypts the data.\n    // It will throw an error if the data was tampered with or the key is wrong.\n    let decryptedData = try ChaChaPoly.open(sealedBox, using: symmetricKey)\n    return decryptedData\n}\n```\n\n**Common Pitfalls:**\n-   **Poor Key Management:** Storing encryption keys in `UserDefaults`, Plists, or hardcoding them in the source code. This is the most critical mistake. Keys MUST be stored in the Keychain.\n-   **Incorrect Keychain Accessibility:** Using a permissive attribute like `kSecAttrAccessibleAlways` for a sensitive key allows it to be accessed even when the device is locked, defeating much of the hardware-backed security.\n-   **Rolling Your Own Crypto:** Never implement cryptographic algorithms yourself. Use battle-tested, standard libraries like `CryptoKit`.\n\n**When to Use vs. Alternatives:**\n-   **Keychain:** Use for small secrets (< 4KB) like passwords, tokens, and cryptographic keys. It's optimized for this purpose.\n-   **CryptoKit + File System:** Use for encrypting larger data like user-generated content, database files (e.g., an encrypted Realm or Core Data store), or network caches. The data lives in the file system, while its key lives in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "cryptography",
        "keychain",
        "cryptokit",
        "data protection"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "security_a98037d94e1a",
      "front": "Describe three significant risks from the OWASP Mobile Top 10 and detail their specific mitigation strategies within a native iOS application, including code examples.",
      "back": "The OWASP Mobile Top 10 highlights the most critical security risks for mobile apps. A senior developer should be able to address them proactively.\n\nHere are three key risks and their iOS-specific mitigations:\n\n**1. M3: Insecure Communication**\nThis risk involves data interception over the network (Man-in-the-Middle attacks). While TLS is standard via App Transport Security (ATS), a determined attacker can bypass it by installing a custom root certificate on the device. The advanced mitigation is **Certificate Pinning**.\n\n*   **Concept:** Instead of trusting any certificate signed by a trusted CA, the app bundles a specific server certificate's public key hash. During the TLS handshake, it verifies that the server's public key matches the pinned hash.\n*   **Code Example (Public Key Pinning with `URLSessionDelegate`):**\n```swift\nimport CryptoKit\n\nclass SecureURLSessionDelegate: NSObject, URLSessionDelegate {\n    // Pre-computed SHA-256 hash of the server's public key, Base64 encoded.\n    let pinnedPublicKeyHash = \"base64EncodedSha256HashOfServerPublicKey==\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        guard let trust = challenge.protectionSpace.serverTrust,\n              SecTrustEvaluateWithError(trust, nil) else {\n            completionHandler(.cancelAuthenticationChallenge, nil); return\n        }\n\n        // Extract public key from the first certificate in the chain.\n        guard let cert = SecTrustGetCertificateAtIndex(trust, 0),\n              let key = SecCertificateCopyKey(cert),\n              let keyData = SecKeyCopyExternalRepresentation(key, nil) as? Data else {\n            completionHandler(.cancelAuthenticationChallenge, nil); return\n        }\n\n        // Hash the key and compare with our pinned hash.\n        let hash = SHA256.hash(data: keyData).data.base64EncodedString()\n        if hash == pinnedPublicKeyHash {\n            completionHandler(.useCredential, URLCredential(trust: trust))\n        } else {\n            // Mismatch indicates a potential MitM attack.\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n}\n```\n\n**2. M2: Insecure Data Storage**\nThis involves storing sensitive data (tokens, PII) in insecure locations like `UserDefaults` or unencrypted files. The correct approach is to use the **Keychain**.\n\n*   **Concept:** The Keychain is a secure, encrypted database managed by the OS. It's crucial to use the correct accessibility attribute (`kSecAttrAccessible`) to control when the data can be read.\n*   **Pitfall:** Using `kSecAttrAccessibleAlways` is a common mistake, as it allows access even when the device is locked. For sensitive data, prefer `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` or `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`.\n\n**3. M1: Improper Platform Usage**\nThis broad category includes misusing platform features. A key example is insecure Inter-Process Communication (IPC) via **URL Schemes**.\n\n*   **Concept:** If App A sends sensitive data to App B via a URL scheme (`app-b://data=...`), a malicious app could also register `app-b://` and intercept the data. The OS doesn't guarantee which app will handle the URL.\n*   **Mitigation:** When receiving data via a URL scheme, always validate the source application using the `UIApplication.OpenURLOptionsKey.sourceApplication` key. Verify that the bundle identifier matches the expected sender before processing the data.\n\n*   **When to Use:** These principles are not optional; they should be integrated throughout the development lifecycle. This involves threat modeling during design, secure coding practices, and regular security audits/penetration testing, especially for apps handling sensitive user data.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "networking",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_a325baeb20c1",
      "front": "Describe the chain of trust in iOS code signing, from the developer's private key to OS verification. How do certificates and provisioning profiles work together to enable this?",
      "back": "The iOS code signing process establishes a chain of trust to ensure an app's integrity and authenticity. It guarantees the app was created by a known developer and hasn't been modified since it was signed.\n\n**Core Concept Explanation:**\n\nThe process relies on asymmetric cryptography:\n1.  **Identity (Certificate):** A developer generates a public/private key pair. They send a Certificate Signing Request (CSR) containing their public key to Apple. Apple, acting as a Certificate Authority (CA), validates the developer and signs their public key, creating a developer certificate (`.cer`). This certificate effectively says, \"Apple trusts that this public key belongs to this developer.\"\n\n2.  **Integrity (Code Signature):** During the build process, the app's binary and resources are hashed. This hash is then encrypted using the developer's **private key**. This encrypted hash is the code signature, and it's embedded into the app bundle.\n\n3.  **Authorization (Provisioning Profile):** A provisioning profile (`.mobileprovision`) is a file that ties everything together. It's signed by Apple and contains:\n    *   The **App ID** (e.g., `com.mycompany.myapp`).\n    *   The **developer certificates** authorized to sign this app.\n    *   A list of **device UDIDs** where the app can be installed (for Development/Ad Hoc).\n    *   A list of **entitlements** (e.g., push notifications, iCloud access).\n\n**On-Device Verification:**\nWhen an app is installed, iOS performs these checks:\n1.  It verifies the provisioning profile's signature to ensure it's from Apple.\n2.  It checks if the device's UDID is in the profile (for non-App Store builds).\n3.  It verifies that the developer certificate used to sign the app is listed in the profile.\n4.  It uses the public key from the certificate to decrypt the app's code signature, revealing the original hash. \n5.  It calculates a new hash of the app's binary.\n6.  If the decrypted hash matches the newly calculated hash, the OS confirms the app is untampered and from the correct developer, allowing it to run.\n\n**Practical Code Example (Fastlane `Fastfile`):**\nThis is a build-time process, so a CI/CD script is a more practical example than Swift code. Fastlane's `match` tool automates this.\n\n```ruby\n# Fastfile\nlane :release do\n  # 1. Fetches certificates and provisioning profiles from a secure git repo.\n  # Ensures the correct signing assets are available on the CI machine.\n  match(type: \"appstore\", readonly: true)\n\n  # 2. Builds and signs the app.\n  # `gym` uses the profiles fetched by `match` to sign the .ipa file.\n  gym(\n    scheme: \"MyApp\",\n    export_method: \"app-store\",\n    # Xcode can be instructed to use the profile managed by match\n    export_options: {\n      provisioningProfiles: {\n        \"com.mycompany.myapp\": \"match AppStore com.mycompany.myapp\"\n      }\n    }\n  )\nend\n```\n\n**Common Pitfalls:**\n*   **Private Key Mismatch:** The classic \"No valid signing identities found\" error occurs when the private key corresponding to the certificate in the provisioning profile is not in the build machine's Keychain.\n*   **Entitlement Mismatch:** The entitlements defined in the provisioning profile (e.g., Apple Pay enabled) do not match what's configured in the `Entitlements.plist` file or the App ID configuration on the developer portal.\n*   **Expired Assets:** Certificates and provisioning profiles expire. Automated tools like `match` help manage this, but manual setups often fail when an asset expires.\n\n**When to Use vs. Alternatives:**\nCode signing is mandatory. The variation comes from the *type* of provisioning profile used, which dictates the distribution channel:\n*   **Development:** For installing on a developer's own registered devices.\n*   **Ad Hoc:** For distributing to a limited set of 100 registered test devices.\n*   **App Store:** For submitting the final app to the App Store.\n*   **Enterprise:** For in-house distribution to employees, bypassing the App Store.",
      "code_example": null,
      "tags": [
        "security",
        "code-signing",
        "provisioning",
        "xcode",
        "ci-cd"
      ],
      "sources": [
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "When storing an auth token and a refresh token in the Keychain, what `kSecAttrAccessible` and `kSecAttrAccessControl` attributes would you use for each, and why? Explain the security implications of your choices.",
      "back": "This scenario requires balancing security with user experience based on the sensitivity of each token.\n\n**Core Concept:**\nThe Keychain provides secure, encrypted storage for small secrets. The key is choosing the right protection level. An auth token is short-lived and used frequently, while a refresh token is long-lived and highly sensitive, capable of generating new auth tokens.\n\n**Strategy:**\n1.  **Auth Token:** Since it's used often for API calls while the app is active, it needs to be readily accessible without constant user friction. `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` is ideal. It ensures the token is available only when the user has unlocked their device, and it is never migrated to a new device or included in iCloud backups, tying it to the physical device.\n\n2.  **Refresh Token:** This is the master key. Its access must be strictly controlled. We use `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` as a baseline, but add `kSecAttrAccessControl`. This object is created with flags like `.userPresence` or `.biometryCurrentSet`, which forces an OS-level biometric/passcode prompt before the Keychain will yield the secret. This ensures the user is actively present and authenticating for the critical operation of refreshing their session.\n\n**Code Example:**\n```swift\n// Helper to save a token with fine-grained access controls\nfunc saveToken(_ token: Data, account: String, requireUserPresence: Bool) -> OSStatus {\n    var query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecAttrService as String: \"com.yourapp.tokenservice\",\n        kSecValueData as String: token\n    ]\n\n    if requireUserPresence {\n        // Create access control requiring biometrics or passcode (user presence)\n        var error: Unmanaged<CFError>?\n        guard let accessControl = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            .userPresence, // or .biometryCurrentSet\n            &error\n        ) else {\n            print(\"Error creating access control: \\(error!.takeRetainedValue() as Error)\")\n            return errSecAuthFailed\n        }\n        query[kSecAttrAccessControl as String] = accessControl\n    } else {\n        // Standard accessibility for the less sensitive auth token\n        query[kSecAttrAccessible as String] = kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    }\n\n    // First, try to update an existing item to avoid duplicates\n    let status = SecItemUpdate([kSecClass as String: kSecClassGenericPassword, kSecAttrAccount as String: account] as CFDictionary, [kSecValueData as String: token] as CFDictionary)\n\n    // If it's not found, add it as a new item\n    if status == errSecItemNotFound {\n        return SecItemAdd(query as CFDictionary, nil)\n    }\n    return status\n}\n\n// Usage:\n// saveToken(authTokenData, account: \"authToken\", requireUserPresence: false)\n// saveToken(refreshTokenData, account: \"refreshToken\", requireUserPresence: true)\n```\n\n**Common Pitfalls:**\n*   **Using `kSecAttrAccessibleAlways`:** This is a major security risk, as it allows background processes to access the secret even when the device is locked. It should almost never be used for user credentials.\n*   **Not Handling Updates:** Simply calling `SecItemAdd` will fail with `errSecDuplicateItem` if the item already exists. A robust implementation must handle both add and update scenarios.\n*   **Forgetting `...ThisDeviceOnly`:** If you omit this, sensitive tokens could be synced via iCloud Keychain, potentially exposing them on less secure devices.\n\n**When to Use vs. Alternatives:**\n*   **Keychain:** Perfect for small, high-entropy secrets like tokens, passwords, and cryptographic keys.\n*   **UserDefaults:** Never for secrets. Use for non-sensitive user preferences.\n*   **Encrypted Database (e.g., Core Data with encryption, SQLCipher):** For large amounts of sensitive data. The encryption key for the database should itself be stored in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "authentication",
        "api"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_85b38a95715f",
      "front": "How would you configure App Transport Security (ATS) to allow connections to an internal HTTP-only server for development, while maintaining security for production, and what are the key security implications to consider?",
      "back": "App Transport Security (ATS) is an OS-level feature that enforces best practices for secure network connections, requiring HTTPS with TLS v1.2+, forward secrecy, and strong cipher suites. It is enabled by default.\n\nTo connect to an internal, insecure server (e.g., `http://dev.api.internal`), you should add a specific exception in your app's `Info.plist` file. This is far preferable to disabling ATS globally.\n\n**Core Concept:**\nThe goal is to create a granular exception that only affects the specific domain you need for development, leaving the default high-security policy in place for all other network requests. This is achieved using the `NSExceptionDomains` key within the `NSAppTransportSecurity` dictionary.\n\n**Practical Code Example (Info.plist):**\n```xml\n<!-- Add this dictionary to your Info.plist file -->\n<key>NSAppTransportSecurity</key>\n<dict>\n  <!-- Keep the global default setting to enforce ATS -->\n  <key>NSAllowsArbitraryLoads</key>\n  <false/>\n\n  <!-- Define exceptions for specific, trusted domains -->\n  <key>NSExceptionDomains</key>\n  <dict>\n    <!-- Key is the domain name requiring an exception -->\n    <key>dev.api.internal</key>\n    <dict>\n      <!-- Allows insecure HTTP loads for this domain -->\n      <key>NSExceptionAllowsInsecureHTTPLoads</key>\n      <true/>\n      <!-- Optional: Also apply this exception to subdomains like 'user.dev.api.internal' -->\n      <key>NSIncludesSubdomains</key>\n      <true/>\n    </dict>\n  </dict>\n</dict>\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Using `NSAllowsArbitraryLoads = true`:** This is the most common and dangerous mistake. It disables ATS for your entire application, making all network calls vulnerable to man-in-the-middle attacks. This requires strong justification for App Store review and should be avoided.\n2.  **Shipping Dev Exceptions:** Forgetting to remove development-only exceptions in production builds. A best practice is to use separate `Info.plist` files for different build configurations (Debug vs. Release) or use preprocessor macros to conditionally exclude the exception keys from release builds.\n3.  **Overly Broad Domains:** Using a broad domain like `com` is invalid and will be rejected. Be as specific as possible.\n\n**When to Use vs. Alternatives:**\n-   **Use `NSExceptionDomains`:** When you must connect to a specific, trusted server that doesn't yet meet ATS requirements (e.g., a legacy internal API).\n-   **Alternative - Fix the Server:** The best long-term solution is not an exception, but to update the server to be ATS-compliant. Exceptions should be considered a temporary workaround.\n-   **Alternative - `NSAllowsArbitraryLoadsInWebContent`:** If you need to load arbitrary web content inside a `WKWebView`, use this key instead of the global flag. It scopes the exception to the web view's context, protecting your app's native networking code.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Secure coding practices",
      "back": "",
      "code_example": null,
      "tags": [
        "Secure coding practices"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "Explain how to implement a secure biometric auth flow using `LAContext` and `LAPolicy`. How do you handle keychain integration for credentials unlocked by biometrics, and what are the key invalidation scenarios to consider?",
      "back": "Implementing secure biometric authentication involves two core frameworks: `LocalAuthentication` for the user prompt and the `Security` framework (Keychain) for credential storage.\n\n**Core Concept:**\n`LocalAuthentication`'s `LAContext` is used to evaluate a policy and ask the user to authenticate. It simply returns a success or failure state. It does *not* handle any data. The real security comes from storing sensitive data (like API tokens) in the Keychain and protecting it with an access control policy (`SecAccessControl`) that requires successful biometric authentication for retrieval. This check is enforced by the Secure Enclave at the hardware level, meaning your app code never handles the raw biometric data.\n\n**Practical Code Example:**\nFirst, we authenticate the user. Then, on success, we can attempt to access a Keychain item that is protected by biometrics.\n\n```swift\nimport LocalAuthentication\n\n// 1. Authenticate the user\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    context.localizedCancelTitle = \"Enter Username/Password\"\n    var error: NSError?\n\n    // Policy requires biometrics (Face ID/Touch ID). Passcode fallback is disabled.\n    let policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics\n\n    if context.canEvaluatePolicy(policy, error: &error) {\n        let reason = \"Log in to your account\"\n        context.evaluatePolicy(policy, localizedReason: reason) { success, authError in\n            DispatchQueue.main.async {\n                completion(success, authError)\n            }\n        }\n    } else {\n        // Biometry not available or not configured.\n        completion(false, error)\n    }\n}\n\n// 2. Storing an item in Keychain that requires biometrics to be read\nfunc saveTokenToKeychain(_ token: String) {\n    guard let tokenData = token.data(using: .utf8) else { return }\n\n    // Create an access control object with the desired protection.\n    // .biometryCurrentSet invalidates the item if biometrics are changed.\n    let access = SecAccessControlCreateWithFlags(kCFAllocatorDefault,\n                                                 kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                                                 .biometryCurrentSet, // or .biometryAny\n                                                 nil)!\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"user-api-token\",\n        kSecValueData as String: tokenData,\n        kSecAttrAccessControl as String: access\n    ]\n\n    // Add or update the item\n    SecItemDelete(query as CFDictionary) // Clear old item first\n    SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Biometric Invalidation:** This is the most critical edge case. If you use the `.biometryCurrentSet` flag (recommended), the Keychain item is cryptographically sealed to the current set of enrolled biometrics. If a user adds or removes a finger/face, the OS invalidates these items. Any attempt to read them will fail. Your app must handle this failure gracefully by catching the error, forcing the user to re-authenticate via a primary method (e.g., password), and then re-saving the credential to the Keychain to associate it with the new biometric set.\n2.  **Incorrect Policy:** Using `.deviceOwnerAuthentication` allows fallback to the device passcode. While convenient, this is less secure than `.deviceOwnerAuthenticationWithBiometrics` if your app's threat model requires stronger guarantees.\n3.  **Not Checking `canEvaluatePolicy`:** Always check if the policy is usable before attempting to evaluate it. A device might not have biometric hardware, or the user may not have it configured.\n\n**When to Use vs. Alternatives:**\nUse biometric authentication to reduce friction for frequent actions like unlocking the app or authorizing a transaction. It is not a replacement for a primary authentication mechanism like a password. The standard flow is: User logs in once with a password -> App receives an auth token -> App saves the token to the Keychain, protected by biometrics. On subsequent launches, the app uses biometrics to unlock that token for API calls.",
      "code_example": null,
      "tags": [
        "security",
        "biometrics",
        "localAuthentication",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}