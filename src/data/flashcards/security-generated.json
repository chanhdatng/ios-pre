{
  "topic": "security",
  "generated_at": "2026-01-15T04:04:42.375074+00:00",
  "cards": [
    {
      "id": "security_a98037d94e1a",
      "front": "Explain how you would mitigate the risks of 'Insecure Communication' (M3) and 'Insecure Data Storage' (M2) from the OWASP Mobile Top 10 in a modern Swift application. What are the trade-offs of your chosen solutions?",
      "back": "The OWASP Mobile Top 10 highlights the most critical security risks for mobile apps. M2 and M3 are foundational to protecting user data.\n\n**M3: Insecure Communication (Data-in-Transit)**\nThis risk involves data being intercepted as it travels between the app and the server. Mitigation is multi-layered:\n1.  **App Transport Security (ATS):** Enabled by default, ATS enforces TLSv1.2+ for all network connections. Avoid disabling it globally; only add specific, justified exceptions.\n2.  **Certificate Pinning:** For high-security apps, this prevents Man-in-the-Middle (MitM) attacks even if a device's Certificate Authority (CA) is compromised. You embed the server's public key or certificate hash in the app and validate it during the TLS handshake. The trade-off is operational complexity; you must update the app when the server certificate changes.\n\n```swift\n// Simplified Certificate Pinning with URLSessionDelegate\nclass NetworkService: NSObject, URLSessionDelegate {\n    // Hash of the server's public key (pre-calculated)\n    let pinnedPublicKeyHash = \"base64EncodedServerPublicKeyHash==\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust, \n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0) {\n            let serverPublicKey = SecCertificateCopyKey(serverCertificate)!\n            let serverPublicKeyData = SecKeyCopyExternalRepresentation(serverPublicKey, nil)! as Data\n            \n            // Compare the server's public key hash with our pinned hash\n            let sha256Hash = sha256(data: serverPublicKeyData)\n            if sha256Hash.base64EncodedString() == pinnedPublicKeyHash {\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                return\n            }\n        }\n        // If pinning fails, reject the connection\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n    // Helper to compute SHA256 hash, requires CryptoKit\n    private func sha256(data: Data) -> Data { /* ... */ }\n}\n```\n\n**M2: Insecure Data Storage (Data-at-Rest)**\nThis risk involves sensitive data being read from the device. The app sandbox provides baseline protection, but it's insufficient on a compromised (e.g., jailbroken) device.\n1.  **Keychain for Secrets:** Use the Keychain for small, sensitive data like API tokens, passwords, and encryption keys. It's a hardware-backed secure enclave. Always use the most restrictive `kSecAttrAccessible` attribute possible, like `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`.\n2.  **CryptoKit for Files:** For larger data sets (e.g., cached PII, databases), encrypt them before writing to disk using a symmetric cipher like AES.GCM from CryptoKit. Generate a unique encryption key, store it securely in the Keychain, and use it to encrypt/decrypt the file content.\n\n**Common Pitfalls:**\n*   Storing JWTs or API keys in `UserDefaults`, which is an unencrypted plist file.\n*   Disabling ATS with `NSAllowsArbitraryLoads` set to `true` in `Info.plist`.\n*   Implementing certificate pinning without a robust process for certificate rotation, which can render the app unusable.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "networking",
        "keychain",
        "cryptography",
        "ats"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Beyond Keychain for credentials, describe a multi-layered approach to securing sensitive user data within an iOS app, covering data at rest, in transit, and in memory.",
      "back": "A robust security strategy protects data throughout its lifecycle. This involves three key states:\n1.  **Data at Rest:** Data stored persistently on the device (e.g., in files, databases). Beyond the default filesystem encryption, use `CryptoKit` to encrypt sensitive files or database fields. The encryption key should be stored in the Keychain, not hardcoded. For simpler cases, `NSFileProtection` attributes can provide file-level encryption tied to the device passcode.\n\n2.  **Data in Transit:** Data moving between the app and a server. Always use HTTPS (TLS). For high-security applications, implement Certificate or Public Key Pinning to prevent Man-in-the-Middle (MITM) attacks where an attacker presents a fraudulent but otherwise valid certificate.\n\n3.  **Data in Memory:** Data held in RAM during app execution. This is the most volatile but also vulnerable state. Minimize the time sensitive data (like passwords or private keys) is held in memory. Overwrite memory locations after use. For cryptographic key operations, use the `SecureEnclave` to ensure private keys are never loaded into the main application memory, protecting them even from a compromised OS.\n\n### Code Example\n```swift\n// Encrypting a file using CryptoKit. The symmetric key should be\n// securely generated and stored in the Keychain.\nimport CryptoKit\n\nfunc encryptData(_ data: Data, withKey key: SymmetricKey) throws -> Data {\n    // AES.GCM is an authenticated encryption cipher that provides\n    // confidentiality and integrity.\n    let sealedBox = try AES.GCM.seal(data, using: key)\n    // The 'combined' property returns a single Data object containing\n    // the nonce, ciphertext, and authentication tag.\n    return sealedBox.combined!\n}\n\nfunc decryptData(_ encryptedData: Data, withKey key: SymmetricKey) throws -> Data {\n    let sealedBox = try AES.GCM.SealedBox(combined: encryptedData)\n    // open() will fail (throw an error) if the data has been\n    // tampered with, verifying its integrity.\n    return try AES.GCM.open(sealedBox, using: key)\n}\n```\n\n### Common Pitfalls\n- **Hardcoding Secrets:** Never store API keys, encryption keys, or other secrets in source code or property lists. Use Keychain or a secure server-driven configuration.\n- **Improper Keychain Accessibility:** Using `kSecAttrAccessibleAlways` for highly sensitive data allows it to be read from backups and on locked devices. Prefer stricter levels like `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`.\n- **Logging Sensitive Data:** Accidentally logging user credentials, tokens, or PII to the console or analytics can create a major vulnerability.\n- **Ignoring Jailbreak Threats:** On a jailbroken device, an attacker has root access and can bypass many sandbox protections. High-security apps should implement jailbreak detection.\n\n### When to Use vs. Alternatives\n- **Keychain:** Ideal for small secrets like passwords, auth tokens, and encryption keys.\n- **CryptoKit + File System:** Use for encrypting larger data blobs, files, or specific database fields. The key for this encryption should live in the Keychain.\n- **Certificate Pinning:** Use for apps handling highly sensitive data (finance, health). For most other apps, relying on the standard TLS trust chain and App Transport Security (ATS) is sufficient. Pinning adds significant maintenance overhead.\n- **Secure Enclave:** Use when you need to perform cryptographic operations without the private key ever being accessible to the application processor or OS. It's the highest level of on-device key protection.",
      "code_example": null,
      "tags": [
        "security",
        "cryptography",
        "keychain",
        "CryptoKit",
        "networking"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "How would you implement biometric authentication to protect sensitive data stored in the Keychain? Explain the roles of `LAContext`, `LAPolicy`, and the specific `SecAccessControlCreateFlags` required.",
      "back": "Biometric authentication is managed by the `LocalAuthentication` framework. The key is to not only perform the authentication check but to also tie that requirement directly to sensitive data stored in the Keychain, ensuring the OS enforces the check upon access.\n\n**Core Concept:**\n- `LAContext`: An object that provides an interface for requesting authentication from the user. It manages the UI prompt for Face ID/Touch ID.\n- `LAPolicy`: Defines the authentication method. `.deviceOwnerAuthenticationWithBiometrics` strictly requires biometrics. `.deviceOwnerAuthentication` allows biometrics OR a fallback to the device passcode, which is a less secure but more convenient option.\n- `SecAccessControl`: This is the bridge to the Keychain. When saving a Keychain item, you attach an access control object created with `SecAccessControlCreateWithFlags`. This object tells the OS the conditions under which the item can be read. The most secure flag for biometrics is `.biometryCurrentSet`, which links the item to the specific set of enrolled biometrics at the time of saving. If a user adds or removes a face/finger, the item is invalidated, preventing access even if a new, unauthorized biometric is added.\n\n```swift\nimport LocalAuthentication\n\n// 1. Authenticate the user and gate access to a feature\nfunc authenticateWithBiometrics() async -> Bool {\n    let context = LAContext()\n    var error: NSError?\n\n    // First, check if the device is capable of biometric authentication\n    guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n        print(\"Biometrics not available: \\(error?.localizedDescription ?? \"Unknown error\")\")\n        return false\n    }\n\n    // Present the biometric prompt to the user\n    do {\n        let reason = \"Authenticate to access your secure data.\"\n        try await context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason)\n        return true\n    } catch {\n        print(\"Authentication failed: \\(error.localizedDescription)\")\n        return false\n    }\n}\n\n// 2. Save data to Keychain, protected by biometrics\nfunc saveSecretToKeychain(_ secret: String) {\n    // Create access control object requiring the current set of biometrics\n    guard let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n        .biometryCurrentSet, // This flag invalidates the item if biometrics change\n        nil\n    ) else { return }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"myAppSecret\",\n        kSecValueData as String: secret.data(using: .utf8)!,\n        kSecAttrAccessControl as String: accessControl // Link policy to the item\n    ]\n\n    SecItemDelete(query as CFDictionary) // Ensure no old item exists\n    let status = SecItemAdd(query as CFDictionary, nil)\n    guard status == errSecSuccess else { \n        print(\"Failed to save to Keychain, status: \\(status)\") \n        return\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Missing `Info.plist` Key:** Forgetting to add the `NSFaceIDUsageDescription` string will cause the app to crash when authentication is requested.\n- **Choosing the Wrong `LAPolicy`:** Using `.deviceOwnerAuthentication` when you intend to *only* allow biometrics. This unintentionally allows the less-secure passcode fallback.\n- **Incorrect `SecAccessControlCreateFlags`:** Using `.biometryAny` is less secure than `.biometryCurrentSet` because it allows any biometric, even one added after the item was saved. Forgetting flags entirely means the data has no biometric protection.\n- **Poor Error Handling:** Not inspecting the `LAError` code to distinguish between user cancellation, lockout, or hardware unavailability, leading to a poor user experience.",
      "code_example": null,
      "tags": [
        "Security",
        "LocalAuthentication",
        "Keychain",
        "FaceID",
        "TouchID"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_85b38a95715f",
      "front": "Your app must connect to a legacy backend that doesn't support TLS 1.2. How would you configure App Transport Security (ATS), and what are the security trade-offs and potential App Store review issues you must consider?",
      "back": "App Transport Security (ATS) is an OS-level feature enforcing secure network connections over HTTPS with TLS v1.2+ and forward secrecy. By default, it blocks non-compliant connections. To connect to a legacy server, you must configure a domain-specific exception in your app's `Info.plist`.\n\nThis is done by adding the `NSAppTransportSecurity` dictionary and specifying `NSExceptionDomains`. You should be as specific as possible to minimize the security surface area.\n\n**Code Example (`Info.plist`):**\nThis allows insecure HTTP loads and connections using TLS v1.1 for a specific domain.\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>legacy.api.com</key>\n        <dict>\n            <!-- Include all subdomains, e.g., 'v1.legacy.api.com' -->\n            <key>NSIncludesSubdomains</key>\n            <true/>\n            <!-- Allow plain HTTP connections (use with caution) -->\n            <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n            <!-- Specify a lower minimum TLS version than the default 1.2 -->\n            <key>NSExceptionMinimumTLSVersion</key>\n            <string>TLSv1.1</string>\n        </dict>\n    </dict>\n</dict>\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Overly Broad Exceptions:** Never use `NSAllowsArbitraryLoads` set to `true` globally unless absolutely necessary (e.g., a web browser app). This disables ATS entirely and requires strong justification for App Store review.\n- **`WKWebView` Content:** For web views loading arbitrary content, use `NSAllowsArbitraryLoadsInWebContent` to create an exception specifically for that content, rather than disabling ATS app-wide.\n- **Justification:** Apple's review team scrutinizes ATS exceptions. You must provide a clear, valid reason for each one, such as connecting to a government server or a piece of hardware on a local network that cannot be updated.\n\n**When to Use vs. Alternatives:**\n- **Use Exceptions:** As a temporary measure for legacy backends or third-party SDKs that you do not control.\n- **Alternative (Preferred):** The best solution is to upgrade the server to be ATS-compliant. As a senior developer, you should advocate for this as the most secure and future-proof approach, rather than patching the client.",
      "code_example": null,
      "tags": [
        "Security",
        "Networking",
        "Info.plist",
        "ATS",
        "App Store Review"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "How would you architect the storage of sensitive user data like an OAuth token, and what specific Keychain attribute would you use to ensure it's accessible only when the device is unlocked? Explain the implications of this choice.",
      "back": "For sensitive data like an OAuth token, the only appropriate storage mechanism on iOS is the Keychain. It's a secure, encrypted database managed by the OS, designed specifically for small secrets.\n\n**Core Concept:**\nKeychain Services provides a secure enclave for data, isolated from the application's sandbox. Access is arbitrated by the `securityd` daemon, not the app directly. The core of my approach would be to use `SecItemAdd` and `SecItemCopyMatching` with a carefully constructed query dictionary. The most critical attribute for this scenario is `kSecAttrAccessible`.\n\nI would set `kSecAttrAccessible` to `kSecAttrAccessibleWhenUnlocked`. This ensures the keychain item can only be read when the device is unlocked by the user. The data is encrypted and inaccessible once the user locks their device, providing strong protection against unauthorized physical access and certain background attacks.\n\n**Practical Code Example:**\n```swift\nfunc saveToken(_ token: String, service: String) -> OSStatus {\n    guard let data = token.data(using: .utf8) else { return errSecParam }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword, // Store as a generic password\n        kSecAttrService as String: service, // Unique service identifier for your app\n        kSecAttrAccount as String: \"user_oauth_token\", // Unique account name for this token\n        kSecValueData as String: data, // The actual secret data\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked // CRITICAL: Only accessible when device is unlocked\n    ]\n\n    // Delete any existing item before saving to avoid duplicates\n    SecItemDelete(query as CFDictionary)\n\n    // Add the new item to the keychain\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls & Implications:**\n\n1.  **Background Access:** The major implication of `kSecAttrAccessibleWhenUnlocked` is that if your app needs to perform a background task (e.g., background fetch) that requires this token while the device is locked, the operation will fail with `errSecInteractionNotAllowed`. You must handle this gracefully.\n2.  **Choosing the Wrong Attribute:** Using `kSecAttrAccessibleAlways` is highly discouraged as it weakens security significantly. If background access is a hard requirement, `kSecAttrAccessibleAfterFirstUnlock` is a safer compromise, as the data remains encrypted until the user unlocks the device once after a reboot.\n3.  **Simulator vs. Device:** Keychain access controls are not fully enforced on the simulator. Always test security-sensitive features on a physical device.\n4.  **Error Handling:** Failing to check the `OSStatus` return code. For example, `errSecDuplicateItem` should be handled by updating the existing item, not treating it as a fatal error.\n\n**When to Use vs. Alternatives:**\n-   **Keychain:** Use for small secrets: auth tokens, API keys, passwords, cryptographic keys.\n-   **UserDefaults:** For non-sensitive user settings and preferences. Data is stored in an unencrypted plist.\n-   **Core Data/Files:** For large or complex application data. This data is not encrypted by default. If it's sensitive, you should encrypt it using a key stored in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "persistence",
        "authentication"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_a325baeb20c1",
      "front": "Your CI/CD pipeline fails with a 'No valid signing identity found' error, despite the correct certificate being on the build machine. Describe the chain of trust from certificate to device, and diagnose the most likely points of failure.",
      "back": "The error points to a breakdown in the chain of trust that Apple uses to verify an app's integrity and origin. This chain ensures an app comes from a known developer and hasn't been tampered with.\n\n**Core Concept Explanation:**\nThe process involves three key components:\n1.  **Certificate (Signing Identity):** This is a public/private key pair that identifies you as a trusted Apple developer. The private key, stored securely in your Keychain, is used to create a digital signature on your app's code. The public key is embedded in the certificate issued by Apple.\n2.  **App ID:** A unique string (e.g., `com.company.appname`) that identifies your app. It also defines the app's 'entitlements' or capabilities, such as Push Notifications or Sign in with Apple.\n3.  **Provisioning Profile:** This is the glue. It's a file that bundles everything together: the App ID, the certificates that are allowed to sign this app, and a list of device UDIDs authorized to run it (for Development/Ad Hoc builds). The profile itself is signed by Apple, vouching for its contents.\n\nWhen an app is installed, iOS verifies this chain: It checks that the provisioning profile is valid and signed by Apple. It then confirms that the certificate used to sign the app's code is listed in the profile. Finally, it verifies the app's bundle ID matches the App ID in the profile and that the device's UDID is included (if applicable).\n\n**Practical Code Example (Fastlane):**\nIn a CI/CD context, manual signing is preferred for its predictability. Fastlane's `match` and `gym` tools are commonly used to manage this.\n\n```ruby\n# Fastfile\nlane :build_and_sign do\n  # 1. 'match' ensures the correct certs and profiles are on the machine.\n  # It fetches them from a secure git repo. The error often happens here.\n  match(type: \"appstore\", readonly: true)\n\n  # 2. 'gym' builds and signs the app.\n  # It needs the profile and a matching identity in the keychain.\n  gym(\n    scheme: \"MyApp\",\n    export_method: \"app-store\",\n    export_options: {\n      # Explicitly tells Xcode which profile to use for which bundle ID.\n      provisioningProfiles: {\n        \"com.mycompany.myapp\" => \"match AppStore com.mycompany.myapp\"\n      },\n      # Explicitly states the certificate to use.\n      signingCertificate: \"Apple Distribution: My Company Inc.\"\n    }\n  )\nend\n```\n\n**Common Pitfalls & Diagnosis:**\nThe 'No valid signing identity found' error with a present certificate almost always means the **private key is missing**. A `.cer` file only contains the public key. You need the corresponding private key from the machine that originally created the Certificate Signing Request (CSR). This is why exporting a `.p12` file (which bundles the cert and private key) is critical.\n\nOther potential failures in the chain:\n1.  **Mismatched Entitlements:** The app requests a capability in its `Entitlements.plist` that is not enabled for the App ID in the provisioning profile.\n2.  **Expired Profile/Certificate:** The provisioning profile or the signing certificate has expired.\n3.  **Wrong Profile Type:** Trying to sign an App Store build with a Development profile, which lacks the necessary entitlements and distribution method.\n4.  **Device Not in Profile:** For Ad Hoc builds, the UDID of the target device is not included in the profile's list.\n\n**When to Use vs. Alternatives:**\n- **Automatic Signing (Xcode):** Ideal for solo developers or local builds. It's simple but can be a 'black box', making CI/CD debugging difficult as it may create its own managed profiles.\n- **Manual Signing (Explicit Profiles):** The standard for senior developers and teams, especially in CI/CD. It provides deterministic and repeatable builds by explicitly defining which certificate and profile to use, eliminating environmental ambiguity.",
      "code_example": null,
      "tags": [
        "security",
        "code signing",
        "provisioning",
        "xcode",
        "build process",
        "ci-cd"
      ],
      "sources": [
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_b2f1eb5efae8",
      "front": "You're tasked with storing sensitive user PII in a local database (e.g., Core Data). How would you design the encryption layer, and which native frameworks are critical for this implementation?",
      "back": "For sensitive PII, I'd implement application-level encryption on top of the default OS-level Data Protection. This ensures data is secure even if the device is unlocked and the database file is exfiltrated.\n\n**Core Concept:**\nThe strategy involves two key frameworks:\n1.  **CryptoKit:** A modern, Swift-native framework for cryptographic operations. I'd use an Authenticated Encryption with Associated Data (AEAD) cipher like `AES.GCM`. This is crucial because it provides both confidentiality (encryption) and integrity/authenticity (a tag to detect tampering), preventing common cryptographic attacks.\n2.  **Keychain Services (`Security` framework):** The system's secure vault for storing small secrets like cryptographic keys. The encryption key **must not** be stored with the data. By placing it in the Keychain, we tie its accessibility to device-level security policies (e.g., requiring device unlock) and keep it separate from the database.\n\nThe process is: On first launch for a user, generate a cryptographically secure symmetric key. Store this key in the Keychain. When writing an attribute to Core Data, encrypt it using the key, and store the resulting `Data` blob (the ciphertext + nonce + authentication tag, represented by `SealedBox`). When reading, fetch the encrypted blob, retrieve the key from Keychain, and decrypt.\n\n**Practical Code Example:**\n```swift\nimport CryptoKit\nimport Security\n\n// Simplified Keychain service for storing the key\nclass KeyManager {\n    private let account = \"com.myapp.encryptionkey\"\n\n    func getOrGenerateKey() throws -> SymmetricKey {\n        // 1. Try to fetch existing key from Keychain\n        // (Keychain query logic is verbose and omitted for clarity)\n        if let keyData = readFromKeychain() {\n            return SymmetricKey(data: keyData)\n        }\n\n        // 2. If no key, generate a new one and save it\n        let newKey = SymmetricKey(size: .bits256)\n        try saveToKeychain(key: newKey.withUnsafeBytes { Data($0) })\n        return newKey\n    }\n    // ... Keychain read/save helper methods ...\n}\n\nclass DataEncryptor {\n    private let key: SymmetricKey\n\n    init() throws {\n        self.key = try KeyManager().getOrGenerateKey()\n    }\n\n    // Encrypt PII (e.g., a user's email string)\n    func encrypt(pii: String) throws -> Data {\n        let dataToEncrypt = Data(pii.utf8)\n        let sealedBox = try AES.GCM.seal(dataToEncrypt, using: key)\n        // The sealedBox.combined property returns a single Data object\n        // containing nonce, ciphertext, and tag for easy storage.\n        return sealedBox.combined!\n    }\n\n    // Decrypt the data blob from the database\n    func decrypt(encryptedData: Data) throws -> String {\n        let sealedBox = try AES.GCM.SealedBox(combined: encryptedData)\n        let decryptedData = try AES.GCM.open(sealedBox, using: key)\n        return String(data: decryptedData, encoding: .utf8) ?? \"\"\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Key Mismanagement:** Storing the encryption key in `UserDefaults`, a plist, or hardcoding it. This is the most critical mistake as it completely undermines the security.\n*   **Using a predictable key:** Deriving a key from user input without proper key-derivation functions (KDFs) like PBKDF2.\n*   **Reusing Nonces/IVs:** `CryptoKit` handles nonce generation automatically, but when using lower-level APIs like `CommonCrypto`, developers might mistakenly reuse nonces, which is catastrophic for security in ciphers like AES-GCM.\n*   **Ignoring Key Lifecycle:** Failing to delete the key from the Keychain upon user logout or account deletion, leaving orphaned data that could potentially be decrypted later.\n\n**When to use vs. Alternatives:**\n*   **This Approach (CryptoKit + Keychain):** Best for highly sensitive data requiring the strongest protection. It provides granular, application-controlled security.\n*   **File Data Protection:** An OS feature (`NSFileProtectionComplete`) that encrypts a file when the device is locked. It's a great baseline defense but doesn't protect data when the device is unlocked. This approach should be used *in addition* to File Data Protection, not instead of it.\n*   **Core Data's `NSPersistentStoreEncrypted`:** An option available since iOS 15. It handles encryption transparently but offers less control over key management and the underlying cryptographic primitives. For maximum security and auditability, a manual implementation is often preferred in high-security contexts.",
      "code_example": null,
      "tags": [
        "security",
        "encryption",
        "cryptokit",
        "keychain",
        "core-data"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}