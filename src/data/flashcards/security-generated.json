{
  "topic": "security",
  "generated_at": "2026-01-19T04:22:05.538152+00:00",
  "cards": [
    {
      "id": "security_85b38a95715f",
      "front": "An app's network request to a legacy internal server via `http://intranet.mycompany.com` is failing. What's the likely cause, how do you diagnose it, and what are the recommended steps to resolve it while adhering to security best practices?",
      "back": "The likely cause is App Transport Security (ATS), an iOS security feature enabled by default since iOS 9. ATS enforces best practices for network connections, requiring servers to use HTTPS with TLS v1.2+ and forward secrecy. Any attempt to connect to an insecure `http://` endpoint will be blocked by the system.\n\n**Diagnosis:**\nThe first step is to check the device console logs in Xcode. When ATS blocks a request, it logs a detailed message, typically stating: `App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.` This confirms ATS is the culprit.\n\n**Resolution:**\nThe ideal solution is always to upgrade the server to support HTTPS. If that's not immediately possible, you must configure a specific exception in your app's `Info.plist`.\n\n**Code Example (Info.plist - Source Code):**\nAvoid the global override, which is a major security risk and may lead to App Store rejection.\n\n```xml\n<!-- \u274c BAD PRACTICE - AVOID -->\n<key>NSAppTransportSecurity</key>\n<dict>\n  <key>NSAllowsArbitraryLoads</key>\n  <true/>\n</dict>\n\n<!-- \u2705 GOOD PRACTICE - Domain-Specific Exception -->\n<key>NSAppTransportSecurity</key>\n<dict>\n  <key>NSExceptionDomains</key>\n  <dict>\n    <key>intranet.mycompany.com</key>\n    <dict>\n      <!-- Allows insecure HTTP loads for this domain -->\n      <key>NSExceptionAllowsInsecureHTTPLoads</key>\n      <true/>\n      <!-- Optional: Include if you need to connect to subdomains like api.intranet.mycompany.com -->\n      <key>NSIncludesSubdomains</key>\n      <true/>\n    </dict>\n  </dict>\n</dict>\n```\n\n**Common Pitfalls:**\n- **Global Exceptions:** Using `NSAllowsArbitraryLoads` opens your app to man-in-the-middle attacks on any network connection and requires strong justification for App Store review.\n- **Forgetting Subdomains:** If the API is on a subdomain, you must include the `NSIncludesSubdomains` key.\n- **WebView Content:** If a `WKWebView` needs to load mixed content (HTTP content on an HTTPS page), use `NSAllowsArbitraryLoadsInWebContent` instead of a broader exception to limit the scope.\n\n**When to Use vs. Alternatives:**\nUse ATS exceptions only as a temporary measure or when you have no control over the server (e.g., legacy enterprise systems, local hardware devices). The primary, long-term goal should always be to collaborate with backend teams to migrate the server to modern HTTPS standards. This is the only way to ensure true end-to-end security and data integrity for your users.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "Discuss your approach to securing an iOS app, covering data at rest, data in transit, and runtime protection. What are the trade-offs between using Keychain vs. an encrypted database like SQLCipher for sensitive data?",
      "back": "A multi-layered security approach is critical. For **data at rest**, sensitive information must never be stored in plaintext (e.g., in UserDefaults or logs). The Keychain is the standard for small secrets like API tokens or passwords, as it's hardware-backed by the Secure Enclave. For larger datasets, use libraries like CryptoKit to encrypt files or database fields before storing them.\n\nFor **data in transit**, App Transport Security (ATS) is the baseline, enforcing HTTPS. For high-security applications, **SSL/TLS Certificate Pinning** is essential to prevent Man-in-the-Middle (MITM) attacks by ensuring the app only communicates with servers presenting a specific, known certificate.\n\n**Runtime protection** involves measures like jailbreak detection and anti-debugging checks. These are deterrents, not foolproof, and should be used to make reverse-engineering more difficult.\n\n**Keychain vs. Encrypted Database (e.g., SQLCipher):**\n- **Keychain**: Use for small, atomic secrets. It's managed by the OS, offers hardware-level security, and the data is isolated from the app's sandbox. It is not designed for querying or storing large, structured data.\n- **Encrypted Database**: Use for large volumes of structured, sensitive data that needs to be queried (e.g., PII, financial records). It encrypts the entire database file. The crucial trade-off is that you must manage and protect the encryption key, which should itself be stored in the Keychain.\n\n```swift\n// Example: Simple Keychain wrapper for an API token\nimport Security\n\nfunc saveToken(token: String, service: String) {\n    guard let data = token.data(using: .utf8) else { return }\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: service,\n        kSecValueData as String: data,\n        // Ensures item is only accessible when device is unlocked\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked\n    ]\n    // Clear old item first to allow updates\n    SecItemDelete(query as CFDictionary)\n    \n    let status = SecItemAdd(query as CFDictionary, nil)\n    guard status == errSecSuccess else {\n        print(\"Error saving to Keychain: \\(status)\")\n        return\n    }\n}\n```\n\n**Common Pitfalls:**\n- Storing sensitive data in logs, UserDefaults, or plist files.\n- Using the wrong `kSecAttrAccessible` flag, making Keychain data available when the device is locked.\n- Relying solely on client-side security; the server must always be the source of truth and perform its own validation.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "networking",
        "cryptokit",
        "ats"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "When implementing biometric auth with `LAContext`, what are the key differences between `.deviceOwnerAuthentication` and `...WithBiometrics` policies, and what security considerations must be made regarding keychain access and policy invalidation?",
      "back": "The core difference lies in the authentication methods allowed. `LAPolicy.deviceOwnerAuthenticationWithBiometrics` strictly requires Face ID or Touch ID. If biometrics fail or are not enrolled, the evaluation fails. In contrast, `LAPolicy.deviceOwnerAuthentication` allows the user to fall back to the device passcode if biometrics fail.\n\n**Core Concept:**\nThis choice has significant security implications. The passcode is more susceptible to shoulder-surfing and can be simpler than the complex data backing biometrics. Therefore, the stricter `...WithBiometrics` policy should be used for actions requiring the highest level of assurance that the specific, registered user is present, such as authorizing a financial transaction or accessing encrypted keys.\n\n**Keychain and Policy Invalidation:**\nWhen storing secrets in the Keychain using `kSecAccessControlBiometryCurrentSet`, the data is cryptographically tied to the current set of enrolled biometrics. If a user adds or removes a finger/face, the underlying keys are invalidated, and access is permanently lost. To handle this, you must check for biometric changes using `LAContext`'s `evaluatedPolicyDomainState`. If this state data changes between app launches, you know the biometric database has been altered and must prompt the user to re-authenticate and re-establish their credentials.\n\n```swift\nimport LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    // 1. Check if the device is capable of biometric authentication.\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Log in to your account\"\n\n        // 2. Evaluate the policy. Use the stricter policy for sensitive actions.\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authError in\n            // 3. UI updates must be on the main thread.\n            DispatchQueue.main.async {\n                if success {\n                    // Authentication successful\n                    // Proceed with sensitive action\n                    // Optionally, store context.evaluatedPolicyDomainState to check for changes later.\n                } else {\n                    // Authentication failed\n                    // Handle specific errors like .userCancel, .authenticationFailed, etc.\n                } \n            }\n        }\n    } else {\n        // Biometry not available or not enrolled. Provide an alternative auth method.\n        print(\"Biometry not available: \\(error?.localizedDescription ?? \"N/A\")\")\n    }\n}\n```\n\n**Common Pitfalls:**\n- **UI on Background Thread:** `evaluatePolicy`'s completion handler is not guaranteed to be on the main thread. Always dispatch UI updates to `DispatchQueue.main`.\n- **Ignoring `canEvaluatePolicy`:** Failing to check for hardware support and enrollment before attempting to authenticate.\n- **Neglecting `evaluatedPolicyDomainState`:** Not tracking changes to the biometric database can lead to users being permanently locked out of keychain data tied to a previous biometric set.\n\n**When to Use vs. Alternatives:**\n- **`...WithBiometrics`:** Use for critical operations: financial transactions, accessing medical records, or decrypting data from the Keychain.\n- **`...Authentication`:** Use for lower-security convenience features, like unlocking the app to view non-sensitive content, where a passcode fallback is an acceptable risk.",
      "code_example": null,
      "tags": [
        "Security",
        "LocalAuthentication",
        "Keychain",
        "LAContext",
        "Biometrics"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_a98037d94e1a",
      "front": "You're auditing a new feature that handles PII. Based on the OWASP Mobile Top 10, what are your top 3 concerns, and how would you mitigate each in Swift?",
      "back": "When auditing a feature handling Personally Identifiable Information (PII), my top three concerns from the OWASP Mobile Top 10 would be M2: Insecure Data Storage, M3: Insecure Communication, and M1: Improper Platform Usage.\n\n**1. M2: Insecure Data Storage**\nThis is the most common vulnerability. Storing sensitive data like auth tokens or PII in plaintext files, `UserDefaults`, or unencrypted databases makes it trivial to extract on a compromised device.\n\n*   **Mitigation:** The iOS Keychain is the only appropriate place for such data. It's a hardware-backed, encrypted database managed by the OS. I'd create a secure wrapper around the Keychain APIs to handle storing and retrieving data.\n*   **Code Example (Simplified Keychain Helper):**\n```swift\n// Simplified Keychain helper to store a user's API token\nfunc saveToken(token: String, for account: String) {\n    guard let data = token.data(using: .utf8) else { return }\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account, // e.g., user's email\n        kSecValueData as String: data,\n        // Use the most restrictive protection class possible\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n    SecItemDelete(query as CFDictionary) // Delete old item first\n    SecItemAdd(query as CFDictionary, nil)\n}\n```\n*   **Pitfall:** Choosing the wrong `kSecAttrAccessible` level. Using a less secure option could expose the data even when the device is locked.\n\n**2. M3: Insecure Communication**\nTransmitting PII over unencrypted or improperly secured channels exposes it to Man-in-the-Middle (MitM) attacks. Standard TLS is good, but a compromised certificate authority or a user-installed malicious root certificate can defeat it.\n\n*   **Mitigation:** Enforce TLS 1.2+ via App Transport Security (ATS) in `Info.plist`. For maximum security, implement SSL/Certificate Pinning. This involves bundling the server's public key or certificate within the app and validating the server's identity against this bundled copy during the TLS handshake.\n*   **Code Example (Conceptual Pinning Check):**\n```swift\n// In URLSession delegate, conceptually how you'd check a cert\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n    guard let serverTrust = challenge.protectionSpace.serverTrust,\n          SecTrustGetCertificateCount(serverTrust) > 0 else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n    \n    // 1. Get the server's certificate from the trust evaluation\n    guard let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0) else { /* ... */ }\n    let serverCertData = SecCertificateCopyData(serverCertificate) as Data\n\n    // 2. Load your bundled, trusted certificate\n    let bundledCertData = /* Load your .cer file from the app bundle */\n\n    // 3. Compare the server's cert with your bundled cert\n    if serverCertData == bundledCertData {\n        completionHandler(.useCredential, URLCredential(trust: serverTrust))\n    } else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n}\n```\n*   **Pitfall:** Certificate pinning creates operational overhead. When the server certificate expires, the app will break. A robust strategy for updating the pinned certificate (via app updates) is essential.\n\n**3. M1: Improper Platform Usage**\nThis involves misusing iOS features like Touch ID/Face ID, Keychain, or permissions. A common mistake is using a successful biometric auth as a key to unlock locally stored (but insecure) data.\n\n*   **Mitigation:** Use platform features as intended. For biometrics, perform authentication to authorize a specific, sensitive action (like a transaction), not to simply unlock the app or retrieve a stored password. The sensitive operation itself should happen inside the successful authentication callback.\n*   **Pitfall:** Not including the `NSFaceIDUsageDescription` key in `Info.plist` will cause the app to crash when attempting to use Face ID. Always provide a fallback for users without biometrics.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "keychain",
        "networking",
        "biometrics"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_b2f1eb5efae8",
      "front": "You're tasked with storing sensitive user data: an API auth token and a large JSON file of user-generated content. How would you securely persist both, and what are the trade-offs of your chosen approaches versus alternatives like SQLCipher?",
      "back": "For a robust and secure solution, you should employ a layered approach tailored to the data type.\n\n**Core Concept: Layered Security**\n1.  **Auth Token:** The Keychain is the ideal storage for small, discrete secrets like API tokens. It's a system-managed, encrypted database that can leverage the device's Secure Enclave for key management, making it extremely difficult to extract keys. You can specify accessibility attributes (e.g., `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`) to control when the data can be read.\n\n2.  **Large JSON File:** Storing large data in the Keychain is inefficient. Instead, we use a two-layer approach:\n    *   **Layer 1 (OS-Level): `FileProtection`**. We write the file to disk with a strong file protection type, like `Data.WritingOptions.completeFileProtection`. This encrypts the file at rest, and the OS manages decryption when the device is unlocked.\n    *   **Layer 2 (App-Level): `CryptoKit`**. We generate a symmetric encryption key, use it to encrypt the file's contents before writing to disk, and store this key in the Keychain. This protects the data even if the device is unlocked and the file system is somehow compromised.\n\n**Practical Code Example (CryptoKit)**\n```swift\nimport CryptoKit\nimport Foundation\n\n// 1. Generate and store a key securely in the Keychain (this is a one-time setup).\n// let key = SymmetricKey(size: .bits256)\n// KeyChainManager.save(key, for: \"myFileEncryptionKey\")\n\n// 2. Encrypt and write data.\nfunc encryptAndSave(data: Data, key: SymmetricKey, to url: URL) throws {\n    // Encrypt using AES-GCM, a modern authenticated encryption algorithm.\n    let sealedBox = try AES.GCM.seal(data, using: key)\n    \n    // The sealedBox contains the nonce, ciphertext, and authentication tag.\n    // We write its combined representation to a file with strong protection.\n    try sealedBox.combined!.write(to: url, options: [.atomic, .completeFileProtection])\n}\n\n// 3. Read and decrypt data.\nfunc loadAndDecrypt(from url: URL, key: SymmetricKey) throws -> Data {\n    let combinedData = try Data(contentsOf: url)\n    let sealedBox = try AES.GCM.SealedBox(combined: combinedData)\n    \n    // Decrypting automatically verifies the data's integrity.\n    return try AES.GCM.open(sealedBox, using: key)\n}\n```\n\n**Common Pitfalls**\n*   **Storing Keys Insecurely:** Never store encryption keys in `UserDefaults`, plists, or hardcoded in the source. They are secrets and belong in the Keychain.\n*   **Using Weak File Protection:** Choosing a weak `FileProtection` type (e.g., `completeUntilFirstUserAuthentication`) can leave data vulnerable for longer periods.\n*   **Rolling Your Own Crypto:** Never implement cryptographic algorithms yourself. Always use established, peer-reviewed libraries like Apple's `CryptoKit`.\n\n**When to Use vs. Alternatives**\n*   **Keychain + CryptoKit/FileProtection (Recommended):** The standard, most secure approach for iOS apps. It leverages platform-specific hardware and OS features for maximum security.\n*   **SQLCipher:** This is a third-party library that provides full database encryption for SQLite. It's an excellent choice if your primary requirement is to encrypt an entire Core Data or GRDB database. However, it adds an external dependency, can have a performance overhead, and requires careful management of the database passphrase (which itself should be stored in the Keychain).",
      "code_example": null,
      "tags": [
        "security",
        "encryption",
        "CryptoKit",
        "Keychain",
        "FileProtection"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "security_a325baeb20c1",
      "front": "Describe the cryptographic chain of trust established by iOS code signing. How do Certificates, App IDs, and Provisioning Profiles work together to ensure an app can securely run on a specific device?",
      "back": "iOS security relies on a cryptographic chain of trust to ensure apps are from a known source and haven't been tampered with. This process connects your identity as a developer to your app and the devices it can run on.\n\n**Core Concept Explanation:**\nThe chain starts with Apple's trusted root certificate. Apple uses this to sign an intermediate certificate, which in turn signs your Developer/Distribution Certificate. This certificate links your identity (verified by Apple) to a public/private key pair you generated.\n\n1.  **Certificate (.cer):** An identity document. It confirms you are a trusted Apple developer. It contains your public key.\n2.  **App ID:** A unique identifier for your app (e.g., `com.company.appname`) that also defines which app services (like Push Notifications or HealthKit) it can use.\n3.  **Provisioning Profile (.mobileprovision):** This is the critical link. It's a file that bundles everything together: the App ID, the certificates allowed to sign the app, and (for non-App Store builds) a list of authorized device UDIDs. This profile is signed by Apple.\n\nWhen you build your app, Xcode uses your **private key** (stored in your Keychain) to sign the app binary. The provisioning profile is embedded into the app bundle. When a user tries to install the app, iOS performs a series of checks: it verifies the profile's signature from Apple, checks if the app's signature corresponds to a certificate in the profile, and confirms the device's UDID is on the list. If all checks pass, the app is trusted and allowed to launch.\n\n**Practical Code Example (Fastlane `Fastfile`):**\nSenior developers often automate this process for consistency, especially in CI/CD environments. Fastlane's `match` tool is a common way to manage this.\n\n```ruby\n# In your Fastfile\nlane :deploy_adhoc do\n  # 'match' syncs certificates and profiles from a secure git repo\n  # It ensures the entire team uses the same signing identity.\n  match(type: \"adhoc\", app_identifier: \"com.yourcompany.yourapp\")\n\n  # build_app uses the credentials fetched by match\n  build_app(\n    scheme: \"YourApp\",\n    export_method: \"ad-hoc\"\n  )\nend\n```\n\n**Common Pitfalls:**\n*   **Missing Private Key:** Having a certificate in Keychain Access without its corresponding private key. This often happens when setting up a new machine and only importing the .cer file.\n*   **Entitlement Mismatch:** The app's `Entitlements.plist` file requests a capability (e.g., iCloud) that is not enabled for the App ID in the provisioning profile.\n*   **Profile/Certificate Expiration:** A classic CI/CD failure. Automated tools like Fastlane can help manage and renew these automatically.\n*   **Xcode's \"Automatic Signing\" Ambiguity:** While convenient, it can sometimes create confusing, duplicate profiles (e.g., \"Managed by Xcode\") and hide the underlying mechanics, making it harder to debug issues in a team or CI environment.\n\n**When to Use vs. Alternatives:**\nThis process is mandatory for all iOS development. The choice lies in *how* you manage it:\n*   **Manual/Automatic Xcode Management:** Suitable for solo developers or small projects. It's built-in but can be opaque and lead to team inconsistencies (\"it works on my machine\").\n*   **Automated Certificate Management (e.g., Fastlane Match):** The standard for senior developers and teams. It centralizes signing assets in a secure, version-controlled repository, ensuring consistent, reproducible builds across all developer machines and CI servers.",
      "code_example": null,
      "tags": [
        "security",
        "build process",
        "ci-cd",
        "xcode"
      ],
      "sources": [
        "https://developer.apple.com/news/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "Design a robust Keychain storage strategy for a user's auth token. How do you ensure it persists across app reinstalls but is invalidated if the device backup is restored to a *new* device? Detail the specific Keychain attributes you'd use.",
      "back": "The core of this strategy lies in using a combination of Keychain Access Groups and specific accessibility attributes.\n\n**Core Concept Explanation:**\nKeychain Services provides a secure, on-device database for sensitive data. To achieve the required behavior:\n1.  **Persistence across Reinstalls:** Use an `kSecAttrAccessGroup`. When an item is added to an access group, it's associated with that group's provisioning profile, not just the app's sandbox. If the user deletes and reinstalls the app, as long as the new app has the same App ID and the 'Keychain Sharing' entitlement for that group, it can retrieve the item.\n2.  **Invalidation on New Devices:** Use an accessibility attribute ending in `...ThisDeviceOnly`, such as `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`. This flag instructs the system *not* to include this Keychain item in an encrypted device backup. When a user restores their backup to a new device, the auth token will be missing, forcing them to log in again. This is a critical security measure to prevent token hijacking.\n\n**Practical Code Example (Upsert logic):**\n```swift\nfunc saveToken(data: Data, for account: String) -> OSStatus {\n    // 1. Define the query to locate the item, including the access group.\n    // The 'Keychain Sharing' capability must be enabled for this to work.\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecAttrService as String: \"com.yourapp.authtoken\",\n        kSecAttrAccessGroup as String: \"YOUR_TEAM_ID.com.yourapp.shared\"\n    ]\n\n    // 2. Attributes to add/update. The accessibility constant is key here.\n    let attributes: [String: Any] = [\n        kSecValueData as String: data,\n        kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly\n    ]\n\n    // 3. Attempt to update an existing item first.\n    let status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)\n\n    // 4. If the item doesn't exist (errSecItemNotFound), add it.\n    if status == errSecItemNotFound {\n        var newQuery = query\n        newQuery.merge(attributes) { (_, new) in new }\n        return SecItemAdd(newQuery as CFDictionary, nil)\n    }\n\n    return status\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Missing Entitlement:** Forgetting to enable the 'Keychain Sharing' capability in Xcode for your App ID. Without this, `kSecAttrAccessGroup` will fail silently, and data will be lost on app deletion.\n*   **Simulator vs. Device:** Keychain behavior, especially regarding entitlements and access controls, is not fully replicated on the simulator. Always test persistence and security features on a physical device.\n*   **Wrong Accessibility:** Using `kSecAttrAccessibleWhenUnlocked` instead of a `...ThisDeviceOnly` variant will cause the token to be migrated to new devices via backups, which is a security risk.\n\n**When to Use vs. Alternatives:**\n*   **Use Keychain For:** Small, critical secrets like auth tokens, API keys, and cryptographic keys. Its strength is secure, atomic storage, not querying or large data sets.\n*   **Alternatives:** `UserDefaults` is insecure (plaintext plist) and should never be used for secrets. Encrypted Core Data/Realm is for larger volumes of sensitive *structured data*, but the encryption key itself should be stored in the Keychain.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "persistence",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}