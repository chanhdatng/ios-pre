{
  "topic": "security",
  "generated_at": "2026-01-12T04:20:49.156920+00:00",
  "cards": [
    {
      "id": "security_a325baeb20c1",
      "front": "Explain the chain of trust in iOS code signing. How does a provisioning profile link your developer identity to a specific app and device, and what role does each component (CSR, certificate, private key) play in this process?",
      "back": "The core goal of code signing is to guarantee an app's integrity (it hasn't been modified) and authenticity (it comes from a trusted developer). This is achieved through a chain of trust rooted in Apple.\n\n**Core Concept: The Chain of Trust**\n1.  **Key Pair & CSR:** You generate a public/private key pair on your Mac. The Certificate Signing Request (CSR) bundles your public key and identity information. Your private key remains securely in your Keychain.\n2.  **Developer Certificate:** You submit the CSR to Apple. Apple's Certificate Authority (CA) verifies you and uses its private key to sign your public key, creating your Developer Certificate (`.cer`). This certificate effectively says, \"Apple vouches that this public key belongs to this developer.\"\n3.  **Signing the App:** When you build, Xcode hashes your app's binary. This hash is then encrypted with your **private key**. This encrypted hash is the digital signature. Anyone with your public key (from your certificate) can decrypt it and verify that the app binary hasn't changed.\n\n**Provisioning Profile: The Glue**\nA provisioning profile (`.mobileprovision`) is a file signed by Apple that connects all the pieces. It authorizes your signed app to be installed and run. It contains:\n- **App ID:** The bundle identifier(s) the profile is valid for.\n- **Certificates:** A list of developer certificates allowed to sign the app.\n- **Entitlements:** A list of enabled services (e.g., Push Notifications, iCloud).\n- **Device UDIDs:** (For Development/Ad Hoc) A list of specific devices permitted to run the app.\n\n**Practical Example: Tapping 'Run' in Xcode**\n```text\n// This is a conceptual flow, not executable code.\n\n// 1. ON YOUR MAC (Signing)\n// Xcode finds your private key in the Keychain.\n// It compiles the app, creating a binary hash.\n// It encrypts the hash with your private key, creating the digital signature.\n// It bundles the app, signature, and a valid provisioning profile into an .ipa.\n\n// 2. ON THE iOS DEVICE (Verification)\n// a. iOS checks the provisioning profile's signature using Apple's public key (built into iOS).\n// b. It verifies the device's UDID is in the profile.\n// c. It uses your certificate's public key to decrypt the app's signature, revealing the original hash.\n// d. It computes a new hash from the app binary it received.\n// e. If (original_hash == new_hash), the app is trusted and allowed to launch.\n```\n\n**Common Pitfalls**\n- **\"Missing private key\" error:** You have the certificate but not the corresponding private key it was generated with. This often happens when setting up a new machine without properly exporting the full identity (`.p12` file) from the original machine.\n- **Profile/Certificate Mismatch:** The provisioning profile selected in Xcode was not created with the developer certificate being used for signing.\n- **Entitlement Mismatch:** Enabling a capability (e.g., HealthKit) in Xcode but using a provisioning profile whose App ID wasn't configured for that entitlement on the developer portal.\n\n**Profile Types (Use Cases)**\n- **Development:** For debugging on registered devices.\n- **Ad Hoc:** For distributing to a limited set (100) of registered test devices.\n- **App Store:** For the final build submitted to App Store Connect. Contains no device list.\n- **Enterprise:** For in-house distribution within a large organization, bypassing the App Store.",
      "code_example": null,
      "tags": [
        "security",
        "build process",
        "xcode",
        "app distribution"
      ],
      "sources": [
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_199ddce13d96",
      "front": "When protecting locally stored data with biometrics, what is the purpose of `evaluatedPolicyDomainState` and how would you implement it to prevent unauthorized access if new biometrics are enrolled?",
      "back": "The `evaluatedPolicyDomainState` property of `LAContext` is a critical security feature that ensures the integrity of biometric authentication over time. When a user successfully authenticates, this property contains an opaque `Data` object that represents the current state of enrolled biometrics (e.g., the set of registered fingerprints or faces). This state changes whenever a biometric identity is added or removed.\n\nThe primary security risk it mitigates is this: a user authenticates, unlocking sensitive data. Later, a malicious actor gains access to the device and enrolls their own fingerprint. Without checking the domain state, they could then use their new biometric to authenticate and access the previously unlocked data.\n\nTo implement it correctly, you must:\n1. After a successful biometric authentication, retrieve the `evaluatedPolicyDomainState`.\n2. Securely store this state alongside the sensitive data it protects (e.g., in the Keychain).\n3. On subsequent attempts to access the data, perform a new biometric authentication.\n4. Compare the new `evaluatedPolicyDomainState` with the one you stored. If they do not match, it means the device's biometric settings have changed, and you must invalidate the stored data and force the user to re-authenticate from scratch (e.g., with their master password).\n\n```swift\nimport LocalAuthentication\n\nclass BiometricSafe {\n    private let keychainService: KeychainService // Assume this handles secure storage\n\n    func accessSensitiveData() async -> String? {\n        let context = LAContext()\n        var error: NSError?\n\n        // 1. Check if biometrics are available\n        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n            // Handle case where biometrics are not available\n            return nil\n        }\n\n        do {\n            // 2. Authenticate the user\n            let reason = \"Access your secure data\"\n            let _ = try await context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason)\n\n            // 3. On success, compare the current domain state with the stored one\n            if let newDomainState = context.evaluatedPolicyDomainState,\n               let storedDomainState = keychainService.getDomainState() {\n                \n                if newDomainState == storedDomainState {\n                    // States match: Biometrics haven't changed. Grant access.\n                    return keychainService.getSensitiveData()\n                } else {\n                    // States MISMATCH: Biometrics changed! Invalidate data.\n                    keychainService.invalidateAllData()\n                    // Force user to re-authenticate fully\n                    return nil\n                }\n            } else {\n                // First time use or no stored state, save the new state\n                if let newDomainState = context.evaluatedPolicyDomainState {\n                    keychainService.save(domainState: newDomainState)\n                    return keychainService.getSensitiveData()\n                }\n            }\n        } catch {\n            // Handle authentication failure\n        }\n        return nil\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Ignoring it entirely:** The most common mistake is to only check the boolean success of `evaluatePolicy` and not validate the domain state, leaving data vulnerable.\n- **Storing State Insecurely:** Saving the `evaluatedPolicyDomainState` in `UserDefaults` is not secure. It must be stored in the Keychain with the data it protects.\n- **Not Invalidating Data:** If a mismatch is detected, you *must* delete the old sensitive data. Simply denying access is not enough; the old data is now considered compromised.",
      "code_example": null,
      "tags": [
        "Security",
        "LocalAuthentication",
        "Keychain",
        "Biometrics"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/"
      ]
    },
    {
      "id": "security_85b38a95715f",
      "front": "Explain the hierarchy of App Transport Security (ATS) exceptions. When would you use a global exception like `NSAllowsArbitraryLoads` versus a domain-specific one like `NSExceptionDomains`, and what are the security trade-offs?",
      "back": "App Transport Security (ATS) is a core security feature that enforces best practices for network connections, requiring HTTPS with TLS v1.2+ and forward secrecy by default. The configuration hierarchy allows for both broad and specific exceptions.\n\n**Core Concept:**\nATS operates on a principle of 'secure by default'. All exceptions must be explicitly declared in your app's `Info.plist` file under the `NSAppTransportSecurity` key. The system evaluates these exceptions with a clear precedence:\n1.  **`NSExceptionDomains`**: This is the most specific and recommended approach. It's a dictionary where each key is a domain name (e.g., `api.example.com`). You can define fine-grained rules for that domain, such as allowing insecure HTTP loads (`NSExceptionAllowsInsecureHTTPLoads`) or specifying a lower minimum TLS version (`NSExceptionMinimumTLSVersion`). This approach minimizes your app's attack surface by only weakening security for specific, trusted domains.\n2.  **`NSAllowsArbitraryLoads`**: This is the global 'kill switch'. Setting this boolean to `true` disables ATS for all network requests not covered by an `NSExceptionDomains` entry. It is a massive security risk, as it exposes all network traffic to potential man-in-the-middle attacks. Its use is strongly discouraged and requires strong justification during App Store Review.\n\n**Practical Code Example (`Info.plist`):**\n```xml\n<!-- Best Practice: Using a domain-specific exception -->\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>api.legacy-service.com</key>\n        <dict>\n            <!-- Allows insecure HTTP connections ONLY for this domain -->\n            <key>NSExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n            <!-- Also apply this rule to all subdomains -->\n            <key>NSIncludesSubdomains</key>\n            <true/>\n        </dict>\n    </dict>\n</dict>\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Over-reliance on `NSAllowsArbitraryLoads`:** Developers often use this during early development for convenience and forget to remove it, shipping a less secure app.\n*   **Forgetting Subdomains:** If your exception is for `example.com` but an asset is loaded from `assets.example.com`, the request will fail unless you set `NSIncludesSubdomains` to `true`.\n*   **`NSAllowsArbitraryLoadsInWebContent`:** A safer alternative for apps with a `WKWebView`. It disables ATS *only* for requests originating from web views, while your app's native networking (e.g., `URLSession`) remains protected.\n\n**When to Use vs. Alternatives:**\n*   **`NSExceptionDomains`:** Always the preferred choice. Use it when you must connect to a specific, known third-party service that you don't control and which doesn't meet ATS requirements.\n*   **`NSAllowsArbitraryLoads`:** Avoid in production. The only (weakly) justifiable case is for an app like a generic web browser where the user can input any URL. Even then, it's better to attempt secure connections first and warn the user.\n*   **The Best Alternative:** The ideal solution is not an exception. A senior developer should advocate for the backend service to be upgraded to comply with modern security standards. This is the only truly secure, long-term fix.",
      "code_example": null,
      "tags": [
        "security",
        "networking",
        "ats",
        "infoplist"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_c64c3d914723",
      "front": "How would you architect the storage and transmission of sensitive user data (e.g., auth tokens, PII) in a new iOS app, and what common security pitfalls would you actively avoid?",
      "back": "A robust security architecture follows the principle of \"defense in depth,\" layering protections for data at rest, in transit, and during processing.\n\n**Core Concepts:**\n1.  **Data at Rest:** Sensitive data stored on the device must be protected. The primary tool is the **Keychain**, which stores small secrets in a hardware-backed encrypted database. For larger datasets, use Core Data or files with the **Data Protection API** by setting the `NSFileProtectionKey` attribute. This encrypts files when the device is locked.\n\n2.  **Data in Transit:** Network communication must be secure. **App Transport Security (ATS)** is enabled by default and enforces TLS 1.2+ connections. For higher security, **Certificate Pinning** can be implemented to prevent man-in-the-middle (MITM) attacks by trusting only a specific server certificate.\n\n3.  **Secure Processing:** Avoid exposing data in memory or logs. Never log sensitive information. Validate and sanitize all inputs from users or APIs to prevent injection or data corruption vulnerabilities.\n\n**Practical Code Example (Keychain Wrapper):**\n```swift\nimport Security\n\n// A simplified service to securely store and retrieve data from the Keychain.\nclass KeychainService {\n    static func save(key: String, data: Data) -> OSStatus {\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrAccount as String: key,\n            kSecValueData as String: data,\n            // Most secure: only accessible when device is unlocked.\n            // Not backed up to iCloud/iTunes.\n            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n        ]\n        \n        SecItemDelete(query as CFDictionary) // Clear old item\n        return SecItemAdd(query as CFDictionary, nil)\n    }\n\n    static func load(key: String) -> Data? {\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrAccount as String: key,\n            kSecReturnData as String: kCFBooleanTrue!,\n            kSecMatchLimit as String: kSecMatchLimitOne\n        ]\n\n        var dataTypeRef: AnyObject?\n        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)\n        \n        return status == noErr ? dataTypeRef as? Data : nil\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Storing Secrets in UserDefaults:** `UserDefaults` is a plain text plist file, easily readable on a jailbroken device. It's for non-sensitive user preferences only.\n*   **Hardcoding API Keys:** Embedding keys directly in code makes them easily extractable from the app binary.\n*   **Disabling ATS Globally:** Instead of turning off ATS entirely in `Info.plist`, add specific domain exceptions for valid reasons.\n*   **Logging Sensitive Data:** Printing tokens, passwords, or PII to the console can expose them via device logs or crash reporting tools.\n\n**When to Use vs. Alternatives:**\n*   **Keychain:** Use for small, critical secrets like auth tokens, passwords, and cryptographic keys.\n*   **UserDefaults:** Use for non-sensitive user settings like theme preference or feature flags.\n*   **Encrypted Files/Core Data:** Use for large volumes of sensitive PII that need to be stored locally, leveraging the Data Protection API for file-level encryption.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "app transport security",
        "data protection"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "security_a98037d94e1a",
      "front": "You're tasked with a security review for a new feature handling sensitive PII. Describe your process, referencing key risks from the OWASP Mobile Top 10.",
      "back": "My security review process is a proactive, layered approach based on threat modeling, not just a reactive checklist. For a feature handling PII, I would focus on the following OWASP Mobile Top 10 risks:\n\n**1. M2: Insecure Data Storage**\nThis is the highest priority. PII must never be stored in plaintext in insecure locations like `UserDefaults` or unencrypted files/databases.\n\n*   **Control:** All sensitive data must be stored in the iOS Keychain. The Keychain provides hardware-backed, encrypted storage, isolating secrets from the application's sandbox.\n\n```swift\n// Example: Securely storing an API token in the Keychain\nfunc save(token: String, for account: String) -> OSStatus {\n    guard let data = token.data(using: .utf8) else { return errSecParam } // Ensure data is valid\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: data,\n        // Most restrictive access control: only available when device is unlocked.\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n\n    SecItemDelete(query as CFDictionary) // Clear any old item first\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**2. M3: Insecure Communication**\nData is vulnerable in transit. We must ensure it's protected between the app and the server.\n\n*   **Control:** Enforce TLS 1.2+ for all network requests via App Transport Security (ATS). For high-security applications, implement certificate pinning to prevent sophisticated Man-in-the-Middle (MitM) attacks where an attacker uses a fraudulent (but trusted by the system) certificate.\n\n**3. M8: Code Tampering / M9: Reverse Engineering**\nOn a jailbroken device, an attacker can use tools like Frida or Cycript to inspect and manipulate the app's logic at runtime to extract data or bypass security checks.\n\n*   **Control:** Implement multiple layers of defense: jailbreak detection, code obfuscation to make reverse engineering harder, and anti-debugging checks.\n\n**Common Pitfalls & Edge Cases:**\n*   **Keychain Misconfiguration:** Using a weak accessibility flag like `kSecAttrAccessibleAlways` negates much of the Keychain's security, as the data is accessible even on a locked device.\n*   **Logging Sensitive Data:** Developers often accidentally print sensitive data to the console via `print()` or `OSLog`, which can be captured by attackers. All logging of PII must be stripped from release builds.\n*   **Improper Certificate Pinning:** A poorly implemented pinning check can be easily bypassed or, worse, can break the app if the server certificate is updated legitimately.\n\n**Alternatives:**\n*   For storing larger volumes of sensitive data (not just secrets), an encrypted database like SQLCipher is a better alternative to the Keychain, which is designed for small key-value pairs.",
      "code_example": null,
      "tags": [
        "security",
        "owasp",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "security_33cf632c026b",
      "front": "Explain `kSecAttrAccessible` in Keychain Services. Describe three distinct options and their implications on data availability, security, and backups.",
      "back": "Keychain Services provides a secure, encrypted container for secrets. `kSecAttrAccessible` is a critical OS-level policy set when storing an item that dictates the precise conditions under which your app can retrieve it. This creates a fundamental trade-off between security and availability.\n\n**Core Options & Use Cases:**\n*   `kSecAttrAccessibleWhenUnlocked`: (Default) Data is accessible only when the device is unlocked. Ideal for secrets needed exclusively when the app is in the foreground.\n*   `kSecAttrAccessibleAfterFirstUnlock`: Accessible after the user unlocks the device once post-boot. It remains accessible in the background even if the device is subsequently locked. This is crucial for services needing credentials for background sync or fetches.\n*   `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`: Same as `kSecAttrAccessibleWhenUnlocked`, but the item is excluded from iCloud and iTunes backups. Use for device-specific secrets that should not be transferred to a new device.\n\n**Practical Code Example:**\n```swift\n// Saves a secret to the Keychain with a specific accessibility level.\nfunc save(secret: Data, for account: String, accessibility: CFString) -> OSStatus {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: secret\n    ]\n\n    // Try to update first\n    let status = SecItemUpdate(query as CFDictionary, [kSecValueData as String: secret] as CFDictionary)\n\n    // If it doesn't exist, add it with the specified accessibility\n    if status == errSecItemNotFound {\n        var newItemQuery = query\n        newItemQuery[kSecAttrAccessible as String] = accessibility\n        return SecItemAdd(newItemQuery as CFDictionary, nil)\n    }\n    return status\n}\n\n// Usage: Store a token needed for background tasks\nlet token = \"secret-token\".data(using: .utf8)!\nlet status = save(secret: token, for: \"user-api-token\", accessibility: kSecAttrAccessibleAfterFirstUnlock)\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Incorrect Accessibility Choice:** Using the default `kSecAttrAccessibleWhenUnlocked` for data needed by background tasks is a common error. The task will fail to access the data if the device is locked, leading to subtle, hard-to-debug bugs.\n*   **Ignoring Backup Implications:** Failing to use a `...ThisDeviceOnly` attribute can lead to device-specific secrets being restored to a new device where they are invalid, causing authentication or state issues.\n*   **Simulator Behavior:** Keychain behavior, especially with lock states, differs on the simulator. Always test on a physical device.\n\n**When to Use vs. Alternatives:**\nUse Keychain for small, high-value secrets (auth tokens, API keys, cryptographic keys). For larger sensitive datasets, encrypt them using a library like CryptoKit and store the encryption key itself in the Keychain. Never use `UserDefaults` for sensitive data as it is stored unencrypted.",
      "code_example": null,
      "tags": [
        "security",
        "keychain",
        "ios",
        "data persistence"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "security_b2f1eb5efae8",
      "front": "Design a multi-layered data encryption strategy for an iOS app handling PII. What are the key trade-offs between CryptoKit and CommonCrypto, and how should you manage cryptographic keys securely?",
      "back": "A senior-level encryption strategy involves multiple layers for defense-in-depth:\n\n1.  **File System Layer (Data Protection API):** This is the first line of defense provided by iOS. By setting an appropriate file protection attribute (e.g., `NSFileProtectionComplete`), the OS encrypts the file's content when the device is locked. This leverages the device's hardware security features in the Secure Enclave. It's effective but only protects data when the device is locked.\n\n2.  **Application Layer (In-App Encryption):** For highly sensitive data (like PII or tokens), you should encrypt the data *before* writing it to a file, database (Core Data/Realm), or UserDefaults. This ensures the data remains encrypted even if the file is accessed while the device is unlocked. CryptoKit is the modern, preferred API for this.\n\n3.  **Key Management (Keychain):** The strength of your encryption is meaningless if the keys are compromised. Cryptographic keys must **never** be hardcoded or stored in plaintext files like plists or UserDefaults. They must be stored in the Keychain, which is a secure, encrypted database managed by the OS and backed by the Secure Enclave.\n\n**Code Example (CryptoKit):**\n```swift\nimport CryptoKit\n\n// In a real app, this key would be securely generated once and stored in/retrieved from the Keychain.\n// Never hardcode a key or generate a new one every time.\nfunc getEncryptionKeyFromKeychain() -> SymmetricKey {\n    // Placeholder for robust Keychain retrieval logic.\n    // If not found, generate, save to Keychain, then return.\n    return SymmetricKey(size: .bits256)\n}\n\nfunc encrypt(data: Data) throws -> Data {\n    let key = getEncryptionKeyFromKeychain()\n    let sealedBox = try AES.GCM.seal(data, using: key)\n    return sealedBox.combined! // Contains nonce, ciphertext, and tag\n}\n\nfunc decrypt(data: Data) throws -> Data {\n    let key = getEncryptionKeyFromKeychain()\n    let sealedBox = try AES.GCM.SealedBox(combined: data)\n    return try AES.GCM.open(sealedBox, using: key)\n}\n```\n\n**Common Pitfalls:**\n*   **Insecure Key Storage:** Storing keys in UserDefaults or hardcoding them in the app binary. This is a critical vulnerability.\n*   **Relying Solely on Data Protection:** Assuming file-level encryption is sufficient for all PII. It offers no protection on an unlocked device.\n*   **Rolling Your Own Crypto:** Never invent your own encryption algorithms. Use industry-standard, well-vetted ones like AES-GCM.\n\n**CryptoKit vs. CommonCrypto:**\n*   **CryptoKit (iOS 13+):** The modern, Swift-native choice. It's a high-level, safe API that prevents common errors (e.g., misuse of nonces, buffer handling). It's strongly-typed and easier to use correctly. **Use this for all new development where possible.**\n*   **CommonCrypto:** A powerful, low-level C API. It offers more algorithmic flexibility and is required for older iOS versions. However, it's far more error-prone, requiring manual memory management and a deep understanding of cryptographic primitives. Use it only when CryptoKit is not an option.",
      "code_example": null,
      "tags": [
        "security",
        "cryptography",
        "keychain",
        "cryptokit",
        "commoncrypto"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}