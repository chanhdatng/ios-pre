{
  "topic": "debugging",
  "generated_at": "2026-01-15T04:04:42.375080+00:00",
  "cards": [
    {
      "id": "debugging_75b31908b8e1",
      "front": "How would you build an in-app network inspector to log all outgoing requests and their responses, without relying on external tools like Charles or Proxyman? What are the key components and potential challenges?",
      "back": "To build an in-app network inspector, the primary mechanism is a custom `URLProtocol`. This allows you to intercept network requests made through `URLSession` before they are sent.\n\n**Core Concept:**\n`URLProtocol` is an abstract class that handles the loading of URL data. By creating a custom subclass, you can define your own transport mechanism. You can intercept a request, log its properties, forward it to the network, receive the response, log it, and then pass it back to the original caller. This makes it transparent to the rest of your app.\n\nThe key methods to override are:\n1.  `canInit(with:)`: Determines if your protocol should handle a given request.\n2.  `canonicalRequest(for:)`: Provides an opportunity to create a canonical version of a request.\n3.  `startLoading()`: This is where the main logic lives. You'll create a new `URLSessionDataTask` to actually perform the network call, log the data, and report back to the client using `self.client`.\n4.  `stopLoading()`: Called to stop loading, for instance if the request is cancelled.\n\n**Practical Code Example:**\n```swift\nclass LoggingURLProtocol: URLProtocol {\n    private var dataTask: URLSessionDataTask?\n\n    override class func canInit(with request: URLRequest) -> Bool {\n        // Handle all http and https requests\n        return true\n    }\n\n    override class func canonicalRequest(for request: URLRequest) -> URLRequest {\n        return request\n    }\n\n    override func startLoading() {\n        print(\"Intercepted Request: \\(request.httpMethod ?? \"\") \\(request.url?.absoluteString ?? \"\")\")\n\n        // Use a standard session to avoid an infinite loop\n        let session = URLSession(configuration: .default)\n        self.dataTask = session.dataTask(with: request) { [weak self] data, response, error in\n            if let error = error {\n                self?.client?.urlProtocol(self!, didFailWithError: error)\n                return\n            }\n            guard let response = response, let data = data else { return }\n            \n            print(\"Intercepted Response: \\(response.url?.absoluteString ?? \"\")\")\n            // Log response data here...\n\n            // Forward the response and data to the original caller\n            self?.client?.urlProtocol(self!, didReceive: response, cacheStoragePolicy: .notAllowed)\n            self?.client?.urlProtocol(self!, didLoad: data)\n            self?.client?.urlProtocolDidFinishLoading(self!)\n        }\n        self.dataTask?.resume()\n    }\n\n    override func stopLoading() {\n        self.dataTask?.cancel()\n    }\n}\n\n// To register it:\nlet config = URLSessionConfiguration.default\nconfig.protocolClasses = [LoggingURLProtocol.self]\nlet session = URLSession(configuration: config)\n```\n**Common Pitfalls:**\n-   **Infinite Loops:** The most common mistake. If your `startLoading` implementation uses a `URLSession` whose configuration also includes your custom protocol, you will create an infinite loop. You must use a separate, standard configuration for the internal data task.\n-   **Ignoring `URLSession` Delegate Calls:** You are responsible for forwarding all relevant events (`didReceive response`, `didLoad data`, etc.) to `self.client`. Forgetting to do so will break your app's networking layer.\n-   **Background Sessions:** `URLProtocol` does not work with background `URLSession` configurations. This is a critical limitation to be aware of.\n\n**When to Use vs. Alternatives:**\n-   **Custom `URLProtocol`:** Ideal for building in-app debug tools, shipping diagnostic capabilities to QA, or implementing a mock server for UI/unit tests (a \"fake transport layer\"). It's essential when external proxies are blocked by security policies like SSL pinning.\n-   **External Proxies (Charles/Proxyman):** The standard for day-to-day development. They offer a powerful UI for inspection, modification, and replaying requests but require setup and cannot be shipped with your app.",
      "code_example": null,
      "tags": [
        "debugging",
        "networking",
        "URLSession",
        "URLProtocol",
        "interception"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_6a4d1a449a68",
      "front": "You receive a raw crash log from a user. The stack trace points to system libraries. Describe your step-by-step process to symbolicate the log and identify the root cause in your app's code.",
      "back": "Analyzing a raw crash log is a critical debugging skill. My process involves these steps:\n\n1.  **Gather Artifacts**: I need the raw crash log (`.ips` file), the matching dSYM file, and the application binary. For App Store builds with Bitcode, the dSYM must be downloaded from App Store Connect, as Apple recompiles the app.\n\n2.  **Symbolication**: The core task is translating memory addresses into human-readable function/method names. While Xcode can do this automatically if it has the files, the `atos` command-line tool is essential for manual analysis.\n\n3.  **Analyze the Backtrace**: I locate the crashed thread (marked in the log) and examine its stack trace. The key is to read from the bottom up (or highest frame number to lowest). I look for the last frame that belongs to my application's binary before it transitions into system frameworks (like UIKit, Foundation, etc.). This is almost always the source of the issue.\n\n**Practical Example**\n\nAn unsymbolicated line looks like this:\n`2   MyApp    0x1048a4d2c 0x10489c000 + 36140`\n\nI would use `atos` to symbolicate it. I need the load address (`0x10489c000`), the address to symbolicate (`0x1048a4d2c`), and the path to the DWARF file inside the dSYM bundle.\n\n```bash\n# -o: Path to DWARF file\n# -arch: Architecture (e.g., arm64)\n# -l: Load address of the binary\natos -o MyApp.app.dSYM/Contents/Resources/DWARF/MyApp -arch arm64 -l 0x10489c000 0x1048a4d2c\n```\n\nThis would output the readable function name, file, and line number:\n`LoginViewController.loginButtonTapped(_:) + 124 (in MyApp) (LoginViewController.swift:52)`\n\n**Common Pitfalls**\n\n*   **Mismatched dSYM**: Using a dSYM from a different build (even a minor one) will result in incorrect or no symbolication. Each build has a unique UUID that must match between the crash log and the dSYM.\n*   **Ignoring System Library Crashes**: A crash in `libobjc.A.dylib` with `objc_msgSend` or in CoreFoundation often means a memory corruption issue, like a dangling pointer or sending a message to a deallocated object. The root cause is in the app code that triggered this state.\n*   **Focusing Only on the Crashing Thread**: While the crashing thread is primary, other threads can reveal deadlocks or race conditions that led to the crash.\n\n**Alternatives**\n\nFor production apps, services like Firebase Crashlytics or Sentry are standard. They automate dSYM uploading and symbolication. However, manual analysis is an indispensable skill for crashes these services fail to process, for analyzing logs from testers, or for debugging particularly obscure issues.",
      "code_example": null,
      "tags": [
        "debugging",
        "xcode",
        "dSYM",
        "symbolication"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_3561e6d6eeee",
      "front": "You've identified a screen with significant scrolling jank. Describe your systematic approach using Xcode's tools to diagnose and resolve the root cause, moving from high-level indicators to specific code-level issues.",
      "back": "My approach is to methodically narrow down the problem from the system level to the exact lines of code. The core issue with scrolling jank is almost always blocking the main thread for more than 16.7ms, causing a frame drop.\n\n**1. High-Level Profiling (Instruments):**\nI'd start by profiling the app on a real device using a Release build configuration. The primary tools are:\n- **Time Profiler:** This is the workhorse. I'll record a session while performing the janky scroll. The key is to look at the main thread's track and identify the heaviest stack traces (the widest parts of the flame graph). This points directly to the functions consuming the most CPU time. I would also check the \"Invert Call Tree\" and \"Hide System Libraries\" options to focus on my app's code.\n- **Core Animation:** This instrument is crucial for rendering performance. I'd enable the 'Color Off-screen Rendered' and 'Color Blended Layers' debug options. Yellow layers indicate off-screen rendering, and red indicates blending, both of which are GPU-intensive and common causes of jank. The FPS counter will visually confirm the frame drops.\n\n**2. Code-Level Investigation:**\nOnce Instruments points to a problematic area, like a `cellForItemAt` method, I'll investigate the code.\n\n**Example: A common cause of jank in a cell**\n```swift\n// Problematic code in a UICollectionViewCell subclass\nfunc configure(with viewModel: ItemViewModel) {\n    // 1. Shadow and corner radius together causes off-screen rendering\n    self.layer.cornerRadius = 8.0\n    self.layer.shadowColor = UIColor.black.cgColor\n    self.layer.shadowOpacity = 0.5\n    self.layer.shadowOffset = .zero\n    \n    // 2. Expensive, synchronous image processing on the main thread\n    let filter = CIFilter(name: \"CISepiaTone\")!\n    let originalImage = CIImage(image: viewModel.image)!\n    filter.setValue(originalImage, forKey: kCIInputImageKey)\n    let context = CIContext()\n    if let outputImage = filter.outputImage,\n       let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        self.imageView.image = UIImage(cgImage: cgImage)\n    }\n}\n// Optimized Solution\nfunc configureOptimized(with viewModel: ItemViewModel) {\n    // 1. Fix: Use a container view for shadow, content view for mask\n    self.contentView.layer.cornerRadius = 8.0\n    self.contentView.layer.masksToBounds = true\n    self.layer.shadowColor = UIColor.black.cgColor\n    self.layer.shadowOpacity = 0.5\n    self.layer.shadowOffset = .zero\n    // Crucially, set a shadow path to avoid expensive calculation\n    self.layer.shadowPath = UIBezierPath(roundedRect: self.bounds, cornerRadius: 8.0).cgPath\n    \n    // 2. Fix: The view model should provide the final image, \n    // processed ahead of time or on a background thread.\n    self.imageView.image = viewModel.processedImage \n}\n```\n\n**3. Common Pitfalls:**\n- **Profiling on Simulator:** The simulator uses your Mac's CPU and has a different rendering pipeline. Always profile on a real, representative device.\n- **Profiling Debug Builds:** The compiler skips crucial optimizations in Debug builds. Always use a Release build for accurate performance measurement.\n- **Premature Optimization:** Don't guess. Use Time Profiler to prove where the bottleneck is before changing code.\n\n**4. Alternatives:**\n- **Xcode Debug Gauges:** Good for a quick, real-time check of CPU/memory during development, but not for deep analysis.\n- **MetricKit:** To gather aggregated performance data (hangs, launch times) from users in the wild, helping to identify issues you can't reproduce locally.\n- **OSLog Signposts:** To measure the performance of very specific blocks of your own code, which can be more precise than Time Profiler for custom operations.",
      "code_example": null,
      "tags": [
        "debugging",
        "performance",
        "instruments",
        "profiling",
        "uikit",
        "core animation"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_a0af6467c998",
      "front": "A button in your UI is visible but not responding to taps. How would you use Xcode's View Debugger to diagnose this, and what are its limitations?",
      "back": "Xcode's View Debugger is the primary tool for diagnosing static UI layout and interaction issues. It provides a 3D, exploded view of the entire view hierarchy, allowing you to inspect properties and relationships that are difficult to see in code or on the running app.\n\n**Core Concept & Debugging Process:**\nFor an un-tappable button, the issue is often an invisible view layered on top of it, intercepting the touch events. My process would be:\n1.  Run the app and navigate to the problematic screen.\n2.  Pause the app and launch the View Debugger (Debug > View Debugging > Capture View Hierarchy).\n3.  Locate the button in the view hierarchy list or by clicking it in the 3D canvas.\n4.  First, use the Object Inspector to verify basic properties: `isUserInteractionEnabled` is true, `alpha` > 0.01, and `isHidden` is false.\n5.  Next, check for occlusion. I'd rotate the 3D view to see if any other views are positioned in front of the button. Often, a container view with a clear background color is the culprit.\n6.  If an occluding view is found, I'd select it and check its frame and properties. The fix could be to set `isUserInteractionEnabled = false` on the overlay, send it to the back, or adjust the layout.\n\n**Code Example (The Problem):**\n```swift\n// A common scenario causing an un-tappable button\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    let myButton = UIButton(type: .system)\n    myButton.setTitle(\"Tap Me\", for: .normal)\n    myButton.frame = CGRect(x: 100, y: 100, width: 100, height: 50)\n    myButton.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)\n    view.addSubview(myButton)\n\n    // This overlay view has a clear background but still blocks touches!\n    let touchBlocker = UIView(frame: view.bounds)\n    touchBlocker.backgroundColor = .clear\n    // touchBlocker.isUserInteractionEnabled is true by default\n    view.addSubview(touchBlocker)\n}\n```\nIn the View Debugger, you would clearly see `touchBlocker`'s frame positioned over `myButton`.\n\n**Common Pitfalls & Limitations:**\n*   **Static Snapshot:** The View Debugger captures a single frame. It cannot debug animations in progress or issues that occur only during a state transition. You must pause execution at the precise moment the issue occurs.\n*   **Custom Drawing:** It only shows the frame and properties of a view, not the content rendered by Core Graphics (`draw(_:)`) or Metal. The view will appear as an empty rectangle.\n*   **Performance:** On extremely complex view hierarchies, it can be slow or even fail to launch.\n*   **SwiftUI:** While it works for SwiftUI, the hierarchy can be complex and full of internal views (`_UIHostingView`, etc.), making it harder to navigate than a pure UIKit hierarchy.\n\n**Alternatives:**\n*   **`recursiveDescription`:** If the View Debugger fails, printing `po view.recursiveDescription()` in the LLDB console gives a detailed text-based tree of the view hierarchy.\n*   **Breakpoints & `po`:** Set a breakpoint in `viewDidLayoutSubviews` and inspect frames and properties (`po myButton.frame`) programmatically.\n*   **Third-Party Tools:** Reveal or Sherlock offer more advanced features like live modification of properties without recompiling.",
      "code_example": null,
      "tags": [
        "Debugging",
        "UIKit",
        "SwiftUI",
        "Xcode",
        "Layout"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_0c5380e23e69",
      "front": "A production app crashes and you receive a crash log with only memory addresses. Describe the symbolication process, the critical role of the dSYM file and its UUID, and pitfalls like Bitcode recompilation.",
      "back": "Symbolication is the process of resolving stack trace memory addresses into meaningful symbols like function names, file names, and line numbers. When you compile an app for release, debug symbols are stripped from the executable to reduce its size. These symbols are instead stored in a separate Debug Symbols file (`.dSYM`).\n\nEach compiled binary and its corresponding dSYM are tagged with a unique UUID. A crash report also contains this UUID. For symbolication to succeed, the UUID of the crash log, the binary, and the dSYM must all match perfectly. This guarantees you're mapping addresses against the exact version of the code that crashed.\n\nThe process involves taking a stack frame address (e.g., `0x104a4d8c8`) and its binary's load address, calculating an offset, and then looking up that offset in the dSYM's symbol map to find the corresponding function and line.\n\n**Example (Manual Symbolication):**\nAn unsymbolicated crash log frame looks like this:\n`2   MyApp    0x0000000104a4d8c8 0x104a48000 + 22728`\n\nUsing the `atos` command-line tool with the correct dSYM, you can resolve it:\n```sh\n# -o: path to dSYM \n# -arch: architecture\n# -l: load address of the binary\n# address to symbolicate\natos -o MyApp.app.dSYM -arch arm64 -l 0x104a48000 0x0000000104a4d8c8\n\n// Output:\n// LoginViewController.loginButtonTapped() (in MyApp) (LoginViewController.swift:52)\n```\n\n**Common Pitfalls:**\n1.  **Bitcode Recompilation:** If you enable Bitcode, the App Store recompiles your app. The dSYM you have locally from your archive will NOT match the binary on the App Store. You must download the correct dSYMs from App Store Connect for production crashes.\n2.  **Missing dSYMs:** Forgetting to archive dSYMs or having a CI system that discards them. Always set `Debug Information Format` to `DWARF with dSYM File` for release builds.\n3.  **UUID Mismatch:** Trying to symbolicate a report with a dSYM from a different build, even with minor code changes. This leads to incorrect or completely failed symbolication.",
      "code_example": null,
      "tags": [
        "debugging",
        "crash reporting",
        "dSYM",
        "symbolication",
        "Xcode",
        "Bitcode"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_0ea0235941aa",
      "front": "Your app has a bug where a property is unexpectedly mutated. How would you use `watchpoint`, `expression`, and `thread return` in LLDB to diagnose and temporarily fix this without recompiling?",
      "back": "This combination of LLDB commands allows for powerful, dynamic debugging to find the root cause of unexpected state changes and test fixes in real-time without the slow cycle of modifying code and recompiling.\n\n**Core Concept Explanation**\n\n1.  **`watchpoint set variable <variable>`**: This command sets a hardware watchpoint on a variable's memory address. The debugger will pause execution immediately *after* the memory at that address is written to. This is incredibly efficient for tracking down exactly which line of code is responsible for an unwanted mutation, unlike breakpoints which only stop on execution.\n\n2.  **`expression <command>` (alias `e`)**: This is LLDB's most versatile command. It evaluates an expression or statement in the current context. Beyond just printing values (`po`), you can use it to modify state (e.g., `e self.viewModel.title = \"Corrected Title\"`) or execute functions to test behavior from the paused state.\n\n3.  **`thread return <value>`**: This command allows you to hijack the execution flow. It immediately exits the current function frame, skipping any remaining code within it. You can optionally provide a return value, forcing the calling function to receive a specific result. This is perfect for simulating conditions or preventing a buggy function from causing further damage.\n\n**Practical Code Example**\n\nImagine this buggy view controller:\n```swift\nclass ProfileViewController: UIViewController {\n    var username: String = \"\" \n\n    func viewDidLoad() {\n        super.viewDidLoad()\n        // Set a breakpoint here to start\n        loadUserData()\n    }\n\n    private func loadUserData() {\n        // ... logic ...\n        processLegacyData()\n        // ... logic ...\n        print(\"Final username: \\(username)\") // Prints \"DEPRECATED_USER\"\n    }\n\n    private func processLegacyData() {\n        // BUG: This function incorrectly overwrites the username\n        self.username = \"DEPRECATED_USER\"\n    }\n}\n```\n\n**LLDB Debugging Session:**\n\n```lldb\n// 1. At the breakpoint in viewDidLoad(), set a watchpoint on the 'username' property.\n// LLDB needs the memory address, so we target the instance variable.\n(lldb) watchpoint set variable self.username\n\n// 2. Continue execution. The debugger will now break inside processLegacyData() right after the write.\n(lldb) continue\n// Execution stops on the line after `self.username = ...`\n\n// 3. Check the call stack to confirm the culprit.\n(lldb) bt\n// -> #0 ProfileViewController.processLegacyData() at ...\n//    #1 ProfileViewController.loadUserData() at ...\n//    #2 ProfileViewController.viewDidLoad() at ...\n\n// 4. Use 'expression' to correct the state live.\n(lldb) expression self.username = \"CorrectedUsername\"\n\n// 5. Use 'thread return' to exit processLegacyData() immediately, preventing other side effects.\n(lldb) thread return\n\n// 6. Continue execution. The final print statement will now show the corrected username.\n(lldb) continue\n// Console Output: Final username: CorrectedUsername\n```\n\n**Common Pitfalls**\n\n*   **Watchpoint Scope**: Watchpoints monitor a memory address. If the object is deallocated and a new object is allocated at the same address, the watchpoint may trigger unexpectedly.\n*   **Expression State**: Modifying state with `expression` can lead to an inconsistent UI or data model if not done carefully. It's a temporary diagnostic tool.\n*   **`thread return` Dangers**: Aborting a function can skip crucial cleanup code (e.g., releasing a lock, completing a closure), potentially causing deadlocks, memory leaks, or other bugs.\n\n**When to Use vs. Alternatives**\n\n*   **Use For**: Complex state corruption bugs, race conditions, or situations where recompiling is slow. It excels at testing a potential fix's impact before writing any code.\n*   **Alternatives**: **Conditional breakpoints** are great for stopping on a specific condition but lack the ability to modify state or execution flow. **Logging (`print`/`os_log`)** is simpler but requires recompilation and can alter timing, potentially hiding the bug.",
      "code_example": null,
      "tags": [
        "debugging",
        "lldb",
        "xcode"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_aa5b0c0bdfb3",
      "front": "An app exhibits unexplained memory growth over time, but the Memory Graph Debugger doesn't show any obvious retain cycles. What is your systematic approach to diagnose this, and what advanced tools or techniques would you employ?",
      "back": "When the Memory Graph Debugger doesn't show clear retain cycles, the issue is likely 'abandoned memory' or memory bloat, where objects are still referenced but no longer needed. My approach is to use Instruments for dynamic analysis.\n\n**Core Concept: Dynamic Analysis with Instruments**\n\n1.  **Establish a Baseline:** Launch the app and let it settle to a stable memory state.\n2.  **Use the Allocations Instrument:** Profile the app (Cmd+I) and choose the Allocations template.\n3.  **Mark Generations:** Before triggering the problematic workflow, click 'Mark Generation' in Instruments. This creates a snapshot (Generation A) of the current memory heap.\n4.  **Reproduce the Issue:** Perform the actions in the app that cause memory to grow. Repeat this several times to amplify the effect.\n5.  **Mark Another Generation:** After the workflow, click 'Mark Generation' again (Generation B).\n6.  **Analyze Growth:** Focus on the 'Growth' column for the latest generation. This shows objects created since the last mark that are still alive. Sort by size or count to find suspicious candidates. The key is to look for objects that you *expect* to have been deallocated.\n7.  **Inspect Backtraces:** Once a suspicious object type is identified, inspect its instances. The right-hand panel in Instruments will show its allocation backtrace. To get full, symbolicated backtraces, you must enable 'Malloc Stack Logging' in the scheme's diagnostics settings *before* profiling.\n\n**Practical Code Example (Abandoned Memory):**\n```swift\n// A global cache without an eviction policy is a common source of memory bloat.\nclass UnboundedImageCache {\n    static let shared = UnboundedImageCache()\n    private var cache: [URL: Data] = [:]\n\n    func cacheData(_ data: Data, for url: URL) {\n        // This dictionary will grow indefinitely as new images are viewed.\n        // The memory is not leaked (the cache holds a strong reference),\n        // but it's abandoned because it's never cleared.\n        cache[url] = data\n    }\n}\n\n// In a view controller that is pushed and popped repeatedly:\nfunc displayImage(from url: URL, data: Data) {\n    UnboundedImageCache.shared.cacheData(data, for: url)\n    // ... display image\n}\n```\n**Common Pitfalls:**\n*   **Relying only on the 'Leaks' Instrument:** It's excellent for finding classic retain cycles but often misses abandoned memory.\n*   **Forgetting to enable Malloc Stack Logging:** Without this enabled in your scheme *before* profiling, the allocation backtraces in Instruments will be incomplete and less useful.\n*   **Ignoring System Frameworks:** Focus on call stacks originating from your own app's code. While system frameworks may hold the memory, your code is usually the root cause.\n\n**When to Use vs. Alternatives:**\n*   **Memory Graph Debugger:** Use this first for a static snapshot. It's fast and ideal for finding obvious, persistent retain cycles.\n*   **Instruments (Allocations):** Use this for dynamic analysis of memory growth over time. It's the primary tool for abandoned memory and understanding allocation patterns.",
      "code_example": null,
      "tags": [
        "debugging",
        "memory-management",
        "instruments",
        "performance"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.objc.io/issues/15-testing/dependency-injection/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}