{
  "topic": "debugging",
  "generated_at": "2026-01-10T03:57:26.895072+00:00",
  "cards": [
    {
      "id": "debugging_3561e6d6eeee",
      "front": "You're investigating a report of UI stuttering during scrolling in a complex list. Describe your step-by-step process using Xcode's profiling tools to diagnose and resolve the root cause.",
      "back": "My process starts by profiling the app on a physical device, as the simulator's performance is not representative. I'd use the Time Profiler instrument to diagnose the CPU-bound issue.\n\n**Core Concept Explanation:**\nUI stuttering, or 'dropped frames,' occurs when the main thread is blocked for more than 16.7ms (for a 60Hz display), preventing the system from rendering a new frame in time. The goal is to identify and move any long-running, synchronous work off the main thread.\n\nMy step-by-step process:\n1.  **Launch Instruments:** From Xcode, I'll choose Product -> Profile (Cmd+I) and select the Time Profiler template.\n2.  **Reproduce:** I'll run the app and perform the action that causes stuttering (e.g., scrolling the list).\n3.  **Analyze:** After stopping the recording, I'll focus on the time region with high CPU usage on the main thread. I'll use these settings:\n    *   **Separate by Thread:** To isolate the main thread's activity.\n    *   **Invert Call Tree:** This is crucial. It shows which methods are at the *top* of the most time-consuming stacks, helping to pinpoint the origin of the heavy work, not just the system calls it triggers.\n    *   **Hide System Libraries:** To filter out noise and focus on my app's code.\n4.  **Identify Bottleneck:** I'll look for methods in my code with high 'Self-Weight,' indicating significant time spent within the method itself. This is often found in `tableView(_:cellForRowAt:)` or related data processing/view configuration methods.\n\n**Practical Code Example:**\nA common bottleneck is performing synchronous, expensive work inside `cellForRowAt`.\n\n```swift\n// BEFORE: Expensive, blocking operation on the main thread.\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"ItemCell\", for: indexPath) as! ItemCell\n    let item = viewModel.item(at: indexPath)\n\n    // PITFALL: This complex data processing blocks the UI during scrolling.\n    let processedData = processComplexDataSynchronously(from: item)\n    cell.configure(with: processedData)\n    return cell\n}\n\n// AFTER: Offloading work and updating asynchronously.\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"ItemCell\", for: indexPath) as! ItemCell\n    let item = viewModel.item(at: indexPath)\n    cell.configure(with: nil) // Configure with placeholder\n\n    // SOLUTION: Move work to a background queue.\n    DispatchQueue.global(qos: .userInitiated).async {\n        let processedData = self.processComplexDataSynchronously(from: item)\n        DispatchQueue.main.async {\n            // Ensure the cell is still visible and for the correct index path before updating.\n            if let currentCell = tableView.cellForRow(at: indexPath) as? ItemCell {\n                currentCell.configure(with: processedData)\n            }\n        }\n    }\n    return cell\n}\n```\n\n**Common Pitfalls:**\n*   **Profiling on Simulator:** The Mac's powerful CPU masks many real-world performance issues. Always profile on a release build on a physical device.\n*   **Ignoring I/O:** Synchronous disk reads, heavy Core Data fetches, or network calls on the main thread are common culprits.\n*   **Focusing on Total Weight:** Don't just look at methods with high total weight; they might just be calling other long-running functions. High **Self-Weight** is the key indicator of a problem within that specific method.\n\n**When to use vs. Alternatives:**\n*   **Time Profiler:** The primary tool for CPU-bound issues like slow calculations, processing, or layout.\n*   **Core Animation Instrument:** Use this for GPU-bound issues. The 'Color Offscreen-Rendered' and 'Color Misaligned Images' debug options are invaluable for identifying expensive layer blending and rendering that can also cause stuttering.\n*   **Allocations Instrument:** Useful if stuttering is caused by memory churn (rapid allocation and deallocation of many small objects), which puts pressure on the CPU.",
      "code_example": null,
      "tags": [
        "Debugging",
        "Performance",
        "Instruments",
        "Concurrency",
        "UI"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_6a4d1a449a68",
      "front": "You receive a symbolicated crash log for a critical production issue. Describe your step-by-step process to diagnose the root cause, highlighting the key sections of the log you would focus on.",
      "back": "Analyzing a symbolicated crash log is a systematic process of deduction. My approach is as follows:\n\n1.  **Context & Header:** I first check the header information: App Version, OS Version, and Device Type. This helps me understand if the crash is specific to a certain release, OS, or hardware, and helps me set up a matching test environment.\n\n2.  **Exception Information:** I then look at the `Exception Type` and `Exception Codes`. This gives me the 'what'. For example:\n    *   `EXC_BAD_ACCESS (SIGSEGV/SIGBUS)`: Memory access issue, like trying to access a deallocated object (dangling pointer).\n    *   `EXC_CRASH (SIGABRT)`: Usually an unhandled language exception (e.g., Swift runtime error like force-unwrapping a nil optional, or an array index out of bounds).\n    *   `0x8badf00d` (\"ate bad food\"): Watchdog timeout. The app took too long to launch, terminate, or respond to a system event.\n\n3.  **Backtrace Analysis:** This is the core of the investigation. I find the backtrace for the `Triggered by Thread`. I read the stack trace from bottom to top (oldest to newest call) but focus my analysis from top to bottom (most recent call first).\n    *   I look for the highest stack frame that belongs to my application's code. System framework calls (like UIKitCore, Foundation) are usually symptoms, not the cause. The root cause is typically my app's code calling into the system framework with invalid parameters or in an invalid state.\n\n**Example Crash Log Snippet & Analysis:**\n```\nException Type:  EXC_CRASH (SIGABRT)\nTriggered by Thread:  0\n\nLast Exception Backtrace:\n0   CoreFoundation  … __exceptionPreprocess + 164\n1   libobjc.A.dylib … objc_exception_throw + 60\n2   Foundation      … -[__NSArrayI objectAtIndexedSubscript:] + 160\n3   MyApp           0x104b8f0a4 MyViewController.updateUI() + 324 (MyViewController.swift:85)\n4   MyApp           0x104b8e8c8 MyViewController.viewDidLoad() + 120 (MyViewController.swift:42)\n5   UIKitCore       … -[UIViewController loadViewIfRequired] + 1182\n...\n```\n*   **My Analysis:**\n    1.  The exception is `SIGABRT`, and `Last Exception Backtrace` is present, pointing to a language-level exception.\n    2.  Frame 2, `-[__NSArrayI objectAtIndexedSubscript:]`, is the immediate cause: an array index is out of bounds.\n    3.  Frame 3 is the most important. It's my code: `MyViewController.swift`, line 85, inside the `updateUI` method. This is where the invalid array access occurred.\n    4.  Frame 4 shows that `updateUI()` was called from `viewDidLoad()`. The bug is likely a logic error where the data source array is empty or smaller than expected when the UI is first being set up.\n\n**Common Pitfalls:**\n*   **Blaming System Libraries:** Seeing `UIKitCore` at the top of a crash doesn't mean UIKit is broken. It means your code (further down the stack) caused it to enter an unrecoverable state. Always find *your* code.\n*   **Unsymbolicated Logs:** A log without dSYMs is nearly useless, showing only memory addresses. It's critical to have a process to save the dSYM file for every build distributed to users.\n*   **Crashes on Background Threads:** Crashes on non-zero threads often point to threading issues, like data races or performing UI updates off the main thread. I'd look for where that background work was initiated and check the synchronization mechanisms.",
      "code_example": null,
      "tags": [
        "debugging",
        "crashlytics",
        "xcode",
        "symbolication",
        "lldb"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2"
      ]
    },
    {
      "id": "debugging_aa5b0c0bdfb3",
      "front": "You suspect a memory leak in a view controller involving closures and delegates. Describe your systematic approach to diagnosing and fixing it, comparing the use of Xcode's Memory Graph Debugger with the Instruments Allocations/Leaks tools.",
      "back": "My systematic approach begins by enabling 'Malloc Stack Logging' in the scheme's diagnostics for detailed allocation history. Then, I use a combination of tools.\n\n**Core Concept Explanation:**\n1.  **Reproduce & Verify:** I first confirm the leak by adding a `deinit` print statement to the suspected view controller. I navigate to and from the screen; if the message doesn't print, the leak is confirmed.\n2.  **Memory Graph Debugger:** My first tool is Xcode's live memory graph debugger. After navigating away from the screen, I pause the app and capture the graph (`Debug > Debug Memory Graph`). I filter for the view controller's class name. If it's present, the graph visually shows the strongest reference paths keeping it alive, making retain cycles immediately obvious. It's excellent for a quick, interactive snapshot of the current memory state.\n3.  **Instruments (Allocations Tool):** If the leak is more subtle (e.g., abandoned memory, not a cycle) or happens over time, I use the Allocations instrument. I record a session, perform the navigation flow multiple times, and use the 'Mark Generation' feature. This allows me to see which objects were created and failed to be deallocated between two points in time. The stack trace for each allocation is crucial for pinpointing the exact line of code responsible.\n\n**Practical Code Example (Closure Retain Cycle):**\n```swift\nclass LeakyViewController: UIViewController {\n    // The VC holds a strong reference to the service.\n    let dataFetcher = DataFetcher()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // The closure captures 'self' strongly, creating a cycle:\n        // self -> dataFetcher -> onCompletion -> self\n        dataFetcher.onCompletion = { result in\n            self.handleResult(result) // Strong capture of self\n        }\n    }\n    \n    func handleResult(_ result: String) { /* ... */ }\n    deinit { print(\"VC deallocated\") } // This will not be called\n}\n\n// FIX: Break the cycle with a weak capture list.\ndataFetcher.onCompletion = { [weak self] result in\n    self?.handleResult(result)\n}\n```\n\n**Common Pitfalls:**\n*   **Delegate Cycles:** Forgetting to declare delegate properties as `weak`. This creates a strong `A -> B -> A` cycle.\n*   **Ignoring Abandoned Memory:** Focusing only on cycles. A leak can occur if a long-lived object (like a singleton) holds a strong reference to an object that is no longer needed.\n*   **Misinterpreting the Graph:** A strong reference isn't inherently bad. It's only a problem when it forms a cycle or persists beyond the object's expected lifetime.\n\n**When to Use vs. Alternatives:**\n*   **Memory Graph Debugger:** Use for quick, interactive debugging of the app's current state. Best for visually identifying obvious retain cycles between known objects.\n*   **Instruments (Allocations):** Use for complex scenarios involving gradual memory growth, abandoned memory, or for a historical view of all allocations and deallocations over time. It's more powerful for understanding *when* and *why* memory is being persistently allocated.",
      "code_example": null,
      "tags": [
        "debugging",
        "memory management",
        "arc",
        "instruments",
        "xcode",
        "retain cycle",
        "leaks"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.objc.io/issues/15-testing/dependency-injection/"
      ]
    },
    {
      "id": "debugging_a0af6467c998",
      "front": "A view in your app is unexpectedly hidden or misplaced at runtime, but its constraints and `isHidden` property appear correct in code. How would you use Xcode's view debugging tools and LLDB to diagnose the root cause of this layout issue?",
      "back": "Xcode's View Debugger captures a snapshot of your app's live UI, allowing you to inspect the view hierarchy in 3D, check frames, and analyze Auto Layout constraints. For a senior developer, its true power lies in diagnosing issues that aren't apparent from static code analysis. A view might be hidden because it's off-screen, has a zero-size frame due to unsatisfiable constraints, is clipped by a superview (`clipsToBounds = true`), or is overlaid by another transparent view. The debugger reveals this *runtime truth*.\n\nWhen the visual debugger isn't enough, LLDB provides deeper insights. You can programmatically interact with the UI components at a breakpoint.\n\n```swift\n// 1. Pause execution with a breakpoint in viewDidAppear or later.\n// 2. In the View Debugger, select the problematic view and find its memory address (e.g., 0x7f...).\n// 3. Use these LLDB commands in the console:\n\n// Get a strongly-typed reference to your view\n(lldb) expression let $myView = unsafeBitCast(0x7f..., to: UILabel.self)\n\n// Check for layout ambiguity and force a resolution to see what happens\n(lldb) po $myView.hasAmbiguousLayout\n(lldb) e $myView.exerciseAmbiguityInLayout()\n\n// Traverse the hierarchy to find clipping superviews\n(lldb) po $myView.superview?.clipsToBounds\n(lldb) po $myView.superview?.superview?.clipsToBounds\n\n// Modify properties to test a theory and flush to see the result\n(lldb) e $myView.alpha = 1.0\n(lldb) e CATransaction.flush()\n```\n\n**Common Pitfalls:**\n- **Debugging Too Early:** Inspecting views in `viewDidLoad` is often misleading as frames and constraints are not final. Use breakpoints in `viewDidLayoutSubviews` or `viewDidAppear`.\n- **Misinterpreting System Constraints:** `UIView-Encapsulated-Layout` constraints are managed by the system (e.g., for self-sizing cells). Focus on the constraints *you* created inside the view.\n- **Performance:** On complex UIs, the View Debugger can be slow. In these cases, falling back to LLDB's `recursiveDescription` is more stable.\n\n**When to Use vs. Alternatives:**\n- **Use View Debugger for:** Visual problems like incorrect frames, clipping, or understanding a complex view hierarchy you inherited.\n- **Use LLDB for:** Programmatic inspection, modifying properties live, or when the visual debugger is too slow.\n- **Alternatives:** Third-party tools like Reveal offer more powerful live-editing features. For quick checks, setting a view's `layer.borderColor` in code is a fast way to confirm its final position and size.",
      "code_example": null,
      "tags": [
        "debugging",
        "uikit",
        "autolayout",
        "xcode",
        "lldb"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "debugging_75b31908b8e1",
      "front": "Compare and contrast using a proxy tool like Charles/Proxyman with a custom `URLProtocol` for network debugging. When is one more appropriate than the other?",
      "back": "Both proxy tools and custom `URLProtocol`s are powerful for network debugging, but they operate at different levels and solve different problems.\n\n**Core Concept Explanation**\n\n*   **Proxy Tools (Charles, Proxyman, Fiddler):** These act as a Man-in-the-Middle (MITM) proxy. Your device's network traffic is routed through an app running on your Mac. To decrypt HTTPS traffic, you must install a root certificate on the device. They provide a rich UI to inspect, modify, throttle, or replay requests and responses without changing any application code. This is ideal for inspecting traffic from third-party SDKs or for quick, non-invasive debugging.\n\n*   **Custom `URLProtocol`:** This is an in-code solution using Apple's frameworks. By subclassing `URLProtocol` and registering it with a `URLSessionConfiguration`, you can intercept any network request made through that session. This gives you programmatic control to log, stub, or modify requests from within the app itself. It's perfect for building in-app debug menus, handling complex mocking scenarios, or when security features like certificate pinning prevent the use of an external proxy.\n\n**Practical Code Example (Custom `URLProtocol`)**\n```swift\nclass LoggingURLProtocol: URLProtocol {\n    // A dictionary to mark requests we've already handled to prevent infinite loops.\n    private static var handledRequests = Set<URLRequest>()\n\n    override class func canInit(with request: URLRequest) -> Bool {\n        // Check if we haven't handled this request yet.\n        return !handledRequests.contains(request)\n    }\n\n    override class func canonicalRequest(for request: URLRequest) -> URLRequest {\n        return request\n    }\n\n    override func startLoading() {\n        // Mark the request as handled.\n        LoggingURLProtocol.handledRequests.insert(self.request)\n        print(\"Intercepted Request: \\(request.httpMethod ?? \"\") \\(request.url?.absoluteString ?? \"\")\")\n\n        // Create a new data task to actually perform the request.\n        let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in\n            if let error = error {\n                self?.client?.urlProtocol(self!, didFailWithError: error)\n            } else {\n                if let response = response { self?.client?.urlProtocol(self!, didReceive: response, cacheStoragePolicy: .notAllowed) }\n                if let data = data { self?.client?.urlProtocol(self!, didLoad: data) }\n            }\n            self?.client?.urlProtocolDidFinishLoading(self!)\n        }\n        task.resume()\n    }\n\n    override func stopLoading() { /* No-op for this example */ }\n}\n\n// To use it, register it in your URLSessionConfiguration:\nlet config = URLSessionConfiguration.default\nconfig.protocolClasses = [LoggingURLProtocol.self]\nlet session = URLSession(configuration: config)\n```\n\n**Common Pitfalls**\n*   **`URLProtocol` Infinite Loop:** If your `URLProtocol` makes a network request using a session that also has the protocol registered, it will intercept its own request, creating an infinite loop. The example above shows a simple way to prevent this.\n*   **Proxy & Certificate Pinning:** Proxies cannot work with certificate pinning enabled, as the proxy's certificate will not match the pinned certificate. You must disable pinning in debug builds to use a proxy.\n\n**When to Use vs. Alternatives**\n*   **Use a Proxy when:**\n    *   You need to quickly inspect traffic without code changes.\n    *   Debugging a third-party SDK or a `WKWebView`.\n    *   You need powerful UI features like request rewriting, throttling, or breakpoints.\n\n*   **Use a custom `URLProtocol` when:**\n    *   Certificate pinning prevents the use of a proxy.\n    *   You need to build shippable, in-app debugging tools for QA.\n    *   You want to programmatically mock responses for UI or unit tests.",
      "code_example": null,
      "tags": [
        "debugging",
        "networking",
        "URLProtocol",
        "proxy",
        "URLSession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "debugging_0c5380e23e69",
      "front": "A production crash log shows only memory addresses. Describe the symbolication process, the role of the dSYM file and its UUID, and how you'd manually symbolicate a stack trace if automated tools fail.",
      "back": "Symbolication is the process of translating memory addresses in a crash report's stack trace into human-readable symbols like function names, file names, and line numbers.\n\n**Core Concept:**\nWhen an app is compiled for release, debug symbols are stripped from the main binary to reduce its size. These symbols are instead placed in a separate Debug Symbols file (`.dSYM`). Both the binary and its corresponding dSYM are tagged with a unique build UUID. A crash report contains the UUID of the binary that crashed. To symbolicate it, a tool needs to find the dSYM file with the exact same UUID. It then uses the dSYM's mapping data to resolve the memory addresses in the stack trace.\n\n**Practical Code Example (Manual Symbolication with `atos`):**\n`atos` is a command-line tool that converts addresses to symbols. Given a line from a crash report:\n`2   MyApp   0x0000000104a4eb9c 0x104a44000 + 43932`\n\nTo symbolicate this single address, you need the application binary, the architecture, the load address (`0x104a44000`), and the address to symbolicate (`0x0000000104a4eb9c`).\n\n```bash\n# -o: Path to the binary (inside the .app bundle) or dSYM\n# -arch: The architecture from the crash report (e.g., arm64)\n# -l: The load address of the binary in memory\n\natos -o MyApp.app.dSYM/Contents/Resources/DWARF/MyApp -arch arm64 -l 0x104a44000 0x0000000104a4eb9c\n\n# Expected Output:\n# -[CheckoutViewController placeOrderTapped:] (in MyApp) (CheckoutViewController.swift:134)\n```\n\n**Common Pitfalls:**\n1.  **UUID Mismatch:** The most common issue. If the crash report's UUID doesn't match the dSYM's UUID, symbolication will fail. This often happens when Bitcode is enabled, as Apple recompiles the app, generating a new binary and dSYM. You must download the correct dSYMs from App Store Connect.\n2.  **Missing dSYMs:** Not archiving dSYMs for every build sent to users (including TestFlight) makes those crash reports impossible to debug.\n3.  **Partial Symbolication:** A crash report may be partially symbolicated if dSYMs for third-party libraries or system frameworks are unavailable.\n\n**When to Use vs. Alternatives:**\n-   **Automated Services (Firebase Crashlytics, Sentry):** The standard for production apps. They provide build scripts to automatically upload dSYMs, making the process seamless.\n-   **Xcode Organizer:** Can automatically symbolicate crashes from App Store users who have opted-in to share diagnostics, provided Xcode has access to the original archive.\n-   **Manual (`atos`, `symbolicatecrash`):** Use when automated tools fail or when you receive a crash file directly. `atos` is great for individual addresses, while Xcode's `symbolicatecrash` script can process an entire `.crash` file at once.",
      "code_example": null,
      "tags": [
        "debugging",
        "crash-analysis",
        "xcode",
        "tooling"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "debugging_0ea0235941aa",
      "front": "Your project uses a custom `Color` struct. How would you use LLDB's type summaries and command aliases to improve the debugging experience, making it as informative as debugging a built-in `UIColor`?",
      "back": "A senior developer should not only use the debugger but also customize it to accelerate their workflow. When dealing with custom types, the default `po` output can be verbose and unhelpful. We can improve this using type summaries and command aliases.\n\n**Core Concept:**\n1.  **Type Summaries (`type summary add`):** This command allows you to define a custom, single-line string representation for any data type within the LLDB session. It's a debugger-only enhancement that doesn't require modifying your application code. You use a format string with placeholders like `${var.propertyName}` to craft the desired output.\n\n2.  **Command Aliases (`command alias`):** This creates a shortcut for a longer, more complex LLDB command. This is invaluable for repetitive tasks, such as forcing a UI refresh after modifying a view property or calling a specific debug function in your app.\n\nTo make these customizations permanent, add the commands to your `~/.lldbinit` file.\n\n**Practical Code Example:**\n```swift\n// In your app code (e.g., in a file within the 'MyApp' target)\nstruct Color {\n    let hex: String // e.g., \"#4A90E2\"\n    let name: String\n}\n\n// Imagine a breakpoint is hit after this line:\nlet brandColor = Color(hex: \"#4A90E2\", name: \"Dodger Blue\")\n```\n\n```lldb\n# Default, verbose output\n(lldb) po brandColor\n▿ MyApp.Color\n  - hex: \"#4A90E2\"\n  - name: \"Dodger Blue\"\n\n# 1. Add a custom type summary for cleaner output\n(lldb) type summary add MyApp.Color --summary-string \"${var.name} (${var.hex})\"\n\n# Now, 'po' gives a much more readable summary\n(lldb) po brandColor\n(MyApp.Color) Dodger Blue (#4A90E2)\n\n# 2. Create an alias to force a UI refresh\n(lldb) command alias refresh expression -l objc -O -- @import QuartzCore; CATransaction.flush()\n\n# Now you can modify a UI property and see the change immediately\n(lldb) e self.view.layer.borderWidth = 2.0\n(lldb) refresh\n```\n\n**Common Pitfalls:**\n*   **Module Name:** You must prefix the type with its module name (e.g., `MyApp.Color`). Forgetting this is a common error. If the name contains spaces or special characters, wrap it in backticks.\n*   **Persistence:** Commands entered in an LLDB session are ephemeral. Forgetting to add them to `~/.lldbinit` means you'll have to re-type them in every new debug session.\n*   **`expression` vs. `po`:** Using `e` or `expression` executes code and can have side effects. `po` is generally safer as it calls the `debugDescription` of an object.\n\n**When to use vs Alternatives:**\n*   **vs. `CustomDebugStringConvertible`:** `CustomDebugStringConvertible` modifies the description in both your code (`print()`) and the debugger. A `type summary` is a debugger-only customization, which is useful when you want a different representation for debugging than you do for logging or other runtime purposes.\n*   **vs. `print()` statements:** LLDB customizations are interactive and don't require you to modify code and recompile, making the debug cycle much faster for inspecting state and testing hypotheses.",
      "code_example": null,
      "tags": [
        "debugging",
        "lldb",
        "xcode",
        "tooling"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}