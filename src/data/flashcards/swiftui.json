{
  "topic": "swiftui",
  "title": "SwiftUI Fundamentals",
  "description": "State management, view lifecycle, and SwiftUI patterns",
  "cards": [
    {
      "id": "swiftui-001",
      "front": "What's the difference between @State and @Binding?",
      "back": "@State: Owns the source of truth, local to view. @Binding: References state owned elsewhere, creates two-way connection. Parent uses @State, passes $state as Binding to child.",
      "tags": [
        "state-management"
      ]
    },
    {
      "id": "swiftui-002",
      "front": "When do you use @StateObject vs @ObservedObject?",
      "back": "@StateObject: Creates and owns the ObservableObject instance (use in view that creates it). @ObservedObject: References externally-owned instance (passed in). Wrong choice causes object recreation.",
      "tags": [
        "state-management"
      ]
    },
    {
      "id": "swiftui-003",
      "front": "Explain @EnvironmentObject and when to use it",
      "back": "Injects ObservableObject into view hierarchy. Access without explicit passing. Use for app-wide state (auth, settings). Must provide via .environmentObject() modifier on ancestor.",
      "tags": [
        "state-management",
        "dependency-injection"
      ]
    },
    {
      "id": "swiftui-004",
      "front": "What is the SwiftUI view lifecycle?",
      "back": "init \u2192 body (computed) \u2192 onAppear \u2192 [updates via state changes] \u2192 onDisappear. Views are structs, recreated frequently. body is recomputed when state changes. Use onAppear for side effects.",
      "tags": [
        "lifecycle"
      ]
    },
    {
      "id": "swiftui-005",
      "front": "How does SwiftUI diffing work?",
      "back": "SwiftUI compares view identity and state to determine updates. Uses structural identity (position in hierarchy) or explicit id(). Only redraws changed parts. Keep body pure and fast.",
      "tags": [
        "performance"
      ]
    },
    {
      "id": "swiftui-006",
      "front": "What's the difference between NavigationStack and NavigationView?",
      "back": "NavigationStack (iOS 16+): Modern, value-based navigation with NavigationPath. NavigationView: Deprecated, uses NavigationLink with destination. Stack supports programmatic navigation.",
      "tags": [
        "navigation"
      ]
    },
    {
      "id": "swiftui-007",
      "front": "How do you handle navigation programmatically in SwiftUI?",
      "back": "iOS 16+: NavigationStack with path binding, append/remove from NavigationPath. Pre-iOS 16: isActive binding on NavigationLink, or tag/selection. Use @State to control navigation state.",
      "tags": [
        "navigation"
      ]
    },
    {
      "id": "swiftui-008",
      "front": "What is @ViewBuilder and when do you use it?",
      "back": "@ViewBuilder: Function builder enabling multiple views as closure content. Used for custom container views. Allows if/else, switch, ForEach without explicit Group. body property has implicit @ViewBuilder.",
      "tags": [
        "view-composition"
      ]
    },
    {
      "id": "swiftui-009",
      "front": "Explain GeometryReader and its uses",
      "back": "Provides parent size via GeometryProxy. Use for: Responsive layouts, positioning relative to parent, reading safe area. Caution: Takes all available space, can cause layout issues.",
      "tags": [
        "layout"
      ]
    },
    {
      "id": "swiftui-010",
      "front": "What are PreferenceKeys in SwiftUI?",
      "back": "Pass data up the view hierarchy (child to parent). Define PreferenceKey, set with preference(key:value:), read with onPreferenceChange. Used for: Coordination, custom navigation bars.",
      "tags": [
        "data-flow"
      ]
    },
    {
      "id": "swiftui-011",
      "front": "How do you create custom view modifiers?",
      "back": "Conform to ViewModifier protocol, implement body(content:). Apply with .modifier() or create View extension. Use for reusable styling, behavior composition. Can have @State.",
      "tags": [
        "view-composition"
      ]
    },
    {
      "id": "swiftui-012",
      "front": "What's the difference between task and onAppear?",
      "back": "task: Async context, automatically cancelled when view disappears. onAppear: Synchronous, fires every time view appears. Use task for async work (fetching), onAppear for sync setup.",
      "tags": [
        "lifecycle",
        "concurrency"
      ]
    },
    {
      "id": "swiftui-013",
      "front": "How does @Environment work?",
      "back": "Access environment values (colorScheme, locale, dismiss). Read-only by default. System provides many values. Custom: Define EnvironmentKey, extend EnvironmentValues, use .environment() modifier.",
      "tags": [
        "dependency-injection"
      ]
    },
    {
      "id": "swiftui-014",
      "front": "Explain List vs LazyVStack performance",
      "back": "List: Built-in cell reuse, optimized for large datasets, automatic separators/styling. LazyVStack: Creates views lazily but doesn't reuse, more customizable. Use List for long scrolling content.",
      "tags": [
        "performance",
        "layout"
      ]
    },
    {
      "id": "swiftui-015",
      "front": "What is @MainActor and why is it important?",
      "back": "@MainActor ensures code runs on main thread. Required for UI updates. ObservableObject often needs @MainActor. Async functions can be marked @MainActor for automatic main thread dispatch.",
      "tags": [
        "concurrency"
      ]
    },
    {
      "id": "swiftui-016",
      "front": "How do you handle sheets and alerts in SwiftUI?",
      "back": "Use .sheet(isPresented:) or .sheet(item:) modifiers. Alert: .alert(title:isPresented:actions:). Control via @State binding. item: variant provides data to presented view.",
      "tags": [
        "presentation"
      ]
    },
    {
      "id": "swiftui-017",
      "front": "What's the Observation framework (iOS 17)?",
      "back": "@Observable macro replaces ObservableObject. No need for @Published. Views automatically track which properties they read. Simpler API, better performance. Use @State for observable in views.",
      "tags": [
        "state-management",
        "ios-17"
      ]
    },
    {
      "id": "swiftui-018",
      "front": "How do you animate in SwiftUI?",
      "back": "withAnimation {} block, .animation() modifier, or .transition(). Implicit: State change auto-animates. Explicit: Wrap in withAnimation. Custom: Animatable protocol for complex animations.",
      "tags": [
        "animation"
      ]
    },
    {
      "id": "swiftui-019",
      "front": "What is @FocusState and how do you use it?",
      "back": "Manages keyboard focus for text fields. Declare @FocusState var, use .focused($var, equals:value). Set to nil to dismiss keyboard. Works with enums for multiple fields.",
      "tags": [
        "forms",
        "keyboard"
      ]
    },
    {
      "id": "swiftui-020",
      "front": "Explain SwiftUI's coordinate spaces",
      "back": ".local: View's own coordinate space. .global: Screen/window coordinates. .named(\"custom\"): Custom coordinate space via .coordinateSpace(). Use GeometryProxy.frame(in:) to convert.",
      "tags": [
        "layout"
      ]
    },
    {
      "id": "swiftui-021",
      "front": "How do you integrate UIKit views in SwiftUI?",
      "back": "UIViewRepresentable protocol. Implement makeUIView() and updateUIView(). Use Coordinator for delegates. UIViewControllerRepresentable for view controllers.",
      "tags": [
        "interop"
      ]
    },
    {
      "id": "swiftui-022",
      "front": "What are the new container APIs in iOS 17?",
      "back": "ContentUnavailableView: Empty states. containerRelativeFrame: Size relative to container. scrollTargetLayout/scrollTargetBehavior: Paging and snapping. safeAreaPadding: Safe area handling.",
      "tags": [
        "ios-17",
        "layout"
      ]
    },
    {
      "id": "swiftui-023",
      "front": "How does @AppStorage work?",
      "back": "@AppStorage: Property wrapper reading/writing UserDefaults. Auto-updates view on change. Supports basic types. @SceneStorage: Per-scene state restoration. Use for simple preferences.",
      "tags": [
        "persistence"
      ]
    },
    {
      "id": "swiftui-024",
      "front": "What's the difference between frame and fixedSize?",
      "back": "frame: Sets explicit size constraints. fixedSize: Prevents view from compressing below ideal size. fixedSize(horizontal:vertical:) for one axis. Use to prevent text truncation.",
      "tags": [
        "layout"
      ]
    },
    {
      "id": "swiftui-025",
      "front": "How do you handle deep links in SwiftUI?",
      "back": "onOpenURL modifier receives URL. Parse and update navigation state (@State path). iOS 16+: Update NavigationPath based on URL components. Handle in root view or App struct.",
      "tags": [
        "navigation",
        "deep-linking"
      ]
    },
    {
      "id": "swiftui_52087b03c6db",
      "front": "How does SwiftUI manage View lifecycle and identity, and what are the implications for state management and animations?",
      "back": "SwiftUI's View lifecycle is declarative and driven by data changes. Unlike UIKit's delegate-based approach, SwiftUI re-renders views when its dependencies (state, bindings, environment objects) change. Identity is crucial for SwiftUI to track changes efficiently. Views are identified using the `Identifiable` protocol or a unique identifier. When a view's data changes, SwiftUI compares the new and old states to determine what needs updating. If a view's identity changes, SwiftUI treats it as a new view, potentially triggering animations or re-initialization.\n\nExample:\n\n```swift\nstruct MyView: View {\n @State private var count = 0\n let id = UUID()\n\n var body: some View {\n VStack {\n Text(\"Count: \\(count)\")\n Button(\"Increment\") {\n count += 1\n }\n .id(id) // Explicitly set identity\n }\n }\n}\n```\n\nCommon pitfalls include:\n- Not providing a stable identity, leading to unexpected view re-creations and animation glitches.\n- Over-relying on `onChange` modifiers for complex logic, as they can be triggered multiple times during a single update cycle.\n- Neglecting to optimize view updates, resulting in performance issues, especially in large lists or complex hierarchies.\n\nAlternatives to consider:\n- Using `withAnimation` for controlled animations during state changes.\n- Employing `EquatableView` to prevent unnecessary updates when the view's data hasn't changed.\n- Leveraging `PreferenceKey` to propagate data up the view hierarchy for centralized state management. SwiftUI's identity management is important for animations. SwiftUI uses view identity to determine whether a view is the same view that was previously rendered or a new view. This allows SwiftUI to animate changes between views, such as when a view is added or removed from the view hierarchy. In addition, SwiftUI identity management is important for performance. By tracking view identity, SwiftUI can avoid re-rendering views that have not changed, which can improve the performance of your app.",
      "code_example": null,
      "tags": [
        "swiftui",
        "lifecycle",
        "identity",
        "state management",
        "animation"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_cddc3f3f2aa5",
      "front": "Describe different state management patterns in SwiftUI, contrasting their use cases and trade-offs. Include examples using `@State`, `@ObservedObject`, `@StateObject`, `@EnvironmentObject`, and `@Binding`.",
      "back": "SwiftUI offers several property wrappers for state management, each suited for different scenarios. \n\n`@State` is for simple, local state within a single view. Changes trigger view updates. **Example:**\n```swift\nstruct MyView: View {\n @State private var count = 0\n var body: some View {\n  Button(\"Count: \\(count)\") { count += 1 }\n }\n}\n```\n*Pitfall:* Don't use for complex data or sharing state.\n\n`@ObservedObject` allows external objects to drive view updates. The object must conform to `ObservableObject` and publish changes via `@Published`. **Example:**\n```swift\nclass MyData: ObservableObject {\n @Published var value = \"Initial\"\n}\nstruct MyView: View {\n @ObservedObject var data = MyData()\n var body: some View {\n  Text(data.value)\n }\n}\n```\n*Pitfall:* The view recreates the object on initialization, leading to unintended side effects.\n\n`@StateObject` solves the lifecycle issue of `@ObservedObject`. It ensures the object is created only once, even when the view is re-rendered. **Example:**\n```swift\nstruct MyView: View {\n @StateObject var data = MyData()\n var body: some View {\n  Text(data.value)\n }\n}\n```\n*When to use:* When you need to preserve the state of an `ObservableObject` across view updates.\n\n`@EnvironmentObject` is used to share data across the entire view hierarchy. The object is injected into the environment using `.environmentObject()`. **Example:**\n```swift\nstruct MyView: View {\n @EnvironmentObject var data: MyData\n var body: some View {\n  Text(data.value)\n }\n}\n// In parent view:\nMyView().environmentObject(MyData())\n```\n*Pitfall:* Crashing if the object isn't provided in the environment. Use `.environment(\\.managedObjectContext, persistenceController.container.viewContext)` for CoreData.\n\n`@Binding` creates a two-way connection to a state variable owned by another view. Changes in the child view update the parent's state and vice versa. **Example:**\n```swift\nstruct ParentView: View {\n @State private var name = \"\"\n var body: some View {\n  ChildView(name: $name)\n }\n}\nstruct ChildView: View {\n @Binding var name: String\n var body: some View {\n  TextField(\"Name\", text: $name)\n }\n}\n```\n*Pitfall:* Avoid creating circular dependencies between views using bindings.\n\n**Comparison:** `@State` is for simple, local state. `@ObservedObject` and `@StateObject` manage external data, with `@StateObject` handling lifecycle better. `@EnvironmentObject` shares data globally. `@Binding` creates two-way data flow between views.\n\nAlternatives include using Combine framework directly for more complex reactive programming, or custom solutions with `PreferenceKey` for specific cases. Consider the complexity and scope when choosing a state management pattern.",
      "code_example": null,
      "tags": [
        "swiftui",
        "state management",
        "observableobject",
        "state",
        "binding",
        "environmentobject",
        "stateobject"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_57b904137e80",
      "front": "@Observable vs ObservableObject",
      "back": "",
      "code_example": null,
      "tags": [
        "@Observable vs ObservableObject"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_5db790af102a",
      "front": "How do custom `ViewModifier`s enhance SwiftUI code reusability and maintainability? Provide an example, highlighting best practices and potential pitfalls.",
      "back": "Custom `ViewModifier`s promote code reuse and maintainability by encapsulating view modifications into reusable components.  Instead of repeating the same set of modifiers across multiple views, a custom `ViewModifier` lets you define them once and apply them consistently. This reduces redundancy, simplifies code, and makes it easier to update styles across your app. \n\n```swift\nstruct ShadowModifier: ViewModifier {\n    let radius: CGFloat\n\n    func body(content: Content) -> some View {\n        content\n            .shadow(color: .gray, radius: radius, x: 2, y: 2)\n    }\n}\n\nextension View {\n    func customShadow(radius: CGFloat) -> some View {\n        modifier(ShadowModifier(radius: radius))\n    }\n}\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, world!\")\n            .padding()\n            .customShadow(radius: 5)\n        Text(\"Another View\")\n            .padding()\n            .customShadow(radius: 10)\n    }\n}\n```\n\nThis example creates a `ShadowModifier` to add a shadow to any view. The extension on `View` allows us to apply this modifier easily using `.customShadow(radius:)`. \n\n**Best Practices:**\n*   **Keep modifiers focused:** Each modifier should ideally handle a single, well-defined aspect of styling.\n*   **Use extensions:** Extend the `View` protocol to create convenient access to your modifiers.\n*   **Parameterize:**  Make your modifiers configurable by accepting parameters (e.g., shadow radius, color).\n*   **Consider `Environment`:**  For modifiers that need to access environment values (e.g., color scheme), inject them appropriately.\n\n**Common Pitfalls:**\n*   **Over-complication:** Avoid creating overly complex modifiers that do too much.  Break them down into smaller, more manageable units.\n*   **Modifier order:** The order in which modifiers are applied matters.  Be mindful of how different modifiers interact.  Incorrect order can lead to unexpected results.\n*   **Performance:**  Excessive or inefficient modifiers can impact performance, especially in complex views. Profile your code to identify and optimize slow modifiers.\n*   **Forgetting `some View`**:  The return type of `body` *must* be `some View`. Returning `Content` directly will cause compiler errors.\n\n**Alternatives:**\n*   **Computed Properties:** For simple styling, computed properties can be a lightweight alternative, but they don't offer the same level of reusability as `ViewModifier`s.\n*   **Subviews:**  Creating custom subviews is suitable for more complex UI elements, but it's less efficient for simple styling changes compared to `ViewModifier`s.\n\nWhen to use `ViewModifier`s: Use them when you want to apply the same set of styling changes to multiple views throughout your application, promoting a consistent look and feel and reducing code duplication. They are especially useful when you need to modify the view's properties in a reusable and configurable way.",
      "code_example": null,
      "tags": [
        "swiftui",
        "viewmodifier",
        "reusability",
        "design",
        "architecture"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_0c71a581d980",
      "front": "Preference Keys",
      "back": "",
      "code_example": null,
      "tags": [
        "Preference Keys"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_fce609cc67b5",
      "front": "Explain the `Layout` protocol in SwiftUI. How does it differ from using standard layout containers like `VStack` or `HStack`? Provide a code example.",
      "back": "The `Layout` protocol in SwiftUI allows you to create custom layout containers beyond the built-in options like `VStack`, `HStack`, and `ZStack`.  Instead of relying on predefined arrangement rules, you define your own layout logic. This offers greater control over how views are positioned and sized within their parent. \n\nUnlike `VStack`/`HStack` which dictate a fixed arrangement, `Layout` gives you the flexibility to consider the size and properties of the child views when determining their final positions. \n\n**Explanation:**\n\n1.  **`sizeThatFits(proposal: Subviews, cache:)`**:  This method determines the ideal size of the layout container based on a `proposal` (suggested size) from the parent and the sizes of its `Subviews`.  The `cache` allows for optimization by storing intermediate calculations.\n2.  **`placeSubviews(in:bounds:proposal:cache:)`**: This is where the actual layout happens. You iterate through the `Subviews` and, using the `bounds` provided by the parent, determine the position of each subview using the `place(at:anchor:proposal:)` method on each subview.  The `proposal` is passed down to the subview.\n\n**Code Example:**\n\n```swift\nstruct CustomHFlow: Layout {\n  func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {\n    guard !subviews.isEmpty else { return .zero }\n    let subviewSizes = subviews.map { $0.sizeThatFits(.unspecified) }\n    let totalWidth = subviewSizes.reduce(0) { $0 + $1.width }\n    let maxHeight = subviewSizes.max(by: { $0.height < $1.height })?.height ?? 0\n    return CGSize(width: totalWidth, height: maxHeight)\n  }\n\n  func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {\n    var currentX = bounds.minX\n    for subview in subviews {\n      let subviewSize = subview.sizeThatFits(.unspecified)\n      subview.place(at: CGPoint(x: currentX, y: bounds.midY - subviewSize.height / 2), anchor: .topLeading, proposal: ProposedViewSize(subviewSize))\n      currentX += subviewSize.width\n    }\n  }\n}\n\nstruct ContentView: View {\n  var body: some View {\n    CustomHFlow {\n      Text(\"Item 1\").border(.red)\n      Text(\"Item 2\").border(.blue)\n      Text(\"Item 3\").border(.green)\n    }.border(.black)\n  }\n}\n```\nThis example creates a horizontal flow layout (`CustomHFlow`). The `sizeThatFits` method calculates the total width required by summing the widths of all subviews and using the maximum height of the subviews. The `placeSubviews` method then positions each subview horizontally, centering them vertically within the available bounds.\n\n**Common Pitfalls:**\n\n*   **Ignoring the Proposal:** Failing to consider the `proposal` in `sizeThatFits` can lead to layouts that don't adapt well to different screen sizes or orientations.\n*   **Incorrect View Placement:**  Miscalculating the position of subviews in `placeSubviews` can result in overlapping or improperly aligned elements.\n*   **Performance:** Complex layout calculations can impact performance, especially with a large number of subviews.  Use the `cache` parameter to store intermediate results and avoid redundant calculations.\n\n**When to Use vs. Alternatives:**\n\n*   Use `Layout` when you need precise control over view placement and sizing beyond what the standard layout containers provide. This is useful for creating custom grids, flow layouts, or other specialized arrangements.\n*   Use `VStack`, `HStack`, `ZStack`, and `Grid` for simpler layouts where the built-in arrangement rules are sufficient. These are generally more efficient and easier to use for common layout scenarios.\n*   Consider using `GeometryReader` for size-dependent layouts, but be aware of its performance implications (it can cause layout thrashing if used excessively). The `Layout` protocol often offers a better structured and performant alternative when you need fine-grained control.\n",
      "code_example": null,
      "tags": [
        "swiftui",
        "layout",
        "custom layout"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_4bd31d70cc62",
      "front": "Explain how SwiftUI animations work internally. What are the key components involved in creating and managing animations?",
      "back": "SwiftUI animations are declarative, meaning you describe the desired state change, and SwiftUI handles the transition. At a high level, SwiftUI animations involve the following: \n\n1. **State Changes:** Animations are triggered by changes in a view's state. SwiftUI observes these changes and initiates an animation if one is defined.\n\n2. **`withAnimation` Block:**  Enclosing state changes within a `withAnimation` block tells SwiftUI to animate those changes.  You can specify the animation type (e.g., `.linear`, `.easeIn`, `.spring`) and duration.\n\n3. **AnimatableData:** SwiftUI uses `AnimatableData` protocol.  When a property conforming to `AnimatableData` changes inside `withAnimation`, SwiftUI calculates the intermediate values to create a smooth transition. This is often implicit with built-in types like `Double`, `CGFloat`, `Color`, `CGPoint`, etc.\n\n4. **Geometry Effects:** For more complex animations (custom shapes, paths), SwiftUI uses geometry effects. These effects modify the view's geometry during the animation, creating visual transformations.\n\nExample:\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @State private var isScaled: Bool = false\n\n    var body: some View {\n        Circle()\n            .fill(.blue)\n            .frame(width: 100, height: 100)\n            .scaleEffect(isScaled ? 2 : 1)\n            .onTapGesture {\n                withAnimation(.spring(response: 0.5, dampingFraction: 0.5, blendDuration: 0)) {\n                    isScaled.toggle()\n                }\n            }\n    }\n}\n```\n\n**Pitfalls:**\n*   **Unexpected Animations:** Ensure that only state changes intended for animation are inside `withAnimation`.  Unintended changes can lead to performance issues.\n*   **Complex Calculations:** Avoid heavy computations within the animation block, as this can cause frame drops.  Pre-calculate values if possible.\n*   **Animation Conflicts:**  Be mindful of conflicting animations.  If multiple animations try to modify the same property simultaneously, the result may be unpredictable. Use `.transaction` to control animation flow.\n\n**Alternatives:**\n*   **UIView Animations (UIKit):** While SwiftUI is preferred for new development, UIKit animations (`UIView.animate`) might be necessary when integrating with existing UIKit code or when needing very fine-grained control.\n*   **Timer-Based Animations:** For animations that are not directly tied to state changes, you might use `Timer` to update view properties over time, though this is generally less efficient and harder to manage than SwiftUI animations.\n\nSwiftUI simplifies animation creation, but understanding the underlying principles is crucial for optimizing performance and handling complex scenarios. Use `.animation` modifier for default animation, use `.transition` for view appearance/disappearance animations.",
      "code_example": null,
      "tags": [
        "swiftui",
        "animation",
        "animatabledata",
        "geometryeffect"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    }
  ]
}