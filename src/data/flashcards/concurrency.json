{
  "topic": "concurrency",
  "title": "Swift Concurrency",
  "description": "async/await, actors, tasks, and modern concurrency",
  "cards": [
    {
      "id": "conc-001",
      "front": "What is async/await in Swift?",
      "back": "Language feature for asynchronous code. async marks function that can suspend. await marks suspension point. Compiler ensures thread safety. Replaces completion handlers with linear code flow.",
      "tags": [
        "async-await"
      ]
    },
    {
      "id": "conc-002",
      "front": "What's the difference between Task and Task.detached?",
      "back": "Task: Inherits actor context and priority from caller. Task.detached: Runs independently, no inherited context. Prefer Task for most cases. Detached for truly independent work.",
      "tags": [
        "tasks"
      ]
    },
    {
      "id": "conc-003",
      "front": "Explain actors in Swift",
      "back": "Reference type with isolated state. Only one task accesses actor at a time. Use await to access from outside. Prevents data races at compile time. Perfect for shared mutable state.",
      "tags": [
        "actors"
      ]
    },
    {
      "id": "conc-004",
      "front": "What is @MainActor?",
      "back": "Global actor for main thread. Guarantees code runs on main thread. Use for UI code. Can mark class, function, or property. Async calls to @MainActor auto-dispatch to main thread.",
      "tags": [
        "actors",
        "main-thread"
      ]
    },
    {
      "id": "conc-005",
      "front": "How do you handle cancellation in Swift concurrency?",
      "back": "Check Task.isCancelled or call Task.checkCancellation() (throws). Propagates through async calls. task.cancel() signals cancellation. AsyncSequence ends on cancellation.",
      "tags": [
        "tasks",
        "cancellation"
      ]
    },
    {
      "id": "conc-006",
      "front": "What is a continuation and when do you use it?",
      "back": "Bridges callback-based code to async/await. withCheckedContinuation (safe) or withUnsafeContinuation (fast). Must call resume exactly once. Use to wrap legacy async APIs.",
      "tags": [
        "async-await",
        "interop"
      ]
    },
    {
      "id": "conc-007",
      "front": "Explain structured concurrency",
      "back": "Child tasks are scoped to parent. Parent waits for children. Cancellation propagates down. async let and TaskGroup provide structure. Prevents orphaned tasks and resource leaks.",
      "tags": [
        "structured-concurrency"
      ]
    },
    {
      "id": "conc-008",
      "front": "What's the difference between async let and TaskGroup?",
      "back": "async let: Fixed number of concurrent tasks, results bound to variables. TaskGroup: Dynamic number of tasks, add tasks in loop, collect results. Use async let for known count.",
      "tags": [
        "structured-concurrency"
      ]
    },
    {
      "id": "conc-009",
      "front": "What is Sendable?",
      "back": "Protocol marking types safe to share across concurrency domains. Value types usually auto-conform. Classes must be final with immutable properties or use locks. @Sendable for closures.",
      "tags": [
        "sendable",
        "thread-safety"
      ]
    },
    {
      "id": "conc-010",
      "front": "How does AsyncSequence work?",
      "back": "Async version of Sequence. Use for-await-in to iterate. Elements arrive over time. Built-in: URLSession.bytes, NotificationCenter.notifications. Create with AsyncStream.",
      "tags": [
        "async-sequence"
      ]
    },
    {
      "id": "conc-011",
      "front": "What is AsyncStream?",
      "back": "Create custom AsyncSequence from callbacks. AsyncStream.Continuation yields values. yield(_:) adds element, finish() ends stream. Bridges delegate patterns to async/await.",
      "tags": [
        "async-sequence"
      ]
    },
    {
      "id": "conc-012",
      "front": "Explain task priority in Swift",
      "back": "Priorities: userInitiated > high > medium > low > utility > background. Set via Task(priority:). Higher priority tasks scheduled first. Priority can be elevated (not lowered) by system.",
      "tags": [
        "tasks"
      ]
    },
    {
      "id": "conc-013",
      "front": "What is actor reentrancy?",
      "back": "When actor awaits, other tasks can execute on it. State may change during suspension. Always revalidate state after await. Don't assume state persists across await points.",
      "tags": [
        "actors"
      ]
    },
    {
      "id": "conc-014",
      "front": "How do you use nonisolated in actors?",
      "back": "Marks method/property as not requiring actor isolation. Can be called synchronously from outside. Must only access immutable state or use other nonisolated members. Good for constants.",
      "tags": [
        "actors"
      ]
    },
    {
      "id": "conc-015",
      "front": "What's the difference between GCD and Swift Concurrency?",
      "back": "GCD: Manual queue management, completion handlers, no compile-time safety. Swift Concurrency: Automatic scheduling, async/await, compiler-enforced safety, structured cancellation.",
      "tags": [
        "comparison"
      ]
    },
    {
      "id": "conc-016",
      "front": "How do you handle errors in async functions?",
      "back": "Mark async throws, use try await at call site. Errors propagate like sync code. Task catches unhandled errors (access via task.result). TaskGroup can use throwing variant.",
      "tags": [
        "error-handling"
      ]
    },
    {
      "id": "conc-017",
      "front": "What is @TaskLocal?",
      "back": "Thread-local-like storage for tasks. Value bound for task scope, inherited by child tasks. Use for request IDs, logging context. Set via TaskLocal.withValue { }.",
      "tags": [
        "tasks"
      ]
    },
    {
      "id": "conc-018",
      "front": "Explain global actors",
      "back": "@globalActor creates singleton actor for isolation. @MainActor is built-in global actor. Create custom: @globalActor actor MyActor { static let shared = MyActor() }. Share isolation domain.",
      "tags": [
        "actors"
      ]
    },
    {
      "id": "conc-019",
      "front": "How do you test async code?",
      "back": "XCTest supports async: func testExample() async throws { }. Use await directly in test. For tasks, await task.value. Mock actors for isolation testing.",
      "tags": [
        "testing"
      ]
    },
    {
      "id": "conc-020",
      "front": "What are the common Swift Concurrency pitfalls?",
      "back": "1) Actor reentrancy bugs 2) Forgetting @MainActor for UI 3) Blocking threads with sync calls 4) Not handling cancellation 5) Sendable violations 6) Retain cycles in Task closures.",
      "tags": [
        "best-practices"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "Structured Concurrency",
      "back": "",
      "code_example": null,
      "tags": [
        "Structured Concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Actors and Actor isolation",
      "back": "",
      "code_example": null,
      "tags": [
        "Actors and Actor isolation"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain the Sendable protocol and its role in Swift concurrency. How does it help prevent data races, and what are some common ways to adopt it?",
      "back": "The `Sendable` protocol (Swift 5.5+) is a marker protocol indicating that a type's values are safe to be shared between concurrent execution contexts (e.g., different threads or actors). It prevents data races by ensuring that only immutable or properly synchronized data is accessed concurrently.  Types conforming to `Sendable` guarantee that instances can be copied without introducing concurrency issues.  \n\n**Core Concept:**\n`Sendable` doesn't enforce any specific synchronization mechanism itself. Instead, it's a *promise* that the type inherently manages its state safely when shared concurrently. The Swift compiler uses this promise to enforce compile-time checks and warnings about potential data races.\n\n**Adoption:**\n1. **Immutable Types:** Structs and enums with only immutable stored properties are implicitly `Sendable`.  No explicit conformance is needed.\n\n2. **Value Types:**  Value types that are thread-safe are also implicitly `Sendable`.\n\n3. **Classes:** Classes are generally *not* implicitly `Sendable` because they have mutable state and reference semantics.  To make a class `Sendable`, you must use synchronization mechanisms like locks or actors to protect its mutable state.  Even then, you MUST mark the class as `@unchecked Sendable`. This tells the compiler that *you* have ensured thread safety, even though it can't verify it automatically. Misusing `@unchecked Sendable` is dangerous and can lead to data races.\n\n4. **Actors:** Actors inherently provide mutual exclusion for their state, so actor types are implicitly `Sendable`.\n\n**Code Example:**\n```swift\n// Implicit Sendable (struct with immutable properties)\nstruct Point: Sendable {\n    let x: Int\n    let y: Int\n}\n\n// Implicit Sendable (enum)\nenum State: Sendable {\n    case idle\n    case running\n    case completed\n}\n\n// Class - requires explicit synchronization and @unchecked Sendable\nclass Counter {\n    private var value: Int = 0\n    private let lock = NSLock()\n\n    func increment() {\n        lock.lock()\n        defer { lock.unlock() }\n        value += 1\n    }\n\n    func getValue() -> Int {\n        lock.lock()\n        defer { lock.unlock() }\n        return value\n    }\n}\n\nextension Counter: @unchecked Sendable {}\n\n// Actor - inherently Sendable\nactor MyActor {\n    private var count: Int = 0\n\n    func increment() {\n        count += 1\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n```\n\n**Common Pitfalls:**\n*   Forgetting synchronization in classes and marking them `@unchecked Sendable` without proper protection.  This is a major source of data races.\n*   Assuming a type is `Sendable` without verifying its thread safety.\n*   Passing non-`Sendable` data across actor boundaries or to concurrent tasks without proper isolation.\n\n**Alternatives:**\n*   **Data Isolation:** Instead of sharing mutable state, consider copying data or using immutable data structures.\n*   **Actors:** Actors provide a higher-level concurrency model that simplifies thread safety.\n*   **DispatchQueues (with caution):**  While possible, using `DispatchQueue.sync` to protect data is error-prone and can lead to deadlocks.  Actors are generally preferred.\n\n`Sendable` is crucial for writing safe concurrent code in Swift.  It provides a compile-time safety net to help prevent data races, but it requires careful consideration of the thread safety of your types.",
      "code_example": null,
      "tags": [
        "concurrency",
        "sendable",
        "actors",
        "thread safety",
        "data race",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Task Groups",
      "back": "",
      "code_example": null,
      "tags": [
        "Task Groups"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "AsyncSequence and AsyncStream",
      "back": "",
      "code_example": null,
      "tags": [
        "AsyncSequence and AsyncStream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain the purpose of MainActor and global actors in Swift concurrency, including how they ensure thread safety and how they differ from GCD. Provide a practical example.",
      "back": "MainActor and global actors address thread safety in Swift's concurrent environment.  \n\n**Core Concept:**\n\n*   **Data Races:**  Occur when multiple threads access and modify the same data concurrently, leading to unpredictable behavior. Actors isolate state, ensuring that only one thread can access it at a time.\n*   **MainActor:** A global actor that executes code on the main thread. UI updates *must* occur on the main thread.  `@MainActor` ensures code runs on the main thread.\n*   **Global Actors:** Custom actors that provide isolation similar to MainActor, but for other contexts. They define a specific execution context.\n\n**Code Example:**\n\n```swift\nimport Foundation\n\nactor Counter {\n    private var count = 0\n\n    func increment() -> Int {\n        count += 1\n        return count\n    }\n}\n\n@MainActor\nclass MyViewController: UIViewController {\n    let counter = Counter()\n    @IBOutlet weak var label: UILabel!\n\n    func updateUI() async {\n        let newCount = await counter.increment()\n        label.text = \"Count: \\(newCount)\"\n    }\n\n    @IBAction func buttonTapped(_ sender: UIButton) {\n        Task {\n            await updateUI()\n        }\n    }\n}\n```\n\n**Explanation:**\n\n1.  `Counter` is an actor, protecting its `count` property from concurrent access. Only one task can call `increment` at a time.\n2.  `MyViewController` is a UIViewController that needs to update the label, which *must* occur on the main thread. `@MainActor` attribute ensures that the `MyViewController` will run on the main thread.\n3.  `buttonTapped` starts a `Task` to increment the counter and update the UI.\n4.  `updateUI` is marked `async` because it needs to `await` the result of `counter.increment()`.  Because `MyViewController` is running on MainActor, the UI updates are also performed on the main thread.\n\n**Common Pitfalls:**\n\n*   **Forgetting `await`:**  When calling an actor's method, you *must* use `await`.  Failing to do so will result in a compiler error.\n*   **Deadlocks:**  Be careful when calling `await` from within an actor.  If two actors are waiting for each other, a deadlock can occur.\n*   **Overuse of MainActor:** Performing long-running tasks on the main thread will block the UI. Offload intensive work to background tasks or global actors.\n\n**When to Use vs. Alternatives (GCD):**\n\n*   **Actors:**  Ideal for managing state and ensuring thread safety. They provide compile-time safety, preventing data races.  Actors are preferred when data isolation and preventing race conditions are paramount.\n*   **GCD:**  Lower-level API for managing concurrent tasks. More flexible but requires manual synchronization (locks, semaphores) to avoid data races. GCD is still useful for dispatching tasks to background queues, but for state management, actors are generally safer and easier to use.\n\n**Key Differences from GCD:**\n\n*   **Compile-time Safety:** Actors provide compile-time guarantees about thread safety. GCD requires manual synchronization, which is prone to errors.\n*   **Data Isolation:** Actors inherently isolate their state. GCD requires explicit locking mechanisms.\n*   **Simplicity:** Actors simplify concurrent programming by handling the synchronization details internally.\n\nIn summary, `MainActor` ensures UI updates occur on the main thread, while global actors create isolated contexts for thread-safe concurrent operations, offering a safer and more manageable alternative to GCD's manual synchronization.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "mainactor",
        "global actor",
        "thread safety",
        "gcd"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Explain different techniques for preventing data races in Swift, considering both performance and complexity tradeoffs.",
      "back": "I'd focus on these:\n1. **Serial Queues:** Simple. Guarantee serial access. Great for simple cases, but limit concurrency. Example: file access.\n2. **Dispatch Barrier:** Allows concurrent reads, exclusive writes. Good balance. `DispatchWorkItemFlags.barrier`.  Example: Cache with frequent reads, infrequent writes.\n3. **Locks:**  `NSLock`, `NSRecursiveLock`, `os_unfair_lock`. Fine-grained control. `os_unfair_lock` avoids priority inversion, unlike `NSLock`. Can cause deadlocks if not managed carefully.\n4. **@actor:** Swift 5.5+. Simplifies concurrent code by isolating state. Compiler enforces mutual exclusion.  Avoids explicit locking. Example: Data model shared between views.\n5. **Atomic Operations:** `OSAtomic.h` (legacy), `Atomic<T>`. Low-level, lock-free. Best performance if used correctly. Complex, error-prone.  Example: Incrementing a counter.\nChoose the right tool for job. Actors and serial queues are often easiest. Unfair locks offer a good balance. Use atomic operations as a last resort.",
      "code_example": null,
      "tags": [
        "concurrency",
        "data race",
        "swift",
        "synchronization",
        "actors",
        "locks",
        "dispatch queue"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "combine_e78094e3e387",
      "front": "Explain Combine's Publisher/Subscriber model. How does it differ from delegation or notifications? Provide a practical example and discuss common pitfalls.",
      "back": "Combine is a declarative Swift framework for handling asynchronous events. It uses a Publisher/Subscriber model for data streams.\n\n**Core Concepts:**\n*   **Publisher:** Emits a sequence of values over time and a completion or failure event.\n*   **Subscriber:** Receives values and completion/failure events from a Publisher.\n*   **Subscription:** Represents the connection between a Publisher and a Subscriber.\n*   **Operators:** Functions that modify, filter, or combine Publishers.\n\n**Difference from Delegation/Notifications:**\n*   **Delegation:** One-to-one, tightly coupled. Requires explicit protocol conformance.\n*   **Notifications:** One-to-many, loosely coupled. Can lead to scattered code and difficulty tracking data flow.\n*   **Combine:** Provides a unified, type-safe, and composable way to handle asynchronous events. Uses reactive programming principles, making data flow more predictable and easier to manage.\n\n**Example:**\n```swift\nimport Combine\n\n// Publisher: A timer that emits dates every second\nlet timerPublisher = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()\n\n// Subscriber: Prints the received date\nlet timerSubscription = timerPublisher\n    .sink(receiveValue: { date in\n        print(\"Current date: \\(date)\")\n    })\n\n// After 5 seconds, cancel the subscription\nDispatchQueue.main.asyncAfter(deadline: .now() + 5) {\n    timerSubscription.cancel()\n    print(\"Timer stopped.\")\n}\n```\n\n**Common Pitfalls:**\n*   **Retain Cycles:** Publishers and Subscribers can create strong reference cycles. Use `[weak self]` or `[unowned self]` in closures to avoid this.\n*   **Backpressure:** Publishers can emit data faster than Subscribers can process it. Use operators like `.throttle`, `.debounce`, or `.buffer` to manage the flow of data.\n*   **Error Handling:** Properly handle errors in your Publishers using `.catch` or `.retry` operators.  Failing to do so can silently stop your pipeline.\n*   **Memory Management:**  Store subscriptions in properties with appropriate scope to prevent premature deallocation and unexpected behavior.\n*   **Over-releasing:** Cancelling a subscription multiple times can lead to crashes. Ensure subscriptions are cancelled only once.\n\n**Alternatives:**\n*   **Delegation:** Suitable for simple one-to-one communication.\n*   **Notifications:** Useful for broadcasting events to multiple observers.\n*   **GCD (Grand Central Dispatch):** Lower-level API for managing concurrency. Can be used for asynchronous tasks but requires more manual management.\n*   **Async/Await:**  More modern approach for handling asynchronous operations, focused on sequential code flow, but may not be as suitable for complex data stream transformations as Combine.\n\n**When to use Combine:**\n*   Complex asynchronous data flows.\n*   UI event handling (e.g., text field changes, button taps).\n*   Networking requests and responses.\n*   Any situation where you need to react to changes in data over time.\n\nCombine offers a powerful and type-safe way to manage asynchronous events in Swift. Understanding its core concepts and potential pitfalls is crucial for building robust and maintainable iOS applications.",
      "code_example": null,
      "tags": [
        "combine",
        "publisher",
        "subscriber",
        "asynchronous",
        "reactive programming"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "combine_d81a9c91347b",
      "front": "Explain Combine's `map`, `flatMap`, and `combineLatest` operators.  How do they transform and combine publishers?  Provide examples and use cases for each, including potential pitfalls.",
      "back": "Combine offers powerful operators for transforming and combining publishers. `map` transforms each element emitted by a publisher. `flatMap` transforms each element into a *new* publisher and then flattens these publishers into a single stream. `combineLatest` waits for each of its input publishers to emit at least one value, then emits a new value whenever *any* of the upstream publishers emit, combining the latest values from each.\n\n**map**:  Use `map` for simple, synchronous transformations.  It's similar to `map` on arrays.  \n```swift\nimport Combine\n\nlet numbers = PassthroughSubject<Int, Never>()\n\nlet squaredNumbers = numbers\n    .map { $0 * $0 }\n    .sink { print(\"Squared: \\($0)\") }\n\nnumbers.send(1)\nnumbers.send(2)\nnumbers.send(3)\n// Prints: Squared: 1, Squared: 4, Squared: 9\n```\n\n**flatMap**: Use `flatMap` when you need to create a new publisher for each emitted value and then merge the results.  It's useful for asynchronous operations or when the transformation results in a stream of values.  A common pitfall is creating too many inner publishers, which can lead to performance issues.  Consider using `maxPublishers` to limit concurrency.\n\n```swift\nimport Combine\n\nlet strings = PassthroughSubject<String, Never>()\n\nlet urlPublisher = strings\n    .flatMap { string -> Future<URL, Error> in\n        return Future { promise in\n            guard let url = URL(string: string) else {  promise(.failure(URLError(.badURL))) ; return }\n            promise(.success(url))\n        }\n    }\n    .sink(receiveCompletion: { completion in\n        print(\"Completion: \\(completion)\")\n    }, receiveValue: { url in\n        print(\"URL: \\(url)\")\n    })\n\nstrings.send(\"https://www.example.com\")\nstrings.send(\"invalid url\")\nstrings.send(\"https://www.apple.com\")\n\n//prints URL, and completion with failure\n```\n\n**combineLatest**: Use `combineLatest` when you need to react to changes in multiple publishers.  It emits a new value only when *all* publishers have emitted at least once.  A common use case is combining data from multiple UI elements (e.g., text fields) to enable/disable a button.  A potential pitfall is that it won't emit anything until all input publishers have emitted at least one value. Also, order matters! The order of publishers in `combineLatest` determines the order of their values in the resulting tuple.\n\n```swift\nimport Combine\n\nlet namePublisher = CurrentValueSubject<String, Never>(\"\")\nagePublisher = CurrentValueSubject<Int, Never>(0)\n\nlet combinedPublisher = Publishers.CombineLatest(namePublisher, agePublisher)\n    .sink { (name, age) in\n        print(\"Name: \\(name), Age: \\(age)\")\n    }\n\nnamePublisher.send(\"Alice\")\nagePublisher.send(30)\nnamePublisher.send(\"Bob\")\n\n// Prints:\n// Name: Alice, Age: 30\n// Name: Bob, Age: 30\n\n```\n\nAlternatives:  For `map`, consider using `Publisher.handleEvents` for side effects without transforming the data.  For `flatMap`, explore `Publisher.switchToLatest` for managing the latest publisher from a stream of publishers (cancels previous ones). For combining, `zip` emits only when all publishers emit a new value *simultaneously* (index-aligned), which is different from `combineLatest`. `merge` combines values from multiple publishers of the *same* type into a single publisher.\n",
      "code_example": null,
      "tags": [
        "combine",
        "operators",
        "map",
        "flatMap",
        "combineLatest",
        "publisher",
        "swiftui"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_1cf53805b48a",
      "front": "Error handling in Combine",
      "back": "",
      "code_example": null,
      "tags": [
        "Error handling in Combine"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "combine_83feeebb4e47",
      "front": "Combine and async/await both address asynchronous programming. Compare and contrast their strengths, weaknesses, and ideal use cases. When would you choose one over the other and why?",
      "back": "Both Combine and async/await simplify asynchronous code, but differ significantly.\n\n**Combine:** A declarative framework for handling asynchronous events over time. It uses publishers, subscribers, and operators to process data streams. Think of it as reactive programming.\n\n**async/await:** A language-level feature that allows writing asynchronous code in a synchronous style. It simplifies working with completion handlers and eliminates callback hell.\n\n**Strengths:**\n*   **Combine:** Powerful for complex data transformations and event handling. Great for UI updates based on data streams (e.g., search bars, network status). Centralized error handling and cancellation.\n*   **async/await:** Simpler syntax for basic asynchronous tasks. Easier to read and write than completion handlers. Integrates well with existing Swift code.\n\n**Weaknesses:**\n*   **Combine:** Steeper learning curve due to its reactive nature and operators. Can lead to complex chains of operators that are hard to debug.\n*   **async/await:** Less powerful for complex data transformations. Requires more manual error handling and cancellation in some cases.  Not ideal for continuous data streams.\n\n**Code Example (Combine):**\n```swift\nimport Combine\n\nfunc fetchDataPublisher() -> AnyPublisher<String, Error> {\n    Future<String, Error> {\n        promise in\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            promise(.success(\"Data from network\"))\n        }\n    }\n    .eraseToAnyPublisher()\n}\n\n\nlet cancellable = fetchDataPublisher()\n    .sink(\n        receiveCompletion: { completion in\n            switch completion {\n            case .finished:\n                print(\"Finished\")\n            case .failure(let error):\n                print(\"Error: \\(error)\")\n            }\n        },\n        receiveValue: { value in\n            print(\"Received: \\(value)\")\n        }\n    )\n```\n\n**Code Example (async/await):**\n```swift\nfunc fetchDataAsync() async throws -> String {\n    try await Task.sleep(nanoseconds: 1_000_000_000) // Simulate network delay\n    return \"Data from network\"\n}\n\n\nTask {\n    do {\n        let data = try await fetchDataAsync()\n        print(\"Received: \\(data)\")\n    } catch {\n        print(\"Error: \\(error)\")\n    }\n}\n```\n\n**When to Use:**\n*   **Combine:** When dealing with complex, continuous data streams, reactive UI, or requiring robust error handling and cancellation.\n*   **async/await:** For simpler, one-off asynchronous tasks, improving code readability, and integrating with existing completion-handler-based APIs.\n\n**Common Pitfalls:**\n*   **Combine:** Over-complicating pipelines with unnecessary operators. Forgetting to store cancellables, leading to memory leaks. Incorrectly handling errors in the pipeline.\n*   **async/await:** Not handling errors with `try` and `catch`. Blocking the main thread with long-running asynchronous tasks.  Not understanding structured concurrency.\n\n**Alternatives:** Grand Central Dispatch (GCD) - lower level, more manual management needed. Operation Queues - useful for managing dependencies between asynchronous tasks.\n\nIn summary, Choose Combine for reactive streams and complex transformations. Opt for async/await for easier-to-read, straightforward asynchronous operations.  Understanding both allows you to select the best tool for the job.",
      "code_example": null,
      "tags": [
        "combine",
        "async/await",
        "concurrency",
        "asynchronous",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_4d7c72d6d8db",
      "front": "Explain how to create a custom `Publisher` in Combine, including its purpose, implementation considerations, and potential use cases. What are the key components?",
      "back": "A custom `Publisher` allows you to bridge existing asynchronous code, event sources, or delegate patterns into the Combine framework. It's essential when you need to expose non-Combine APIs as reactive streams.\n\nKey components:\n1.  `Publisher` protocol conformance: Define `Output` and `Failure` types.\n2.  `subscribe(_:)`: This method is called when a `Subscriber` attaches to the `Publisher`. You must create a custom `Subscription` here.\n3.  `Subscription` protocol conformance: Manages the relationship between the `Publisher` and `Subscriber`.  It handles demand and cancellation.\n4.  `receive(subscription:)`: Called on the `Subscriber` to signal the start of the subscription.\n5.  `receive(_:)`: Called on the `Subscriber` to send new values.  Can be called multiple times.\n6.  `receive(completion:)`: Called on the `Subscriber` to signal completion (success or failure).\n\nExample:\n```swift\nimport Combine\n\nclass MyCustomPublisher: Publisher {\n    typealias Output = String\n    typealias Failure = Never\n\n    private var subscribers: [AnySubscriber<String, Never>] = []\n\n    func subscribe<S: Subscriber>(_ subscriber: S) where S.Failure == Failure, S.Input == Output {\n        let subscription = MyCustomSubscription(subscriber: AnySubscriber(subscriber), publisher: self)\n        subscribers.append(AnySubscriber(subscriber))\n        subscriber.receive(subscription: subscription)\n    }\n\n    func send(value: String) {\n        subscribers.forEach { $0.receive(value) }\n    }\n\n    func complete() {\n        subscribers.forEach { $0.receive(completion: .finished) }\n    }\n}\n\nclass MyCustomSubscription: Subscription {\n    private var subscriber: AnySubscriber<String, Never>?\n    private var publisher: MyCustomPublisher\n\n    init(subscriber: AnySubscriber<String, Never>, publisher: MyCustomPublisher) {\n        self.subscriber = subscriber\n        self.publisher = publisher\n    }\n\n    func request(_ demand: Subscribers.Demand) {\n        // In a real implementation, you'd use the demand to control\n        // how much data you produce.\n        // For simplicity, we ignore demand here.\n    }\n\n    func cancel() {\n        subscriber = nil\n    }\n}\n\n// Usage:\nlet myPublisher = MyCustomPublisher()\nlet cancellable = myPublisher\n    .sink(receiveCompletion: { completion in\n        print(\"Completion: \\(completion)\")\n    }, receiveValue: { value in\n        print(\"Received: \\(value)\")\n    })\n\nmyPublisher.send(value: \"Hello\")\nmyPublisher.send(value: \"World\")\nmyPublisher.complete()\n```\n\nCommon Pitfalls:\n*   Incorrectly handling `Subscribers.Demand`: Not respecting demand can lead to backpressure issues, where the `Publisher` overwhelms the `Subscriber`.\n*   Memory leaks:  Ensure the `Subscription` cancels properly to avoid retaining the `Subscriber` or `Publisher`.\n*   Thread safety: If the `Publisher` interacts with shared mutable state, ensure proper synchronization.\n*   Incorrect error handling:  Make sure to handle errors correctly and send a `.failure` completion when appropriate.\n\nAlternatives:\n*   `PassthroughSubject`:  A simpler way to bridge imperative code when you don't need full control over subscription and demand.\n*   `CurrentValueSubject`:  Similar to `PassthroughSubject`, but it holds the latest value.\n*   `Future`:  For one-time asynchronous operations.\n\nWhen to Use:\nUse a custom `Publisher` when you need fine-grained control over the publishing process, especially when integrating with existing asynchronous APIs that don't natively support Combine.  Avoid it if a `Subject` or `Future` adequately meets your needs, as they are simpler to implement.",
      "code_example": null,
      "tags": [
        "Combine",
        "Publisher",
        "Subscription",
        "Asynchronous Programming"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_32f69cce08dc",
      "front": "Memory management in Combine",
      "back": "",
      "code_example": null,
      "tags": [
        "Memory management in Combine"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_b90e0a9fafad",
      "front": "Debugging Combine pipelines",
      "back": "",
      "code_example": null,
      "tags": [
        "Debugging Combine pipelines"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}