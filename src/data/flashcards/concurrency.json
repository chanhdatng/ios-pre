{
  "topic": "concurrency",
  "title": "Swift Concurrency",
  "description": "async/await, actors, tasks, and modern concurrency",
  "cards": [
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "Explain Swift's Structured Concurrency. How does it improve upon older concurrency models like GCD, and what are its core components (async/await, Tasks, Actors)?",
      "back": "Structured concurrency ensures predictable execution and simplifies error handling by creating explicit parent-child relationships between concurrent tasks. It improves upon GCD by enforcing compile-time checks for proper task management, preventing issues like orphaned tasks and unhandled errors.\n\n**Core Components:**\n\n*   **async/await:**  `async` marks a function as potentially suspending, while `await` pauses execution until the async function returns. This makes asynchronous code look and behave like synchronous code.\n\n```swift\nfunc fetchData(from url: URL) async throws -> Data {\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\n*   **Tasks:** Represent a unit of asynchronous work.  Tasks can be created using `Task {}` or by detaching a closure with `Task.detached {}`. Detached tasks are not part of the current structured concurrency scope and require manual management.\n\n```swift\nfunc processData() async {\n    async let data1 = fetchData(from: URL(string: \"...\")!)\n    async let data2 = fetchData(from: URL(string: \"...\")!)\n\n    do {\n        let result1 = try await data1\n        let result2 = try await data2\n        // Process results\n    } catch {\n        // Handle errors\n    }\n}\n```\n\n*   **Actors:** Protect mutable state from concurrent access. Only one task can access an actor's state at a time, preventing data races. Accessing an actor's properties or methods requires using `await`.\n\n```swift\nactor Counter {\n    private var count = 0\n\n    func increment() async {\n        count += 1\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n\nlet counter = Counter()\n\nTask {\n    await counter.increment()\n    print(counter.getCount())\n}\n```\n\n**Common Pitfalls:**\n\n*   **Ignoring Errors:**  Failing to handle errors thrown by `async` functions can lead to unexpected behavior.\n*   **Deadlocks:**  Occur when two or more tasks are blocked indefinitely, waiting for each other. Avoid circular dependencies between actors and tasks.\n*   **Over-using detached tasks:** Detached tasks lose the benefits of structured concurrency, making error handling and cancellation more difficult. Use them sparingly and only when truly necessary.\n\n**When to Use vs. Alternatives:**\n\n*   **Structured Concurrency (async/await, Tasks, Actors):**  Preferred for new projects or when refactoring existing code. Offers better readability, error handling, and data race prevention compared to GCD and Operation Queues.\n*   **GCD:**  Useful for simple background tasks and dispatching work to specific queues. Can be more efficient for very low-level operations where performance is critical.\n*   **Operation Queues:**  Suitable for managing complex dependencies between tasks and controlling concurrency levels.  Offers more control over task execution order and cancellation than GCD, but less safety than structured concurrency.\n\nStructured concurrency provides a safer and more maintainable way to write concurrent code in Swift, reducing the risk of common concurrency issues and improving overall application stability.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "async/await",
        "tasks",
        "actors",
        "GCD"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Swift's structured concurrency improves upon GCD with compile-time safety via async/await, Tasks, and Actors for safer concurrency."
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain Actors in Swift's concurrency model. What problem do they solve, and how does actor isolation work? Provide an example and discuss potential pitfalls.",
      "back": "Actors address data races in concurrent environments by providing a safe way to encapsulate state and ensure exclusive access. An actor is a reference type that protects its mutable state, allowing only one thread to access its properties or methods at a time.\n\n**Core Concept:**\nActors enforce *actor isolation*.  This means that any access to an actor's state must go through its methods, and these methods are executed serially, preventing data races.  The compiler enforces this isolation at compile time.\n\n**Code Example:**\n```swift\nactor Counter {\n    private var count = 0\n\n    func increment() async {\n        count += 1\n        print(\"Count is now: \\(count)\")\n    }\n\n    nonisolated func currentCount() -> Int {\n        return count\n    }\n}\n\nfunc testCounter() async {\n    let counter = Counter()\n    \n    await withTaskGroup(of: Void.self) { group in\n        for _ in 0..<100 {\n            group.addTask {\n                await counter.increment()\n            }\n        }\n    }\n\n    print(\"Final count: \\(counter.currentCount())\")\n}\n```\nIn this example, `Counter` is an actor. The `increment()` method is automatically isolated to the actor instance. Multiple tasks can call `increment()` concurrently, but the actor ensures that they are executed one at a time, preventing race conditions on `count`. The `currentCount()` method is marked `nonisolated` because it only returns the value of count, without modifying it, and it can be accessed without requiring an `await`.  This is useful for read-only access.\n\n**Common Pitfalls:**\n*   **Deadlocks:**  If two actors are waiting for each other, a deadlock can occur.  This often happens when one actor calls an `async` method on another actor while holding a lock or waiting for something else.  Careful design is needed to avoid circular dependencies.\n*   **Reentrancy:** While an actor is processing an `async` function, it *can* be re-entered via another `async` call.  If the state changes during the first `async` call, the second call might see unexpected results.  Always ensure that your actor's methods are reentrant-safe.\n*   **Forgetting `await`:**  When calling an `async` method on an actor from outside the actor, you *must* use `await`.  Forgetting `await` will cause a compiler error.\n*   **Performance:** Because actor methods are executed serially, excessive contention can lead to performance bottlenecks. Consider using finer-grained actors or other concurrency mechanisms if needed.\n\n**When to Use vs. Alternatives:**\n*   **Use Actors:** When you have mutable state that needs to be accessed concurrently and you want to avoid data races. Actors are excellent for encapsulating data and ensuring thread safety.\n*   **Alternatives:**\n    *   **DispatchQueues with Barriers:**  Can be used for managing concurrent access to shared resources, but require manual locking and are more prone to errors.  Actors provide a higher-level, safer abstraction.\n    *   **NSLock/NSRecursiveLock:** Low-level locking mechanisms that require careful management to avoid deadlocks.  Actors provide a more structured approach to concurrency.\n    *   **Atomic Properties (Objective-C):** Atomic properties provide basic thread safety, but can be less performant than actors and don't prevent all types of race conditions.\n    *   **Immutable Data Structures:** If possible, using immutable data structures eliminates the need for locking altogether.\n\nActors are a powerful tool for writing safe and efficient concurrent code in Swift. By understanding their core principles and potential pitfalls, you can leverage them to build robust and scalable applications.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "actor isolation",
        "swift",
        "async/await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Actors prevent data races by isolating mutable state. Only one thread accesses an actor's state at a time via its methods."
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Sendable protocol",
      "back": "",
      "code_example": null,
      "tags": [
        "Sendable protocol"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "How do Task Groups in Swift concurrency help manage child tasks and propagate results, and what are their advantages over dispatch groups?",
      "back": "Task Groups enable structured concurrency, allowing you to create dynamic child tasks within a parent task. They provide a scope where child tasks execute concurrently, and the parent task waits for all children to complete before continuing. Results can be collected and aggregated. Task Groups offer better error handling and cancellation compared to dispatch groups.\n\n```swift\nfunc processData() async throws -> [Int] {\n    await withTaskGroup(of: Int.self, returning: [Int].self) { group in\n        for i in 1...5 {\n            group.addTask {\n                // Simulate some work\n                try? await Task.sleep(nanoseconds: UInt64(i * 100_000_000))\n                if i == 3 { throw MyError.simulatedError }\n                return i * 2\n            }\n        }\n\n        var results: [Int] = []\n        for await result in group {\n            results.append(result)\n        }\n\n        return results\n    }\n}\n\nenum MyError: Error {\n    case simulatedError\n}\n\n//Usage\nTask {\n    do {\n        let processedData = try await processData()\n        print(\"Processed data: \\(processedData)\")\n    } catch {\n        print(\"Error processing data: \\(error)\")\n    }\n}\n```\n\n**Core Concept:** Task Groups provide a structured way to manage concurrent child tasks.  `withTaskGroup` creates the group, `addTask` adds work, and the `await` on the group waits for completion.\n\n**Advantages over Dispatch Groups:**\n*   **Structured Concurrency:** Task Groups enforce a clear parent-child relationship, improving code clarity and error handling.\n*   **Cancellation Propagation:**  Cancelling the parent task automatically cancels child tasks.\n*   **Error Propagation:** Errors thrown by child tasks are automatically propagated to the parent task, simplifying error handling. DispatchGroups require manual error tracking.\n*   **Type Safety:** Task Groups are type-safe, ensuring that the results returned by child tasks are of the expected type.\n\n**Common Pitfalls:**\n*   Not awaiting all child tasks: If you don't iterate over the TaskGroup, the parent task might complete before all children are done.\n*   Ignoring errors:  Make sure to handle errors propagated from child tasks using `try await` or `try? await` when adding tasks, and then handling the error in the `do/catch` block.\n*   Accidental synchronous work: Ensure work within `addTask` is truly asynchronous to avoid blocking the Task Group.\n\n**When to Use:**\nUse Task Groups when you need to perform multiple independent asynchronous operations concurrently and aggregate their results.  Use Dispatch Groups for lower-level concurrency management when finer-grained control is needed and structured concurrency isn't a priority.",
      "code_example": null,
      "tags": [
        "concurrency",
        "taskgroup",
        "swift",
        "async",
        "structured concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Task Groups enable structured concurrency, managing child tasks and propagating results/errors. They offer better error handling than dispatch groups."
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Explain `AsyncSequence` and `AsyncStream` in Swift. How do they facilitate asynchronous data processing, and what are their key differences and use cases?",
      "back": "`AsyncSequence` and `AsyncStream` are Swift's answer to dealing with asynchronous data streams. Think of `AsyncSequence` as the asynchronous counterpart to `Sequence`. It represents a series of values produced over time, asynchronously. You can iterate over it using `for await in`. `AsyncStream`, on the other hand, is a type that lets you create an `AsyncSequence` by manually yielding values to it.\n\nKey Differences:\n*   `AsyncSequence`: A protocol defining the structure of an asynchronous sequence.  You *consume* data from an `AsyncSequence`.\n*   `AsyncStream`: A concrete type that *produces* an asynchronous sequence. It acts as a bridge between synchronous and asynchronous code.\n\nUse Cases:\n*   `AsyncSequence`: Ideal for representing data feeds like network streams, file reads, or sensor data.\n*   `AsyncStream`: Useful when you need to adapt existing synchronous APIs to the async/await world or when you have complex logic for producing asynchronous values.\n\nExample:\n\n```swift\n// Using AsyncStream to create an asynchronous sequence of numbers\nlet stream = AsyncStream<Int> { continuation in\n    Task {\n        for i in 1...5 {\n            continuation.yield(i)\n            try? await Task.sleep(nanoseconds: 1_000_000_000) // Simulate delay\n        }\n        continuation.finish()\n    }\n}\n\n// Consuming the AsyncStream using AsyncSequence\nTask {\n    for await number in stream {\n        print(\"Received: \\(number)\")\n    }\n    print(\"Stream finished\")\n}\n```\n\nCommon Pitfalls:\n*   Forgetting to call `continuation.finish()` in `AsyncStream` can lead to infinite loops.\n*   Not handling errors properly within the `AsyncStream`'s closure can cause unexpected behavior.\n*   Over-yielding values in `AsyncStream` without proper backpressure handling can lead to memory issues.\n\nAlternatives:\n*   Combine framework: Offers more powerful operators for transforming and combining asynchronous data streams, but has a steeper learning curve.\n*   GCD: Lower-level API for managing concurrency, suitable for simple asynchronous tasks but requires more manual management.\n\nWhen to Use:\n*   Use `AsyncSequence` and `AsyncStream` when you have a clear need for asynchronous data streams and want to leverage the simplicity and readability of async/await.\n*   Choose Combine for complex data transformations and reactive programming.\n*   Consider GCD for simple, low-level asynchronous operations.",
      "code_example": null,
      "tags": [
        "concurrency",
        "async/await",
        "AsyncSequence",
        "AsyncStream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ],
      "summary": "`AsyncSequence` is a protocol to consume async data streams; `AsyncStream` creates them by yielding values, bridging sync/async code."
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain MainActor and global actors. How do they ensure thread safety and what are their use cases? Provide a code example.",
      "back": "MainActor and global actors in Swift concurrency manage shared mutable state safely across threads.\n\nMainActor:  Ensures code executes on the main thread, vital for UI updates and avoiding UI freezes.  It's a global actor implicitly used for UI-related tasks. All UI updates MUST happen on the MainActor.\n\nGlobal Actors:  Enable you to define custom execution contexts (similar to dispatch queues) to isolate specific resources or data. Accessing data guarded by an actor is always serialized, preventing race conditions.  You can create multiple instances of global actors.\n\nThread Safety: Actors achieve thread safety by serializing access to their internal state.  Only one task can access an actor's mutable state at a time. This prevents data races and ensures consistency.\n\nUse Cases:\n* MainActor: All UI updates, interacting with UIKit/AppKit.\n* Global Actors: Managing access to shared resources (e.g., a database connection pool, a file system).  Performing long-running tasks on background threads while ensuring data consistency.\n\nExample:\n```swift\nimport Foundation\n\nactor Counter {\n    private var count = 0\n\n    func increment() async -> Int {\n        count += 1\n        return count\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n\n@MainActor\nclass MyViewController {\n    let counter = Counter()\n\n    func updateUI() async {\n        let newCount = await counter.increment()\n        // Safely update UI on the main thread\n        print(\"Count: \\(newCount)\")\n    }\n}\n\n// Usage\nlet viewController = MyViewController()\nTask {\n    await viewController.updateUI()\n}\n```\n\nCommon Pitfalls:\n* Deadlocks:  Occur when two or more tasks are blocked indefinitely, waiting for each other.  Avoid circular dependencies between actors.\n* Actor reentrancy: An actor can re-enter itself if it suspends during a call and another task calls it before the first task resumes. Be mindful of state changes during suspension points.\n* Forgetting `await`: If you forget `await` when calling an `async` function on an actor, the compiler will likely warn you, but the code will execute synchronously, potentially blocking the current thread.\n\nAlternatives:\n* GCD:  Lower-level, requires manual thread management and synchronization (e.g., locks).  More error-prone than actors.\n* OperationQueues: Higher-level than GCD, but still requires manual synchronization for shared mutable state.\n\nActors are generally preferred for managing shared mutable state due to their built-in thread safety and ease of use.  GCD and OperationQueues are useful for general concurrency tasks where shared mutable state is not a primary concern.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "MainActor",
        "global actors",
        "thread safety",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Actors ensure thread safety by serializing access to mutable state, preventing data races. MainActor for UI, global actors for other shared resources."
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Explain data races in concurrent programming and describe strategies to prevent them in Swift.  Include common pitfalls and alternative solutions.",
      "back": "Data races occur when multiple threads access and modify the same memory location concurrently, without proper synchronization, leading to unpredictable behavior.  To prevent them, we ensure exclusive access to shared resources.\n\n**Strategies:**\n\n1.  **Locks (Mutexes):** Provide mutual exclusion. Only one thread can hold the lock at a time.\n    ```swift\n    import Foundation\n\n    class SafeCounter {\n        private var counter = 0\n        private let lock = NSRecursiveLock()\n\n        func increment() {\n            lock.lock()\n            defer { lock.unlock() }\n            counter += 1\n        }\n\n        func value() -> Int {\n            lock.lock()\n            defer { lock.unlock() }\n            return counter\n        }\n    }\n    ```\n    *   `NSRecursiveLock` allows the same thread to acquire the lock multiple times (recursion).\n    *   `defer` ensures the lock is always released, even if errors occur.\n\n2.  **Serial Dispatch Queues:** GCD serial queues execute tasks one at a time, eliminating concurrent access.\n    ```swift\n    let serialQueue = DispatchQueue(label: \"com.example.serial\", qos: .default)\n    var sharedResource = 0\n\n    serialQueue.async {\n        // Access and modify sharedResource safely\n        sharedResource += 1\n    }\n\n    serialQueue.async {\n        // Access and modify sharedResource safely\n        sharedResource *= 2\n    }\n    ```\n\n3.  **Dispatch Barriers:** Used with concurrent queues to create exclusive write access.  Multiple readers can access concurrently, but a writer gets exclusive access.\n    ```swift\n    let concurrentQueue = DispatchQueue(label: \"com.example.concurrent\", attributes: .concurrent)\n    var data = [Int]()\n\n    func readData() {\n        concurrentQueue.async {\n            // Read data safely\n            print(data)\n        }\n    }\n\n    func writeData(newValue: Int) {\n        concurrentQueue.async(flags: .barrier) {\n            // Write data exclusively\n            data.append(newValue)\n        }\n    }\n    ```\n\n4.  **Atomic Operations:**  Provide low-level primitives for thread-safe operations on single variables (e.g., using `OSAtomic` functions or `Atomic` property wrappers in newer Swift versions).\n\n5.  **Actors (Swift 5.5+):**  Provide a higher-level concurrency model that isolates state and ensures that only one task can access the actor's state at a time.\n    ```swift\n    actor Counter {\n        private var count = 0\n\n        func increment() {\n            count += 1\n        }\n\n        func getCount() -> Int {\n            return count\n        }\n    }\n\n    let counter = Counter()\n\n    Task {\n        await counter.increment()\n        print(await counter.getCount())\n    }\n    ```\n\n**Common Pitfalls:**\n\n*   **Deadlocks:** Occur when threads are blocked indefinitely, waiting for each other to release locks.  Avoid circular dependencies in lock acquisition.\n*   **Priority Inversion:** A low-priority thread holds a lock needed by a high-priority thread.  Use priority inheritance or adjust thread priorities.\n*   **Over-locking:**  Holding locks for too long reduces concurrency. Minimize the critical section.\n*   **Forgetting to unlock:** Always ensure locks are released, even in error conditions (using `defer`).\n*   **Incorrect Queue Usage:** Using the wrong type of queue (e.g., concurrent instead of serial) can lead to data races.\n\n**Alternatives:**\n\n*   **Immutable Data Structures:**  If data is immutable, no synchronization is needed.\n*   **Message Passing:** Threads communicate by sending messages, avoiding direct shared memory access.\n\n**When to Use:**\n\n*   Locks: When you need fine-grained control over synchronization and have complex data structures.\n*   Serial Queues:  When you need to ensure sequential execution of tasks that access shared resources.\n*   Dispatch Barriers: When you have a mix of read and write operations and want to allow concurrent reads but exclusive writes.\n*   Actors:  When you want a higher-level, safer concurrency model with isolated state.  Generally preferred for new code in Swift 5.5+.\n\nChoosing the right strategy depends on the specific requirements of your application and the complexity of the data being shared.",
      "code_example": null,
      "tags": [
        "concurrency",
        "data race",
        "mutex",
        "gcd",
        "dispatch barrier",
        "actor",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Data races: unsynchronized concurrent access to shared memory. Prevent with locks, serial queues, dispatch barriers, and atomics."
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Structured Concurrency in Swift improve upon older models like GCD and OperationQueue, particularly regarding task lifetime, cancellation, and error handling?",
      "back": "Structured Concurrency fundamentally changes how we reason about concurrent code by introducing a clear, hierarchical relationship between tasks. Unlike GCD or OperationQueue, where tasks are often 'fire-and-forget' and exist independently, structured concurrency creates a 'task tree'.\n\n**Core Concept:**\nA parent task's scope completely contains the lifetime of any child tasks it creates (using `async let` or `TaskGroup`). This provides three key guarantees:\n1.  **Scoped Lifetime:** The parent task cannot finish until all its child tasks have completed. This eliminates a common source of bugs where a function returns while its dispatched work is still running, potentially leading to race conditions or resource leaks.\n2.  **Automatic Cancellation:** If a parent task is cancelled, Swift automatically propagates the cancellation signal down to all its child tasks. This is a massive improvement over the manual, error-prone process of checking an `isCancelled` flag in `NSOperation` or managing custom cancellation tokens with GCD.\n3.  **Error Propagation:** If a child task throws an error, it is immediately propagated up to the parent task's scope, where it can be caught and handled. This prevents errors from being silently lost, which can happen with detached GCD blocks.\n\n**Practical Code Example:**\n```swift\nstruct UserProfile {\n    let info: UserInfo\n    let posts: [Post]\n}\n\nfunc fetchUserProfile(for userID: String) async throws -> UserProfile {\n    // A TaskGroup creates a scope for dynamic child tasks.\n    return try await withThrowingTaskGroup(of: UserProfileComponent.self) { group in\n        // Child task to fetch user info\n        group.addTask {\n            let info = try await api.fetchUserInfo(userID)\n            return .info(info)\n        }\n        \n        // Child task to fetch posts\n        group.addTask {\n            let posts = try await api.fetchPosts(userID)\n            return .posts(posts)\n        }\n        \n        // The group's scope will not exit until both tasks complete.\n        var userInfo: UserInfo?\n        var posts: [Post]?\n        \n        // Await results as they complete.\n        for try await component in group {\n            switch component {\n            case .info(let info): userInfo = info\n            case .posts(let p): posts = p\n            }\n        }\n\n        // If a task throws, the error propagates here, the group is cancelled,\n        // and remaining results are discarded.\n        guard let userInfo, let posts else {\n            throw APIError.incompleteData\n        }\n        \n        return UserProfile(info: userInfo, posts: posts)\n    }\n}\nenum UserProfileComponent { case info(UserInfo), posts([Post]) } // Helper enum\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` inside an async function creates a new, detached task tree, breaking the parent-child relationship. This task can outlive the function scope, losing the guarantees of structured concurrency. Use `Task.init` only for bridging to non-async contexts or for tasks that must outlive the current scope.\n- **Misunderstanding Cancellation:** Cancellation is cooperative, not preemptive. A long-running child task must periodically check `Task.isCancelled` and throw a `CancellationError` to halt its execution promptly.\n\n**When to Use vs. Alternatives:**\n- **Structured Concurrency (`async let`, `TaskGroup`):** The default choice for all new concurrent Swift code. It's safer, more readable, and less error-prone. Use it whenever a task's work is relevant only within the scope that creates it.\n- **Unstructured Concurrency (`Task.init`):** Use when a task must outlive its originating scope, such as a fire-and-forget analytics event or a background task tied to the application's lifecycle.\n- **GCD/OperationQueue:** Primarily for maintaining legacy code, interacting with older frameworks that require it, or for specific features like `maxConcurrentOperationCount`. For new features, prefer Swift's native concurrency.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured concurrency",
        "async/await",
        "taskgroup"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain how Swift's `actor` model provides thread safety, contrasting it with traditional lock-based concurrency. What are the key rules of 'actor isolation' and how does the compiler enforce them?",
      "back": "Swift's `actor` model provides thread safety by creating a 'concurrency domain' around its mutable state. Unlike traditional mechanisms like `NSLock` or `DispatchQueue.sync`, which require manual and careful management to prevent issues like deadlocks and priority inversion, actors automate this protection at the language level.\n\n**Core Concept:**\nAn actor is a reference type that ensures only one task can access its mutable state at a time. It achieves this by serializing all incoming requests to its properties and methods in a conceptual 'mailbox'. The actor processes these messages one by one, preventing data races by design. The compiler enforces this safety through a set of rules called **Actor Isolation**:\n1.  **Internal Access:** Code within an actor's methods can access its own properties and methods synchronously (`self.balance`).\n2.  **External Access:** Any code outside the actor must access its mutable state or non-`nonisolated` methods asynchronously using `await`. This `await` is a suspension point, indicating that the calling task is yielding to the actor's executor to run the code when it's safe.\n3.  **Sendable Types:** Data passed into or out of an actor's isolated context must conform to the `Sendable` protocol, ensuring the data itself is thread-safe.\n\n**Code Example:**\n```swift\nactor ScoreCounter {\n    private var score = 0\n\n    // Internal access is synchronous and safe.\n    func increment() {\n        score += 1\n    }\n\n    // This function can be called from outside the actor.\n    func getScore() -> Int {\n        return score\n    }\n}\n\nfunc updateScores(counter: ScoreCounter) async {\n    // ERROR: Actor-isolated 'increment' can only be called on 'self'\n    // counter.increment() // This would be a sync call, which is forbidden.\n\n    // CORRECT: Use 'await' to cross the isolation boundary asynchronously.\n    await counter.increment()\n    let currentScore = await counter.getScore()\n    print(\"Current score: \\(currentScore)\")\n}\n```\n\n**Common Pitfalls:**\n- **Re-entrancy:** The most subtle issue. When an actor `await`s another async function, it can process other messages from its mailbox before the original function resumes. This means the actor's state can change across an `await`. You must not assume state is unchanged after a suspension point.\n- **Deadlocks:** While actors reduce many deadlock scenarios, you can still create them. For example, Actor A `await`s a result from Actor B, while Actor B simultaneously `await`s a result from Actor A.\n\n**When to Use vs. Alternatives:**\n- **Use Actors:** For encapsulating and managing mutable state that needs to be accessed from multiple concurrent contexts (e.g., a data cache, a state manager, a repository).\n- **Alternatives:**\n  - **Locks/Queues:** Use for fine-grained control or legacy code. More error-prone and complex.\n  - **`@MainActor`:** A global actor specifically for ensuring code runs on the main thread for UI updates.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "thread-safety",
        "data-races"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "A class needs to safely manage a mutable property accessed from multiple threads. Compare and contrast using `NSLock`, a serial `DispatchQueue`, and an `actor` to prevent data races. Discuss the trade-offs of each approach.",
      "back": "A data race occurs when multiple threads access a shared resource without synchronization, and at least one access is a write. This leads to unpredictable behavior. `NSLock`, serial `DispatchQueue`, and `actor` are three mechanisms to ensure mutual exclusion and prevent this.\n\n**1. NSLock**\nA low-level, traditional locking mechanism. It provides exclusive access to a critical section by requiring a thread to acquire the lock before entering and release it upon exit. It's synchronous and blocking.\n- **Pros:** High performance with low overhead for uncontended locks. Fine-grained control.\n- **Cons:** Manual lock management is error-prone (forgetting to `unlock`). Prone to deadlocks if not handled carefully.\n\n**2. Serial DispatchQueue**\nA Grand Central Dispatch (GCD) queue that executes tasks one at a time in FIFO order. By dispatching all read/write operations to this queue, you guarantee serialized access.\n- **Pros:** Simple, declarative API. Less prone to simple deadlocks than manual locks.\n- **Cons:** Higher overhead than `NSLock`. Using `sync` can lead to deadlocks if called from the same queue. \n\n**3. Actor**\nA Swift concurrency feature that protects its state from concurrent access. The compiler enforces that access to an actor's mutable state from the outside must be done asynchronously (`await`), ensuring serialized access.\n- **Pros:** **Compile-time safety**. The compiler prevents data races by construction. Part of modern structured concurrency.\n- **Cons:** Requires an `async` context to interact with. An `await` inside an actor method can suspend it, re-entrantly allowing other calls to run, which requires careful state management across suspension points.\n\n```swift\n// Shared mutable resource example\nclass ThreadSafeCounter {\n    private let lock = NSLock()\n    private var _count = 0\n    func increment() { // Using NSLock\n        lock.lock()\n        defer { lock.unlock() } // Guarantees unlock even if errors occur\n        _count += 1\n    }\n}\n\nclass QueueSafeCounter {\n    private let queue = DispatchQueue(label: \"com.example.counter.queue\")\n    private var _count = 0\n    func increment() { // Using serial DispatchQueue\n        queue.sync { // sync ensures the operation completes before returning\n            self._count += 1\n        }\n    }\n}\n\nactor ActorSafeCounter {\n    private var count = 0\n    func increment() { // Actor automatically isolates its state\n        count += 1\n    }\n    func getCount() -> Int {\n        return count\n    }\n}\n```\n\n**When to Use:**\n- **NSLock:** Use for performance-critical, synchronous code sections or when interacting with older Objective-C APIs. Be disciplined with `defer`.\n- **DispatchQueue:** A great general-purpose solution. The readers-writer pattern (concurrent queue + barriers) is a common, powerful optimization.\n- **Actor:** The preferred, modern Swift approach. Use for any new code modeling isolated, mutable state. It provides the highest level of safety.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "gcd",
        "threading",
        "data_race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain the purpose of global actors in Swift, using `@MainActor` as a primary example. When would you create a custom global actor instead of using a standard actor instance to manage shared mutable state?",
      "back": "A global actor is a mechanism in Swift Concurrency that provides a globally unique, serial execution context to protect shared mutable state from data races. Any function, type, or property marked with a global actor's attribute (e.g., `@MainActor`) is said to be 'isolated' to that actor, meaning the compiler ensures it can only be accessed from that actor's context.\n\n**Core Concept:**\nThe most prominent example is `@MainActor`, which represents the main thread. It guarantees that any code marked with it (like UI updates in SwiftUI or UIKit) runs on the main thread, enforced at compile time. This prevents common UI-related race conditions and crashes. When you call a `@MainActor`-isolated function from a different context, you must use `await`, which allows the system to suspend the current task and resume it later on the main thread's executor.\n\nCustom global actors extend this concept to any domain. You define one by creating a type marked with `@globalActor` that provides a shared actor instance.\n\n**Practical Code Example:**\n```swift\n// 1. Define a custom global actor for a shared resource, like a logger.\n@globalActor\nstruct AnalyticsActor {\n    static let shared = ActorType()\n    typealias ActorType = Actor\n}\n\n// 2. Isolate a class to this global actor.\n// All methods and properties will be protected by AnalyticsActor.\n@AnalyticsActor\nclass AnalyticsManager {\n    private var sessionEvents: [String] = []\n\n    func logEvent(_ event: String) {\n        print(\"Logging event: \\(event)\")\n        sessionEvents.append(event)\n    }\n}\n\n// 3. In UI code, access requires an 'await' to hop to the actor's executor.\nclass ContentViewModel: ObservableObject {\n    @MainActor @Published var status = \"Ready\"\n\n    func onButtonTapped() async {\n        // Hop from MainActor to AnalyticsActor\n        await AnalyticsManager().logEvent(\"Button Tapped\")\n        \n        // Hop back to MainActor to update UI\n        await MainActor.run { \n            self.status = \"Event Logged\"\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Overuse:** Creating global actors for state that isn't truly global. This leads to unnecessary contention and tight coupling. Most state is better managed by a standard actor instance passed via dependency injection.\n- **Blocking:** Performing long-running synchronous work on a global actor can starve other tasks waiting for it. On `@MainActor`, this freezes the UI.\n- **`nonisolated` Misuse:** Using `nonisolated` to bypass actor protection on mutable state can re-introduce data races. It should primarily be used for immutable state (`let` constants) or internally thread-safe operations.\n\n**When to Use vs. Alternatives:**\n- **Custom Global Actor:** Use for state that is fundamentally singular and global in your application, like a centralized logging service, a file coordinator for a shared directory, or a database connection pool. It's essentially a compile-time safe singleton.\n- **Standard Actor Instance:** This should be your default choice. Use it to protect the internal state of a class/struct instance. It promotes better encapsulation, testability (you can mock it or create multiple instances), and follows dependency injection principles. It's ideal for a network client, a feature-specific repository, or any stateful object that isn't a global singleton.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-structured-concurrency",
        "actors",
        "global-actor",
        "mainactor"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol helps prevent data races in Swift Concurrency. Describe the conditions for implicit conformance and the safety considerations required when explicitly marking a class `@unchecked Sendable`.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's modern concurrency model, designed to statically verify that types can be safely shared across different threads or actors without introducing data races.\n\n**Core Concept Explanation:**\n`Sendable` acts as a contract with the compiler. It doesn't add any methods or properties; it simply marks a type, promising that its values can be safely copied and passed between concurrency domains (e.g., from your main actor to a background task). The compiler enforces this contract, issuing an error if you try to share a non-`Sendable` type across such boundaries. This shifts thread-safety from a runtime problem (crashes, unpredictable behavior) to a compile-time guarantee.\n\nA type implicitly conforms to `Sendable` if it meets these criteria:\n1. It's a value type (struct or enum).\n2. All its stored properties are also `Sendable`.\n3. For enums, all associated values must be `Sendable`.\n4. It's a final class with only immutable (`let`) stored properties of `Sendable` types.\n\n**Practical Code Example:**\n```swift\n// 1. Implicitly Sendable struct\nstruct UserProfile: Sendable {\n    let id: UUID // UUID is Sendable\n    let username: String // String is Sendable\n}\n\n// 2. A class that is NOT Sendable due to mutable state\nclass UnsafeCounter {\n    var value = 0 // Mutable property makes it non-Sendable\n    func increment() { value += 1 }\n}\n\n// 3. A final class marked @unchecked Sendable with internal synchronization\nfinal class SafeCounter: @unchecked Sendable { // We promise the compiler it's safe\n    private var value = 0\n    private let lock = NSLock()\n\n    func increment() {\n        lock.lock()\n        defer { lock.unlock() }\n        value += 1\n    }\n    \n    func getValue() -> Int {\n        lock.lock()\n        defer { lock.unlock() }\n        return value\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Misusing `@unchecked Sendable`:** The most dangerous pitfall is marking a class `@unchecked Sendable` without implementing proper internal synchronization (e.g., using locks, a serial queue). This silences the compiler but reintroduces the risk of data races.\n- **Function Types:** Closures and functions passed across actor boundaries must be `@Sendable`. This means they cannot capture mutable, non-`Sendable` state from their enclosing scope.\n- **Generics:** Generic types must be constrained to `Sendable` (`<T: Sendable>`) if they are to be used in a context that requires `Sendable` conformance.\n\n**When to Use vs. Alternatives:**\n- **Prefer Value Types:** The easiest path to safety is using `struct`s and `enum`s, which are often implicitly `Sendable`.\n- **Use Actors:** If you need shared mutable state, an `actor` is the preferred solution. It encapsulates its state and ensures all access is synchronized, making it inherently safe to interact with from any concurrency domain.\n- **Use `@unchecked Sendable` on Classes:** Reserve this for legacy Objective-C classes or custom classes where you need fine-grained control over locking and performance, and you can manually verify and guarantee thread safety.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "sendable",
        "thread-safety",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}