{
  "topic": "concurrency",
  "title": "Swift Concurrency",
  "description": "async/await, actors, tasks, and modern concurrency",
  "cards": [
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "Explain Swift's Structured Concurrency. How does it improve upon older concurrency models like GCD, and what are its core components (async/await, Tasks, Actors)?",
      "back": "Structured concurrency ensures predictable execution and simplifies error handling by creating explicit parent-child relationships between concurrent tasks. It improves upon GCD by enforcing compile-time checks for proper task management, preventing issues like orphaned tasks and unhandled errors.\n\n**Core Components:**\n\n*   **async/await:**  `async` marks a function as potentially suspending, while `await` pauses execution until the async function returns. This makes asynchronous code look and behave like synchronous code.\n\n```swift\nfunc fetchData(from url: URL) async throws -> Data {\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\n*   **Tasks:** Represent a unit of asynchronous work.  Tasks can be created using `Task {}` or by detaching a closure with `Task.detached {}`. Detached tasks are not part of the current structured concurrency scope and require manual management.\n\n```swift\nfunc processData() async {\n    async let data1 = fetchData(from: URL(string: \"...\")!)\n    async let data2 = fetchData(from: URL(string: \"...\")!)\n\n    do {\n        let result1 = try await data1\n        let result2 = try await data2\n        // Process results\n    } catch {\n        // Handle errors\n    }\n}\n```\n\n*   **Actors:** Protect mutable state from concurrent access. Only one task can access an actor's state at a time, preventing data races. Accessing an actor's properties or methods requires using `await`.\n\n```swift\nactor Counter {\n    private var count = 0\n\n    func increment() async {\n        count += 1\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n\nlet counter = Counter()\n\nTask {\n    await counter.increment()\n    print(counter.getCount())\n}\n```\n\n**Common Pitfalls:**\n\n*   **Ignoring Errors:**  Failing to handle errors thrown by `async` functions can lead to unexpected behavior.\n*   **Deadlocks:**  Occur when two or more tasks are blocked indefinitely, waiting for each other. Avoid circular dependencies between actors and tasks.\n*   **Over-using detached tasks:** Detached tasks lose the benefits of structured concurrency, making error handling and cancellation more difficult. Use them sparingly and only when truly necessary.\n\n**When to Use vs. Alternatives:**\n\n*   **Structured Concurrency (async/await, Tasks, Actors):**  Preferred for new projects or when refactoring existing code. Offers better readability, error handling, and data race prevention compared to GCD and Operation Queues.\n*   **GCD:**  Useful for simple background tasks and dispatching work to specific queues. Can be more efficient for very low-level operations where performance is critical.\n*   **Operation Queues:**  Suitable for managing complex dependencies between tasks and controlling concurrency levels.  Offers more control over task execution order and cancellation than GCD, but less safety than structured concurrency.\n\nStructured concurrency provides a safer and more maintainable way to write concurrent code in Swift, reducing the risk of common concurrency issues and improving overall application stability.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "async/await",
        "tasks",
        "actors",
        "GCD"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Swift's structured concurrency improves upon GCD with compile-time safety via async/await, Tasks, and Actors for safer concurrency."
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain Actors in Swift's concurrency model. What problem do they solve, and how does actor isolation work? Provide an example and discuss potential pitfalls.",
      "back": "Actors address data races in concurrent environments by providing a safe way to encapsulate state and ensure exclusive access. An actor is a reference type that protects its mutable state, allowing only one thread to access its properties or methods at a time.\n\n**Core Concept:**\nActors enforce *actor isolation*.  This means that any access to an actor's state must go through its methods, and these methods are executed serially, preventing data races.  The compiler enforces this isolation at compile time.\n\n**Code Example:**\n```swift\nactor Counter {\n    private var count = 0\n\n    func increment() async {\n        count += 1\n        print(\"Count is now: \\(count)\")\n    }\n\n    nonisolated func currentCount() -> Int {\n        return count\n    }\n}\n\nfunc testCounter() async {\n    let counter = Counter()\n    \n    await withTaskGroup(of: Void.self) { group in\n        for _ in 0..<100 {\n            group.addTask {\n                await counter.increment()\n            }\n        }\n    }\n\n    print(\"Final count: \\(counter.currentCount())\")\n}\n```\nIn this example, `Counter` is an actor. The `increment()` method is automatically isolated to the actor instance. Multiple tasks can call `increment()` concurrently, but the actor ensures that they are executed one at a time, preventing race conditions on `count`. The `currentCount()` method is marked `nonisolated` because it only returns the value of count, without modifying it, and it can be accessed without requiring an `await`.  This is useful for read-only access.\n\n**Common Pitfalls:**\n*   **Deadlocks:**  If two actors are waiting for each other, a deadlock can occur.  This often happens when one actor calls an `async` method on another actor while holding a lock or waiting for something else.  Careful design is needed to avoid circular dependencies.\n*   **Reentrancy:** While an actor is processing an `async` function, it *can* be re-entered via another `async` call.  If the state changes during the first `async` call, the second call might see unexpected results.  Always ensure that your actor's methods are reentrant-safe.\n*   **Forgetting `await`:**  When calling an `async` method on an actor from outside the actor, you *must* use `await`.  Forgetting `await` will cause a compiler error.\n*   **Performance:** Because actor methods are executed serially, excessive contention can lead to performance bottlenecks. Consider using finer-grained actors or other concurrency mechanisms if needed.\n\n**When to Use vs. Alternatives:**\n*   **Use Actors:** When you have mutable state that needs to be accessed concurrently and you want to avoid data races. Actors are excellent for encapsulating data and ensuring thread safety.\n*   **Alternatives:**\n    *   **DispatchQueues with Barriers:**  Can be used for managing concurrent access to shared resources, but require manual locking and are more prone to errors.  Actors provide a higher-level, safer abstraction.\n    *   **NSLock/NSRecursiveLock:** Low-level locking mechanisms that require careful management to avoid deadlocks.  Actors provide a more structured approach to concurrency.\n    *   **Atomic Properties (Objective-C):** Atomic properties provide basic thread safety, but can be less performant than actors and don't prevent all types of race conditions.\n    *   **Immutable Data Structures:** If possible, using immutable data structures eliminates the need for locking altogether.\n\nActors are a powerful tool for writing safe and efficient concurrent code in Swift. By understanding their core principles and potential pitfalls, you can leverage them to build robust and scalable applications.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "actor isolation",
        "swift",
        "async/await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Actors prevent data races by isolating mutable state. Only one thread accesses an actor's state at a time via its methods."
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Sendable protocol",
      "back": "",
      "code_example": null,
      "tags": [
        "Sendable protocol"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "How do Task Groups in Swift concurrency help manage child tasks and propagate results, and what are their advantages over dispatch groups?",
      "back": "Task Groups enable structured concurrency, allowing you to create dynamic child tasks within a parent task. They provide a scope where child tasks execute concurrently, and the parent task waits for all children to complete before continuing. Results can be collected and aggregated. Task Groups offer better error handling and cancellation compared to dispatch groups.\n\n```swift\nfunc processData() async throws -> [Int] {\n    await withTaskGroup(of: Int.self, returning: [Int].self) { group in\n        for i in 1...5 {\n            group.addTask {\n                // Simulate some work\n                try? await Task.sleep(nanoseconds: UInt64(i * 100_000_000))\n                if i == 3 { throw MyError.simulatedError }\n                return i * 2\n            }\n        }\n\n        var results: [Int] = []\n        for await result in group {\n            results.append(result)\n        }\n\n        return results\n    }\n}\n\nenum MyError: Error {\n    case simulatedError\n}\n\n//Usage\nTask {\n    do {\n        let processedData = try await processData()\n        print(\"Processed data: \\(processedData)\")\n    } catch {\n        print(\"Error processing data: \\(error)\")\n    }\n}\n```\n\n**Core Concept:** Task Groups provide a structured way to manage concurrent child tasks.  `withTaskGroup` creates the group, `addTask` adds work, and the `await` on the group waits for completion.\n\n**Advantages over Dispatch Groups:**\n*   **Structured Concurrency:** Task Groups enforce a clear parent-child relationship, improving code clarity and error handling.\n*   **Cancellation Propagation:**  Cancelling the parent task automatically cancels child tasks.\n*   **Error Propagation:** Errors thrown by child tasks are automatically propagated to the parent task, simplifying error handling. DispatchGroups require manual error tracking.\n*   **Type Safety:** Task Groups are type-safe, ensuring that the results returned by child tasks are of the expected type.\n\n**Common Pitfalls:**\n*   Not awaiting all child tasks: If you don't iterate over the TaskGroup, the parent task might complete before all children are done.\n*   Ignoring errors:  Make sure to handle errors propagated from child tasks using `try await` or `try? await` when adding tasks, and then handling the error in the `do/catch` block.\n*   Accidental synchronous work: Ensure work within `addTask` is truly asynchronous to avoid blocking the Task Group.\n\n**When to Use:**\nUse Task Groups when you need to perform multiple independent asynchronous operations concurrently and aggregate their results.  Use Dispatch Groups for lower-level concurrency management when finer-grained control is needed and structured concurrency isn't a priority.",
      "code_example": null,
      "tags": [
        "concurrency",
        "taskgroup",
        "swift",
        "async",
        "structured concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Task Groups enable structured concurrency, managing child tasks and propagating results/errors. They offer better error handling than dispatch groups."
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Explain `AsyncSequence` and `AsyncStream` in Swift. How do they facilitate asynchronous data processing, and what are their key differences and use cases?",
      "back": "`AsyncSequence` and `AsyncStream` are Swift's answer to dealing with asynchronous data streams. Think of `AsyncSequence` as the asynchronous counterpart to `Sequence`. It represents a series of values produced over time, asynchronously. You can iterate over it using `for await in`. `AsyncStream`, on the other hand, is a type that lets you create an `AsyncSequence` by manually yielding values to it.\n\nKey Differences:\n*   `AsyncSequence`: A protocol defining the structure of an asynchronous sequence.  You *consume* data from an `AsyncSequence`.\n*   `AsyncStream`: A concrete type that *produces* an asynchronous sequence. It acts as a bridge between synchronous and asynchronous code.\n\nUse Cases:\n*   `AsyncSequence`: Ideal for representing data feeds like network streams, file reads, or sensor data.\n*   `AsyncStream`: Useful when you need to adapt existing synchronous APIs to the async/await world or when you have complex logic for producing asynchronous values.\n\nExample:\n\n```swift\n// Using AsyncStream to create an asynchronous sequence of numbers\nlet stream = AsyncStream<Int> { continuation in\n    Task {\n        for i in 1...5 {\n            continuation.yield(i)\n            try? await Task.sleep(nanoseconds: 1_000_000_000) // Simulate delay\n        }\n        continuation.finish()\n    }\n}\n\n// Consuming the AsyncStream using AsyncSequence\nTask {\n    for await number in stream {\n        print(\"Received: \\(number)\")\n    }\n    print(\"Stream finished\")\n}\n```\n\nCommon Pitfalls:\n*   Forgetting to call `continuation.finish()` in `AsyncStream` can lead to infinite loops.\n*   Not handling errors properly within the `AsyncStream`'s closure can cause unexpected behavior.\n*   Over-yielding values in `AsyncStream` without proper backpressure handling can lead to memory issues.\n\nAlternatives:\n*   Combine framework: Offers more powerful operators for transforming and combining asynchronous data streams, but has a steeper learning curve.\n*   GCD: Lower-level API for managing concurrency, suitable for simple asynchronous tasks but requires more manual management.\n\nWhen to Use:\n*   Use `AsyncSequence` and `AsyncStream` when you have a clear need for asynchronous data streams and want to leverage the simplicity and readability of async/await.\n*   Choose Combine for complex data transformations and reactive programming.\n*   Consider GCD for simple, low-level asynchronous operations.",
      "code_example": null,
      "tags": [
        "concurrency",
        "async/await",
        "AsyncSequence",
        "AsyncStream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ],
      "summary": "`AsyncSequence` is a protocol to consume async data streams; `AsyncStream` creates them by yielding values, bridging sync/async code."
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain MainActor and global actors. How do they ensure thread safety and what are their use cases? Provide a code example.",
      "back": "MainActor and global actors in Swift concurrency manage shared mutable state safely across threads.\n\nMainActor:  Ensures code executes on the main thread, vital for UI updates and avoiding UI freezes.  It's a global actor implicitly used for UI-related tasks. All UI updates MUST happen on the MainActor.\n\nGlobal Actors:  Enable you to define custom execution contexts (similar to dispatch queues) to isolate specific resources or data. Accessing data guarded by an actor is always serialized, preventing race conditions.  You can create multiple instances of global actors.\n\nThread Safety: Actors achieve thread safety by serializing access to their internal state.  Only one task can access an actor's mutable state at a time. This prevents data races and ensures consistency.\n\nUse Cases:\n* MainActor: All UI updates, interacting with UIKit/AppKit.\n* Global Actors: Managing access to shared resources (e.g., a database connection pool, a file system).  Performing long-running tasks on background threads while ensuring data consistency.\n\nExample:\n```swift\nimport Foundation\n\nactor Counter {\n    private var count = 0\n\n    func increment() async -> Int {\n        count += 1\n        return count\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n\n@MainActor\nclass MyViewController {\n    let counter = Counter()\n\n    func updateUI() async {\n        let newCount = await counter.increment()\n        // Safely update UI on the main thread\n        print(\"Count: \\(newCount)\")\n    }\n}\n\n// Usage\nlet viewController = MyViewController()\nTask {\n    await viewController.updateUI()\n}\n```\n\nCommon Pitfalls:\n* Deadlocks:  Occur when two or more tasks are blocked indefinitely, waiting for each other.  Avoid circular dependencies between actors.\n* Actor reentrancy: An actor can re-enter itself if it suspends during a call and another task calls it before the first task resumes. Be mindful of state changes during suspension points.\n* Forgetting `await`: If you forget `await` when calling an `async` function on an actor, the compiler will likely warn you, but the code will execute synchronously, potentially blocking the current thread.\n\nAlternatives:\n* GCD:  Lower-level, requires manual thread management and synchronization (e.g., locks).  More error-prone than actors.\n* OperationQueues: Higher-level than GCD, but still requires manual synchronization for shared mutable state.\n\nActors are generally preferred for managing shared mutable state due to their built-in thread safety and ease of use.  GCD and OperationQueues are useful for general concurrency tasks where shared mutable state is not a primary concern.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "MainActor",
        "global actors",
        "thread safety",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Actors ensure thread safety by serializing access to mutable state, preventing data races. MainActor for UI, global actors for other shared resources."
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Explain data races in concurrent programming and describe strategies to prevent them in Swift.  Include common pitfalls and alternative solutions.",
      "back": "Data races occur when multiple threads access and modify the same memory location concurrently, without proper synchronization, leading to unpredictable behavior.  To prevent them, we ensure exclusive access to shared resources.\n\n**Strategies:**\n\n1.  **Locks (Mutexes):** Provide mutual exclusion. Only one thread can hold the lock at a time.\n    ```swift\n    import Foundation\n\n    class SafeCounter {\n        private var counter = 0\n        private let lock = NSRecursiveLock()\n\n        func increment() {\n            lock.lock()\n            defer { lock.unlock() }\n            counter += 1\n        }\n\n        func value() -> Int {\n            lock.lock()\n            defer { lock.unlock() }\n            return counter\n        }\n    }\n    ```\n    *   `NSRecursiveLock` allows the same thread to acquire the lock multiple times (recursion).\n    *   `defer` ensures the lock is always released, even if errors occur.\n\n2.  **Serial Dispatch Queues:** GCD serial queues execute tasks one at a time, eliminating concurrent access.\n    ```swift\n    let serialQueue = DispatchQueue(label: \"com.example.serial\", qos: .default)\n    var sharedResource = 0\n\n    serialQueue.async {\n        // Access and modify sharedResource safely\n        sharedResource += 1\n    }\n\n    serialQueue.async {\n        // Access and modify sharedResource safely\n        sharedResource *= 2\n    }\n    ```\n\n3.  **Dispatch Barriers:** Used with concurrent queues to create exclusive write access.  Multiple readers can access concurrently, but a writer gets exclusive access.\n    ```swift\n    let concurrentQueue = DispatchQueue(label: \"com.example.concurrent\", attributes: .concurrent)\n    var data = [Int]()\n\n    func readData() {\n        concurrentQueue.async {\n            // Read data safely\n            print(data)\n        }\n    }\n\n    func writeData(newValue: Int) {\n        concurrentQueue.async(flags: .barrier) {\n            // Write data exclusively\n            data.append(newValue)\n        }\n    }\n    ```\n\n4.  **Atomic Operations:**  Provide low-level primitives for thread-safe operations on single variables (e.g., using `OSAtomic` functions or `Atomic` property wrappers in newer Swift versions).\n\n5.  **Actors (Swift 5.5+):**  Provide a higher-level concurrency model that isolates state and ensures that only one task can access the actor's state at a time.\n    ```swift\n    actor Counter {\n        private var count = 0\n\n        func increment() {\n            count += 1\n        }\n\n        func getCount() -> Int {\n            return count\n        }\n    }\n\n    let counter = Counter()\n\n    Task {\n        await counter.increment()\n        print(await counter.getCount())\n    }\n    ```\n\n**Common Pitfalls:**\n\n*   **Deadlocks:** Occur when threads are blocked indefinitely, waiting for each other to release locks.  Avoid circular dependencies in lock acquisition.\n*   **Priority Inversion:** A low-priority thread holds a lock needed by a high-priority thread.  Use priority inheritance or adjust thread priorities.\n*   **Over-locking:**  Holding locks for too long reduces concurrency. Minimize the critical section.\n*   **Forgetting to unlock:** Always ensure locks are released, even in error conditions (using `defer`).\n*   **Incorrect Queue Usage:** Using the wrong type of queue (e.g., concurrent instead of serial) can lead to data races.\n\n**Alternatives:**\n\n*   **Immutable Data Structures:**  If data is immutable, no synchronization is needed.\n*   **Message Passing:** Threads communicate by sending messages, avoiding direct shared memory access.\n\n**When to Use:**\n\n*   Locks: When you need fine-grained control over synchronization and have complex data structures.\n*   Serial Queues:  When you need to ensure sequential execution of tasks that access shared resources.\n*   Dispatch Barriers: When you have a mix of read and write operations and want to allow concurrent reads but exclusive writes.\n*   Actors:  When you want a higher-level, safer concurrency model with isolated state.  Generally preferred for new code in Swift 5.5+.\n\nChoosing the right strategy depends on the specific requirements of your application and the complexity of the data being shared.",
      "code_example": null,
      "tags": [
        "concurrency",
        "data race",
        "mutex",
        "gcd",
        "dispatch barrier",
        "actor",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Data races: unsynchronized concurrent access to shared memory. Prevent with locks, serial queues, dispatch barriers, and atomics."
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Structured Concurrency in Swift improve upon older models like GCD and OperationQueue, particularly regarding task lifetime, cancellation, and error handling?",
      "back": "Structured Concurrency fundamentally changes how we reason about concurrent code by introducing a clear, hierarchical relationship between tasks. Unlike GCD or OperationQueue, where tasks are often 'fire-and-forget' and exist independently, structured concurrency creates a 'task tree'.\n\n**Core Concept:**\nA parent task's scope completely contains the lifetime of any child tasks it creates (using `async let` or `TaskGroup`). This provides three key guarantees:\n1.  **Scoped Lifetime:** The parent task cannot finish until all its child tasks have completed. This eliminates a common source of bugs where a function returns while its dispatched work is still running, potentially leading to race conditions or resource leaks.\n2.  **Automatic Cancellation:** If a parent task is cancelled, Swift automatically propagates the cancellation signal down to all its child tasks. This is a massive improvement over the manual, error-prone process of checking an `isCancelled` flag in `NSOperation` or managing custom cancellation tokens with GCD.\n3.  **Error Propagation:** If a child task throws an error, it is immediately propagated up to the parent task's scope, where it can be caught and handled. This prevents errors from being silently lost, which can happen with detached GCD blocks.\n\n**Practical Code Example:**\n```swift\nstruct UserProfile {\n    let info: UserInfo\n    let posts: [Post]\n}\n\nfunc fetchUserProfile(for userID: String) async throws -> UserProfile {\n    // A TaskGroup creates a scope for dynamic child tasks.\n    return try await withThrowingTaskGroup(of: UserProfileComponent.self) { group in\n        // Child task to fetch user info\n        group.addTask {\n            let info = try await api.fetchUserInfo(userID)\n            return .info(info)\n        }\n        \n        // Child task to fetch posts\n        group.addTask {\n            let posts = try await api.fetchPosts(userID)\n            return .posts(posts)\n        }\n        \n        // The group's scope will not exit until both tasks complete.\n        var userInfo: UserInfo?\n        var posts: [Post]?\n        \n        // Await results as they complete.\n        for try await component in group {\n            switch component {\n            case .info(let info): userInfo = info\n            case .posts(let p): posts = p\n            }\n        }\n\n        // If a task throws, the error propagates here, the group is cancelled,\n        // and remaining results are discarded.\n        guard let userInfo, let posts else {\n            throw APIError.incompleteData\n        }\n        \n        return UserProfile(info: userInfo, posts: posts)\n    }\n}\nenum UserProfileComponent { case info(UserInfo), posts([Post]) } // Helper enum\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` inside an async function creates a new, detached task tree, breaking the parent-child relationship. This task can outlive the function scope, losing the guarantees of structured concurrency. Use `Task.init` only for bridging to non-async contexts or for tasks that must outlive the current scope.\n- **Misunderstanding Cancellation:** Cancellation is cooperative, not preemptive. A long-running child task must periodically check `Task.isCancelled` and throw a `CancellationError` to halt its execution promptly.\n\n**When to Use vs. Alternatives:**\n- **Structured Concurrency (`async let`, `TaskGroup`):** The default choice for all new concurrent Swift code. It's safer, more readable, and less error-prone. Use it whenever a task's work is relevant only within the scope that creates it.\n- **Unstructured Concurrency (`Task.init`):** Use when a task must outlive its originating scope, such as a fire-and-forget analytics event or a background task tied to the application's lifecycle.\n- **GCD/OperationQueue:** Primarily for maintaining legacy code, interacting with older frameworks that require it, or for specific features like `maxConcurrentOperationCount`. For new features, prefer Swift's native concurrency.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured concurrency",
        "async/await",
        "taskgroup"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain how Swift's `actor` model provides thread safety, contrasting it with traditional lock-based concurrency. What are the key rules of 'actor isolation' and how does the compiler enforce them?",
      "back": "Swift's `actor` model provides thread safety by creating a 'concurrency domain' around its mutable state. Unlike traditional mechanisms like `NSLock` or `DispatchQueue.sync`, which require manual and careful management to prevent issues like deadlocks and priority inversion, actors automate this protection at the language level.\n\n**Core Concept:**\nAn actor is a reference type that ensures only one task can access its mutable state at a time. It achieves this by serializing all incoming requests to its properties and methods in a conceptual 'mailbox'. The actor processes these messages one by one, preventing data races by design. The compiler enforces this safety through a set of rules called **Actor Isolation**:\n1.  **Internal Access:** Code within an actor's methods can access its own properties and methods synchronously (`self.balance`).\n2.  **External Access:** Any code outside the actor must access its mutable state or non-`nonisolated` methods asynchronously using `await`. This `await` is a suspension point, indicating that the calling task is yielding to the actor's executor to run the code when it's safe.\n3.  **Sendable Types:** Data passed into or out of an actor's isolated context must conform to the `Sendable` protocol, ensuring the data itself is thread-safe.\n\n**Code Example:**\n```swift\nactor ScoreCounter {\n    private var score = 0\n\n    // Internal access is synchronous and safe.\n    func increment() {\n        score += 1\n    }\n\n    // This function can be called from outside the actor.\n    func getScore() -> Int {\n        return score\n    }\n}\n\nfunc updateScores(counter: ScoreCounter) async {\n    // ERROR: Actor-isolated 'increment' can only be called on 'self'\n    // counter.increment() // This would be a sync call, which is forbidden.\n\n    // CORRECT: Use 'await' to cross the isolation boundary asynchronously.\n    await counter.increment()\n    let currentScore = await counter.getScore()\n    print(\"Current score: \\(currentScore)\")\n}\n```\n\n**Common Pitfalls:**\n- **Re-entrancy:** The most subtle issue. When an actor `await`s another async function, it can process other messages from its mailbox before the original function resumes. This means the actor's state can change across an `await`. You must not assume state is unchanged after a suspension point.\n- **Deadlocks:** While actors reduce many deadlock scenarios, you can still create them. For example, Actor A `await`s a result from Actor B, while Actor B simultaneously `await`s a result from Actor A.\n\n**When to Use vs. Alternatives:**\n- **Use Actors:** For encapsulating and managing mutable state that needs to be accessed from multiple concurrent contexts (e.g., a data cache, a state manager, a repository).\n- **Alternatives:**\n  - **Locks/Queues:** Use for fine-grained control or legacy code. More error-prone and complex.\n  - **`@MainActor`:** A global actor specifically for ensuring code runs on the main thread for UI updates.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "thread-safety",
        "data-races"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "A class needs to safely manage a mutable property accessed from multiple threads. Compare and contrast using `NSLock`, a serial `DispatchQueue`, and an `actor` to prevent data races. Discuss the trade-offs of each approach.",
      "back": "A data race occurs when multiple threads access a shared resource without synchronization, and at least one access is a write. This leads to unpredictable behavior. `NSLock`, serial `DispatchQueue`, and `actor` are three mechanisms to ensure mutual exclusion and prevent this.\n\n**1. NSLock**\nA low-level, traditional locking mechanism. It provides exclusive access to a critical section by requiring a thread to acquire the lock before entering and release it upon exit. It's synchronous and blocking.\n- **Pros:** High performance with low overhead for uncontended locks. Fine-grained control.\n- **Cons:** Manual lock management is error-prone (forgetting to `unlock`). Prone to deadlocks if not handled carefully.\n\n**2. Serial DispatchQueue**\nA Grand Central Dispatch (GCD) queue that executes tasks one at a time in FIFO order. By dispatching all read/write operations to this queue, you guarantee serialized access.\n- **Pros:** Simple, declarative API. Less prone to simple deadlocks than manual locks.\n- **Cons:** Higher overhead than `NSLock`. Using `sync` can lead to deadlocks if called from the same queue. \n\n**3. Actor**\nA Swift concurrency feature that protects its state from concurrent access. The compiler enforces that access to an actor's mutable state from the outside must be done asynchronously (`await`), ensuring serialized access.\n- **Pros:** **Compile-time safety**. The compiler prevents data races by construction. Part of modern structured concurrency.\n- **Cons:** Requires an `async` context to interact with. An `await` inside an actor method can suspend it, re-entrantly allowing other calls to run, which requires careful state management across suspension points.\n\n```swift\n// Shared mutable resource example\nclass ThreadSafeCounter {\n    private let lock = NSLock()\n    private var _count = 0\n    func increment() { // Using NSLock\n        lock.lock()\n        defer { lock.unlock() } // Guarantees unlock even if errors occur\n        _count += 1\n    }\n}\n\nclass QueueSafeCounter {\n    private let queue = DispatchQueue(label: \"com.example.counter.queue\")\n    private var _count = 0\n    func increment() { // Using serial DispatchQueue\n        queue.sync { // sync ensures the operation completes before returning\n            self._count += 1\n        }\n    }\n}\n\nactor ActorSafeCounter {\n    private var count = 0\n    func increment() { // Actor automatically isolates its state\n        count += 1\n    }\n    func getCount() -> Int {\n        return count\n    }\n}\n```\n\n**When to Use:**\n- **NSLock:** Use for performance-critical, synchronous code sections or when interacting with older Objective-C APIs. Be disciplined with `defer`.\n- **DispatchQueue:** A great general-purpose solution. The readers-writer pattern (concurrent queue + barriers) is a common, powerful optimization.\n- **Actor:** The preferred, modern Swift approach. Use for any new code modeling isolated, mutable state. It provides the highest level of safety.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "gcd",
        "threading",
        "data_race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain the purpose of global actors in Swift, using `@MainActor` as a primary example. When would you create a custom global actor instead of using a standard actor instance to manage shared mutable state?",
      "back": "A global actor is a mechanism in Swift Concurrency that provides a globally unique, serial execution context to protect shared mutable state from data races. Any function, type, or property marked with a global actor's attribute (e.g., `@MainActor`) is said to be 'isolated' to that actor, meaning the compiler ensures it can only be accessed from that actor's context.\n\n**Core Concept:**\nThe most prominent example is `@MainActor`, which represents the main thread. It guarantees that any code marked with it (like UI updates in SwiftUI or UIKit) runs on the main thread, enforced at compile time. This prevents common UI-related race conditions and crashes. When you call a `@MainActor`-isolated function from a different context, you must use `await`, which allows the system to suspend the current task and resume it later on the main thread's executor.\n\nCustom global actors extend this concept to any domain. You define one by creating a type marked with `@globalActor` that provides a shared actor instance.\n\n**Practical Code Example:**\n```swift\n// 1. Define a custom global actor for a shared resource, like a logger.\n@globalActor\nstruct AnalyticsActor {\n    static let shared = ActorType()\n    typealias ActorType = Actor\n}\n\n// 2. Isolate a class to this global actor.\n// All methods and properties will be protected by AnalyticsActor.\n@AnalyticsActor\nclass AnalyticsManager {\n    private var sessionEvents: [String] = []\n\n    func logEvent(_ event: String) {\n        print(\"Logging event: \\(event)\")\n        sessionEvents.append(event)\n    }\n}\n\n// 3. In UI code, access requires an 'await' to hop to the actor's executor.\nclass ContentViewModel: ObservableObject {\n    @MainActor @Published var status = \"Ready\"\n\n    func onButtonTapped() async {\n        // Hop from MainActor to AnalyticsActor\n        await AnalyticsManager().logEvent(\"Button Tapped\")\n        \n        // Hop back to MainActor to update UI\n        await MainActor.run { \n            self.status = \"Event Logged\"\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Overuse:** Creating global actors for state that isn't truly global. This leads to unnecessary contention and tight coupling. Most state is better managed by a standard actor instance passed via dependency injection.\n- **Blocking:** Performing long-running synchronous work on a global actor can starve other tasks waiting for it. On `@MainActor`, this freezes the UI.\n- **`nonisolated` Misuse:** Using `nonisolated` to bypass actor protection on mutable state can re-introduce data races. It should primarily be used for immutable state (`let` constants) or internally thread-safe operations.\n\n**When to Use vs. Alternatives:**\n- **Custom Global Actor:** Use for state that is fundamentally singular and global in your application, like a centralized logging service, a file coordinator for a shared directory, or a database connection pool. It's essentially a compile-time safe singleton.\n- **Standard Actor Instance:** This should be your default choice. Use it to protect the internal state of a class/struct instance. It promotes better encapsulation, testability (you can mock it or create multiple instances), and follows dependency injection principles. It's ideal for a network client, a feature-specific repository, or any stateful object that isn't a global singleton.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-structured-concurrency",
        "actors",
        "global-actor",
        "mainactor"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol helps prevent data races in Swift Concurrency. Describe the conditions for implicit conformance and the safety considerations required when explicitly marking a class `@unchecked Sendable`.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's modern concurrency model, designed to statically verify that types can be safely shared across different threads or actors without introducing data races.\n\n**Core Concept Explanation:**\n`Sendable` acts as a contract with the compiler. It doesn't add any methods or properties; it simply marks a type, promising that its values can be safely copied and passed between concurrency domains (e.g., from your main actor to a background task). The compiler enforces this contract, issuing an error if you try to share a non-`Sendable` type across such boundaries. This shifts thread-safety from a runtime problem (crashes, unpredictable behavior) to a compile-time guarantee.\n\nA type implicitly conforms to `Sendable` if it meets these criteria:\n1. It's a value type (struct or enum).\n2. All its stored properties are also `Sendable`.\n3. For enums, all associated values must be `Sendable`.\n4. It's a final class with only immutable (`let`) stored properties of `Sendable` types.\n\n**Practical Code Example:**\n```swift\n// 1. Implicitly Sendable struct\nstruct UserProfile: Sendable {\n    let id: UUID // UUID is Sendable\n    let username: String // String is Sendable\n}\n\n// 2. A class that is NOT Sendable due to mutable state\nclass UnsafeCounter {\n    var value = 0 // Mutable property makes it non-Sendable\n    func increment() { value += 1 }\n}\n\n// 3. A final class marked @unchecked Sendable with internal synchronization\nfinal class SafeCounter: @unchecked Sendable { // We promise the compiler it's safe\n    private var value = 0\n    private let lock = NSLock()\n\n    func increment() {\n        lock.lock()\n        defer { lock.unlock() }\n        value += 1\n    }\n    \n    func getValue() -> Int {\n        lock.lock()\n        defer { lock.unlock() }\n        return value\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Misusing `@unchecked Sendable`:** The most dangerous pitfall is marking a class `@unchecked Sendable` without implementing proper internal synchronization (e.g., using locks, a serial queue). This silences the compiler but reintroduces the risk of data races.\n- **Function Types:** Closures and functions passed across actor boundaries must be `@Sendable`. This means they cannot capture mutable, non-`Sendable` state from their enclosing scope.\n- **Generics:** Generic types must be constrained to `Sendable` (`<T: Sendable>`) if they are to be used in a context that requires `Sendable` conformance.\n\n**When to Use vs. Alternatives:**\n- **Prefer Value Types:** The easiest path to safety is using `struct`s and `enum`s, which are often implicitly `Sendable`.\n- **Use Actors:** If you need shared mutable state, an `actor` is the preferred solution. It encapsulates its state and ensures all access is synchronized, making it inherently safe to interact with from any concurrency domain.\n- **Use `@unchecked Sendable` on Classes:** Reserve this for legacy Objective-C classes or custom classes where you need fine-grained control over locking and performance, and you can manually verify and guarantee thread safety.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "sendable",
        "thread-safety",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Compare the Actor model in modern Swift Concurrency with traditional locking mechanisms (like NSLock or serial queues) for preventing data races. Discuss the trade-offs and when you would choose one over the other.",
      "back": "A data race occurs when multiple threads access shared mutable state without synchronization, with at least one access being a write. Both actors and locks solve this, but through different paradigms.\n\n**Core Concept: Locking vs. Actor Isolation**\n\n*   **Traditional Locking (e.g., `NSLock`, `DispatchQueue`):** This is an imperative approach. You manually acquire a lock before entering a *critical section* (code accessing shared state) and release it upon exit. A serial `DispatchQueue` achieves a similar effect by ensuring tasks execute one at a time. The responsibility for correctness lies entirely with the developer. You must remember to lock and unlock correctly everywhere.\n\n*   **Actors:** This is a declarative approach built into the Swift language. An `actor` is a reference type that protects its state from concurrent access. The compiler enforces that any access to an actor's mutable state from the *outside* must be asynchronous (`await`). This allows the actor's internal executor to serialize access, guaranteeing data integrity without manual locking.\n\n**Practical Code Example**\n\n```swift\n// Traditional approach with a private serial queue\nclass SafeCounter { \n    private var value = 0\n    private let queue = DispatchQueue(label: \"com.example.counter.queue\")\n\n    func increment(completion: @escaping (Int) -> Void) {\n        queue.async {\n            self.value += 1\n            completion(self.value)\n        }\n    }\n}\n\n// Modern approach with an actor\nactor ActorCounter {\n    private var value = 0\n\n    func increment() -> Int {\n        value += 1\n        return value\n    }\n}\n\n// Usage\nTask {\n    let counter = ActorCounter()\n    let newValue = await counter.increment() // 'await' enforces safe, serialized access\n    print(newValue)\n}\n```\n\n**Common Pitfalls & Edge Cases**\n\n*   **Locks:** \n    *   **Deadlocks:** Thread A locks resource X and waits for Y, while Thread B locks Y and waits for X. Both are stuck forever.\n    *   **Forgetting to Unlock:** Failing to release a lock, especially in an error path, can freeze threads. `defer` is crucial for safety.\n    *   **Priority Inversion:** A low-priority thread holds a lock needed by a high-priority thread, blocking important work.\n\n*   **Actors:**\n    *   **Re-entrancy:** When an actor `await`s another async call, it suspends. During this suspension, other calls can be made to the actor. This can lead to observing inconsistent state if not handled carefully. The actor is *not* locked during suspension.\n\n**When to Use vs. Alternatives**\n\n*   **Use Actors (Default Choice):** For any new Swift code that needs to manage shared, mutable state. The compile-time safety is a massive advantage over manual locking, eliminating an entire class of bugs. They integrate seamlessly with the `async/await` ecosystem.\n\n*   **Use Locks/Queues:** \n    1.  **Interoperability:** When working with legacy Objective-C APIs or libraries that are not actor-aware and require explicit synchronization.\n    2.  **Synchronous Context:** When you must synchronize access within a synchronous function. Note: This often points to a larger design issue that should be refactored to be asynchronous.\n    3.  **Fine-grained Performance:** In rare, highly-optimized scenarios where the overhead of actor context switching is a proven bottleneck (profile first!).",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift concurrency",
        "actors",
        "data race",
        "locking",
        "system design"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency fundamentally change the management of concurrent task lifetimes and error propagation compared to 'fire-and-forget' approaches like GCD?",
      "back": "Swift's Structured Concurrency introduces a parent-child relationship between tasks, forming a 'task tree'. The lifetime of a child task is constrained by the scope of its parent. This means a parent task cannot complete until all of its child tasks have finished, either by returning a value, throwing an error, or being cancelled.\n\nThis model is a stark contrast to older 'fire-and-forget' APIs like Grand Central Dispatch (GCD) or `Task.detached`, where dispatching a task severs its connection to the parent context. In those models, the developer is responsible for manually tracking tasks, propagating cancellation signals, and funneling errors back, which is complex and error-prone.\n\nStructured Concurrency solves this by baking lifetime management, cancellation, and error propagation directly into the language syntax.\n\n**Code Example:**\nUsing `async let` to fetch user data and their feed concurrently. The `fetchUserAndFeed` function is the parent task.\n\n```swift\nstruct User { let name: String }\nstruct Feed { let items: [String] }\n\nfunc fetchUser() async throws -> User { /* ... network call ... */ return User(name: \"Alex\") }\nfunc fetchFeed() async throws -> Feed { /* ... network call ... */ throw NetworkError.timeout }\n\nfunc fetchUserAndFeed() async {\n    print(\"Starting to fetch data...\")\n    do {\n        // 'async let' creates two child tasks that run in parallel.\n        // Their lifetimes are scoped to this 'do' block.\n        async let userTask = fetchUser()\n        async let feedTask = fetchFeed() // This task will throw an error.\n\n        // The parent task suspends here. 'await' waits for both children.\n        // If 'feedTask' throws, 'userTask' is automatically cancelled.\n        let (user, feed) = try await (userTask, feedTask)\n        print(\"Successfully fetched \\(user.name) and \\(feed.items.count) items.\")\n\n    } catch {\n        // The error from 'fetchFeed' is propagated up and caught here.\n        print(\"Failed to fetch data: \\(error)\")\n    }\n    print(\"Function finished.\")\n}\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` without awaiting its result creates a detached, unstructured task, breaking the parent-child hierarchy and its safety guarantees.\n- **Misusing `TaskGroup`:** Using a `TaskGroup` for a fixed, small number of heterogeneous tasks where the simpler `async let` syntax is more appropriate.\n- **Cancellation is Cooperative:** Structured Concurrency propagates the cancellation signal automatically, but the child task must periodically check for it via `Task.isCancelled` or `try Task.checkCancellation()` to actually stop its work.\n\n**When to Use vs. Alternatives:**\n- **Structured Concurrency (`async let`, `TaskGroup`):** The default choice for new concurrent code. It provides compile-time safety, prevents task leakage, and simplifies complex workflows.\n- **Unstructured Concurrency (`Task.detached`):** Use sparingly for tasks that must outlive the scope that created them, such as a background logging operation that must complete even if the UI is dismissed. It's an escape hatch, not the norm.\n- **GCD/OperationQueue:** Still valuable for legacy code, fine-grained control over execution (e.g., `maxConcurrentOperationCount`), or complex dependency graphs between operations. For most common concurrency patterns, Swift's structured approach is safer and more readable.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "async/await",
        "structured concurrency",
        "task"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Explain how `TaskGroup` facilitates dynamic parallelism. Describe its error handling mechanism, specifically the behavior of the group and its child tasks when one task throws an error.",
      "back": "A `TaskGroup` provides a structured way to create a dynamic number of child tasks that can run concurrently. It's a core component of Swift's structured concurrency, ensuring that the parent task's scope does not exit until all child tasks have completed.\n\n**Core Concept & Error Handling:**\nYou create a group using `withTaskGroup` or `withThrowingTaskGroup`. Inside the group's closure, you can call `addTask` in a loop to spin up a variable number of child tasks. These tasks begin executing immediately and in parallel.\n\nIf any child task throws an error, the `TaskGroup` immediately cancels all other running and pending child tasks in the group. The `for try await` loop (or a call to `await group.next()`) that collects results will then rethrow that first error, unwinding the call stack and ensuring failures are propagated correctly.\n\n**Code Example:**\n```swift\n// Fetches multiple images concurrently, failing if any download fails.\nfunc fetchImages(urls: [URL]) async throws -> [UIImage] {\n    var images: [UIImage] = []\n    images.reserveCapacity(urls.count)\n\n    // Use a throwing group for tasks that can fail.\n    try await withThrowingTaskGroup(of: UIImage.self) { group in\n        for url in urls {\n            // Dynamically add a new child task for each URL.\n            // These tasks start running concurrently immediately.\n            group.addTask { \n                // It's crucial to check for cancellation inside child tasks.\n                try Task.checkCancellation()\n                let (data, _) = try await URLSession.shared.data(from: url)\n                guard let image = UIImage(data: data) else { \n                    throw URLError(.cannotDecodeContentData)\n                }\n                return image\n            }\n        }\n\n        // Await and collect results as they complete.\n        // If any task throws, this loop rethrows the error and exits.\n        for try await image in group {\n            images.append(image)\n        }\n    } // The group implicitly awaits all tasks before this scope exits.\n    return images\n}\n```\n\n**Common Pitfalls:**\n1.  **Leaking the Group:** Forgetting to iterate over the group to consume all results (e.g., using `for try await` or `next()`) will cause the parent task to suspend indefinitely, as it waits for a group that never finishes.\n2.  **Ignoring Cancellation:** Child tasks that perform long-running work without periodically checking `Task.isCancelled` or calling `Task.checkCancellation()` will continue to run even after the group is cancelled, wasting system resources.\n\n**When to Use vs. Alternatives:**\n-   **`TaskGroup`:** Use when the number of concurrent tasks is dynamic or unknown at compile time (e.g., processing an array of items).\n-   **`async let`:** Use for a small, fixed number of concurrent tasks where each result is distinct and known at compile time. It offers a simpler syntax for this specific use case (e.g., `async let profile = fetchProfile()`, `async let friends = fetchFriends()`).",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "taskgroup",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain how `@MainActor` enforces main-thread execution. How does this relate to the broader concept of global actors, and what fundamental problem does it solve compared to traditional `DispatchQueue.main.async` calls?",
      "back": "### Core Concept\n\n`@MainActor` is a *global actor*, a specific kind of actor that provides a globally unique, mutually-exclusive execution context. Its purpose is to protect access to resources that must be used on the main thread, primarily UI components from UIKit and SwiftUI. \n\nWhen you annotate a type, function, or property with `@MainActor`, you are telling the Swift compiler that it must only be accessed from the main thread's execution context. The compiler enforces this isolation. Any attempt to call a `@MainActor`-isolated function from a different concurrency context (e.g., a background `Task`) is a compile-time error unless you explicitly use `await`. The `await` keyword signals a potential suspension point where the program can suspend the background task and resume the function's execution on the main actor's executor (the main thread). \n\nThis solves a fundamental problem with `DispatchQueue.main.async`: safety. The older GCD approach relies on the developer to remember to dispatch UI updates to the main queue. Forgetting to do so results in a runtime crash or undefined UI behavior. `@MainActor` shifts this safety check from runtime to compile time, eliminating an entire class of common concurrency bugs.\n\n### Practical Code Example\n\n```swift\n// A custom global actor for a shared, thread-sensitive resource.\n@globalActor\nactor AnalyticsManager {\n    static let shared = AnalyticsManager()\n    private init() {}\n    func logEvent(_ name: String) { print(\"[Analytics] Event: \\(name)\") }\n}\n\n@MainActor // Isolates this entire class to the main thread.\nclass ProfileViewModel: ObservableObject {\n    @Published var username: String = \"Loading...\"\n\n    // This method is guaranteed to run on the main thread.\n    func updateUsername(_ newName: String) {\n        self.username = newName\n    }\n\n    func fetchUser() {\n        // Create a new unstructured task that runs on a background thread.\n        Task {\n            let userData = await fetchFromServer() // async call on background thread\n            \n            // The compiler FORCES an 'await' here to hop back to the MainActor.\n            // Without 'await', this would be a compile-time error.\n            await updateUsername(userData)\n\n            // We can also hop to another global actor's context.\n            await AnalyticsManager.shared.logEvent(\"user_profile_loaded\")\n        }\n    }\n    \n    // Simulate a network request.\n    private func fetchFromServer() async -> String {\n        try? await Task.sleep(for: .seconds(1))\n        return \"senior.dev\"\n    }\n}\n```\n\n### Common Pitfalls & Edge Cases\n\n1.  **Blocking the Main Thread**: `@MainActor` ensures *where* code runs, not *how*. A long-running, synchronous computation inside a `@MainActor` function will still freeze the UI. Heavy work must be offloaded to a background task or a different actor.\n2.  **`nonisolated` Misuse**: You can use `nonisolated` to opt-out a method from actor isolation. This is useful for pure functions that don't access actor state. Incorrectly marking a method that accesses `@Published` properties as `nonisolated` will cause a compile-time error.\n3.  **Initializer Context**: An initializer of a `@MainActor` type runs on the main actor by default. However, if you create an instance from a non-isolated context, the initializer will run in that context, which can be a source of subtle bugs if the initializer touches UI.\n\n### When to Use vs. Alternatives\n\n-   **`@MainActor`**: The modern, preferred choice for all UI-related code in a Swift Concurrency context (e.g., SwiftUI Views, ViewModels, UIKit ViewControllers). It provides compile-time safety, making code easier to reason about and less error-prone.\n-   **`DispatchQueue.main.async`**: A legacy mechanism. It's still necessary for interoperability with older, completion-handler-based APIs that are not `async`/`await` aware. For new code, `@MainActor` is superior because it prevents accidental UI updates from background threads at compile time, rather than crashing at runtime.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "mainactor",
        "global-actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "How do `AsyncSequence` and `AsyncStream` differ, and when would you use `AsyncStream` to bridge older asynchronous APIs into Swift Concurrency?",
      "back": "`AsyncSequence` is a protocol, analogous to `Sequence`, that defines a way to iterate over a series of values that become available over time. You consume it with a `for-await-in` loop, which \"pulls\" values as it's ready for them.\n\n`AsyncStream` is a concrete type that creates an `AsyncSequence`. Its primary role is to act as a bridge, adapting \"push-based\" asynchronous APIs (like delegate callbacks, closures, or notifications) into the \"pull-based\" world of `AsyncSequence`. It does this via a `Continuation`, which you use to `yield` values into the stream or `finish` it.\n\n**Practical Code Example: Wrapping a Delegate**\nHere, we adapt the delegate-based `CLLocationManager` to provide a modern `AsyncSequence` of location updates.\n\n```swift\nimport CoreLocation\n\nactor LocationProvider: NSObject, CLLocationManagerDelegate {\n    private let manager = CLLocationManager()\n    private var continuation: AsyncStream<CLLocation>.Continuation?\n\n    override init() {\n        super.init()\n        manager.delegate = self\n    }\n\n    // This stream is the public, modern API\n    var locations: AsyncStream<CLLocation> {\n        AsyncStream { continuation in\n            self.continuation = continuation\n            // When the stream is terminated, this is called for cleanup\n            continuation.onTermination = { @Sendable [weak self] _ in\n                self?.manager.stopUpdatingLocation()\n            }\n            manager.requestWhenInUseAuthorization()\n            manager.startUpdatingLocation()\n        }\n    }\n\n    // The old delegate method \"pushes\" values into the stream\n    nonisolated func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        // We must hop back to the actor to safely access the continuation\n        Task { await self.yield(locations) }\n    }\n\n    private func yield(_ locations: [CLLocation]) {\n        locations.forEach { continuation?.yield($0) }\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Forgetting `continuation.finish()`:** If you don't explicitly finish the stream (e.g., on error or deinit), any `for-await-in` loop consuming it will hang forever, leaking resources.\n- **Ignoring Backpressure:** The `bufferingPolicy` parameter is critical. The default `.unbounded` can cause memory to grow indefinitely if values are produced faster than consumed. For UI updates, `.bufferingNewest(1)` is often a better choice.\n- **Continuation Thread Safety:** The continuation is not thread-safe. If callbacks can occur on different threads, you must synchronize access. Using an actor, as shown above, is the standard Swift Concurrency pattern to achieve this.\n\n**When to Use vs. Alternatives:**\n- **Use `AsyncStream`:** To adapt any non-`async` source of events (delegates, KVO, NotificationCenter, completion handlers) into an `AsyncSequence`. It's the primary tool for bridging legacy code.\n- **Alternatives:** For a finite set of concurrent jobs, use a `TaskGroup`. For reactive data flows in a Combine-heavy project, use a `Publisher` (which can be converted to an `AsyncSequence` via its `.values` property). `AsyncStream` is specifically for creating an ongoing, potentially infinite sequence of asynchronous values from a non-structured source.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "async-await",
        "asyncsequence"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "How do Swift actors prevent data races on shared mutable state, and what is the concept of 'actor isolation' that enables this safety at compile time?",
      "back": "Actors are a core component of Swift's structured concurrency model, designed to solve data races on shared mutable state. They act as 'islands of serialization' in a concurrent environment.\n\n**Core Concept:**\nAn actor is a reference type that encapsulates its state and ensures that only one task can access that state at a time. It achieves this by managing a 'mailbox' of incoming requests (method calls, property access) and executing them serially. This eliminates the need for manual locking (like `NSLock` or serial dispatch queues) and their associated pitfalls like deadlocks or priority inversions.\n\n'Actor isolation' is the set of compiler rules that enforces this safety. The compiler understands which code is 'on the actor' and which is not. \n1.  **External Access:** Any access to an actor's mutable properties or methods from outside its own context must be asynchronous and marked with `await`. This `await` signifies a potential suspension point where the calling task yields the thread, allowing the actor to process the request when it's free.\n2.  **Internal Access:** Code within an actor's methods can access its own properties and methods synchronously, as it's already operating within the protected, serial context.\n\n**Practical Code Example:**\n```swift\nactor BankAccount {\n    private var balance: Double\n\n    init(initialDeposit: Double) {\n        self.balance = initialDeposit\n    }\n\n    // This method is part of the actor's isolated context.\n    func deposit(amount: Double) {\n        balance += amount\n        logTransaction(type: \"Deposit\", amount: amount)\n    }\n\n    // Internal methods can be called synchronously from other isolated methods.\n    private func logTransaction(type: String, amount: Double) {\n        print(\"\\(type): $\\(amount), New Balance: $\\(balance)\")\n    }\n    \n    // Use 'nonisolated' for properties that are immutable (let) or don't need protection.\n    nonisolated let accountId: UUID = UUID()\n}\n\nfunc performTransactions() async {\n    let account = BankAccount(initialDeposit: 1000)\n\n    // External access to an actor's methods MUST be awaited.\n    // This suspends performTransactions and sends a message to the actor's mailbox.\n    await account.deposit(amount: 500)\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Reentrancy:** When an actor-isolated method `await`s another async call, it becomes reentrant. This means the actor can process other incoming messages while suspended. This can lead to unexpected state changes if not handled carefully, as the state might not be the same before and after the `await`. This is a key difference from a traditional lock, which would block the entire context.\n*   **Misusing `nonisolated`:** Declaring a method or a mutable `var` property as `nonisolated` breaks the actor's safety guarantees and can re-introduce data races. It should only be used for truly immutable state (`let` constants) or methods that don't touch the actor's isolated state.\n\n**When to Use vs. Alternatives:**\n*   **vs. Serial `DispatchQueue`:** Actors are the modern, safer choice for protecting instance state. The compiler enforces correct usage. A serial queue relies on developer discipline (`queue.async { ... }`) and provides no compile-time safety against accidental synchronous access from another thread.\n*   **vs. `NSLock`:** `NSLock` is a low-level, manual locking mechanism. It's error-prone (risk of deadlocks, forgetting to unlock) and doesn't integrate with structured concurrency. Use actors for state protection; reserve locks for fine-grained control over small, critical sections where actor overhead is a proven concern.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "structured-concurrency",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "How does the `Sendable` protocol, in conjunction with Swift's structured concurrency, prevent data races? Explain its compile-time checks and the implications of marking a custom type as `Sendable`.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's concurrency safety model. It's a marker protocol, meaning it has no requirements itself, but instead provides a semantic guarantee to the compiler: a type conforming to `Sendable` can be safely transferred from one concurrency domain to another (e.g., between actors or to a background `Task`).\n\n**Core Concept:**\nThe compiler uses `Sendable` conformance to statically verify that you are not creating shared mutable state, which is the primary cause of data races. A type can be `Sendable` if:\n1. It is a value type (`struct`, `enum`) where all its stored properties are also `Sendable`.\n2. It is a reference type (`class`) that is `final` and contains only immutable stored properties (`let`) of `Sendable` types.\n3. It is a reference type that ensures thread-safety through internal synchronization (e.g., using locks or a serial queue) and is explicitly marked `@unchecked Sendable`. This is an unsafe escape hatch that puts the responsibility on the developer.\nActors, by their nature of serializing access to their state, are implicitly `Sendable`.\n\n**Practical Code Example:**\n```swift\n// 1. Struct is implicitly Sendable because its members are.\nstruct UserProfile: Sendable {\n    let id: UUID\n    let score: Int\n}\n\n// 2. This class is NOT Sendable due to the mutable `var`.\nclass ScoreTracker {\n    var highScores: [String: Int] = [:] // Unsafe to share\n}\n\n// 3. A final class with only immutable 'let' properties can be Sendable.\nfinal class AppConfig: Sendable {\n    let apiBaseURL: URL\n    let featureFlags: Set<String>\n    init(apiBaseURL: URL, featureFlags: Set<String>) { /*...*/ }\n}\n\n// This function requires a Sendable type, ensuring safety.\nfunc processInBackground<T: Sendable>(_ data: T) async {\n    print(\"Processing \\(data) on a background thread.\")\n}\n\nTask {\n    let profile = UserProfile(id: UUID(), score: 100)\n    await processInBackground(profile) // \u2705 Compiles: UserProfile is Sendable\n    \n    let config = AppConfig(apiBaseURL: URL(string: \"...\")!, featureFlags: [\"newUI\"])\n    await processInBackground(config) // \u2705 Compiles: AppConfig is Sendable\n\n    // let tracker = ScoreTracker()\n    // await processInBackground(tracker) // \ud83d\uded1 Compile Error: ScoreTracker does not conform to Sendable\n}\n```\n\n**Common Pitfalls:**\n- **Misusing `@unchecked Sendable`**: This silences the compiler but does not add thread safety. It's a contract that you, the developer, have implemented synchronization. Forgetting a lock or getting it wrong will lead to data races that the compiler can no longer help you find.\n- **Implicit Conformance Trap**: A `struct` is only `Sendable` if *all* its stored properties are. Adding a single non-`Sendable` property (like a reference to a plain class) will break the implicit conformance, often leading to unexpected compiler errors elsewhere.\n- **Closure Captures**: Closures passed to concurrent contexts (like `Task.init`) must be `@Sendable`. This means they can only capture `Sendable` values. Capturing a non-`Sendable` class instance will result in a compile-time error.\n\n**When to Use vs. Alternatives:**\n- **Prefer Value Types**: The idiomatic Swift approach is to use `Sendable` structs and enums to communicate data between concurrent tasks. This avoids shared mutable state entirely by passing copies.\n- **Use Actors for Shared Mutable State**: When you truly need a single, mutable source of truth, encapsulate it within an actor. Actors are `Sendable` by nature, and the `await` keyword ensures that access to their internal state is synchronized and safe.\n- **Use `Sendable` Classes for Immutable Shared State**: For shared configuration or caches that are initialized once and never change, a `final class` with `let` properties is a lightweight and efficient `Sendable` type.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-structured-concurrency",
        "sendable",
        "actors",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol and its compiler checks prevent data races in Swift's structured concurrency. What types are implicitly `Sendable`, and when would you need to explicitly or unsafely conform a custom type?",
      "back": "The `Sendable` protocol is a cornerstone of Swift's modern concurrency model, designed to eliminate data races by enforcing rules at compile time. It acts as a 'marker' protocol, having no requirements of its own, but signaling to the compiler that a type's values can be safely copied and shared across concurrency boundaries (like between actors or tasks) without introducing shared mutable state.\n\n**Core Concept:**\nThe compiler verifies `Sendable` conformance whenever a value crosses a concurrency domain. If you attempt to pass a non-`Sendable` type to an actor or capture it in a concurrent `Task`, the compiler will issue a warning or error. This shifts the responsibility of thread safety from runtime discipline (e.g., manual locking) to compile-time verification.\n\n**Implicit Conformance:**\nSeveral types are implicitly `Sendable`:\n1.  **Value Types:** Structs and enums are `Sendable` if all their stored properties are also `Sendable`.\n2.  **Actors:** Actors inherently manage their own state and are thus `Sendable`.\n3.  **Immutable Classes:** A `final` class is `Sendable` if it has no mutable stored properties (`var`) and all its stored properties are of `Sendable` types.\n\n```swift\n// Implicitly Sendable struct because its properties are Sendable\nstruct UserProfile: Sendable {\n    let id: UUID\n    let name: String\n}\n\n// A class with mutable state is NOT Sendable by default.\nclass UserPreferences {\n    var isDarkMode: Bool = false // Mutable state\n}\n\nactor DataManager {\n    private var userCache: [UUID: UserProfile] = [:]\n\n    // OK: UserProfile is Sendable and can be passed across actor boundary.\n    func cache(_ profile: UserProfile) {\n        userCache[profile.id] = profile\n    }\n\n    // WARNING: Passing a non-Sendable type across actor boundary.\n    // Swift 6 will make this an error.\n    func apply(_ prefs: UserPreferences) {\n        // This is dangerous. Another thread could be modifying `prefs`\n        // at the same time, leading to a data race.\n        print(\"Applying preferences...\")\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Explicit Conformance:** You must explicitly mark a type `Sendable` if it meets the criteria but the compiler can't infer it (e.g., a `public` struct in a library whose properties are `internal`).\n- **`@unchecked Sendable`:** This is a powerful but dangerous escape hatch. You use it to tell the compiler to trust you that a type is safe, even if it doesn't meet the standard criteria. This is typically used for legacy classes that manage their own thread safety via internal locking (`NSLock`, serial queue). Misusing `@unchecked Sendable` can easily re-introduce data races the compiler was designed to prevent.\n\n**When to Use vs. Alternatives:**\nUse `Sendable` and the actor model for all new concurrent code in Swift. It provides the highest level of safety. The alternatives are older, manual synchronization primitives like `NSLock` or `DispatchQueue`. While still useful for interoperability or specific performance optimizations, they lack compiler verification, making them more error-prone. `Sendable` codifies the safety contract, allowing the toolchain to help you write correct concurrent code.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actor",
        "sendable",
        "thread-safety",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain how `@MainActor` solves UI-related data races compared to older GCD approaches. How does it differ from a custom global actor, and in what scenario would you define your own?",
      "back": "The `@MainActor` attribute is a global actor that ensures any code it annotates is executed on the main thread. This provides compile-time safety for UI updates, a significant improvement over the runtime-dependent `DispatchQueue.main.async` approach. With GCD, developers had to manually ensure UI code was dispatched to the main queue, a common source of bugs if forgotten. `@MainActor` lets the Swift compiler enforce this rule, preventing data races on UI components by flagging incorrect calls from other contexts as build errors.\n\nIt differs from a custom global actor in its purpose. `@MainActor` is a specific, system-provided actor tied to the main thread for UI operations. A custom global actor is a general-purpose tool you create to serialize access to any other shared mutable state across an application. You would define your own global actor to protect a resource like a database connection, a file logger, or a shared cache that needs to be accessed safely from multiple concurrent tasks.\n\n```swift\n// 1. A custom global actor for serializing database access\n@globalActor\nactor DatabaseActor {\n  static let shared = DatabaseActor()\n}\n\n// 2. ViewModel isolated to the MainActor\n@MainActor\nclass ProfileViewModel: ObservableObject {\n    @Published var username: String = \"Loading...\"\n\n    // This function can be called from any async context.\n    func fetchUser() async {\n        // Hop off the main actor to do background work\n        let user = await loadUserFromDB()\n        // Hop back to MainActor is implicit here due to class annotation.\n        // This UI update is now guaranteed to be on the main thread.\n        self.username = user.name\n    }\n\n    // 3. Isolate this specific function to our custom DatabaseActor\n    @DatabaseActor\n    private func loadUserFromDB() async -> User {\n        // This is now a protected context for database operations,\n        // preventing concurrent writes/reads from other parts of the app.\n        print(\"Current thread: \\(Thread.current)\") // Not the main thread\n        // ...database logic...\n        return User(name: \"Jane Doe\")\n    }\n}\nstruct User { let name: String }\n```\n\n**Common Pitfalls:**\n- **Over-isolation:** Annotating an entire complex class with `@MainActor` can cause performance issues if many of its methods don't need the main thread. Use `nonisolated` for functions that are thread-safe and don't touch UI to avoid unnecessary hops to the main thread.\n- **Blocking the UI:** `@MainActor` serializes tasks, it doesn't make them non-blocking. A long-running synchronous task or a long `await` on the main actor will still freeze the UI. Offload heavy work to a background `Task` or a different actor.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "MainActor",
        "global-actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Explain how `withThrowingTaskGroup` manages child task lifecycle and error propagation. How does its cancellation behavior enforce the principles of structured concurrency?",
      "back": "A `TaskGroup` provides a structured way to run a dynamic number of child tasks concurrently. The `withThrowingTaskGroup` function creates a scope where the parent task is suspended until all child tasks complete. This enforces structured concurrency by ensuring the parent's scope cannot exit while child tasks are still running, preventing orphaned tasks.\n\nWhen a child task added via `group.addTask` throws an error, the group's behavior is critical:\n1.  The group immediately enters a 'cancelled' state.\n2.  It implicitly cancels all other running child tasks in the group.\n3.  It continues to wait for all child tasks to complete (either by finishing their work, acknowledging the cancellation, or throwing their own error).\n4.  Once all tasks are finished, the `withThrowingTaskGroup` call rethrows the *first* error that was thrown.\n\n```swift\n// Fetches multiple images concurrently, failing if any single download fails.\nfunc fetchThumbnails(for ids: [String]) async throws -> [UIImage] {\n    var thumbnails: [UIImage] = []\n    // The group's scope ensures we don't return until all tasks are done.\n    try await withThrowingTaskGroup(of: UIImage.self) { group in\n        for id in ids {\n            // Dynamically add a new child task for each ID.\n            group.addTask {\n                let url = URL(string: \"https://example.com/img/\\(id).jpg\")!\n                // This task must check for cancellation to be a good citizen.\n                // URLSessionDataTask handles this automatically.\n                try Task.checkCancellation()\n                let (data, _) = try await URLSession.shared.data(from: url)\n                guard let image = UIImage(data: data) else { \n                    throw URLError(.badServerResponse) \n                }\n                return image\n            }\n        }\n        \n        // As tasks complete, collect their results.\n        // If any task throws, this loop breaks and the error propagates.\n        for try await image in group {\n            thumbnails.append(image)\n        }\n    }\n    return thumbnails\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting to drain the group:** Not iterating over all results (e.g., breaking a `for await` loop early without cancelling the group) can cause the task to remain suspended indefinitely.\n- **Ignoring Cancellation:** Child tasks performing long computations must manually check `Task.isCancelled` to halt work promptly when the group is cancelled. Network requests often handle this automatically.\n\n**Use vs. `async let`:**\n- **Task Group:** Ideal for a *dynamic* number of homogenous tasks (e.g., processing items in an array).\n- **`async let`:** Better for a *fixed*, small number of concurrent tasks, especially if they return different types. It offers a simpler, more declarative syntax.",
      "code_example": null,
      "tags": [
        "concurrency",
        "structured concurrency",
        "swift-concurrency",
        "async/await",
        "taskgroup"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain how Swift's `actor` model enforces data race safety at compile time, contrasting it with traditional lock-based approaches. What is actor re-entrancy and why is it a crucial concept to understand?",
      "back": "### Core Concept\n\nSwift's `actor` is a reference type that provides a synchronization mechanism to protect its mutable state from concurrent access, eliminating data races. This is achieved through **actor isolation**: the compiler enforces that all access to an actor's mutable properties and methods from the outside must be asynchronous (`await`). This effectively places incoming calls into a conceptual 'mailbox', which the actor processes serially, one at a time. This shifts the burden of thread safety from the developer (manual locking) to the compiler (static analysis), making concurrent code safer by default.\n\nThis contrasts sharply with traditional locks (`NSLock`, `DispatchQueue`), where developers must manually acquire and release locks around critical sections. This manual approach is error-prone, leading to issues like forgetting to unlock, deadlocks, and performance bottlenecks.\n\n**Actor Re-entrancy** is a key feature. When an actor-isolated function suspends (hits an `await`), it gives up its thread. The actor is now free to process other waiting tasks from its mailbox. When the awaited operation completes, the original function is rescheduled to continue. This prevents deadlocks (e.g., actor A calls actor B, which calls back to A) and improves throughput. However, it means the actor's state can be mutated by other tasks during a suspension point. A senior developer must always assume state has changed across any `await` and re-validate it.\n\n### Practical Code Example\n```swift\nactor TemperatureLogger {\n    private var measurements: [Double] = []\n    var high: Double = -Double.infinity\n\n    func log(temperature: Double) {\n        measurements.append(temperature)\n        if temperature > high {\n            high = temperature // Safe direct mutation\n        }\n    }\n\n    // This method has a suspension point (`await`)\n    func processAndUpload() async throws -> Double {\n        // Read current state before suspension\n        let currentHigh = self.high\n        print(\"Current high before await: \\(currentHigh)\")\n\n        // 'await' is a suspension point. Other tasks can run on this actor now.\n        // For example, another thread could call `log(temperature: 100)` here.\n        let serverResponse = await APIService.upload(data: measurements)\n        \n        // CRITICAL: State might have changed. Must re-read from self.\n        // Using `currentHigh` here would be a bug if state changed.\n        print(\"New high after await: \\(self.high)\")\n        return self.high // Return the potentially updated value\n    }\n}\n```\n### Common Pitfalls\n- **Stale State Across `await`:** The most common mistake is reading state, awaiting an async call, and then acting on the *old*, cached state variable. You must re-read the actor's state (`self.property`) after a suspension point if your logic depends on its latest value.\n- **Blocking Calls:** Performing long, synchronous, blocking work inside an actor method will block the entire actor, preventing it from processing other tasks and negating its concurrency benefits.\n- **Misusing `nonisolated`:** Using `nonisolated` on a method that subtly mutates state (e.g., through a non-isolated class instance it holds) breaks the actor's safety guarantees.\n\n### When to Use vs. Alternatives\n- **Use Actors for:** Encapsulating and protecting the mutable state of an object, like a cache, data manager, or repository. They are the modern, safe default for isolated state in Swift.\n- **Alternatives:**\n  - **Serial `DispatchQueue`:** A classic GCD approach. Provides serial execution but lacks the compiler safety and strong coupling of state-to-protection that actors provide.\n  - **Locks (`os_unfair_lock`)**: For performance-critical, fine-grained control over very small critical sections. They are much more dangerous and should be used sparingly due to the risk of deadlocks and priority inversion.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "data-races",
        "re-entrancy"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Describe how to use `AsyncStream` to adapt a non-async, callback-based API to the modern `async/await` world. What are the critical responsibilities when managing its continuation?",
      "back": "`AsyncStream` is a concrete type that conforms to the `AsyncSequence` protocol. Its primary role is to act as a bridge, adapting existing, non-structured asynchronous code\u2014like delegate patterns or callback closures\u2014into a modern `AsyncSequence` that can be iterated over with a `for await` loop.\n\n**Core Concept:**\nYou initialize an `AsyncStream` with a closure that provides a `continuation`. This continuation is your tool to communicate with the stream from your non-async code. The key responsibilities are:\n1.  **Yielding Values:** Call `continuation.yield(value)` whenever the legacy API produces a new value.\n2.  **Terminating the Stream:** Call `continuation.finish()` when the source of events is exhausted or an unrecoverable error occurs. This is crucial to allow the `for await` loop to terminate gracefully.\n3.  **Resource Management:** Use the `onTermination` closure to clean up resources (e.g., stop a timer, deregister a delegate). This closure is called when the stream is finished or when its consumer is cancelled.\n4.  **Handling Backpressure:** Be mindful of the buffering policy. If the producer (your callback) yields values faster than the consumer (the `for await` loop) consumes them, the buffer can grow. The default is `.unbounded`, which can lead to memory issues. Consider using `.bufferingNewest(n)` or `.bufferingOldest(n)`.\n\n**Practical Code Example (Adapting a Location Manager Delegate):**\n```swift\n// Hypothetical legacy location manager\nclass LocationManager {\n    var onLocationUpdate: ((CLLocation) -> Void)?\n    var onFinish: (() -> Void)?\n    func start() { /* Simulates starting updates */ }\n    func stop() { /* Simulates stopping updates */ }\n}\n\nfunc locations() -> AsyncStream<CLLocation> {\n    let manager = LocationManager()\n\n    return AsyncStream { continuation in\n        // Set the callback to yield values to the stream\n        manager.onLocationUpdate = { location in\n            continuation.yield(location)\n        }\n\n        // Set the completion callback to finish the stream\n        manager.onFinish = {\n            continuation.finish()\n        }\n\n        // Define cleanup logic for when the stream terminates\n        continuation.onTermination = { @Sendable _ in\n            print(\"Stream terminated. Stopping location manager.\")\n            manager.stop()\n        }\n\n        // Start the underlying work\n        manager.start()\n    }\n}\n\n// Usage:\nTask {\n    for await location in locations() {\n        print(\"New location: \\(location.coordinate)\")\n    }\n    print(\"Finished receiving location updates.\")\n}\n```\n\n**Common Pitfalls:**\n*   **Forgetting `finish()`:** The `for await` loop will hang indefinitely, leaking resources.\n*   **Leaking the Continuation:** The continuation must *never* escape the `AsyncStream` initializer closure. Storing it in a property is a serious programming error.\n*   **Mismanaging Termination:** Calling `yield()` after `finish()` will cause a runtime crash.\n*   **Ignoring Cancellation:** The `onTermination` closure is your chance to react to task cancellation and stop expensive work in the underlying legacy API.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "async-await",
        "asyncsequence",
        "asyncstream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Compare Actors, Serial Queues (GCD), and Locks for preventing data races. Describe the trade-offs of each and provide a scenario where one is clearly superior.",
      "back": "Data races occur when multiple threads access shared mutable state without synchronization, leading to unpredictable behavior. Swift provides several mechanisms to prevent this, each with distinct trade-offs.\n\n**1. Actors**\n- **Core Concept:** An actor is a reference type that protects its state from concurrent access. It creates a 'synchronization island', ensuring that only one task can access its mutable state at a time. The Swift compiler enforces this by requiring external access to an actor's properties and methods to be asynchronous (using `await`), which serializes access through the actor's mailbox.\n- **When to Use:** The default choice for new code in a Swift Concurrency environment. Ideal for encapsulating the state and logic of an object, like a view model, repository, or service.\n\n**2. Serial Queues (GCD)**\n- **Core Concept:** A classic approach using Grand Central Dispatch. By dispatching all read/write operations to a shared resource onto a single serial `DispatchQueue`, you guarantee that operations are executed one at a time, in order. Writes are often performed with `sync` or `async` calls, while reads can use the same pattern. For more complex scenarios, a concurrent queue with a barrier flag for write operations is a powerful pattern (Readers-Writer lock).\n- **When to Use:** Excellent for integrating with older, non-async codebases, or when you need to synchronize access to a resource not neatly encapsulated by an object (e.g., a file handle). It offers more manual control over execution priority (QoS).\n\n**3. Locks (`NSLock`, `os_unfair_lock`)**\n- **Core Concept:** A low-level, primitive synchronization mechanism. A thread must acquire a lock before entering a 'critical section' (code accessing shared state) and release it upon exit. This manually enforces mutual exclusion. `os_unfair_lock` is the modern, high-performance choice, replacing the older `OSSpinLock`.\n- **When to Use:** In performance-critical code where the overhead of dispatching to a queue or an actor's mailbox is unacceptable and the critical section is very short. This is an expert-level tool.\n\n**Code Example (Actor is the modern approach):**\n```swift\n// Actor provides compile-time safety\nactor BalanceManager {\n    private var balance: Decimal = 1000.0\n\n    func withdraw(amount: Decimal) -> Bool {\n        if balance >= amount {\n            balance -= amount\n            return true\n        }\n        return false\n    }\n}\n\n// A Serial Queue provides runtime safety\nclass BalanceManager_GCD {\n    private let syncQueue = DispatchQueue(label: \"com.balance.syncqueue\")\n    private var balance: Decimal = 1000.0\n\n    func withdraw(amount: Decimal) -> Bool {\n        syncQueue.sync { // .sync ensures exclusive access and returns the value\n            if balance >= amount {\n                balance -= amount\n                return true\n            }\n            return false\n        }\n    }\n}\n```\n\n**Pitfalls & Trade-offs:**\n- **Actors:** Can introduce suspension points with `await`, and passing non-`Sendable` types can create data races if not handled carefully (though Swift 6 aims to make this fully safe).\n- **Serial Queues:** No compiler protection; correctness relies on developer discipline. Prone to deadlocks if you call `sync` on a queue from a task already running on that same queue.\n- **Locks:** Most dangerous. Easy to forget to unlock, leading to deadlocks. Can cause priority inversion issues. They are not composable and don't integrate with Swift's structured concurrency.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "gcd",
        "data-race",
        "locks"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency improve upon unstructured models like GCD by managing task lifetime, cancellation, and error propagation? Explain the concept of a 'Task Tree'.",
      "back": "Structured Concurrency introduces a paradigm where concurrent tasks are organized into a hierarchy, often called a 'Task Tree.' This structure provides explicit scopes and lifetimes for tasks. Unlike 'unstructured' models like GCD where dispatched blocks run independently, a structured task has a clear parent-child relationship.\n\nThis hierarchy provides three critical guarantees:\n1.  **Lifetime Management:** A parent task cannot complete until all of its child tasks have finished. This eliminates 'leaked' tasks that might continue running after their results are no longer needed, a common bug with fire-and-forget GCD calls.\n2.  **Cancellation Propagation:** When a parent task is cancelled, the cancellation is automatically propagated to all its children. This drastically simplifies cancellation logic compared to manually managing cancellation flags or `NSOperation` states.\n3.  **Error Propagation:** If a child task throws an error, it is immediately propagated up to the parent, which can then handle it. This avoids complex nested completion handlers with `Result` types.\n\n**Code Example:**\n```swift\n// Fetches user profile data by running two network calls in parallel.\nfunc fetchUserProfile(for id: String) async throws -> UserProfile {\n    print(\"Parent task started for user \\(id)\")\n\n    // 'async let' creates child tasks that run concurrently.\n    // They are \"children\" of the `fetchUserProfile` task.\n    async let user = fetchUserDetails(id)\n    async let friends = fetchUserFriends(id)\n\n    // The function implicitly awaits both child tasks here before returning.\n    // If 'fetchUserFriends' throws, the 'user' task is cancelled.\n    // If the parent `fetchUserProfile` task is cancelled, both children are cancelled.\n    let profile = try await UserProfile(user: user, friends: friends)\n    \n    print(\"Parent task finished, all children completed.\")\n    return profile\n}\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` inside an `async` function creates a *new, detached, top-level task*. It breaks the parent-child relationship, losing all structured benefits. Use `async let` or `TaskGroup` to maintain structure.\n- **Ignoring Cancellation:** Cancellation is cooperative. Your long-running child task must periodically check for it with `try Task.checkCancellation()` or `Task.isCancelled` and stop its work. Without this check, the task will run to completion despite being 'cancelled.'\n\n**When to Use vs. Alternatives:**\n- **Structured Concurrency (`async let`, `TaskGroup`):** The default choice for all new concurrent code in Swift. It's safer and more readable. Use `async let` for a fixed number of parallel tasks and `TaskGroup` for a dynamic number.\n- **Unstructured `Task { ... }`:** Use deliberately for tasks that must outlive the current scope, like a background sync started from a view that might be dismissed. You are responsible for managing its lifetime.\n- **GCD/`OperationQueue`:** Still necessary for legacy code, Objective-C interoperability, or for specific features like `NSOperation` dependencies.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured-concurrency",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol helps prevent data races in Swift Concurrency. Describe a scenario where you'd need to use `@unchecked Sendable` and the risks involved.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's modern concurrency model, designed to provide compile-time guarantees against data races. It acts as a 'marker' protocol, indicating that a type's values can be safely copied and shared between different actors or tasks without introducing shared mutable state.\n\n**Core Concept:**\nA data race occurs when multiple threads access the same memory location concurrently, and at least one access is a write. `Sendable` prevents this by ensuring that any type passed across a concurrency boundary is either a value type (like a struct or enum) whose members are also `Sendable`, or a reference type (class) that is immutable or internally synchronized. The compiler enforces this, flagging attempts to pass non-`Sendable` types into actors or `Task` closures as errors.\n\n**Practical Code Example:**\n```swift\n// Structs with Sendable members are implicitly Sendable.\nstruct UserProfile: Sendable {\n    let id: Int\n    let username: String\n}\n\n// This class is NOT Sendable due to the 'var' property.\nclass UserSettings {\n    var isDarkMode: Bool = false\n}\n\n// This wrapper uses a lock, but the compiler can't see it.\n// We must manually and carefully assert its thread-safety.\nfinal class ThreadSafeSettings: @unchecked Sendable {\n    private let lock = NSLock()\n    private var _isDarkMode: Bool = false\n\n    var isDarkMode: Bool {\n        get { lock.withLock { _isDarkMode } }\n        set { lock.withLock { _isDarkMode = newValue } }\n    }\n}\n\nactor AccountManager {\n    private var settings = ThreadSafeSettings()\n\n    // OK: UserProfile is Sendable.\n    func updateProfile(_ profile: UserProfile) { /* ... */ }\n\n    // ERROR: Non-Sendable type 'UserSettings' passed across actor boundary.\n    // func updateUnsafeSettings(_ settings: UserSettings) { /* ... */ }\n\n    // OK: We've promised the compiler this is safe.\n    func updateSafeSettings(_ newSettings: ThreadSafeSettings) {\n        self.settings = newSettings\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\nThe most significant pitfall is misusing `@unchecked Sendable`. This directive overrides the compiler's safety checks. You are making a promise that you have ensured thread safety through other means (e.g., internal locking). If this promise is broken, you re-introduce the potential for data races that Swift Concurrency aims to eliminate. It's typically reserved for wrapping legacy, thread-safe Objective-C classes or complex custom synchronization patterns.\n\n**When to Use:**\nYou don't 'choose' to use `Sendable` as an alternative to something else; it's a fundamental requirement for passing data between actors and tasks in Swift Concurrency. The real choice is between designing your types to conform to `Sendable` (preferring value types like structs) versus falling back to older, manual synchronization primitives like locks or serial dispatch queues. Adhering to `Sendable` allows the compiler to reason about your code and provide powerful safety guarantees, which is strongly preferred over manual, error-prone locking mechanisms.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "sendable",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "How do `TaskGroup`s enable dynamic, structured concurrency in Swift, and what are the key considerations for error handling and cancellation within a group?",
      "back": "A `TaskGroup` provides a structured way to perform a dynamic number of concurrent child tasks. It's a cornerstone of structured concurrency, guaranteeing that the parent task will not continue until all child tasks in the group have completed.\n\n**Core Concept:**\nYou create a task group using `withTaskGroup` or `withThrowingTaskGroup`. Inside the group's closure, you can dynamically add child tasks using `group.addTask()`. The group acts as an asynchronous sequence, allowing you to iterate over the results as they complete. If any child task in a `withThrowingTaskGroup` throws an error, the group is automatically cancelled, and all other running child tasks will be notified of the cancellation. The `for try await` loop will then rethrow the original error.\n\n**Practical Code Example:**\n```swift\n// Fetches multiple image URLs concurrently and returns the downloaded images.\nfunc fetchImages(from urls: [URL]) async throws -> [UIImage] {\n    return try await withThrowingTaskGroup(of: UIImage.self) { group in\n        // Dynamically add a task for each URL.\n        for url in urls {\n            group.addTask { \n                let (data, _) = try await URLSession.shared.data(from: url)\n                // Check for cancellation before doing expensive work.\n                try Task.checkCancellation()\n                guard let image = UIImage(data: data) else {\n                    throw URLError(.badServerResponse) // Or a custom error\n                }\n                return image\n            }\n        }\n\n        // Collect results as they finish. `reduce` is a concise way to do this.\n        return try await group.reduce(into: [UIImage]()) { $0.append($1) }\n    }\n}\n```\n**Common Pitfalls & Edge Cases:**\n1.  **Implicit Cancellation:** If one task in a `withThrowingTaskGroup` throws, all other tasks are implicitly cancelled. You must check for cancellation (`try Task.checkCancellation()` or `Task.isCancelled`) within your child tasks to stop work early.\n2.  **Forgetting to Await Results:** The group's scope (`with...TaskGroup`) does not exit until all child tasks are complete, but you must explicitly `await` the results (e.g., via a `for try await` loop or `reduce`) to use them.\n3.  **Unstructured Tasks:** Calling `Task { ... }` inside a group breaks structured concurrency. Always use `group.addTask { ... }` to ensure the child task's lifetime is scoped to the group.\n\n**When to Use vs. Alternatives:**\n-   **Use `TaskGroup`:** When the number of concurrent tasks is **dynamic** or unknown at compile time (e.g., fetching data for a list of IDs).\n-   **Use `async let`:** When you have a **fixed, small number** of concurrent tasks known at compile time. The syntax is more lightweight and declarative for this specific scenario.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "taskgroup",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Describe how `@MainActor` enforces main-thread-only access at compile time. How does this differ from runtime checks, and when would you define a custom global actor for a non-UI-related shared resource?",
      "back": "### Core Concept\n\n`@MainActor` is a global actor that guarantees its code executes on the main thread. It achieves this through Swift's actor isolation model. When a type, function, or property is annotated with `@MainActor`, the compiler enforces that it can only be accessed from a context that is also on the main actor. Any attempt to access it from a different concurrency context (like a `Task` on a background thread) requires an `await` to safely transfer execution, or it will result in a compile-time error. This is a fundamental shift from the older `DispatchQueue.main.async` pattern, which was a runtime mechanism. With GCD, you could forget to dispatch to the main queue, leading to runtime crashes or UI glitches that the compiler couldn't detect.\n\nCustom global actors generalize this concept. They allow you to define a globally unique actor to serialize access to any shared resource, not just the UI. This is useful for resources like a database connection, a file logger, or a keychain wrapper that must be accessed serially from various parts of your application.\n\n### Code Example\n\n```swift\n// 1. Define a custom global actor for a logging resource\n@globalActor\nstruct LoggerActor {\n    actor ActorType {}\n    static let shared = ActorType()\n}\n\n@MainActor // This entire class is isolated to the main actor\nclass ContentViewModel: ObservableObject {\n    @Published var data: String = \"Loading...\"\n\n    // This property can only be mutated from the main actor.\n    // The compiler will enforce this.\n\n    func fetchData() {\n        Task {\n            // This task runs on a background thread by default\n            let result = await performNetworkRequest()\n            \n            // Compile Error if you just write `updateData(with: result)`!\n            // Must 'await' to hop back to the MainActor\n            await updateData(with: result)\n            \n            await logCompletion()\n        }\n    }\n\n    private func performNetworkRequest() async -> String {\n        try? await Task.sleep(nanoseconds: 1_000_000_000) // Simulate network\n        return \"Data Loaded!\"\n    }\n    \n    // Because the class is @MainActor, this method is too.\n    private func updateData(with result: String) {\n        self.data = result\n    }\n    \n    // 2. Use the custom global actor to isolate logging calls\n    @LoggerActor\n    private func logCompletion() {\n        // This code is now guaranteed to run serially on the LoggerActor\n        print(\"Logging operation complete.\")\n    }\n}\n```\n\n### Common Pitfalls\n\n*   **Over-isolation:** Marking an entire large class with `@MainActor` can be problematic if it contains heavy, non-UI logic. This can inadvertently lead to blocking the main thread. It's often better to isolate only the specific properties or methods that require main-thread access.\n*   **Misunderstanding `await`:** `await` on a `@MainActor` function doesn't make the work non-blocking; it suspends the current task and re-schedules it on the main actor's executor. If the main thread is already blocked, the task will have to wait.\n*   **`nonisolated`:** Forgetting to use `nonisolated` for thread-safe properties (like constants) or synchronous, pure functions within an actor-isolated type can lead to unnecessary `await` requirements and potential deadlocks.\n\n### When to Use vs. Alternatives\n\n*   **`@MainActor` vs. `DispatchQueue.main.async`:** Always prefer `@MainActor` in modern Swift Concurrency code. It provides compile-time safety and makes the developer's intent explicit and verifiable. `DispatchQueue.main.async` should be reserved for legacy codebases or when interfacing with frameworks that don't yet support async/await.\n*   **Custom Global Actor vs. Standard `actor`:**\n    *   Use a standard `actor` when you need multiple, independent instances of a type that protects its own state (e.g., `actor BankAccount`).\n    *   Use a *global* actor when you have a single, app-wide resource that needs to be accessed serially from many unrelated types (e.g., a central logging service, a database connection pool). The global actor provides a convenient annotation (`@MyGlobalActor`) to achieve this without dependency injection.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "mainactor",
        "global-actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "How does the Swift `actor` model prevent data races, and what are the key differences between its compiler-enforced isolation and traditional lock-based synchronization? Discuss the role and risks of using `nonisolated`.",
      "back": "Swift's `actor` model provides data race safety by creating a synchronization boundary around its mutable state. An actor is a reference type that ensures only one task can access its state at a time, effectively creating a serial queue for its methods and properties.\n\n**Core Concept: Actor Isolation**\nAn actor protects its data by allowing only its own code to access it synchronously. Any access from outside the actor must be done asynchronously via an `await` call. This `await` is a potential suspension point, which signals to the Swift runtime that it must wait for the actor to become available to execute the request. This compiler-enforced mechanism, known as actor isolation, eliminates the need for manual locking (like mutexes or dispatch queues) and prevents entire classes of data race bugs at compile time.\n\n**Contrast with Locks:**\n- **Safety:** Actors are compiler-enforced, making it impossible to forget to 'lock' or 'unlock'. Traditional locks are manual and error-prone.\n- **Performance:** When a task `await`s an actor, its thread is not blocked. It can be used for other work, improving system throughput. A traditional lock blocks the thread entirely until the lock is released, wasting resources.\n- **Deadlocks:** While actors significantly reduce deadlock risk, they don't eliminate it (e.g., two actors awaiting each other). However, they avoid common lock-ordering deadlocks found with mutexes.\n\n```swift\nactor BankAccount {\n    private var balance: Double\n    // nonisolated allows synchronous access to immutable data\n    nonisolated let accountID: String\n\n    init(id: String, initialDeposit: Double) {\n        self.accountID = id\n        self.balance = initialDeposit\n    }\n\n    // This method is isolated to the actor's serial executor.\n    func withdraw(amount: Double) -> Double {\n        if balance >= amount {\n            balance -= amount\n            return balance\n        }\n        return balance // Not enough funds\n    }\n}\n\nfunc performTransactions(account: BankAccount) {\n    Task {\n        // 'await' is required to cross the actor boundary.\n        // This is a suspension point.\n        let newBalance = await account.withdraw(amount: 50.0)\n        print(\"New balance: \\(newBalance)\")\n        // The compiler would error here if we tried to access balance directly.\n        // print(account.balance) // Error: Actor-isolated property 'balance' can only be referenced from inside the actor\n    }\n}\n```\n\n**Role and Risks of `nonisolated`:**\nThe `nonisolated` keyword explicitly opts-out of actor isolation for a specific declaration. \n- **When to Use:** It's safe for immutable properties (`let`) or methods that only access immutable state or are otherwise thread-safe. This allows synchronous, non-awaiting access, which can be a useful performance optimization.\n- **Common Pitfalls:** The biggest risk is incorrectly marking a method as `nonisolated` when it accesses or mutates the actor's state. This completely bypasses the actor's protection, re-introducing the possibility of data races the actor was designed to prevent. It is a sharp tool that breaks the safety model if misused.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "data-race",
        "isolation"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency improve upon older concurrency models like GCD/Operations, particularly regarding task lifetime, cancellation, and error handling?",
      "back": "Swift's Structured Concurrency fundamentally rethinks asynchronous programming by imposing a hierarchical structure on concurrent tasks, a concept largely absent in Grand Central Dispatch (GCD) or Operation Queues.\n\n**Core Concept:**\nThe central idea is that every asynchronous task exists within a specific scope and has a defined lifetime tied to that scope. When a parent task creates child tasks (e.g., using `async let` or a `TaskGroup`), the parent cannot complete until all its children have finished. This parent-child relationship is enforced by the compiler and runtime, eliminating a whole class of bugs like leaked tasks or accessing data from a completed operation.\n\n- **Task Lifetime:** A child task cannot outlive its parent. This prevents resource leaks and ensures cleanup happens predictably.\n- **Cancellation:** If a parent task is cancelled, cancellation is automatically propagated down to all its child tasks. This is a significant improvement over the manual cancellation token management required with `Operation`.\n- **Error Handling:** Errors thrown by child tasks are automatically propagated up to the parent, where they can be handled using familiar `do-catch` blocks. If one child in an `async let` group throws, the other children are implicitly cancelled.\n\n**Practical Code Example:**\n```swift\nstruct UserProfile {\n    let info: UserInfo\n    let posts: [Post]\n}\n\n// Fetches user info and their posts concurrently.\nfunc fetchUserProfile(for userID: String) async throws -> UserProfile {\n    print(\"Parent task started.\")\n    // 'async let' creates two concurrent child tasks scoped to this function.\n    async let userInfo = fetchUserInfo(userID) // Child task 1\n    async let userPosts = fetchPosts(for: userID) // Child task 2\n\n    // The parent task implicitly waits here for both children to complete.\n    // If either child throws an error, it's caught here and the other child\n    // is automatically cancelled by the system.\n    let profile = try await UserProfile(info: userInfo, posts: userPosts)\n    print(\"Both child tasks completed.\")\n    return profile\n} // Parent scope ends; compiler guarantees children are finished.\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` instead of `async let` or a `TaskGroup` creates a new, detached top-level task. This breaks the parent-child hierarchy, losing automatic cancellation and error propagation from the original context.\n- **Ignoring Cooperative Cancellation:** Cancellation is not preemptive. A long-running child task must periodically check `Task.isCancelled` and throw a `CancellationError` to halt its execution gracefully.\n\n**When to use vs. Alternatives:**\n- **Structured Concurrency:** The modern default for any new asynchronous work in Swift. Ideal for operations with a clear beginning and end, like network requests or data processing.\n- **GCD/OperationQueue:** Still useful for legacy codebases, fine-grained control over execution contexts (e.g., a serial queue for a critical section), or complex dependency graphs that don't fit a simple parent-child model. However, they lack the compile-time safety and clarity of the new system.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured-concurrency",
        "async-await",
        "actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Beyond a simple lock, compare and contrast modern Swift mechanisms for preventing data races, like Actors and serial DispatchQueues. What are the trade-offs of each approach in terms of performance, safety, and complexity?",
      "back": "A data race occurs when multiple threads access shared mutable state without synchronization, with at least one access being a write. This leads to corrupted data and undefined behavior. Swift provides several mechanisms to ensure mutual exclusion.\n\n**Core Concepts & Comparison:**\n- **Serial `DispatchQueue`:** A classic GCD primitive. It executes tasks one at a time in FIFO order. By dispatching all read/write operations for a shared resource onto the same serial queue, you guarantee mutual exclusion at runtime. It's a robust and flexible pattern.\n- **Actors:** A Swift Concurrency feature. An actor is a reference type that protects its internal state from concurrent access. The Swift compiler enforces that any access to an actor's state from outside must be asynchronous (`await`) and serialized through the actor's executor. This provides powerful compile-time safety, making data races a compile error in many cases.\n\n**Practical Code Example (Actor):**\n```swift\n// An actor protects its state from data races.\nactor BankAccount {\n    private(set) var balance: Double\n\n    init(initialDeposit: Double) { self.balance = initialDeposit }\n\n    // This method is guaranteed to have exclusive access to `balance`.\n    func withdraw(_ amount: Double) {\n        if balance >= amount {\n            balance -= amount\n        }\n    }\n}\n\n// Usage is safe even with concurrent calls.\nlet account = BankAccount(initialDeposit: 500.0)\nTask { await account.withdraw(100.0) }\nTask { await account.withdraw(200.0) }\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Deadlocks:** Still a risk, especially with serial queues if you `sync` from one queue to another that is waiting on the first. Actors can also deadlock if two actors wait on each other.\n- **Actor Reentrancy:** When an actor `await`s a call, it is suspended, and other tasks can enter the actor. This can break state invariants if not handled carefully, a subtle issue that doesn't exist with non-reentrant serial queues.\n- **Performance Overhead:** `os_unfair_lock` is fastest for fine-grained locking. GCD queues and Actors have scheduling overhead. Over-synchronizing can serialize your code and eliminate parallelism.\n\n**When to Use vs. Alternatives:**\n- **Actors:** The default choice in modern Swift Concurrency. Ideal for modeling stateful objects. The compile-time safety is a major advantage for new development.\n- **Serial `DispatchQueue`:** A great choice for non-`async/await` code, interfacing with older APIs, or when you need more control (e.g., using barrier flags for a reader-writer pattern).\n- **Locks (`NSLock`, `os_unfair_lock`):** For performance-critical code where you've profiled and found GCD/Actor overhead to be a bottleneck. Requires careful manual management and is error-prone.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "gcd",
        "data race",
        "swift concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "When would you implement a custom `AsyncSequence` versus using `AsyncStream`? Explain `AsyncStream`'s role in bridging legacy APIs into Swift Concurrency.",
      "back": "An `AsyncSequence` is a protocol for a sequence of values that are produced asynchronously over time, which you can iterate using a `for await in` loop. While you can create a custom type conforming to `AsyncSequence` and its `AsyncIteratorProtocol`, this involves manually managing the iterator's state, which can be complex.\n\n`AsyncStream` is a concrete type that conforms to `AsyncSequence` and serves as a powerful bridge to adapt non-structured, event-driven APIs into the structured world of Swift Concurrency. It provides a `Continuation` which you use to imperatively push values (`yield`), signal completion (`finish`), or throw an error from within a non-async context, like a delegate method or a closure callback.\n\n**Practical Example: Bridging a Delegate-based API**\nImagine a legacy `LocationManager` that provides updates via a delegate. We can wrap it in an `AsyncThrowingStream` to provide a modern async interface.\n\n```swift\n// Assume a legacy LocationManager with a delegate pattern\nclass LocationManager {\n    // ... details omitted ...\n    func start() { /* ... */ }\n    func stop() { /* ... */ }\n}\n\n// Bridge to an AsyncSequence\nfunc locationStream() -> AsyncThrowingStream<CLLocation, Error> {\n    return AsyncThrowingStream { continuation in\n        // Create a delegate object that holds the continuation\n        let locationDelegate = LocationDelegate(continuation: continuation)\n        let manager = LocationManager(delegate: locationDelegate)\n        \n        // onTermination is critical for cleanup to prevent leaks\n        continuation.onTermination = { @Sendable _ in\n            manager.stop()\n            print(\"Location stream terminated and manager stopped.\")\n        }\n        \n        manager.start()\n    }\n}\n\n// Helper class to act as the delegate\nprivate class LocationDelegate: LocationManagerDelegate {\n    let continuation: AsyncThrowingStream<CLLocation, Error>.Continuation\n\n    init(continuation: AsyncThrowingStream<CLLocation, Error>.Continuation) {\n        self.continuation = continuation\n    }\n\n    func locationManager(_ manager: LocationManager, didUpdateLocation location: CLLocation) {\n        // Push a new value into the stream\n        continuation.yield(location)\n    }\n\n    func locationManager(_ manager: LocationManager, didFailWithError error: Error) {\n        // Finish the stream with an error\n        continuation.finish(throwing: error)\n    }\n}\n```\n\n**Common Pitfalls:**\n1.  **Backpressure:** `AsyncStream` has a buffer. If you `yield` values faster than the consumer can process them, the buffer may overflow and values can be dropped, depending on the `bufferingPolicy`.\n2.  **Leaking Resources:** Forgetting to implement cleanup logic in the `onTermination` closure is a common mistake that leads to resource leaks (e.g., the `LocationManager` never stops).\n3.  **Continuation Misuse:** The continuation must not be used after `finish` has been called. This will result in a runtime crash.\n\n**When to Use vs. Alternatives:**\n-   **Use `AsyncStream`:** The go-to choice for adapting existing, non-async code. Perfect for `NotificationCenter`, delegate patterns, KVO, or any callback-based API.\n-   **Implement custom `AsyncSequence`:** When you need full control over the iteration logic and state, especially when the sequence generation is self-contained (not driven by external events). A good example is an `AsyncSequence` that handles API pagination, where each call to `next()` fetches the next page.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "async-await",
        "asyncsequence",
        "asyncstream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}