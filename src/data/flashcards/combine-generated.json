{
  "topic": "combine",
  "generated_at": "2026-01-18T04:17:57.524041+00:00",
  "cards": [
    {
      "id": "combine_b90e0a9fafad",
      "front": "Your Combine pipeline is failing silently or producing unexpected output. How do you instrument it to trace the flow of values and events, and what are the tradeoffs of each debugging operator?",
      "back": "Debugging declarative Combine pipelines requires a different approach than imperative code. Instead of setting breakpoints on sequential lines, you tap into the stream of events using specialized operators.\n\n**Core Concepts & Operators:**\n\n1.  **`print(_:to:)`**: The simplest debugging tool. It prints a log of all publishing events (subscription, output, completion) as they pass through that point in the pipeline. It\u2019s excellent for getting a quick, high-level overview of a stream's activity.\n\n2.  **`handleEvents(...)`**: The most versatile operator. It provides closures that are called for specific lifecycle events: `receiveSubscription`, `receiveOutput`, `receiveCompletion`, `receiveCancel`, and `receiveRequest`. This allows for more targeted debugging, such as logging only values or only errors, or even triggering side effects like showing a loading indicator.\n\n3.  **`breakpoint(...)` & `breakpointOnError()`**: These operators pause execution and drop you into the LLDB debugger when a specific event occurs. `breakpointOnError()` is invaluable, as it only triggers when the upstream publisher emits a failure, allowing you to inspect the entire application state at the exact moment of error.\n\n**Practical Code Example:**\n\n```swift\nstruct Post: Decodable { let id: Int }\n\ncancellable = URLSession.shared.dataTaskPublisher(for: url)\n    // 1. Use print() to see the raw output from the network call.\n    .print(\"1. Network Output\")\n    .map(\\.data)\n    // 2. Use breakpointOnError() to catch any decoding failures.\n    .decode(type: [Post].self, decoder: JSONDecoder())\n    .breakpointOnError()\n    // 3. Use handleEvents to specifically log the count of decoded posts.\n    .handleEvents(receiveOutput: { posts in\n        print(\"2. Decoded \\(posts.count) posts\")\n    })\n    .flatMap { $0.publisher }\n    .filter { $0.id > 50 }\n    // 4. Print again after filtering to see what was removed.\n    .print(\"3. After Filtering\")\n    .sink(\n        receiveCompletion: { print(\"Completion: \\($0)\") },\n        receiveValue: { print(\"Final Value: \\($0.id)\") }\n    )\n```\n\n**Common Pitfalls:**\n\n*   **Operator Placement:** The position of a debugging operator is critical. Placing `print()` before a `filter` will show all elements, while placing it after shows only the elements that passed the filter.\n*   **Side Effects in `handleEvents`**: Be cautious about introducing state-modifying side effects in `handleEvents`. Its primary purpose is observation. Modifying state can lead to unexpected behavior and race conditions.\n*   **Over-logging:** Using `print()` on a publisher that emits values frequently (e.g., from a UI slider) can flood the console, making it difficult to read.\n\n**When to Use vs. Alternatives:**\n\n*   **`print()`**: Best for quick, initial investigations to confirm if a pipeline is emitting *anything* at all.\n*   **`handleEvents()`**: Use when you need to inspect a specific event (like cancellation or subscription) or when `print()` is too noisy and you need custom logging logic.\n*   **`breakpointOnError()`**: Your go-to for diagnosing errors. It's far more efficient than trying to catch an error in `sink` because it preserves the call stack and state at the point of failure.",
      "code_example": null,
      "tags": [
        "combine",
        "debugging",
        "reactive_programming"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_83feeebb4e47",
      "front": "Describe the core philosophical difference between Combine and async/await. When would you choose one over the other for handling complex, time-based event streams, and why?",
      "back": "The core difference is paradigmatic. Combine is a declarative, functional reactive framework for processing values over time. You define a pipeline of operators that transform, filter, and combine event streams, focusing on *what* should happen when data flows. Async/await provides an imperative, structured concurrency model. It allows you to write asynchronous code that reads sequentially, focusing on *how* to execute a series of steps that may suspend.\n\n**Practical Example:** Fetching and decoding a user profile.\n\n```swift\n// ViewModel properties\n@Published var user: User?\nprivate var cancellables = Set<AnyCancellable>()\nprivate let userURL = URL(string: \"https://api.example.com/user/1\")!\n\n// Combine: Declarative stream processing\nfunc fetchWithCombine() {\n    URLSession.shared.dataTaskPublisher(for: userURL)\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main) // Ensure UI updates are on the main thread\n        .sink(receiveCompletion: { print(\"Completion: \\($0)\") },\n              receiveValue: { [weak self] user in self?.user = user })\n        .store(in: &cancellables) // CRITICAL: stores the subscription\n}\n\n// async/await: Imperative, sequential logic\n@MainActor // Ensures properties are updated on the main actor\nfunc fetchWithAsyncAwait() async {\n    do {\n        let (data, _) = try await URLSession.shared.data(from: userURL)\n        self.user = try JSONDecoder().decode(User.self, from: data)\n    } catch {\n        print(\"Error fetching user: \\(error)\")\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Combine:** Forgetting `.store(in: &cancellables)` is a classic mistake, causing the subscription to be deallocated instantly and silently fail. Overly long operator chains can become difficult to debug (\"operator soup\").\n*   **async/await:** Not understanding that `await` is a suspension point where the function can be re-scheduled on a different thread unless constrained by an actor (like `@MainActor`). Forgetting to check `Task.isCancelled` in long-running loops can lead to unresponsive cancellation.\n\n**When to Use:**\n*   **Choose Combine** for reactive scenarios involving multiple, continuous event streams. It excels at composing events over time, such as debouncing search field input, observing multiple database properties, or reacting to notifications. Its strength is in managing the flow and transformation of data from one or more sources.\n*   **Choose async/await** for discrete, often sequential, asynchronous tasks. It's ideal for fetching data to populate a view, performing a single database transaction, or any operation with a clear start and a single completion (a value or an error). Its linearity greatly improves readability for these common cases.\n*   They can be used together. You can iterate over a publisher's values with `for await value in publisher.values { ... }`, bridging the declarative world of Combine into the imperative world of async/await.",
      "code_example": null,
      "tags": [
        "concurrency",
        "combine",
        "async/await",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "combine_1cf53805b48a",
      "front": "Discuss the tradeoffs between `catch`, `retry`, and `replaceError` in a Combine pipeline. How does the typed `Failure` associated type influence your strategy for stream recovery vs. termination?",
      "back": "In Combine, a publisher's stream terminates immediately upon receiving a failure event. Error handling operators provide strategies to intercept this failure and decide whether to recover or let the stream terminate.\n\n**Core Concept:**\nEvery `Publisher` has a `Failure` associated type. If it's `Never`, the publisher cannot fail. If it's a specific `Error` type, any failure must be of that type. This typed system forces developers to explicitly handle potential errors, preventing them from being ignored.\n\n- **`retry(_:)`**: Re-subscribes to the upstream publisher a specified number of times when a failure occurs. It's for transient errors (e.g., temporary network loss). It doesn't change the error type; it just delays the failure.\n- **`catch(_:)`**: Intercepts a failure and replaces the upstream publisher with a new one. This is for recovery. The new publisher must produce the same `Output` type, but can have a different `Failure` type (often `Never` to guarantee no further failures).\n- **`replaceError(with:)`**: A simpler version of `catch`. It replaces the failure with a single, static `Output` value. This immediately completes the stream successfully and changes the publisher's `Failure` type to `Never`.\n\n**Practical Code Example:**\n```swift\nenum APIError: Error { case network, decoding }\n\n// A publisher that simulates a failing network request\nfunc fetchUser(id: Int) -> AnyPublisher<String, APIError> {\n    return Future<String, APIError> { promise in\n        // Simulate a network call that fails 50% of the time\n        if Bool.random() {\n            promise(.success(\"User #\\(id)\"))\n        } else {\n            promise(.failure(.network))\n        }\n    }.eraseToAnyPublisher()\n}\n\nlet cancellable = fetchUser(id: 123)\n    .mapError { _ in APIError.decoding } // Example of transforming an error type\n    .retry(2) // 1. Attempt the fetch up to 3 times (1 initial + 2 retries)\n    .catch { error -> Just<String> in\n        // 2. If all retries fail, catch the error and provide a fallback publisher\n        print(\"All retries failed. Error: \\(error). Returning cached user.\")\n        return Just(\"Cached User\") // Just produces one value then completes.\n    }\n    // For a simpler case, you could use: .replaceError(with: \"Guest User\")\n    .sink {\n        print(\"Completion: \\($0)\") // Will be .finished, never .failure\n    } receiveValue: { user in\n        print(\"Received User: \\(user)\")\n    }\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Infinite Retry:** Using `retry()` without a count on a publisher that will always fail can create an infinite loop, consuming resources.\n- **Hiding Errors:** `replaceError` and `catch` (if returning a `Never` failure type) can swallow important errors. This is fine for UI updates where a default state is acceptable, but dangerous for critical business logic where the failure itself is meaningful information.\n- **Type Mismatches:** The publisher returned from a `catch` block must have the same `Output` type as the upstream publisher. A common mistake is to return a publisher with an incompatible `Output`.\n\n**When to use vs. Alternatives:**\n- **`retry`:** Best for transient, recoverable errors like network timeouts. The operation should be idempotent.\n- **`catch`:** Use when you have a meaningful fallback strategy that may itself be asynchronous, like fetching data from a local cache when the network fails.\n- **`replaceError`:** Ideal for when a simple, static default value is sufficient and the stream can terminate. It's the simplest way to guarantee a value for UI bindings.\n- **No Operator:** Sometimes, the best strategy is to let the stream fail and handle the error in the `sink`'s completion block, for example, by showing an alert to the user. This is appropriate for non-recoverable errors.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous",
        "Error Handling",
        "Swift"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "combine_32f69cce08dc",
      "front": "Describe the lifecycle of a Combine subscription and the role of `AnyCancellable`. How does its deinitialization trigger pipeline cancellation, and why is storing it crucial for preventing memory leaks and resource wastage?",
      "back": "### Core Concept\n\nA Combine publisher is inert until a subscriber attaches. The subscription process creates a chain of operators and a subscriber, which remains active and can receive values. This active subscription consumes resources (memory, network sockets, etc.).\n\nThe key to managing this lifecycle is the `Cancellable` protocol, with `AnyCancellable` being its primary concrete implementation. `AnyCancellable` is a type-erased class (a reference type) that wraps a subscription's cancellation logic.\n\nIts magic lies in its `deinit` method. When an `AnyCancellable` instance is deallocated by ARC (i.e., its reference count drops to zero), its `deinit` is called, which in turn calls `cancel()` on the underlying subscription. This action triggers a cancellation signal that propagates up the publisher chain, allowing each component to clean up its resources, close connections, and stop producing values. Storing the `AnyCancellable` in a property (typically a `Set<AnyCancellable>`) ties the subscription's lifetime to the lifetime of the owning object (e.g., a `ViewModel`). When the owner is deallocated, its properties are deallocated, triggering the cancellation.\n\n### Practical Code Example\n```swift\nimport Combine\n\nclass DataViewModel {\n    // A set to store subscriptions. When the ViewModel is deallocated,\n    // this set is also deallocated, cancelling all stored subscriptions.\n    private var cancellables = Set<AnyCancellable>()\n\n    @Published var data: String = \"Initial\"\n\n    init() {\n        fetchData()\n    }\n\n    func fetchData() {\n        let url = URL(string: \"https://api.example.com/data\")!\n        \n        URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: String.self, decoder: JSONDecoder())\n            .replaceError(with: \"Failed to load\")\n            .receive(on: DispatchQueue.main)\n            .sink { [weak self] fetchedData in\n                // Using [weak self] is still good practice inside closures\n                // to prevent strong reference cycles with the subscriber itself.\n                self?.data = fetchedData\n            }\n            // .store(in:) adds the AnyCancellable to our set, ensuring it lives\n            // as long as the ViewModel instance.\n            .store(in: &cancellables)\n    }\n}\n```\n### Common Pitfalls\n1.  **Forgetting to Store:** The most common mistake. If `.store(in:)` is omitted, the `AnyCancellable` returned by `.sink` is not retained. It deinitializes immediately, cancelling the subscription before any asynchronous work can complete. The network request would be fired and instantly cancelled.\n2.  **Incorrect Scope:** Storing the cancellable in a local variable of a method. The subscription will be cancelled as soon as the method returns and the local variable goes out of scope.\n3.  **Unnecessary `[weak self]`:** While generally safe, if the *only* thing you do in a sink is `.assign(to: \\.property, on: self)`, you don't need `[weak self]`. However, if you call methods on `self` like `self.process(value)`, `[weak self]` is crucial to avoid a retain cycle between the sink's closure and the `ViewModel`.\n\n### When to Use vs. Alternatives\n-   **`Set<AnyCancellable>`:** The standard pattern for objects like ViewModels that manage multiple, long-lived subscriptions. The lifecycle is automatically managed by the owner's lifecycle.\n-   **Single `AnyCancellable?` property:** Use when you need to manage a single subscription and might want to cancel it manually by setting the property to `nil`.\n-   **Async/Await (iOS 15+):** For many use cases, `async/await` is a modern alternative. You can iterate over a publisher's values with `for await value in publisher.values`. The subscription's lifetime is tied to the scope of the `Task` or the `for-await` loop, and cancellation is handled via `Task.cancel()`.",
      "code_example": null,
      "tags": [
        "Combine",
        "Memory Management",
        "ARC",
        "AnyCancellable",
        "Concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "combine_4d7c72d6d8db",
      "front": "How would you create a custom Combine Publisher to wrap a delegate-based API, such as `CLLocationManager`? Describe the roles of the `Subscription` and `Subscriber` in this process.",
      "back": "To wrap a delegate-based API, you create a custom `Publisher` that, upon receiving a `Subscriber`, creates a custom `Subscription` instance to manage the interaction.\n\n**Core Concept:**\n- **Publisher:** A value type that defines the output and failure types. Its only job is to implement the `receive(subscriber:)` method. In this method, it creates a `Subscription` and hands it off to the subscriber.\n- **Subscriber:** The object that receives values. It initiates the stream by subscribing to the `Publisher` and controls the flow of data by telling the `Subscription` how many values it can handle (`.request(_:)`).\n- **Subscription:** This is the heart of a custom publisher. It's a class that connects a specific publisher with a specific subscriber. Its key responsibilities are:\n  1.  **State Management:** It holds the `CLLocationManager` instance and acts as its delegate.\n  2.  **Lifecycle Control:** It starts location updates when demand is requested (`request(_:)`) and stops them on cancellation (`cancel()`) to prevent resource leaks.\n  3.  **Event Forwarding:** It receives delegate callbacks and forwards them as values or completions to the `Subscriber`.\n  4.  **Backpressure:** It must respect the demand signaled by the `Subscriber`, only sending as many values as were requested.\n\n**Code Example:**\n```swift\nimport Combine\nimport CoreLocation\n\n// 1. Define the custom Publisher\nstruct LocationPublisher: Publisher {\n    typealias Output = CLLocation\n    typealias Failure = Error\n\n    private let locationManager: CLLocationManager\n\n    init(locationManager: CLLocationManager = .init()) {\n        self.locationManager = locationManager\n    }\n\n    func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, S.Input == Output {\n        // 2. Create the Subscription and connect it to the Subscriber\n        let subscription = LocationSubscription(subscriber: subscriber, locationManager: locationManager)\n        subscriber.receive(subscription: subscription)\n    }\n\n    // 3. The Subscription class does all the heavy lifting\n    private final class LocationSubscription<S: Subscriber>: NSObject, Subscription, CLLocationManagerDelegate where S.Input == CLLocation, S.Failure == Error {\n        private var subscriber: S?\n        private let locationManager: CLLocationManager\n\n        init(subscriber: S, locationManager: CLLocationManager) {\n            self.subscriber = subscriber\n            self.locationManager = locationManager\n            super.init()\n            self.locationManager.delegate = self\n        }\n\n        // Called by the downstream subscriber to request data\n        func request(_ demand: Subscribers.Demand) {\n            // For this simple example, we start on any demand.\n            // A more complex publisher would track demand.\n            locationManager.startUpdatingLocation()\n        }\n\n        // Called when the subscription is cancelled\n        func cancel() {\n            locationManager.stopUpdatingLocation()\n            subscriber = nil // Break retain cycle\n        }\n\n        // MARK: - CLLocationManagerDelegate\n        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n            locations.forEach { _ = subscriber?.receive($0) }\n        }\n\n        func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n            subscriber?.receive(completion: .failure(error))\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Retain Cycles:** The `Subscription` holds the `Subscriber`. Ensure `subscriber` is set to `nil` in `cancel()` and upon completion to break any potential cycles.\n- **Ignoring Backpressure:** A naive implementation might forward all delegate events without checking demand. A robust publisher must buffer or drop events if demand is zero.\n- **Improper Cleanup:** Forgetting to call `stopUpdatingLocation()` in `cancel()` is a common bug that leads to significant battery drain.\n- **Thread Safety:** Delegate methods can be called on any thread. The `Subscription` must ensure it serializes calls to the `Subscriber` as per the Combine contract.\n\n**When to use vs. Alternatives:**\n- **Use Custom Publisher:** Ideal for bridging complex, stateful, or multi-event callback/delegate APIs into Combine. It provides the most control over lifecycle and backpressure.\n- **Alternatives:**\n  - **`Future`:** Use for a single asynchronous result (e.g., a one-shot network call). It's much simpler but can only emit one value or an error.\n  - **`PassthroughSubject`:** Can be used for a quick-and-dirty bridge by holding a subject in your delegate and calling `.send()` on it. This is simpler to implement but offers no backpressure handling and can make resource management (cancellation) more complex and error-prone.",
      "code_example": null,
      "tags": [
        "Combine",
        "Concurrency",
        "Architecture"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "combine_d81a9c91347b",
      "front": "Compare `map`, `flatMap`, and `combineLatest` in Combine. Describe a scenario where you would chain `flatMap` and then use `combineLatest` to merge the result with another independent stream.",
      "back": "These three operators are fundamental to transforming and combining streams in Combine, but serve distinct purposes.\n\n**Core Concept Explanation:**\n\n*   **`map`**: Performs a synchronous, one-to-one transformation on each value emitted by an upstream publisher. It's analogous to Swift's standard `map` on collections. It takes a value `A` and returns a value `B`. The closure you provide should not perform asynchronous work.\n\n*   **`flatMap`**: Transforms each upstream value into a *new publisher*. It then subscribes to these inner publishers and flattens their emissions into a single downstream. This is essential for chaining dependent asynchronous operations, like network requests. It takes a value `A` and returns a `Publisher<B, Error>`.\n\n*   **`combineLatest`**: Merges two or more publishers. It waits until each publisher has emitted at least one value. Afterwards, it emits a new tuple containing the latest value from each source publisher whenever *any* of them emit a new value. It's ideal for UIs that depend on multiple, independent state sources.\n\n**Practical Code Example:**\nImagine fetching a user's profile, and concurrently fetching their account settings, then combining both to update the UI.\n\n```swift\nimport Combine\n\nstruct User { let id: Int; let name: String }\nstruct Settings { let isDarkMode: Bool }\n\n// Simulates network calls\nfunc fetchUser(id: Int) -> AnyPublisher<User, URLError> {\n    return Just(User(id: id, name: \"Jane Doe\"))\n        .setFailureType(to: URLError.self)\n        .eraseToAnyPublisher()\n}\n\nfunc fetchSettings(for userId: Int) -> AnyPublisher<Settings, URLError> {\n    return Just(Settings(isDarkMode: true))\n        .setFailureType(to: URLError.self)\n        .eraseToAnyPublisher()\n}\n\nlet userIdPublisher = PassthroughSubject<Int, URLError>()\nvar cancellables = Set<AnyCancellable>()\n\n// 1. flatMap is used to chain the dependent async call to fetch the user.\nlet userPublisher = userIdPublisher\n    .flatMap { userId -> AnyPublisher<User, URLError> in\n        return fetchUser(id: userId)\n    }\n    .share() // Use share() to avoid re-triggering fetchUser for each subscriber\n\n// 2. combineLatest merges two independent streams: the user and their settings.\nuserPublisher\n    .combineLatest(userPublisher.flatMap { fetchSettings(for: $0.id) })\n    .sink(receiveCompletion: { print($0) },\n          receiveValue: { (user, settings) in\n        print(\"User: \\(user.name), Dark Mode: \\(settings.isDarkMode)\")\n    })\n    .store(in: &cancellables)\n\nuserIdPublisher.send(123)\n// Output: User: Jane Doe, Dark Mode: true\n```\n\n**Common Pitfalls & Edge Cases:**\n\n*   **`map` vs. `flatMap` Confusion**: A common mistake is using `map` for an async operation. This results in a nested publisher type, e.g., `Publisher<Publisher<User, Error>, Error>`, instead of the desired `Publisher<User, Error>`. `flatMap` correctly unwraps this.\n*   **`combineLatest` Initial Emission**: It will not emit *any* value until all of its upstream publishers have emitted at least once. If one publisher is very slow or never emits, the stream will be blocked.\n*   **`flatMap` Concurrency**: By default, `flatMap` subscribes to inner publishers with no limit (`maxPublishers: .unlimited`). For sequential processing, you can use `.max(1)`, which is useful for avoiding race conditions in operations like uploads.\n\n**When to Use vs. Alternatives:**\n\n*   Use **`map`** for simple, synchronous data manipulation.\n*   Use **`flatMap`** for dependent, asynchronous sequences (e.g., fetch ID, then use ID to fetch details).\n*   Use **`combineLatest`** to aggregate the state of multiple independent streams (e.g., form validation where a button is enabled based on multiple text fields).\n*   An alternative to `combineLatest` is **`zip`**, which waits for a new value from *all* upstreams before emitting a tuple. It pairs emissions 1-to-1, whereas `combineLatest` uses the most recent value from other streams.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous Programming",
        "Reactive Programming",
        "Concurrency"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/power-of-swift/"
      ]
    },
    {
      "id": "combine_e78094e3e387",
      "front": "Describe the detailed lifecycle of a Combine subscription, from the moment a Subscriber attaches to a Publisher. What specific roles do the Subscription object and the concept of 'demand' play in this process?",
      "back": "The relationship between a Publisher and a Subscriber is a well-defined, protocol-driven contract that ensures controlled data flow and resource management. This lifecycle is centered around the `Subscription` object and the concept of 'demand' (backpressure).\n\n**Core Concept Explanation:**\n\n1.  **Attachment:** The process begins when `publisher.subscribe(subscriber)` is called. The publisher is now aware of a potential new subscriber.\n\n2.  **Handshake:** The publisher calls the subscriber\u2019s `receive(subscription: Subscription)` method. This is the critical handshake. The subscriber receives a `Subscription` object, which represents its unique connection to the publisher. At this point, no data has been sent.\n\n3.  **Signaling Demand:** The subscriber is now in control. It must call `subscription.request(_: Subscribers.Demand)` to signal how many values it's ready to receive. This is the core of backpressure. It can request `.unlimited` or a specific number (e.g., `.max(1)`). Without this call, no values will ever be sent.\n\n4.  **Value Emission:** Once demand is signaled, the publisher can begin sending values by calling the subscriber\u2019s `receive(_ input: Input) -> Subscribers.Demand` method. It will send at most the number of values requested. The subscriber can return a new demand from this method (e.g., `.max(1)`) to incrementally request more data.\n\n5.  **Termination:** The stream terminates in one of two ways:\n    *   The publisher sends a final event by calling `receive(completion: Subscribers.Completion<Failure>)`, with either `.finished` or `.failure(Error)`. After this, no more values are sent.\n    *   The subscriber (or the code holding the subscription) calls `subscription.cancel()`. This tears down the subscription, and the publisher should stop sending events.\n\n**Practical Code Example:**\n```swift\n// A custom subscriber to demonstrate the lifecycle methods\nclass IntSubscriber: Subscriber {\n    typealias Input = Int\n    typealias Failure = Never\n\n    private var subscription: Subscription?\n\n    // 1. Handshake: Publisher provides the subscription\n    func receive(subscription: Subscription) {\n        print(\"Subscriber received subscription\")\n        self.subscription = subscription\n        // 2. Initial Demand: Subscriber requests the first 3 items\n        subscription.request(.max(3))\n    }\n\n    // 3. Value Emission: Publisher sends a value\n    func receive(_ input: Int) -> Subscribers.Demand {\n        print(\"Subscriber received value: \\(input)\")\n        // We return .max(1) to request one more item for each one we receive\n        return .max(1)\n    }\n\n    // 4. Termination: Publisher signals completion\n    func receive(completion: Subscribers.Completion<Never>) {\n        print(\"Subscriber received completion: \\(completion)\")\n        self.subscription = nil\n    }\n}\n\nlet subscriber = IntSubscriber()\n(1...10).publisher.subscribe(subscriber)\n```\n\n**Common Pitfalls:**\n*   **Forgetting Demand:** A custom subscriber that doesn't call `request(_:)` in `receive(subscription:)` will never receive any values.\n*   **Leaking Subscriptions:** When using convenience subscribers like `.sink`, the returned `AnyCancellable` must be stored. If it's not retained, the subscription is immediately cancelled upon deallocation.\n*   **Ignoring Backpressure:** Always requesting `.unlimited` demand negates the benefits of backpressure, which can lead to performance issues or memory spikes if the publisher emits values faster than the subscriber can process them.\n\n**When to use vs Alternatives:**\n*   **Custom Subscriber:** Use for building new Combine operators or when you need extremely fine-grained control over demand. It is rarely needed in typical application-level code.\n*   **`.sink` / `.assign`:** These are the most common choices. They are built-in subscribers that handle the lifecycle details (including initial demand) for you. Use them for most use cases.\n*   **Async/Await (`.values`):** For Swift 5.5+, you can use `for await value in publisher.values`. This provides a modern, structured concurrency alternative to closures, simplifying error handling and flow control without manually managing cancellables.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous",
        "Reactive Programming",
        "Lifecycle"
      ],
      "sources": [
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}