{
  "topic": "combine",
  "generated_at": "2026-01-17T03:55:34.001180+00:00",
  "cards": [
    {
      "id": "combine_83feeebb4e47",
      "front": "Beyond syntax, when would you architect a feature using Combine's reactive streams versus async/await's structured concurrency? Discuss the trade-offs.",
      "back": "Combine and async/await are both powerful concurrency tools, but they solve different problems and represent different programming paradigms.\n\n**Core Concept Explanation**\n\n*   **Combine** is a declarative, functional reactive programming (FRP) framework. It treats asynchronous events as streams of values over time. You create pipelines of operators (`map`, `filter`, `debounce`) to transform and react to these values. It excels at handling many-to-many relationships between data sources and consumers. The core components are Publishers (emit values), Subscribers (receive values), and Operators (transform values).\n\n*   **Async/await** is a language feature for structured concurrency. It allows you to write asynchronous code that looks and reads like synchronous, linear code. It's imperative in nature. The `await` keyword suspends a function's execution until an asynchronous task completes, without blocking the thread. It's ideal for sequences of asynchronous operations where one step depends on the previous one.\n\n**Practical Code Example**\nFetching a user and then their avatar image:\n\n```swift\n// Combine Approach\nfunc fetchUserAndAvatarWithCombine(userId: Int) -> AnyPublisher<UIImage, Error> {\n    let userURL = URL(string: \"/users/\\(userId)\")!\n    // 1. Fetch user data\n    return URLSession.shared.dataTaskPublisher(for: userURL)\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n        // 2. Chain to fetch avatar using flatMap\n        .flatMap { user in\n            URLSession.shared.dataTaskPublisher(for: user.avatarURL)\n                .map(\\.data)\n                .compactMap(UIImage.init)\n                .mapError { $0 as Error } // Align error types\n        }\n        .receive(on: DispatchQueue.main) // Switch to main thread for UI updates\n        .eraseToAnyPublisher()\n}\n\n// Async/Await Approach\nfunc fetchUserAndAvatarWithAsyncAwait(userId: Int) async throws -> UIImage {\n    let userURL = URL(string: \"/users/\\(userId)\")!\n    // 1. Fetch user data, suspending execution\n    let (userData, _) = try await URLSession.shared.data(from: userURL)\n    let user = try JSONDecoder().decode(User.self, from: userData)\n    \n    // 2. Fetch avatar, suspending again\n    let (imageData, _) = try await URLSession.shared.data(from: user.avatarURL)\n    \n    guard let image = UIImage(data: imageData) else {\n        throw URLError(.cannotDecodeContentData)\n    }\n    return image\n}\n```\n\n**Common Pitfalls & Edge Cases**\n\n*   **Combine:** Forgetting to store the `AnyCancellable` from a subscription, causing it to be deallocated and cancelled immediately. Also, complex operator chains (\"operator soup\") can become difficult to debug, and type erasure with `.eraseToAnyPublisher()` can obscure the underlying logic.\n*   **Async/await:** Creating unstructured tasks (`Task { ... }`) without managing their lifecycle can lead to work continuing after it's no longer needed. Actor re-entrancy is a subtle but critical concept to understand to avoid race conditions and deadlocks.\n\n**When to Use vs. Alternatives**\n\n*   **Choose Combine when:**\n    *   Handling streams of events: UI control events (e.g., text field input with `.debounce`), KVO, Notifications, WebSocket messages.\n    *   You need powerful transformation operators: `combineLatest` to merge multiple inputs, `throttle` to limit event rates, `retry` for network resilience.\n    *   Your architecture is declarative and reactive, especially when using SwiftUI, where it's the native binding mechanism.\n\n*   **Choose async/await when:**\n    *   Performing a sequence of asynchronous tasks: Fetching data, processing it, then saving it to a database.\n    *   You prioritize readability and maintainability for linear asynchronous flows. The code is often much simpler.\n    *   Error handling is straightforward using the familiar `do-try-catch` pattern.\n\nThey are not mutually exclusive. A common pattern is to use `async/await` within a Combine pipeline (e.g., in a `flatMap`) or to bridge a one-shot Combine publisher to an async context using its `.values` property.",
      "code_example": null,
      "tags": [
        "concurrency",
        "combine",
        "async/await",
        "architecture",
        "swiftui"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_4d7c72d6d8db",
      "front": "Describe the process of creating a custom Combine Publisher. What are the roles of the `Publisher`, `Subscription`, and `Subscriber` protocols, and how does the `Subscription` object specifically handle demand and cancellation?",
      "back": "Creating a custom publisher involves orchestrating three key protocols:\n\n1.  **Publisher**: A stateless blueprint describing a sequence of values. Its sole responsibility is the `receive(subscriber:)` method, where it creates a `Subscription` to connect itself to a new `Subscriber`.\n2.  **Subscriber**: The consumer of values. It signals its readiness to receive data by requesting demand from its `Subscription`.\n3.  **Subscription**: The stateful link between *one* Publisher and *one* Subscriber. This is the most critical component. It must:\n    *   Handle `request(_ demand: Subscribers.Demand)`: This is the backpressure mechanism. The subscription should only send values to the subscriber if there is positive demand.\n    *   Handle `cancel()`: This is for cleanup. It must stop producing values and release any resources it holds (e.g., network connections, observers) to prevent memory leaks.\n\n**Code Example: A `NotificationCenter` Publisher**\n\n```swift\n// 1. The Publisher struct is stateless and generic.\nstruct NotificationPublisher: Publisher {\n    typealias Output = Notification\n    typealias Failure = Never\n\n    let name: Notification.Name\n    let center: NotificationCenter\n\n    func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, S.Input == Output {\n        // 2. Create and attach the stateful Subscription.\n        let subscription = NotificationSubscription(subscriber: subscriber, name: name, center: center)\n        subscriber.receive(subscription: subscription)\n    }\n}\n\n// 3. The Subscription class holds the state.\nprivate final class NotificationSubscription<S: Subscriber>: Subscription\n    where S.Input == Notification, S.Failure == Never {\n\n    private var subscriber: S?\n    private var observer: NSObjectProtocol?\n\n    init(subscriber: S, name: Notification.Name, center: NotificationCenter) {\n        self.subscriber = subscriber\n        self.observer = center.addObserver(forName: name, object: nil, queue: nil) { [weak self] notification in\n            // 4. Send value to the subscriber.\n            _ = self?.subscriber?.receive(notification)\n        }\n    }\n\n    // 5. Backpressure is handled here. For notifications, we can't control the source,\n    // but we honor the contract by not doing anything if demand is .none.\n    func request(_ demand: Subscribers.Demand) { /* No-op for this example */ }\n\n    // 6. Critical for cleanup to prevent leaks.\n    func cancel() {\n        if let observer = observer {\n            NotificationCenter.default.removeObserver(observer)\n        }\n        observer = nil\n        subscriber = nil // Break retain cycle\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **State in the Publisher:** A `Publisher` should be a struct and stateless. All state (buffered items, demand count, observers) must live in the `Subscription` class. This allows one publisher instance to be subscribed to multiple times without conflicts.\n*   **Ignoring Cancellation:** Forgetting to implement `cancel()` correctly is a common source of memory leaks and retain cycles. Always release resources and nil out references to the subscriber.\n*   **Violating Backpressure:** Sending values via `subscriber.receive()` without respecting the subscriber's demand breaks the Combine contract and can overwhelm downstream operators.\n\n**When to Use vs. Alternatives:**\n*   **Use Custom Publisher:** To wrap non-Combine asynchronous APIs (delegates, callbacks, KVO), or for complex event sources requiring custom buffering or resource management.\n*   **Alternatives:**\n    *   `Future`: Simpler for a single asynchronous result (e.g., a network call).\n    *   `PassthroughSubject` / `CurrentValueSubject`: Far easier for bridging imperative code into Combine. You can manually send values into the subject. This is often a more pragmatic choice than a full custom publisher implementation.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous",
        "Publisher",
        "Backpressure",
        "Architecture"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_1cf53805b48a",
      "front": "Compare and contrast the `retry`, `catch`, and `replaceError` operators in Combine for handling a failing network request. When would you choose one over the others?",
      "back": "In Combine, error handling operators intercept a failure event, preventing the subscription from terminating and allowing for recovery strategies.\n\n**Core Concepts:**\n- `retry(_ retries: Int)`: Re-subscribes to the upstream publisher when it fails, up to a specified number of times. It's ideal for transient errors (e.g., temporary network loss) where the original operation might succeed on a subsequent attempt.\n\n- `replaceError(with output: Output)`: Replaces an error with a single, default value. The stream then finishes successfully with that value. This is the simplest recovery mechanism, useful for providing a sensible default or cached value. The publisher's failure type becomes `Never`.\n\n- `catch(_ handler: (Failure) -> P)`: The most flexible operator. It catches an error and replaces the entire upstream publisher with a new publisher returned by the handler closure. This allows for complex logic, like falling back to a different data source (e.g., a local cache publisher) or transforming the error. The new publisher must have the same `Output` type but can have a different `Failure` type (often `Never`).\n\n**Code Example:**\n```swift\nstruct User: Decodable { let name: String }\nenum APIError: Error { case network, decoding }\n\nfunc fetchUser(url: URL) -> AnyPublisher<User, APIError> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .mapError { _ in APIError.network } // Map URLSession error to our custom type\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n        .mapError { _ in APIError.decoding } // Map decoding error\n        .eraseToAnyPublisher()\n}\n\nlet badURL = URL(string: \"https://example.com/user\")!\nlet defaultUser = User(name: \"Guest\")\n\n// 1. retry: For transient network issues\nfetchUser(url: badURL)\n    .retry(2) // Attempt the request up to 3 times (1 initial + 2 retries)\n    .sink(receiveCompletion: { print(\"Retry completion: \\($0)\") }, receiveValue: { print(\"Retry user: \\($0)\") })\n\n// 2. replaceError: Provide a default value\nfetchUser(url: badURL)\n    .replaceError(with: defaultUser)\n    .sink(receiveValue: { print(\"ReplaceError user: \\($0.name)\") })\n\n// 3. catch: Fallback to another publisher (e.g., from cache)\nfetchUser(url: badURL)\n    .catch { error -> Just<User> in\n        print(\"Caught error: \\(error), providing cached user.\")\n        return Just(defaultUser) // Fallback to a publisher that emits the default user\n    }\n    .sink(receiveValue: { print(\"Catch user: \\($0.name)\") })\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Infinite `retry`:** Using `retry` without a limit on a persistent error (like a 404) can create an infinite loop, wasting resources and potentially overwhelming a server.\n- **Type Mismatches in `catch`:** The publisher returned from a `catch` block MUST have the same `Output` type as the upstream publisher. A common mistake is trying to return a different type.\n- **Losing Error Information:** `replaceError` discards the specific error. If you need to log or react to the error type, use `catch` instead.\n\n**When to Use:**\n- **`retry`**: When failures are temporary and likely to resolve themselves, like a flaky connection.\n- **`replaceError`**: When a single, static default value is an acceptable fallback and you don't care about the specific error.\n- **`catch`**: When you need dynamic recovery logic, such as fetching from a cache, transforming the error, or logging the specific failure before providing a fallback.",
      "code_example": null,
      "tags": [
        "combine",
        "error-handling",
        "reactive-programming",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_b90e0a9fafad",
      "front": "A complex Combine pipeline is failing silently. Beyond simple `print`, what operators and techniques would you employ to thoroughly debug the event flow, from subscription to completion or cancellation?",
      "back": "Debugging declarative Combine pipelines requires specific tools because failures can be silent. The primary operators for this are `print`, `handleEvents`, and `breakpoint`.\n\n**Core Concept Explanation:**\n\n1.  **`print(_:to:)`**: The simplest tool. It logs all publishing events (subscription, output, completion) to the console with an optional prefix. It\u2019s great for a quick, high-level view of what a specific part of the pipeline is emitting.\n\n2.  **`handleEvents(...)`**: The most versatile and powerful debugging operator. It provides closures to intercept every lifecycle event without modifying the stream: `receiveSubscription`, `receiveOutput`, `receiveCompletion`, `receiveCancel`, and `receiveRequest`. This allows you to inspect the pipeline's state at any point, log custom messages, or even set breakpoints programmatically. It's essential for understanding *why* a pipeline might be stopping, such as an unexpected cancellation.\n\n3.  **`breakpoint(...)`**: This operator pauses the debugger by raising a `SIGTRAP` signal when specific events occur. You can configure it to break on `receiveSubscription`, `receiveOutput`, or `receiveCompletion`. The `receiveOutput` and `receiveCompletion` variants can include a condition, allowing you to pause execution only when a problematic value or error appears. This is invaluable for inspecting the full application state and call stack at the exact moment of an issue.\n\n**Practical Code Example:**\n```swift\nstruct Post: Codable { let id: Int }\nvar cancellables = Set<AnyCancellable>()\n\nURLSession.shared.dataTaskPublisher(for: URL(string: \"invalid-url\")!)\n    // 1. Use `print` for a quick, high-level check of network output.\n    .print(\"1. Network Fetch\")\n    .map(\\.data)\n    // 2. Use `handleEvents` for detailed lifecycle inspection.\n    .handleEvents(receiveSubscription: { sub in\n        print(\"  -> Subscription Received: \\(sub)\")\n    }, receiveCompletion: { completion in\n        print(\"  -> Pipeline Completed with: \\(completion)\")\n    }, receiveCancel: {\n        print(\"  -> Pipeline was cancelled.\") // Critical for silent failures\n    })\n    .decode(type: Post.self, decoder: JSONDecoder())\n    // 3. Use `breakpoint` to pause execution on a specific error.\n    .breakpoint(receiveCompletion: { completion in\n        if case .failure = completion { return true } // Break only on failure\n        return false\n    })\n    .sink(receiveCompletion: { _ in }, receiveValue: { _ in })\n    .store(in: &cancellables)\n```\n\n**Common Pitfalls:**\n\n*   **Forgetting `.store(in: &cancellables)`**: The most common cause of a pipeline \u201cdoing nothing.\u201d The subscription is created and immediately deallocated before any events can occur.\n*   **Misplacing Operators**: The placement of a debug operator matters. Placing `print` before a `map` shows the pre-transform value; placing it after shows the post-transform value.\n*   **Ignoring Cancellation**: A pipeline might be cancelled by a parent task or object deallocation. `handleEvents(receiveCancel:)` is the only way to reliably catch this silent termination.\n\n**When to Use vs. Alternatives:**\n\n*   **`print`**: Quick and easy for tracing values. Less useful for lifecycle events.\n*   **`handleEvents`**: The default choice for complex issues. Use it when you need to know *what* event happened and *when*, especially for subscription and cancellation.\n*   **`breakpoint`**: Use when a logged value isn\u2019t enough and you need to inspect the program's memory, call stack, and overall state at a specific point in the event stream.",
      "code_example": null,
      "tags": [
        "combine",
        "debugging",
        "swift",
        "asynchronous"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_32f69cce08dc",
      "front": "Describe the memory management lifecycle of a Combine pipeline. How does `AnyCancellable` interact with object lifecycles, and what are the critical pitfalls when capturing `self` in operators like `sink`?",
      "back": "The memory management of a Combine pipeline is centered around the `Cancellable` protocol, most commonly used via the `AnyCancellable` type-erased wrapper.\n\n**Core Concept:**\nA publisher is inert until a subscriber attaches. When you call `.sink` or `.assign`, a subscription is created, and an `AnyCancellable` instance is returned. This instance represents the active subscription. The subscription remains active and can receive values only as long as this `AnyCancellable` object is held in memory. When the `AnyCancellable` is deinitialized, it automatically calls `cancel()` on the subscription, tearing down the entire pipeline and releasing all associated resources. The standard pattern is to store these cancellables in a `Set<AnyCancellable>` property on the owning object (e.g., a ViewModel). When the owner is deinitialized, its `cancellables` set is also deinitialized, which in turn deinitializes all contained `AnyCancellable`s, automatically cancelling all subscriptions.\n\n**Code Example:**\n```swift\nclass UserViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    private let userAPI: UserAPI\n\n    init(userAPI: UserAPI) {\n        self.userAPI = userAPI\n        setupBindings()\n        print(\"ViewModel Initialized\")\n    }\n\n    deinit {\n        print(\"ViewModel Deinitialized - All subscriptions cancelled.\")\n    }\n\n    private func setupBindings() {\n        // This subscription's lifecycle is now tied to the ViewModel's lifecycle.\n        userAPI.fetchUsername()\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                // Handle completion\n            }, receiveValue: { [weak self] newName in\n                // [weak self] is crucial to prevent a retain cycle.\n                // ViewModel -> cancellables -> AnyCancellable -> sink closure -> ViewModel\n                guard let self = self else { return }\n                self.username = newName\n            })\n            .store(in: &cancellables) // Stores the AnyCancellable, keeping it alive.\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Forgetting `.store(in: &cancellables)`:** This is the most common mistake. If you don't store the returned `AnyCancellable`, it is deallocated at the end of the scope, and the subscription is immediately cancelled. You will never receive any values.\n2.  **Strong `self` Retain Cycle:** Capturing `self` strongly within a `sink` or other operator closure creates a retain cycle. The ViewModel holds the `cancellables` set, which holds the `AnyCancellable`, which holds the closure, which holds the ViewModel. Always use `[weak self]` or `[unowned self]` to break this cycle.\n3.  **Using `assign(to:on:)`:** The older `assign(to: \\.property, on: self)` creates a strong reference to `self` by default, causing a retain cycle. Prefer using `.sink` with `[weak self]` or, if available, use the `assign(to:)` operator on a `Never`-failure publisher which is safer.\n\n**When to Use vs. Alternatives:**\n-   **`store(in:)`:** Use this for 99% of cases where a subscription's lifetime should match its owner's (e.g., a ViewModel fetching data for a view).\n-   **Manual `.cancel()`:** If you need to imperatively stop a long-running subscription before the owner deallocates (e.g., cancelling an old network request when a new one starts), you can store the `AnyCancellable` in a dedicated property and call `.cancel()` on it.\n-   **Async/Await:** For one-shot asynchronous operations (e.g., a single API call), `async/await` is often much simpler as it doesn't require manual subscription management. Combine excels when dealing with streams of events over time, not just single asynchronous results.",
      "code_example": null,
      "tags": [
        "combine",
        "memory-management",
        "arc",
        "concurrency",
        "cancellable"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_d81a9c91347b",
      "front": "You need to fetch a user profile, then their posts using the profile's ID. Separately, you fetch their app settings. How do you model this with Combine operators like map, flatMap, and combineLatest?",
      "back": "This scenario requires understanding how to handle both sequential, dependent asynchronous operations and parallel, independent ones.\n\n### Core Concept Explanation\n\n*   **`map`**: A synchronous 1-to-1 transformation operator. It takes an input value from an upstream publisher and applies a function to transform it into a new output value. It does *not* create a new publisher. Use it for simple data manipulation, like converting a `Data` object to a `UIImage` or formatting a `String`.\n\n*   **`flatMap(maxPublishers:)`**: The key operator for chaining dependent asynchronous calls. It takes an upstream value and transforms it into a *new publisher* (e.g., a network request). Combine then subscribes to this new inner publisher and flattens its output into a single stream. This avoids nested publishers like `Publisher<Publisher<Post>>`.\n\n*   **`combineLatest`**: Merges multiple *independent* publishers. It waits until each publisher has emitted at least one value. Then, whenever *any* of the publishers emits a new value, `combineLatest` emits a tuple containing the most recent value from *all* of them.\n\n### Practical Code Example\n```swift\n// Mock API functions returning publishers\nfunc fetchUserID() -> AnyPublisher<String, Error> { /* ... */ }\nfunc fetchPosts(for userID: String) -> AnyPublisher<[String], Error> { /* ... */ }\nfunc fetchAppSettings() -> AnyPublisher<[String: Bool], Error> { /* ... */ }\n\n// 1. Start by fetching the user ID.\nlet postsPublisher = fetchUserID()\n    // 2. Use flatMap for the dependent async call.\n    // The output of fetchUserID (a String) is transformed into a new publisher.\n    .flatMap { userID -> AnyPublisher<[String], Error> in\n        return fetchPosts(for: userID)\n    }\n    .eraseToAnyPublisher()\n\n// 3. Fetch settings independently.\nlet settingsPublisher = fetchAppSettings()\n\n// 4. Use combineLatest to merge the two independent streams.\n// The pipeline now emits a tuple: ([Post], [Settings]).\nlet cancellable = Publishers.CombineLatest(postsPublisher, settingsPublisher)\n    .sink(\n        receiveCompletion: { completion in print(\"Completed: \\(completion)\") },\n        receiveValue: { (posts, settings) in\n            print(\"Received \\(posts.count) posts with settings: \\(settings)\")\n        }\n    )\n```\n\n### Common Pitfalls & Edge Cases\n\n*   **Using `map` instead of `flatMap`**: A common error is returning a publisher from `map`'s closure. This results in a nested publisher type (e.g., `Publisher<AnyPublisher<Data, URLError>, URLError>`), which is almost never what you want. If your transformation involves another async call, you need `flatMap`.\n*   **`combineLatest` Not Emitting**: `combineLatest` will not produce any output until *all* of its upstream publishers have emitted at least one value. If one publisher is very slow or fails, the entire stream is blocked or fails.\n*   **`flatMap` Concurrency**: `flatMap` has a `maxPublishers` parameter. By default, it's `.unlimited`, meaning it will create and subscribe to new inner publishers without limit. For operations like uploading multiple files, you might set it to `.max(3)` to limit concurrent network requests and avoid overwhelming the server.\n\n### When to Use vs. Alternatives\n\n*   **`flatMap`**: For sequential, dependent async calls (A -> B).\n*   **`combineLatest`**: For parallel, independent streams where you need the latest combined state (A + B -> C).\n*   **`zip`**: Use instead of `combineLatest` when you need to pair corresponding values from multiple streams. `zip` waits for a new value from *every* publisher before emitting a new tuple, making it ideal for stitching streams together in lockstep.\n*   **`merge`**: Use when you have multiple publishers of the same type and want to forward their values downstream as they arrive, in an interleaved fashion.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous",
        "Reactive Programming",
        "flatMap",
        "combineLatest"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    },
    {
      "id": "combine_e78094e3e387",
      "front": "Describe the contract between a Publisher and a Subscriber in Combine. What role does the Subscription object play in managing this relationship and handling backpressure?",
      "back": "The relationship between a Publisher and a Subscriber in Combine is governed by a strict, well-defined contract, with the `Subscription` object acting as the mediator.\n\n**Core Concept Explanation:**\nThe lifecycle is as follows:\n1.  A `Subscriber` attaches to a `Publisher` by calling `publisher.subscribe(subscriber)`.\n2.  The `Publisher` acknowledges this by calling the subscriber's `receive(subscription:)` method exactly once, passing a `Subscription` object.\n3.  The `Subscriber` must then call `subscription.request(_:)` to signal its demand (i.e., how many values it's ready to receive). This is the core of Combine's backpressure mechanism. It can request `.unlimited` or a specific number.\n4.  The `Publisher` can then send values by calling the subscriber's `receive(_:)` method. It MUST NOT send more values than the total cumulative demand requested.\n5.  The sequence terminates when the `Publisher` sends a single completion event via `receive(completion:)`, which can be either `.finished` or a `.failure(Error)`.\n6.  After a completion event, no further values are sent. The `Subscriber` can also terminate the sequence at any time by calling `subscription.cancel()`.\n\n**Practical Code Example:**\nThis custom subscriber demonstrates the contract by explicitly managing demand.\n\n```swift\n// A custom subscriber to illustrate the contract\nclass IntSubscriber: Subscriber {\n    typealias Input = Int\n    typealias Failure = Never\n\n    private var subscription: Subscription?\n    private var receivedCount = 0\n    private let demand: Subscribers.Demand = .max(2)\n\n    func receive(subscription: Subscription) {\n        print(\"Subscriber received subscription\")\n        self.subscription = subscription\n        // 1. We have the subscription, now we request initial data.\n        subscription.request(demand)\n    }\n\n    func receive(_ input: Int) -> Subscribers.Demand {\n        receivedCount += 1\n        print(\"Subscriber received value: \\(input)\")\n        // 2. We return .none, indicating we aren't requesting more values *right now*.\n        // We could also return .max(1) to request one more for each one received.\n        return .none\n    }\n\n    func receive(completion: Subscribers.Completion<Never>) {\n        print(\"Subscriber received completion: \\(completion)\")\n        self.subscription = nil\n    }\n}\n\nlet publisher = (0...10).publisher\nlet subscriber = IntSubscriber()\npublisher.subscribe(subscriber)\n// Output:\n// Subscriber received subscription\n// Subscriber received value: 0\n// Subscriber received value: 1\n// (It stops after 2 values because that was our initial demand)\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Forgetting to Store `AnyCancellable`:** When using convenience subscribers like `.sink` or `.assign`, the returned `AnyCancellable` must be stored. If it's deallocated, the subscription is immediately cancelled, and you'll receive no values. This is a common source of bugs.\n- **Ignoring Backpressure:** Most built-in subscribers like `.sink` request `.unlimited` demand by default. For high-frequency publishers (e.g., network streams, sensor data), this can lead to memory pressure or performance issues. A custom subscriber is needed to manage this flow control.\n- **Threading:** Publishers can emit values on any thread. Forgetting to use `receive(on:)` to shift delivery to the main queue before updating the UI will cause crashes.\n\n**When to Use vs. Alternatives:**\n- **Use Combine:** For handling streams of asynchronous events over time, especially when you need to transform, filter, or combine multiple streams. It excels in declarative programming, particularly with SwiftUI.\n- **Alternatives:**\n    - **Async/Await:** Better suited for asynchronous operations that have a clear start and finish to produce a single result (e.g., a single network call). They can be used together, for example by wrapping an async function in a `Future` publisher.\n    - **Closures/Delegates:** Suitable for simple, single-event notifications. They become unwieldy (callback hell) when chaining multiple asynchronous operations.",
      "code_example": null,
      "tags": [
        "combine",
        "reactive programming",
        "publisher",
        "subscriber",
        "concurrency",
        "backpressure"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}