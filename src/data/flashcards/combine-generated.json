{
  "topic": "combine",
  "generated_at": "2026-01-10T03:57:26.895057+00:00",
  "cards": [
    {
      "id": "combine_b90e0a9fafad",
      "front": "A complex Combine pipeline is failing silently or behaving unexpectedly. Describe a systematic approach to debugging it, moving from simple logging to more advanced lifecycle inspection techniques.",
      "back": "Debugging declarative Combine pipelines requires a different mindset than imperative code. Since data flows through a chain of operators, you must instrument the stream itself to gain visibility.\n\n**Core Concept: A Layered Approach**\n\nA systematic approach involves adding increasingly powerful debugging operators at strategic points in the pipeline to isolate the issue.\n\n1.  **`print(_:to:)`**: This is the simplest tool. It prints every event (subscription, output, completion) that passes through it. It's excellent for a quick, initial check to see if a pipeline is emitting values at all.\n\n2.  **`handleEvents(...)`**: This operator provides fine-grained access to the entire publisher lifecycle. It's more powerful than `print()` because you can insert custom logic for specific events like `receiveSubscription`, `receiveOutput`, `receiveCompletion`, `receiveCancel`, and `receiveRequest`. This is crucial for distinguishing between a pipeline that never got subscribed to versus one that completed without emitting values.\n\n3.  **`breakpoint(...)` & `breakpointOnError()`**: These operators pause execution in the debugger when a specific event occurs. `breakpointOnError()` is invaluable for catching failures before a downstream operator like `.catch` or `.replaceError` can swallow them. This allows you to inspect the call stack and variable states at the exact moment of failure.\n\n**Practical Code Example:**\n\nImagine a pipeline that fetches and decodes a user, but the JSON is malformed.\n\n```swift\nstruct User: Codable { let id: Int, name: String }\nvar cancellables = Set<AnyCancellable>()\n\n// Malformed JSON data (missing 'name')\nlet badJSON = \"\"\"{\"id\": 123}\"\"\".data(using: .utf8)!\n\nJust(badJSON)\n    .print(\"1. Initial Data\") // Quick check: Does data flow?\n    // `print` output: \n    // 1. Initial Data: receive subscription: (Just)\n    // 1. Initial Data: request unlimited\n    // 1. Initial Data: receive value: (14 bytes)\n    // 1. Initial Data: receive finished\n\n    .decode(type: User.self, decoder: JSONDecoder())\n    // A `print` here would show nothing, as the decode operator fails and terminates the stream.\n\n    // Use handleEvents to see the specific completion failure.\n    .handleEvents(receiveCompletion: { completion in\n        if case .failure(let error) = completion {\n            // This block will execute, revealing the decoding error.\n            print(\"2. Decoding failed with error: \\(error)\")\n        }\n    })\n\n    // Use breakpointOnError to pause execution right after the failure.\n    .breakpointOnError() // Debugger will pause here.\n\n    .catch { _ in Just(User(id: -1, name: \"Default\")) } // Error is handled here.\n\n    .sink { user in\n        print(\"3. Final User: \\(user.name)\")\n    }\n    .store(in: &cancellables)\n```\n\n**Common Pitfalls:**\n\n*   **Operator Placement:** The position of a debug operator is critical. Placing `breakpointOnError()` *after* a `.catch` operator will have no effect, as the error has already been handled and replaced.\n*   **Silent Cancellation:** Forgetting to store the `AnyCancellable` returned by `.sink` or `.assign` causes the subscription to be cancelled immediately. `handleEvents(receiveCancel: { ... })` is the perfect tool to diagnose this.\n*   **Threading:** Debug operators run on the scheduler defined by upstream operators (e.g., `receive(on:)`). Be aware that `print` or `breakpoint` might execute on a background thread, which can be confusing if you're expecting main thread behavior.",
      "code_example": null,
      "tags": [
        "Combine",
        "Debugging",
        "Reactive Programming",
        "Asynchronous"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_32f69cce08dc",
      "front": "Explain the lifecycle of a Combine subscription and the role of `AnyCancellable`. How do you manage its memory to prevent leaks, especially when `self` is captured in a closure?",
      "back": "In Combine, a subscription's lifecycle is tied directly to the lifetime of the `AnyCancellable` instance returned when you subscribe (e.g., via `sink` or `assign`). If this `AnyCancellable` is deallocated, it automatically sends a `cancel()` signal up the publisher chain, tearing down the subscription and releasing all associated resources. This is a key mechanism for preventing memory leaks from long-running, unterminated streams.\n\nThe developer is responsible for retaining this `AnyCancellable`. The most idiomatic way is to store it in a `Set<AnyCancellable>`, which automatically calls `cancel()` on all its members upon deinitialization.\n\n**Code Example:**\n```swift\nclass UserViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    private let dataService: DataService\n\n    init(dataService: DataService) {\n        self.dataService = dataService\n        setupBindings()\n    }\n\n    private func setupBindings() {\n        dataService.userPublisher\n            .map(\\.name)\n            .receive(on: DispatchQueue.main)\n            // The sink closure captures `self` to update the username.\n            .sink { [weak self] newName in\n                // [weak self] is crucial here to break a retain cycle:\n                // self -> cancellables -> subscriber -> sink closure -> self\n                self?.username = newName\n            }\n            // Storing the cancellable ties its lifetime to the ViewModel.\n            // When the ViewModel deinitializes, this subscription is cancelled.\n            .store(in: &cancellables)\n    }\n}\n```\n**Common Pitfalls:**\n1.  **Forgetting to Store:** Not storing the `AnyCancellable` (e.g., `dataService.userPublisher.sink { ... }`) causes the subscription to be created and immediately cancelled, as the `AnyCancellable` has no owner and is deallocated at the end of the scope.\n2.  **Retain Cycles:** Using `assign(to: \\.property, on: self)` creates a strong reference to `self`. If the returned `AnyCancellable` is also stored in a property on `self`, a retain cycle is formed: `self -> cancellables -> subscription -> self`. The modern `assign(to: &$publishedProperty)` syntax avoids this issue. When using `sink`, always use `[weak self]` if the closure references `self` to prevent a similar cycle.\n\n**When to Use vs. Alternatives:**\n*   **`store(in: &Set<AnyCancellable>)`**: Best practice for most cases. Manages multiple subscriptions whose lifetimes should match the owner's (e.g., a `ViewModel`).\n*   **`var cancellable: AnyCancellable?`**: Use for a single subscription that you may need to control or cancel manually before the owner is deallocated.\n*   **`[weak self]` in Closures**: Essential for preventing retain cycles when a subscription's closure needs to reference its owner.",
      "code_example": null,
      "tags": [
        "combine",
        "memory management",
        "arc",
        "reactive programming",
        "cancellable"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "combine_83feeebb4e47",
      "front": "When building a feature that fetches user data, updates the UI, and listens for real-time profile changes, how would you decide between using Combine and async/await? Explain the trade-offs.",
      "back": "The choice between Combine and async/await depends on the nature of the asynchronous task: whether it's a single, finite operation or a continuous stream of events.\n\n**Core Concept Explanation**\n\n`async/await` is a language-level feature for structured concurrency, designed to make asynchronous code read like synchronous, linear code. It excels at handling functions that suspend their execution to perform a task and then resume with a single result or error. It simplifies control flow and error handling (`try/catch`).\n\n`Combine` is a declarative framework for processing values over time. It's built around the concepts of Publishers (emit values), Operators (transform values), and Subscribers (receive values). It's ideal for handling event streams, where multiple values can be emitted over an extended period.\n\n**Practical Code Example**\n\n```swift\n// Assume a simple User model and NetworkError enum\n\n// --- async/await: Best for one-shot operations ---\nfunc fetchUser(id: String) async throws -> User {\n    let (data, _) = try await URLSession.shared.data(from: userURL(with: id))\n    // Simple, linear control flow with standard try/catch\n    return try JSONDecoder().decode(User.self, from: data)\n}\n\n// --- Combine: Best for streams and complex transformations ---\nfunc userPublisher(id: String) -> AnyPublisher<User, Error> {\n    URLSession.shared.dataTaskPublisher(for: userURL(with: id))\n        .map(\\.data) // Pluck the data from the tuple\n        .decode(type: User.self, decoder: JSONDecoder()) // Decode the JSON\n        .receive(on: DispatchQueue.main) // Ensure delivery on the main thread\n        .eraseToAnyPublisher() // Type-erase for a clean API\n}\n```\n\n**Common Pitfalls or Edge Cases**\n\n*   **async/await**: A common pitfall is creating unstructured tasks (`Task { ... }`) when not needed, which forfeits structured concurrency benefits like cancellation propagation. Developers must also manually check for `Task.isCancelled` within long-running loops to make cancellation effective.\n*   **Combine**: The most frequent mistake is forgetting to store the `AnyCancellable` returned by `.sink` or `.assign`, causing the subscription to be deallocated immediately and the pipeline to never execute. Overusing `eraseToAnyPublisher()` can also lead to complex, hard-to-debug types.\n\n**When to Use vs. Alternatives**\n\n*   **Use `async/await` for:** The majority of asynchronous tasks that produce a single result. This includes network requests, database queries, and file I/O. It's the modern default for asynchronous Swift due to its readability and simpler mental model.\n*   **Use `Combine` for:**\n    1.  **Event Streams:** Handling UI events (e.g., `UITextField` text changes), `NotificationCenter` events, or KVO observations.\n    2.  **Declarative Data Binding:** It's the foundation of SwiftUI. `@Published` properties are Combine publishers, allowing the UI to reactively update when data changes.\n    3.  **Complex Pipelines:** When you need to `debounce` user input, `combineLatest` from multiple sources, or apply a complex chain of transformations (`flatMap`, `filter`, `throttle`).\n\nFor the feature described, a hybrid approach is best: use `async/await` for the initial user data fetch. For real-time updates (e.g., from a WebSocket or server-sent events), use a Combine publisher to model the stream of changes, which can then be easily bound to the UI.",
      "code_example": null,
      "tags": [
        "concurrency",
        "combine",
        "async/await",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "combine_4d7c72d6d8db",
      "front": "Explain the process of creating a custom Combine Publisher. What are the roles of the `Publisher` and `Subscription` protocols, and how do they manage the publishing lifecycle and backpressure?",
      "back": "Creating a custom publisher involves implementing two key protocols: `Publisher` and `Subscription`. This pattern separates the declaration of the event stream from its execution.\n\n**Core Concept:**\n1.  **`Publisher`:** This protocol defines the event stream. Its primary responsibility is to implement the `receive(subscriber:)` method. This method is called for each new subscriber. Inside, you create a custom `Subscription` instance, passing it the subscriber, and then attach the subscription to the subscriber. The publisher itself is typically a lightweight struct.\n\n2.  **`Subscription`:** This protocol is the engine of the publisher. It's a class that manages the state for a single subscription. It must implement:\n    *   `request(_ demand: Subscribers.Demand)`: The subscriber calls this to indicate it can receive more values. This is the core of backpressure. Your subscription must track this demand and only send values when demand is greater than zero.\n    *   `cancel()`: The subscriber calls this to terminate the stream. Your subscription must stop its work and release any resources (e.g., invalidate timers, cancel network tasks).\n\nThe lifecycle is: `Subscriber` -> `Publisher.receive(subscriber:)` -> `Publisher` creates `Subscription` -> `Subscriber.receive(subscription:)` -> `Subscriber` calls `Subscription.request(_:)` -> `Subscription` sends values and a final completion event.\n\n**Practical Code Example:**\n```swift\n// A Publisher that emits an integer every second, a specific number of times.\nstruct IntervalPublisher: Publisher {\n    typealias Output = Int\n    typealias Failure = Never\n\n    let interval: TimeInterval\n    let times: Int\n\n    func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, S.Input == Output {\n        let subscription = IntervalSubscription(subscriber: subscriber, interval: interval, times: times)\n        subscriber.receive(subscription: subscription)\n    }\n}\n\nprivate final class IntervalSubscription<S: Subscriber>: Subscription where S.Input == Int, S.Failure == Never {\n    private var subscriber: S?\n    private let interval: TimeInterval\n    private var remaining: Int\n    private var demand: Subscribers.Demand = .none\n    private var timer: Timer?\n\n    init(subscriber: S, interval: TimeInterval, times: Int) {\n        self.subscriber = subscriber\n        self.interval = interval\n        self.remaining = times\n    }\n\n    func request(_ demand: Subscribers.Demand) {\n        self.demand += demand\n        // Start the timer only if needed and not already running\n        if timer == nil && self.demand > .none && remaining > 0 {\n            timer = Timer.scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in\n                self?.tick()\n            }\n        }\n    }\n\n    private func tick() {\n        guard let subscriber = subscriber, demand > .none, remaining > 0 else {\n            // If conditions aren't met, stop and clean up.\n            timer?.invalidate()\n            timer = nil\n            return\n        }\n\n        demand -= 1\n        let newDemand = subscriber.receive(remaining) // Send value\n        demand += newDemand // Subscriber can add new demand\n        remaining -= 1\n\n        if remaining == 0 {\n            subscriber.receive(completion: .finished)\n            cancel()\n        }\n    }\n\n    func cancel() {\n        timer?.invalidate()\n        timer = nil\n        subscriber = nil // Break retain cycle\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Ignoring Backpressure:** Sending more values than requested by the downstream `demand`. This violates the Combine contract.\n*   **Resource Leaks:** Failing to invalidate timers, close network connections, or release resources in the `cancel()` method.\n*   **Retain Cycles:** The subscription holds a strong reference to the subscriber. Ensure `cancel()` or completion breaks this cycle by setting `subscriber = nil`.\n*   **Forgetting Completion:** A publisher stream must terminate with either `.finished` or `.failure`. Forgetting to send a completion can leave downstream subscribers in an indeterminate state.\n\n**When to Use vs. Alternatives:**\n*   **Use a Custom Publisher:** For wrapping non-Combine asynchronous APIs (e.g., delegate patterns, C-based APIs), managing complex resources, or when you need fine-grained control over backpressure.\n*   **Use `Future` or `Deferred`:** For simpler one-shot async operations.\n*   **Use `PassthroughSubject`:** For imperatively pushing values into a stream, often to bridge UI actions or existing imperative code into a reactive workflow.",
      "code_example": null,
      "tags": [
        "combine",
        "reactive",
        "asynchronous",
        "architecture",
        "backpressure"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "combine_1cf53805b48a",
      "front": "In a Combine pipeline, how would you handle recoverable vs. unrecoverable errors without terminating the stream for the former, and what are the key operators?",
      "back": "Combine treats any error as a terminal event, terminating the subscription. To build resilient pipelines, you must explicitly handle these errors to prevent the stream from dying on recoverable failures.\n\n**Core Concept:**\nThe strategy is to intercept an error before it reaches the subscriber. The `catch` operator is perfect for this. It receives the upstream failure and requires you to return a new publisher of the same `Output` and `Failure` type. This is where you can implement logic to differentiate between error types.\n\n- **Recoverable Error (e.g., expired token):** Inside `catch`, you can trigger a side-effect (like a token refresh) and return a new publisher that retries the original request. The key is that you are replacing the failed stream with a new, valid one.\n- **Unrecoverable Error (e.g., decoding error, invalid URL):** For these, you want the stream to terminate as intended. From within `catch`, you can return a `Fail` publisher, which immediately fails with the original or a new error, thus propagating the terminal event downstream.\n\n**Code Example:**\n```swift\nenum NetworkError: Error {\n    case badURL\n    case unauthorized // Recoverable\n    case decodingFailed(Error) // Unrecoverable\n}\n\nfunc fetchData() -> AnyPublisher<String, NetworkError> {\n    // 1. A publisher that might fail with an 'unauthorized' error.\n    let url = URL(string: \"https://api.example.com/data\")!\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .tryMap { data, response in\n            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n                throw NetworkError.unauthorized\n            }\n            return data\n        }\n        .decode(type: String.self, decoder: JSONDecoder())\n        .mapError { error -> NetworkError in\n            // 2. Map upstream errors into our custom error type.\n            if error is NetworkError { return error as! NetworkError }\n            return .decodingFailed(error)\n        }\n        .catch { error -> AnyPublisher<String, NetworkError> in\n            // 3. The central error handling logic.\n            switch error {\n            case .unauthorized:\n                // 4. For a recoverable error, try to refresh and retry.\n                return refreshTokenAndRetry(request: urlRequest)\n            case .decodingFailed, .badURL:\n                // 5. For a fatal error, terminate the stream with a Fail publisher.\n                return Fail(error: error).eraseToAnyPublisher()\n            }\n        }\n        .eraseToAnyPublisher()\n}\n```\n\n**Common Pitfalls:**\n- **Type Erasure:** The publisher returned from `catch` must match the upstream publisher's type (`Output`, `Failure`). `eraseToAnyPublisher()` is essential for hiding the concrete types of the different publishers you might return (e.g., a `URLSession.dataTaskPublisher` vs. a `Fail` publisher).\n- **Accidental Completion:** Using `replaceError(with:)` or returning `Just(...)` from `catch` will send a value and then a `.finished` completion. This is fine for one-off requests but will incorrectly terminate a long-lived stream that should continue listening for values after an error is handled.\n- **Retry Loops:** Using `retry(_:)` for non-transient errors without a `catch` can cause infinite loops, consuming network and battery resources.\n\n**When to Use vs. Alternatives:**\n- **`catch`:** Best for complex, conditional recovery logic where you might substitute the stream.\n- **`tryCatch`:** A variant of `catch` where the recovery closure itself can throw an error.\n- **`retry(_:)`:** Use *before* `catch` for transient errors (e.g., temporary network loss) where simply re-subscribing might work. It's simpler than `catch` for this specific use case.",
      "code_example": null,
      "tags": [
        "combine",
        "swift",
        "reactive-programming",
        "error-handling",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "combine_d81a9c91347b",
      "front": "Compare and contrast Combine's `map`, `flatMap`, and `combineLatest` operators. Explain a scenario where you would choose `flatMap` over `map`, and another where `combineLatest` is the most appropriate choice.",
      "back": "These three operators are fundamental to Combine, but serve distinct purposes in managing asynchronous data streams.\n\n**Core Concept Explanation:**\n- **`map`**: A synchronous, 1-to-1 transformation operator. It takes a value from an upstream publisher, applies a closure to it, and passes the transformed value downstream. It's used for simple data manipulation, like converting a `Data` object to a `String` or formatting a number. The key is that the transformation itself does not return a new `Publisher`.\n\n- **`flatMap`**: An asynchronous transformation operator. It takes an upstream value and transforms it into a *new publisher*. `flatMap` then subscribes to this new inner publisher and merges its emissions into the main stream. This is essential for chaining dependent asynchronous operations, like making a network request based on the result of a previous one. It effectively \"flattens\" a publisher of publishers (`Publisher<Publisher<Output, Failure>>`) into a single stream (`Publisher<Output, Failure>`).\n\n- **`combineLatest`**: A merging operator. It combines two or more publishers into a single stream that emits a tuple containing the latest value from each. It fires an initial value only after *all* publishers have emitted at least once. Thereafter, it emits a new tuple whenever *any* of the source publishers emits a new value. It's ideal for UI logic that depends on multiple independent states, like form validation.\n\n**Practical Code Example:**\n```swift\n// Assume these functions exist and return publishers\nfunc fetchUserID(for username: String) -> AnyPublisher<Int, Error> { /* ... */ }\nfunc fetchUserProfile(for userID: Int) -> AnyPublisher<String, Error> { /* ... */ }\nfunc fetchUserPreferences() -> AnyPublisher<[String: Bool], Never> { /* ... */ }\n\nlet usernamePublisher = PassthroughSubject<String, Error>()\nlet userPreferencesPublisher = fetchUserPreferences()\n\n// 1. `flatMap` is used to chain dependent async calls (userID -> userProfile)\nlet userProfilePublisher = usernamePublisher\n    .flatMap { username -> AnyPublisher<String, Error> in\n        // The output of this closure is a NEW publisher\n        return fetchUserID(for: username)\n            .flatMap { userID in\n                // Using the result (userID) to create another publisher\n                return fetchUserProfile(for: userID)\n            }\n            .eraseToAnyPublisher()\n    }\n\n// 2. `combineLatest` merges two independent streams (profile and preferences)\nlet viewModelPublisher = userProfilePublisher\n    .combineLatest(userPreferencesPublisher) // Combines profile and preferences\n    .map { (profile, preferences) -> String in // 3. `map` for simple transformation\n        return \"User: \\(profile), Dark Mode: \\(preferences[\"darkMode\"] ?? false)\"\n    }\n```\n\n**Common Pitfalls:**\n- **`map` vs. `flatMap`**: A common mistake is using `map` to start an async operation. This results in a nested publisher (`Publisher<URLSession.DataTaskPublisher, ...>`), which is rarely desired. Use `flatMap` to subscribe to and flatten the inner publisher.\n- **`combineLatest` Initial Emission**: It will not emit anything until *all* of its upstream publishers have produced at least one value. If one publisher never emits, the chain stalls.\n- **`flatMap` Concurrency**: By default, `flatMap` can subscribe to many inner publishers concurrently. To serialize operations (e.g., for search fields where you only want the latest request), use `flatMap(maxPublishers: .max(1))`, which is functionally equivalent to using the `switchToLatest` operator.\n\n**When to Use vs. Alternatives:**\n- **Use `map`**: For simple, synchronous data transformations.\n- **Use `flatMap`**: For chaining dependent asynchronous operations. Alternative: `switchToLatest` is a better choice for scenarios like search bars, where you want to cancel previous inner publishers (network requests) when a new one is created.\n- **Use `combineLatest`**: When UI or logic depends on the combined state of multiple independent streams. Alternative: `zip` pairs up emissions from multiple publishers, waiting for a new value from *each* before emitting a tuple. `merge` interleaves emissions from multiple publishers of the same type into a single stream.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous Programming",
        "Reactive Programming",
        "Operators"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "combine_e78094e3e387",
      "front": "Describe the subscription lifecycle in Combine. How do Publishers, Subscribers, and the Subscription object interact to manage data flow, backpressure, and cancellation?",
      "back": "The Combine subscription lifecycle is a well-defined, subscriber-driven protocol that ensures resources are managed efficiently and data flow is controlled.\n\n**Core Concept Explanation:**\nThe process begins when a `Subscriber` attaches to a `Publisher` by calling `publisher.subscribe(subscriber)`.\n\n1.  **`receive(subscription:)`**: The Publisher acknowledges the subscriber by calling its `receive(subscription:)` method, passing a `Subscription` object. This object represents the connection between the two and is crucial. The subscriber MUST store this subscription.\n\n2.  **`request(_:)` (Backpressure)**: The subscriber is now in control. It calls `subscription.request(_:)` to signal how many values it's prepared to receive (e.g., `.unlimited` or a specific number). This is Combine's backpressure mechanism, preventing a fast publisher from overwhelming a slow subscriber.\n\n3.  **`receive(_:)`**: Once demand is signaled, the Publisher begins sending values by calling the subscriber's `receive(_:)` method. It will never send more values than were requested.\n\n4.  **`receive(completion:)`**: The stream terminates in one of two ways: the Publisher sends a completion event (`.finished` or `.failure(Error)`) via the subscriber's `receive(completion:)` method. After this, no more values will be sent.\n\n5.  **`cancel()`**: At any point, the subscriber (or the owner of the subscription) can call `cancel()` on the subscription. This immediately stops the publisher from sending events and allows for resource cleanup, tearing down the entire pipeline.\n\n**Practical Code Example:**\n```swift\nimport Combine\n\nclass DataFetcher {\n    // A set to store subscriptions, keeping them alive.\n    private var cancellables = Set<AnyCancellable>()\n\n    func fetchAndProcessData() {\n        let url = URL(string: \"https://api.example.com/data\")!\n\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data) // Extract data from the tuple\n            .decode(type: String.self, decoder: JSONDecoder()) // Decode data\n            .receive(on: DispatchQueue.main) // Switch to main thread for UI updates\n            .sink(receiveCompletion: { [weak self] completion in\n                // Step 4: Stream completes with success or failure.\n                print(\"Completed with: \\(completion)\")\n                // The subscription is implicitly cancelled on completion.\n            }, receiveValue: { [weak self] value in\n                // Step 3: Subscriber receives a value from the publisher.\n                print(\"Received value: \\(value)\")\n                self?.updateUI(with: value)\n            })\n            // The .sink operator creates the subscriber and subscription.\n            // Storing the returned 'AnyCancellable' keeps the subscription alive.\n            .store(in: &cancellables)\n    }\n    \n    func updateUI(with text: String) { /* ... */ }\n}\n```\n**Common Pitfalls:**\n*   **Forgetting `.store(in: &cancellables)`**: The most common mistake. If the `AnyCancellable` returned by `sink` or `assign` is not retained, its `deinit` is called immediately, which cancels the subscription before any values can be received.\n*   **Retain Cycles**: Using `self` strongly inside the `sink` or `assign` closures while storing the cancellable in a property of `self`. Always use `[weak self]` to prevent memory leaks.\n*   **Ignoring Backpressure**: While `sink` and `assign` implicitly request `.unlimited` demand, when creating custom subscribers, failing to call `request(_:)` will result in no values being emitted.\n\n**When to Use vs Alternatives:**\n*   **Combine vs. Async/Await**: For a single, one-shot asynchronous request, `async/await` is often simpler and more readable. Combine excels when you need to transform, chain, or merge multiple asynchronous event streams over time (e.g., user input, network responses, notifications).\n*   **Combine vs. Callbacks/Delegates**: Combine provides a declarative, compositional API that avoids nested callbacks (\"callback hell\") and makes complex event-handling logic easier to reason about and test.",
      "code_example": null,
      "tags": [
        "combine",
        "reactive programming",
        "concurrency",
        "memory management",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://developer.apple.com/news/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}