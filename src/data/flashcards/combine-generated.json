{
  "topic": "combine",
  "generated_at": "2026-01-13T04:04:10.582327+00:00",
  "cards": [
    {
      "id": "combine_32f69cce08dc",
      "front": "Explain the lifecycle of a Combine subscription and the role of `AnyCancellable`. What are the two most common memory-related pitfalls developers face, and how do you prevent them?",
      "back": "A Combine publisher is inert until a subscriber attaches. When this happens, a subscription is created, and its lifecycle begins. This connection remains active only as long as the `Cancellable` object, returned by operators like `sink` or `assign`, is retained in memory.\n\nThe key to memory management is the `AnyCancellable` class. It's a type-erasing class that conforms to the `Cancellable` protocol. Its `deinit` automatically calls `cancel()` on the subscription, which tears down the entire publisher pipeline, releasing all associated resources. This RAII (Resource Acquisition Is Initialization) pattern is fundamental to Combine.\n\n```swift\nclass UserViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        fetchUser()\n    }\n\n    func fetchUser() {\n        let url = URL(string: \"https://api.example.com/user/1\")!\n\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: User.self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                // Handle completion (e.g., error state)\n            }, receiveValue: { [weak self] user in\n                // [weak self] is crucial to prevent a retain cycle.\n                // The sink closure is retained by the subscription,\n                // which is retained by self.cancellables.\n                self?.username = user.name\n            })\n            // Storing the cancellable ties its lifecycle to the ViewModel's lifecycle.\n            .store(in: &cancellables)\n    }\n}\n```\n\n**Common Pitfalls & Prevention:**\n\n1.  **Forgetting to Store the Cancellable:** If the `AnyCancellable` returned by `sink` is not stored, it is deallocated at the end of the current scope. This immediately cancels the subscription, often before any asynchronous work can complete. The publisher will fire, but no values will be received. This is a silent failure.\n    *   **Prevention:** Always use `.store(in: &cancellables)` or assign the result to a property to manage its lifetime explicitly.\n\n2.  **Creating Retain Cycles:** A strong reference cycle occurs if `self` retains the `AnyCancellable` (via a `cancellables` set), and the closure inside `sink` or `assign` strongly captures `self`. \n    *   **Prevention:** Use a weak capture list, `[weak self]`, inside the closure. This breaks the cycle, allowing `self` to be deallocated, which in turn deallocates the `cancellables` set and cancels the subscriptions.",
      "code_example": null,
      "tags": [
        "Combine",
        "Memory Management",
        "Concurrency",
        "Swift"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "combine_83feeebb4e47",
      "front": "Combine and async/await both handle asynchronicity. How do you decide which to use for a new feature, and what are the key architectural trade-offs between them?",
      "back": "The choice between Combine and async/await depends on the nature of the asynchronous task. They solve different aspects of concurrency.\n\n**Core Concept Explanation**\n\n*   **`async/await`**: A language feature for structured concurrency. It simplifies writing asynchronous code by allowing you to write it in a linear, sequential style, eliminating nested completion handlers (pyramid of doom). It's best suited for asynchronous operations that produce a single value (or error) and then complete, such as a network request for a piece of data.\n\n*   **`Combine`**: A declarative framework for processing values over time. It's built on the concepts of Publishers, Subscribers, and Operators. Combine excels at handling streams of events, such as user input, KVO notifications, or data that updates over time. It provides powerful operators to transform, filter, and combine these event streams.\n\n**Practical Code Example**\n\nFetching a user profile illustrates the difference:\n\n```swift\n// async/await: Clean, linear, and intuitive for a single result.\nfunc fetchUser(id: String) async throws -> User {\n    let url = URL(string: \"/users/\\(id)\")!\n    // The function suspends here, not blocking the thread.\n    let (data, _) = try await URLSession.shared.data(from: url)\n    // Execution resumes here after the data is fetched.\n    return try JSONDecoder().decode(User.self, from: data)\n}\n\n// Combine: A declarative pipeline for processing data.\nfunc fetchUser(id: String) -> AnyPublisher<User, Error> {\n    let url = URL(string: \"/users/\\(id)\")!\n    return URLSession.shared.dataTaskPublisher(for: url)\n        // Operator to extract data; handles URL/network errors.\n        .map(\\.data)\n        // Operator to decode the data into a User object.\n        .decode(type: User.self, decoder: JSONDecoder())\n        // Erase to a generic publisher type for the API boundary.\n        .eraseToAnyPublisher()\n}\n```\n\n**Common Pitfalls & Edge Cases**\n\n*   **Combine**: Forgetting to store the `AnyCancellable` subscription, causing the pipeline to be immediately cancelled and deallocated. Also, dealing with complex type signatures and the overuse of `eraseToAnyPublisher()` can make debugging difficult.\n*   **async/await**: Creating unstructured tasks (`Task { ... }`) without managing their lifecycle can lead to work continuing after it's no longer needed (e.g., after a view disappears). Misunderstanding structured concurrency can lead to unexpected behavior or resource leaks. Awaiting tasks sequentially in a loop when they could be run in parallel with a `TaskGroup` is a common performance mistake.\n\n**When to Use vs. Alternatives**\n\n*   **Use `async/await` for**: Replacing completion handlers, performing sequential asynchronous tasks (fetch A, then fetch B using A's result), and general one-off async work. Its primary benefit is code readability and maintainability for imperative logic.\n\n*   **Use `Combine` for**: Reacting to streams of events, like text field input for a search query. Binding data models to UI in MVVM. Combining multiple asynchronous data sources (`combineLatest`, `zip`). When you need to transform, debounce, or throttle events over time.\n\nThey are not mutually exclusive. You can bridge them by awaiting a publisher's value: `try await myPublisher.values.first()`. This is useful for migrating a Combine-heavy codebase to use async/await incrementally.",
      "code_example": null,
      "tags": [
        "Concurrency",
        "Combine",
        "async/await",
        "Architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_b90e0a9fafad",
      "front": "A complex Combine pipeline is failing silently or behaving unexpectedly. How would you systematically debug it, and what are the key differences between operators like `print`, `handleEvents`, and `breakpoint` in this process?",
      "back": "Debugging a silent Combine pipeline requires making its internal events visible. The core strategy is to incrementally add debugging operators at different stages to observe the flow of subscriptions, values, and completions, thereby isolating the point of failure.\n\n**Core Concept: Event Tracing**\nA Combine pipeline is a sequence of events. A silent failure usually means an event you expected (like a value) never arrived. This could be due to an upstream publisher completing early, an error being thrown and caught incorrectly, or an operator like `filter` or `compactMap` removing all values. The goal is to find where the event stream deviates from your expectation.\n\n**Practical Example & Operator Comparison**\nImagine a pipeline that fetches and decodes users, then filters them. If it yields no users, the bug could be anywhere.\n\n```swift\n// Assume a networking call that can fail decoding\nmyNetworkPublisher\n    .print(\"1: After Network\") // Use `print` for quick, comprehensive event logging.\n    .decode(type: [User].self, decoder: JSONDecoder())\n    // Use `breakpointOnError` to immediately halt if decoding fails.\n    .breakpointOnError()\n    .flatMap { $0.publisher } // Flatten the array into a stream of users\n    // Use `handleEvents` for targeted side-effects without altering the stream.\n    // Here, we log only the output and completion events.\n    .handleEvents(receiveOutput: { user in\n        print(\"2: Processing User: \\(user.id)\")\n    }, receiveCompletion: { completion in\n        print(\"3: Upstream Completed: \\(completion)\")\n    })\n    .filter { $0.isAdmin }\n    // Use `breakpoint` to inspect state at a critical point.\n    .breakpoint(receiveOutput: { user in\n        return user.id == 42 // Condition to trigger the breakpoint\n    })\n    .sink(...)\n```\n\n*   **`print(_:to:)`**: The simplest tool. It logs *every* event (subscription, request, output, completion, cancellation) to the console. It's great for a high-level overview but can be noisy.\n*   **`handleEvents(...)`**: Offers fine-grained control. You provide closures for specific events you care about (e.g., `receiveOutput`, `receiveCompletion`). Use this for targeted logging or to trigger side effects, like updating a loading indicator.\n*   **`breakpointOnError()`**: A lifesaver. It pauses execution in the debugger *only* if an error is emitted, taking you directly to the source of the failure.\n*   **`breakpoint(...)`**: The most powerful tool. It pauses the debugger when specified events occur, letting you inspect the call stack, variable values, and the complete program state. You can even set conditions for when it should trigger.\n\n**Common Pitfalls**\n*   **Ignoring Threading**: Placing a debug operator *before* a `receive(on: DispatchQueue.main)` means your log/breakpoint will be on a background thread. This can be misleading if you're debugging UI-related issues.\n*   **Silent Filtering**: An aggressive `filter` or a `compactMap` returning `nil` can silently drop all values. Use `print` or `handleEvents` before and after the operator to confirm if values are entering but not exiting.\n*   **Error Type Mismatches**: An upstream `mapError` or `catch` can swallow or transform an error, masking the original root cause. Debug before such operators to see the original failure.",
      "code_example": null,
      "tags": [
        "Combine",
        "Debugging",
        "Asynchronous",
        "Reactive Programming"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "combine_4d7c72d6d8db",
      "front": "Describe the roles of `Publisher`, `Subscription`, and `Subscriber` in a custom Combine publisher. Why is the `Subscription` object crucial for managing backpressure and resource cleanup?",
      "back": "In Combine, these three protocols work together to create a data stream:\n\n1.  **`Publisher`**: This is the source of values. Its primary role is to be a stateless blueprint. Its single required method, `receive(subscriber:)`, is called when a `Subscriber` attaches. The `Publisher`'s job is not to produce values itself, but to create and hand off a `Subscription` instance to the `Subscriber`. Keeping the `Publisher` as a struct (value type) is a best practice, ensuring it's reusable and thread-safe.\n\n2.  **`Subscriber`**: This is the consumer of values. It receives events from the `Subscription`: `receive(subscription:)` to start, `receive(_ input:)` for each value, and `receive(completion:)` for success or failure.\n\n3.  **`Subscription`**: This is the most critical piece. It's the stateful object that connects a single `Publisher` to a single `Subscriber`. It manages the actual work of producing and sending values. It's crucial for two main reasons:\n    *   **Backpressure**: The `request(_ demand:)` method is called by the `Subscriber` to signal how many values it's ready to receive. The `Subscription` must respect this demand and not overwhelm the `Subscriber`.\n    *   **Resource Cleanup**: The `cancel()` method is the hook for tearing down the stream. This is where you must release any resources, such as network connections, timers, or observers, to prevent memory leaks.\n\n**Code Example: A `NotificationCenter` Publisher**\n```swift\n// 1. The Publisher (stateless factory)\nstruct NotificationPublisher: Publisher {\n    typealias Output = Notification\n    typealias Failure = Never\n\n    private let name: Notification.Name\n\n    init(name: Notification.Name) { self.name = name }\n\n    func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, S.Input == Output {\n        // 2. Create a stateful Subscription for this specific subscriber\n        let subscription = NotificationSubscription(subscriber: subscriber, name: name)\n        subscriber.receive(subscription: subscription)\n    }\n}\n\n// 3. The Subscription (stateful worker)\nprivate final class NotificationSubscription<S: Subscriber>: Subscription where S.Input == Notification, S.Failure == Never {\n    private var subscriber: S?\n    private var observer: Any?\n    private var pendingDemand: Subscribers.Demand = .none\n\n    init(subscriber: S, name: Notification.Name) {\n        self.subscriber = subscriber\n        self.observer = NotificationCenter.default.addObserver(forName: name, object: nil, queue: nil) { [weak self] notification in\n            self?.onNext(notification)\n        }\n    }\n\n    // 4. Subscriber requests values\n    func request(_ demand: Subscribers.Demand) {\n        pendingDemand += demand\n    }\n\n    // 5. Cleanup logic\n    func cancel() {\n        if let observer = observer {\n            NotificationCenter.default.removeObserver(observer)\n        }\n        self.observer = nil\n        self.subscriber = nil\n    }\n\n    private func onNext(_ notification: Notification) {\n        guard let subscriber = subscriber, pendingDemand > 0 else { return }\n        \n        // Fulfill demand and get new demand from subscriber\n        pendingDemand -= 1\n        let newDemand = subscriber.receive(notification)\n        pendingDemand += newDemand\n    }\n}\n```\n**Common Pitfalls:**\n*   **State in the Publisher**: Placing the `observer` or `pendingDemand` in the `Publisher` struct would cause multiple subscribers to share state, leading to unpredictable behavior.\n*   **Ignoring Demand**: Sending values in `onNext` without checking `pendingDemand` violates the backpressure contract and can overwhelm the subscriber.\n*   **Memory Leaks**: Forgetting to call `removeObserver` in `cancel()` will cause the `Subscription` object to be retained indefinitely by `NotificationCenter`.\n\n**When to Use:**\n*   Use a custom publisher to wrap non-Combine asynchronous APIs (delegates, completion handlers, KVO) into an idiomatic, reusable, and backpressure-aware stream.\n*   **Alternatives**: For simpler cases, `PassthroughSubject` can bridge imperative code to a Combine stream, but it's less formal and doesn't encapsulate the source logic as cleanly. `Future` is only suitable for a single-value result.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous",
        "Architecture",
        "Reactive Programming"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "combine_e78094e3e387",
      "front": "Describe the contract and communication flow between a Publisher and a Subscriber in Combine. How is backpressure managed using `Subscription` and `Subscribers.Demand`, and why is this critical?",
      "back": "The relationship between a Publisher and a Subscriber is a well-defined protocol that ensures controlled and efficient data flow, centered around the concept of backpressure.\n\n**Core Concept: The Subscription Lifecycle**\n1.  **Attachment:** A `Subscriber` attaches to a `Publisher` by calling `publisher.subscribe(subscriber)`.\n2.  **Handshake:** The Publisher acknowledges the subscription by calling the Subscriber's `receive(subscription:)` method, passing a `Subscription` object. This object is the crucial link for communication from the Subscriber back to the Publisher.\n3.  **Requesting Values (Backpressure):** The Subscriber, now holding the subscription, calls `subscription.request(_:)` to signal its capacity to receive values. It can request `.unlimited()` or a specific number (e.g., `.max(1)`). This is the core of backpressure; the Publisher will *never* send more items than the total demand requested.\n4.  **Value Emission:** As the Publisher produces values, it sends them to the Subscriber via `receive(_:)`. Each value sent decrements the outstanding demand by one.\n5.  **Completion:** The stream terminates with a single call to `receive(completion:)`, which contains either a `.finished` or a `.failure(Error)` case.\n\nThis flow is critical because it prevents a fast Publisher from overwhelming a slow Subscriber, which could lead to unbounded memory growth and application instability.\n\n**Code Example:**\n```swift\n// A custom subscriber to demonstrate the lifecycle explicitly\nclass IntSubscriber: Subscriber {\n    typealias Input = Int\n    typealias Failure = Never\n    var subscription: Subscription?\n\n    // 1. Handshake: Publisher provides the subscription\n    func receive(subscription: Subscription) {\n        print(\"Subscriber received subscription\")\n        self.subscription = subscription\n        // 2. Initial Request: We signal we're ready for 1 value\n        subscription.request(.max(1))\n    }\n\n    // 3. Value Received: Process the value and request another\n    func receive(_ input: Int) -> Subscribers.Demand {\n        print(\"Subscriber received value: \\(input)\")\n        // We've processed the value, now we can handle one more.\n        return .max(1)\n    }\n\n    // 4. Completion: The stream has ended\n    func receive(completion: Subscribers.Completion<Never>) {\n        print(\"Subscriber received completion: \\(completion)\")\n        self.subscription = nil\n    }\n}\n\nlet publisher = [1, 2, 3].publisher\nlet subscriber = IntSubscriber()\npublisher.subscribe(subscriber)\n```\n**Common Pitfalls:**\n*   **Forgetting to Request:** If the subscriber never calls `subscription.request()`, it will never receive any values.\n*   **Ignoring Backpressure:** Always using `.unlimited()` demand with a potentially fast publisher (e.g., UI events) can lead to performance issues. It's better to process items and request more as capacity becomes available.\n*   **Leaking Subscriptions:** Forgetting to store the `AnyCancellable` returned by `.sink` or `.assign` causes the subscription to be cancelled immediately. In custom Subscribers, ensure `cancel()` is called on deinit.\n\n**When to Use vs. Alternatives:**\n*   **Combine:** Ideal for streams of events over time, complex asynchronous data transformations (chaining operators), and binding data to a UI. It excels at composition.\n*   **Async/Await:** Better for single, asynchronous operations that produce one result (or throw an error), like a network request. The code is often simpler to read for linear, non-streaming logic.",
      "code_example": null,
      "tags": [
        "combine",
        "reactive programming",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://developer.apple.com/news/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "combine_d81a9c91347b",
      "front": "Compare and contrast Combine's `map`, `flatMap`, and `combineLatest` operators. Describe a practical scenario where you would chain `map` and `flatMap`, and a separate scenario where `combineLatest` is the ideal choice.",
      "back": "These three operators are fundamental to Combine for transforming and combining streams of values, but they serve distinct purposes.\n\n**Core Concept Explanation:**\n\n*   **`map`**: A synchronous, 1-to-1 transformation operator. It takes a value from an upstream publisher, applies a closure to it, and emits the transformed value downstream. It's analogous to `Array.map`. The key is that the transformation logic itself is synchronous.\n\n*   **`flatMap`**: An asynchronous transformation operator. It takes an upstream value and transforms it into a *new publisher*. It then subscribes to this new inner publisher and forwards its emissions downstream. This is essential for chaining asynchronous operations, like making a network request for each ID emitted by a publisher. It 'flattens' a stream of publishers into a single stream of values. It can handle multiple inner publishers concurrently.\n\n*   **`combineLatest`**: A stream-merging operator. It takes two or more upstream publishers and emits a tuple containing the latest value from each. It only starts emitting after *all* upstreams have produced at least one value. Thereafter, it emits a new tuple whenever *any* of the upstream publishers emits a new value.\n\n**Practical Code Example:**\n\n```swift\n// ViewModel with publishers for user input and data fetching\nclass UserViewModel {\n    let userIdSubject = PassthroughSubject<Int, Never>()\n    let showDetailsSubject = CurrentValueSubject<Bool, Never>(false)\n    private var cancellables = Set<AnyCancellable>()\n    \n    struct UserProfile {\n        let name: String\n        let showExtraDetails: Bool\n    }\n\n    func setupBindings() {\n        // Scenario 1: Chaining `map` and `flatMap` to fetch data\n        let userPublisher = userIdSubject\n            .map { id -> URL in // map: Synchronously transform an Int ID to a URL\n                return URL(string: \"https://api.example.com/users/\\(id)\")!\n            }\n            .flatMap { url -> AnyPublisher<String, URLError> in // flatMap: Asynchronously transform URL into a publisher of a user's name\n                URLSession.shared.dataTaskPublisher(for: url)\n                    .map { String(data: $0.data, encoding: .utf8) ?? \"\" }\n                    .eraseToAnyPublisher()\n            }\n\n        // Scenario 2: `combineLatest` to create a final UI state\n        userPublisher\n            .combineLatest(showDetailsSubject) // Combines the fetched user name and a UI toggle state\n            .map { userName, showDetails -> UserProfile in // map: Synchronously combine the latest values into a single struct\n                UserProfile(name: userName, showExtraDetails: showDetails)\n            }\n            .sink(receiveCompletion: { _ in }, receiveValue: { profile in\n                print(\"Updating UI: \\(profile.name), Show Details: \\(profile.showExtraDetails)\")\n            })\n            .store(in: &cancellables)\n    }\n}\n```\n\n**Common Pitfalls:**\n\n*   **`map` vs. `flatMap`**: A common mistake is using `map` for an async operation, which results in a nested publisher (e.g., `Publisher<Publisher<User>>`) instead of the desired `Publisher<User>`.\n*   **`flatMap` Concurrency**: By default, `flatMap` has no limit on concurrent inner publishers (`maxPublishers: .unlimited`). If the upstream emits rapidly, this can trigger a huge number of network requests. Use `maxPublishers: .max(1)` to serialize operations.\n*   **`combineLatest` Initial Emission**: It will not emit any value until *all* of its source publishers have emitted at least once. This can be a subtle bug if one publisher is slow or never emits.\n\n**When to Use vs. Alternatives:**\n\n*   Use **`map`** for simple, synchronous data shaping.\n*   Use **`flatMap`** to chain dependent asynchronous calls. An alternative is `switchToLatest`, which cancels the previous inner publisher when a new value arrives, perfect for search-as-you-type UI.\n*   Use **`combineLatest`** to aggregate state from multiple independent sources, like validating a form where a 'Login' button's enabled state depends on both username and password fields being valid. An alternative is `zip`, which waits for a new value from *all* sources before emitting, pairing them sequentially.",
      "code_example": null,
      "tags": [
        "Combine",
        "Asynchronous Programming",
        "Reactive Programming",
        "Swift"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "combine_1cf53805b48a",
      "front": "How would you design a robust Combine error handling strategy for a network request that retries on failure, falls back to a cached value, and maps the final error to a specific domain error type? Explain the roles of `retry`, `catch`, and `mapError`.",
      "back": "In Combine, an error of a publisher's `Failure` type terminates the stream. A robust error handling strategy uses a chain of operators to manage failures gracefully without necessarily ending the subscription.\n\n**Core Concepts & Operator Roles:**\n\n1.  **`mapError`**: This operator transforms an error from one type to another. It doesn't prevent stream termination but is crucial for abstracting low-level errors (like `URLError`) into high-level, domain-specific errors (`MyAppError`) that are easier for the rest of the app to handle.\n\n2.  **`retry`**: This operator re-subscribes to the upstream publisher when it fails, up to a specified number of times. It's ideal for transient, recoverable issues like a temporary network timeout. It doesn't alter the error; if all retries fail, the original error is passed downstream.\n\n3.  **`catch`**: This is the most powerful recovery operator. It intercepts an error and replaces the terminated upstream publisher with a new publisher. This new publisher must produce the same `Output` type. It's perfect for implementing fallbacks, like loading data from a cache. If the new publisher has a `Failure` type of `Never`, it effectively guarantees the stream will no longer fail.\n\n**Practical Code Example:**\n\n```swift\n// Define a domain-specific error\nenum MyAppError: Error { case network(URLError), dataNotFound, decoding(Error) }\n\nfunc fetchData(from url: URL) -> AnyPublisher<Data, MyAppError> {\n    // A publisher that might fail with a URLError\n    let networkPublisher = URLSession.shared.dataTaskPublisher(for: url)\n        .mapError { MyAppError.network($0) } // 1. Map URLError to our domain error\n        .map(\\.data)\n        .eraseToAnyPublisher()\n\n    // A fallback publisher that might fail differently\n    let cachePublisher = Cache.shared.publisher(for: url)\n        .mapError { _ in MyAppError.dataNotFound } // Map cache error too\n\n    return networkPublisher\n        .retry(2) // 2. Retry the network request up to 2 times on failure\n        .catch { error -> AnyPublisher<Data, MyAppError> in\n            // 3. If retries fail, catch the error and switch to the cache.\n            print(\"Network failed after retries with \\(error), falling back to cache.\")\n            return cachePublisher\n        }\n        .eraseToAnyPublisher()\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n\n*   **Incorrect `catch` Return Type**: The closure in `catch` must return a new *Publisher*, not a simple value. A common mistake is `catch { return cachedValue }`. The correct way is `catch { return Just(cachedValue).setFailureType(to: E.self) }` if the upstream failure type `E` is not `Never`.\n*   **Over-retrying**: Using `retry` for non-recoverable errors (like a 404 Not Found) is inefficient. You should ideally inspect the error *before* retrying, which can be done by wrapping the publisher in a `Deferred` block.\n*   **Terminating Shared Streams**: If an error occurs on a stream shared via `share()` or `multicast()`, it terminates for *all* subscribers. Error handling operators should typically be applied *before* the sharing operator to keep the shared stream alive.",
      "code_example": null,
      "tags": [
        "combine",
        "reactive-programming",
        "error-handling",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    }
  ]
}