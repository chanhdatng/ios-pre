{
  "topic": "swift-fundamentals",
  "title": "Swift Language Fundamentals",
  "description": "Core Swift concepts for iOS interviews",
  "cards": [
    {
      "id": "swift-001",
      "front": "What's the difference between struct and class in Swift?",
      "back": "Struct: Value type, copied on assignment, stored on stack, no inheritance. Class: Reference type, passed by reference, stored on heap, supports inheritance.",
      "tags": [
        "value-types",
        "reference-types"
      ]
    },
    {
      "id": "swift-002",
      "front": "Explain copy-on-write (CoW) in Swift",
      "back": "Swift collections (Array, Dictionary, Set) use CoW for optimization. Data is only copied when mutated, not when assigned. Multiple variables share the same underlying storage until one modifies it.",
      "tags": [
        "value-types",
        "performance"
      ]
    },
    {
      "id": "swift-003",
      "front": "What are the different ways to unwrap an optional?",
      "back": "if let (conditional), guard let (early exit), ?? (nil coalescing), ! (force unwrap - avoid), ?. (optional chaining)",
      "tags": [
        "optionals"
      ]
    },
    {
      "id": "swift-004",
      "front": "When should you use [weak self] vs [unowned self]?",
      "back": "[weak self]: When self might be nil when closure executes (creates optional). [unowned self]: When certain self will exist (non-optional, crashes if nil). Use when closure and self have same lifecycle.",
      "tags": [
        "closures",
        "memory"
      ]
    },
    {
      "id": "swift-005",
      "front": "What is @escaping and when do you use it?",
      "back": "@escaping marks a closure that can outlive the function call. Required when: stored in a property, called asynchronously, passed to another @escaping closure.",
      "tags": [
        "closures"
      ]
    },
    {
      "id": "swift-006",
      "front": "Explain associated types in protocols",
      "back": "associatedtype is a placeholder type in a protocol. Conforming types specify the concrete type. Example: protocol Container { associatedtype Item; func add(_ item: Item) }",
      "tags": [
        "protocols",
        "generics"
      ]
    },
    {
      "id": "swift-007",
      "front": "What's the difference between 'any' and 'some' keywords?",
      "back": "some: Opaque type, compiler knows concrete type, better performance. any: Existential type, runtime type erasure, more flexible but slower. Prefer some when possible (Swift 5.7+).",
      "tags": [
        "protocols",
        "swift-5.7"
      ]
    },
    {
      "id": "swift-008",
      "front": "How does ARC work in Swift?",
      "back": "Automatic Reference Counting tracks strong references to class instances. When count reaches 0, instance is deallocated. Not garbage collection - deterministic, no runtime overhead.",
      "tags": [
        "memory",
        "arc"
      ]
    },
    {
      "id": "swift-009",
      "front": "What is a retain cycle and how do closures cause them?",
      "back": "A retain cycle occurs when two objects hold strong references to each other. Closures capture self strongly by default, so if a class stores a closure that references self, it creates a cycle. Fix with [weak self].",
      "tags": [
        "closures",
        "memory"
      ]
    },
    {
      "id": "swift-010",
      "front": "What's the difference between throws and rethrows?",
      "back": "throws: Function can throw errors. rethrows: Function only throws if its closure parameter throws. rethrows allows calling without try if closure doesn't throw.",
      "tags": [
        "error-handling"
      ]
    },
    {
      "id": "swift-011",
      "front": "Explain the difference between map, flatMap, and compactMap",
      "back": "map: Transforms each element. flatMap: Transforms and flattens nested collections. compactMap: Transforms and removes nil values from result.",
      "tags": [
        "functional",
        "collections"
      ]
    },
    {
      "id": "swift-012",
      "front": "What is Protocol-Oriented Programming (POP)?",
      "back": "Design pattern using protocols and extensions instead of inheritance. Benefits: composition over inheritance, value type support, protocol extensions provide default implementations, better testability.",
      "tags": [
        "protocols",
        "architecture"
      ]
    },
    {
      "id": "swift-013",
      "front": "What are property wrappers?",
      "back": "@propertyWrapper struct that encapsulates getter/setter logic. Examples: @State, @Published, @AppStorage. Reduces boilerplate by extracting common property patterns.",
      "tags": [
        "swift-5.1"
      ]
    },
    {
      "id": "swift-014",
      "front": "What is type erasure and why is it used?",
      "back": "Technique to hide concrete types behind a wrapper (e.g., AnyPublisher, AnySequence). Used when protocol has associated types but you need to store/return it without specifying concrete type.",
      "tags": [
        "protocols",
        "generics"
      ]
    },
    {
      "id": "swift-015",
      "front": "What are the access control levels in Swift?",
      "back": "open (most permissive), public, internal (default), fileprivate, private (most restrictive). open allows subclassing outside module, public doesn't.",
      "tags": [
        "access-control"
      ]
    },
    {
      "id": "swift_32865dacda56",
      "front": "Explain advanced Swift Generics, including variadic generics and their potential impact (e.g., SwiftUI). Explain Type Erasure with an example.",
      "back": "Advanced generics include features like variadic generics, allowing a variable number of type parameters. Swift 5.6 introduced existential `any` to clarify dynamic dispatch. Type erasure hides concrete types behind a protocol.  Example:  `AnyView` in SwiftUI erases the specific view type, enabling different views in the same container (e.g., within a `VStack`). Without it, SwiftUI's view builders would be severely limited.  Variadic generics can remove arbitrary restrictions on container view item counts (e.g. SwiftUI's LazyVGrid limitations).",
      "code_example": null,
      "tags": [
        "swift",
        "generics",
        "type erasure",
        "swiftui"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6"
      ]
    },
    {
      "id": "swift_69325e446d81",
      "front": "Property Wrappers implementation",
      "back": "",
      "code_example": null,
      "tags": [
        "Property Wrappers implementation"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "swift_5efaf49e1e55",
      "front": "Explain Swift Result Builders, their purpose, and provide a practical example. What are some limitations?",
      "back": "Result Builders (formerly Function Builders) allow you to create DSL-like syntax for constructing values. They accumulate partial results of computations to produce a final result.\n\nPurpose: To simplify code generation, especially when dealing with complex structures like UI layouts (e.g., SwiftUI's `body`).\n\nExample:\n```swift\n@resultBuilder\nstruct StringBuilder {\n    static func buildBlock(_ parts: String...) -> String {\n        parts.joined()\n    }\n\n    static func buildOptional(_ component: String?) -> String {\n        component ?? \"\"\n    }\n\n    static func buildEither(first component: String) -> String {\n        component\n    }\n\n    static func buildEither(second component: String) -> String {\n        component\n    }\n}\n\n@StringBuilder\nfunc makeMessage(includeGreeting: Bool, name: String?) -> String {\n    if includeGreeting {\n        \"Hello, \"\n    }\n    name\n    if let name = name {\n        \"!\"\n    } else {\n        \"User!\"\n    }\n}\n\nlet message = makeMessage(includeGreeting: true, name: \"World\") // \"Hello, World!\"\n```\n\nLimitations:\n*   Can increase compile time if overused or in very complex scenarios.\n*   Debugging can be harder, especially with nested builders.\n*   Limited to specific result types defined by the builder itself.  Can't easily return different types based on conditions without careful design of `buildEither`.",
      "code_example": null,
      "tags": [
        "swift",
        "result builders",
        "dsl",
        "metaprogramming"
      ],
      "sources": [
        "https://www.swift.org/documentation/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.hackingwithswift.com/articles/281/what-to-fix-in-ai-generated-swift-code",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6"
      ]
    },
    {
      "id": "swift_76ae4455ed48",
      "front": "Explain the core concepts behind Swift Macros, including their purpose, execution environment, and key limitations. Provide use case examples.",
      "back": "Swift Macros enable compile-time code transformation, enhancing code generation and reducing boilerplate. They run as separate processes during compilation, transforming source code via SwiftSyntax. Macros are type-safe and sandboxed, limiting access to external resources. Key macro types: `ExpressionMacro`, `AccessorMacro`, `ConformanceMacro`, `MemberAttributeMacro`. Example use cases: generating initializers from properties, automatically conforming to protocols, generating localized strings. Limitations: increased build times, debugging complexity, and dependency on SwiftSyntax.",
      "code_example": null,
      "tags": [
        "swift",
        "macros",
        "compilation",
        "SwiftSyntax"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "swift_5b8fc7f45dfe",
      "front": "Explain ARC's role in Swift memory management and how it differs from manual memory management. What are strong, weak, and unowned references, and when would you use each?",
      "back": "ARC automates memory management by tracking object references. When an object has no strong references, it's deallocated. \n\n*   `strong`: Default; keeps the object alive.\n*   `weak`: Allows the object to be deallocated if no other strong references exist, becoming `nil`. Used to prevent retain cycles, e.g., parent-child relationships where the child doesn't own the parent.\n*   `unowned`: Like `weak` but assumes the object will *never* be `nil` after initialization. Accessing a deallocated `unowned` reference results in a crash. Use when the other instance has the same or longer lifetime. Also prevents retain cycles.\n`weak let` (Swift 5.9+) makes a property immutable but still allows deallocation.",
      "code_example": null,
      "tags": [
        "memory management",
        "ARC",
        "strong",
        "weak",
        "unowned",
        "retain cycle"
      ],
      "sources": [
        "https://www.swift.org/documentation/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "swift_112850a42615",
      "front": "Explain Swift's Copy-on-Write (CoW) optimization. How does it improve performance? Give an example with arrays.",
      "back": "CoW is a performance optimization where data isn't copied when assigned or passed as an argument. Instead, multiple references point to the same underlying data. A copy is only made when one of the references attempts to modify the data. This avoids unnecessary copying, saving memory and CPU cycles. For example:\n\nvar arr1 = [1, 2, 3]\nvar arr2 = arr1 // arr2 now points to the same data as arr1\narr2[0] = 4 // Modification: arr2 now gets a *copy* of the array, and modifies its copy\n\nWithout CoW, `arr2 = arr1` would create a full copy immediately, even if `arr2` was never modified.",
      "code_example": null,
      "tags": [
        "swift",
        "performance",
        "copy-on-write",
        "optimization",
        "arrays"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6"
      ]
    },
    {
      "id": "swift_3264a6b95015",
      "front": "Explain the difference between `some Protocol` and `any Protocol` (Opaque vs Existential) in Swift. When would you use each?",
      "back": "`some Protocol` (Opaque Type): guarantees the return is of a *specific* underlying type conforming to the protocol, even if the exact type is hidden from the caller.\n`any Protocol` (Existential Type): allows the return to be *any* type conforming to the protocol. Each time it can be a different type. \n\nUse `some` when you need static dispatch and performance is critical. Use `any` when you need type erasure and the specific type isn't known or needs to vary at runtime. \n\n`any` was introduced in Swift 5.6, with warnings in later versions, and required in Swift 6.",
      "code_example": null,
      "tags": [
        "swift",
        "opaque types",
        "existential types",
        "protocols",
        "performance"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6"
      ]
    }
  ]
}