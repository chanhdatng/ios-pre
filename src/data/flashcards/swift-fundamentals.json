{
  "topic": "swift-fundamentals",
  "title": "Swift Language Fundamentals",
  "description": "Core Swift concepts for iOS interviews",
  "cards": [
    {
      "id": "swift_32865dacda56",
      "front": "Explain Swift's advanced generics, including variadic generics and type erasure. Provide use cases and potential drawbacks.",
      "back": "Generics enable writing flexible, reusable code that works with different types. Advanced generics extend this with features like variadic generics and type erasure.\n\nVariadic Generics:\nIntroduced to handle functions requiring a variable number of type parameters. Before, generic functions needed a fixed number of type parameters. With variadic generics, you can create functions that accept different numbers of types.\n\nExample:\n```swift\nfunc combine<each T>(_ values: repeat each T) -> String {\n    var result = \"\"\n    repeat with element in (repeat each T) {\n        result += String(describing: element)\n    }\n    return result\n}\n\nlet combined = combine(1, \"hello\", true) // \"1hellotrue\"\n```\n\nType Erasure:\nAllows hiding the underlying concrete type that conforms to a protocol, providing a type-safe way to work with heterogeneous collections. It's useful when you need to store different concrete types conforming to the same protocol in a single collection without exposing their specific types.\n\nExample:\n```swift\nprotocol Drawable {\n    func draw() -> String\n}\n\nstruct Circle: Drawable {\n    func draw() -> String { return \"Drawing a circle\" }\n}\n\nstruct Square: Drawable {\n    func draw() -> String { return \"Drawing a square\" }\n}\n\n// Type eraser\nstruct AnyDrawable: Drawable {\n    private let _draw: () -> String\n\n    init<D: Drawable>(_ drawable: D) {\n        _draw = { drawable.draw() }\n    }\n\n    func draw() -> String {\n        return _draw()\n    }\n}\n\nlet drawables: [AnyDrawable] = [AnyDrawable(Circle()), AnyDrawable(Square())]\nfor drawable in drawables {\n    print(drawable.draw())\n}\n```\n\nCommon Pitfalls:\n- Overuse of generics can reduce readability.\n- Type erasure introduces a performance overhead due to dynamic dispatch.\n- Complex generic constraints can lead to compile-time errors.\n\nAlternatives:\n- Using `Any` can simplify code but loses type safety.\n- Protocol-oriented programming with associated types can sometimes replace type erasure but may not be suitable for all scenarios.\n\nWhen to Use:\n- Variadic generics improve flexibility in functions needing a varying number of types.\n- Type erasure hides concrete types and handles heterogenous collections.\n\nIn summary, advanced generics like variadic generics and type erasure offer powerful tools for writing flexible and reusable Swift code, but they should be used judiciously, considering the trade-offs between flexibility, performance, and complexity.",
      "code_example": null,
      "tags": [
        "swift",
        "generics",
        "type erasure",
        "variadic generics",
        "advanced"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ],
      "summary": "Variadic generics allow functions with variable type parameters. Type erasure hides concrete types behind a protocol, enabling type-safe collections."
    },
    {
      "id": "swift_69325e446d81",
      "front": "Explain Property Wrappers in Swift. Describe their implementation, benefits, and potential drawbacks. Provide a practical example and discuss when to use them versus other approaches.",
      "back": "Property Wrappers encapsulate code for managing how a property is stored and accessed. They provide a reusable way to add functionality to properties, like validation, thread-safety, or persistence. \n\n**Implementation:**\nProperty wrappers are defined using the `@propertyWrapper` attribute before a `struct`, `class`, or `enum`. They must have a `wrappedValue` property, which defines the property's type and provides the logic for getting and setting its value.\n\n```swift\n@propertyWrapper\nstruct Clamped<T: Comparable> {\n    private var value: T\n    let range: ClosedRange<T>\n\n    init(wrappedValue initialValue: T, _ range: ClosedRange<T>) {\n        self.range = range\n        self.value = min(max(initialValue, range.lowerBound), range.upperBound)\n    }\n\n    var wrappedValue: T {\n        get { value }\n        set {\n            value = min(max(newValue, range.lowerBound), range.upperBound)\n        }\n    }\n}\n\nstruct MyStruct {\n    @Clamped(0...100) var percentage: Int = 50\n}\n\nvar myInstance = MyStruct()\nmyInstance.percentage = 120 // myInstance.percentage will be 100\nmyInstance.percentage = -10  // myInstance.percentage will be 0\nprint(myInstance.percentage) // Prints 100\n```\n**Benefits:**\n*   **Reusability:**  The same wrapper can be applied to multiple properties.\n*   **Code Clarity:**  Reduces boilerplate code in structs/classes by centralizing property behavior.\n*   **Maintainability:** Changes to the property's logic are made in one place.\n\n**Drawbacks:**\n*   **Added Indirection:**  Accessing a wrapped property involves an extra layer of indirection, potentially impacting performance (though usually negligible).\n*   **Complexity:** Can make code harder to understand if overused or if the wrapper logic is too complex.\n*   **Implicit Behavior:** The behavior of the property is not immediately obvious from the property declaration, requiring developers to understand the wrapper's implementation.\n\n**Common Pitfalls:**\n*   Forgetting to initialize the `wrappedValue` in the wrapper's initializer.\n*   Creating overly complex wrappers that obscure the property's core purpose.\n*   Not considering the performance implications of the added indirection, especially in performance-critical sections.\n\n**Alternatives:**\n*   **Computed Properties:** Suitable for simple property transformations or calculations. Computed properties don't store a value directly but provide getter and setter methods to compute it on demand.  Use when the logic is specific to a single property and doesn't need to be reused.\n*   **Property Observers (willSet/didSet):**  Useful for reacting to property changes. Use when you need to perform actions before or after a property is set, such as updating the UI or triggering other events. Not suitable when you need to modify the value being set.\n*   **Functions/Methods:**  For complex property management logic.  Use when the logic involves multiple steps or external dependencies.  Less reusable than property wrappers.\n\n**When to Use:**\nUse property wrappers when you have a common pattern of property behavior that needs to be applied to multiple properties across different types. Examples include data validation, thread safety, persistence, and SwiftUI state management (`@State`, `@ObservedObject`, etc.). Avoid overusing them for simple transformations that can be handled with computed properties or for actions triggered by property changes using property observers.",
      "code_example": null,
      "tags": [
        "swift",
        "property wrappers",
        "design patterns",
        "swiftui"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ],
      "summary": "Property Wrappers encapsulate and reuse property behavior like validation. They offer clarity and maintainability but add indirection."
    },
    {
      "id": "swift_5efaf49e1e55",
      "front": "Explain Swift's Result Builders. What problems do they solve, and how do they work under the hood?",
      "back": "Result builders are a powerful Swift feature (introduced in Swift 5.4) that allow you to create a DSL (Domain Specific Language) for declaratively building up complex data structures, most commonly used for constructing UI in SwiftUI. \n\n**Core Concept:** They provide a way to accumulate partial results of a computation to produce a final value.  This is achieved through a series of `buildBlock` methods (and others for more complex scenarios) that the compiler uses to transform the code within the builder into a sequence of operations that construct the desired output.\n\n**Problem Solved:** Result builders solve the problem of deeply nested and verbose code when programmatically constructing complex structures.  Without them, creating a view hierarchy in SwiftUI would involve many nested closures and conditional statements, making the code difficult to read and maintain.\n\n**Example:** SwiftUI's `ViewBuilder` is a prime example. Consider this:\n\n```swift\nimport SwiftUI\n\nstruct MyView: View {\n    let showDetail: Bool\n\n    var body: some View {\n        VStack {\n            Text(\"Hello, world!\")\n            if showDetail {\n                Text(\"Detailed information here.\")\n            }\n            Button(\"Tap me\") { }\n        }\n    }\n}\n```\n\nBehind the scenes, the `ViewBuilder` transforms this into a series of `buildBlock` calls, effectively concatenating the results of each statement (Text, if statement, Button) into a single `View`.\n\n**How it Works:**\n1.  The `@resultBuilder` attribute is applied to a type (usually a struct or enum).\n2.  This type must implement static `buildBlock` methods, which define how to combine partial results.\n3.  The compiler transforms the code within the result builder's scope into calls to these `buildBlock` methods.\n4.  Other methods like `buildOptional`, `buildEither`, `buildArray` allow for conditional and iterative content.\n\n**Common Pitfalls:**\n*   Forgetting to implement all necessary `buildBlock` variants for different numbers of components.\n*   Incorrectly handling optional or conditional content, leading to unexpected results.\n*   Overusing result builders for simple cases where they add unnecessary complexity.\n\n**Alternatives:**\n*   Without result builders, you would typically use manual construction with nested closures and conditional statements, which can become unwieldy.\n*   Custom DSLs using other techniques are possible but generally more complex to implement and maintain.\n\n**When to Use:** Use Result Builders when constructing complex, hierarchical data structures in a declarative and readable way. Good use cases are SwiftUI views, attributed strings, or any time you need to assemble a complex structure from smaller, composable parts. Avoid for simple cases, where a more direct approach is clearer.",
      "code_example": null,
      "tags": [
        "swift",
        "result builders",
        "dsl",
        "swiftui",
        "metaprogramming"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.hackingwithswift.com/articles/281/what-to-fix-in-ai-generated-swift-code",
        "https://www.swift.org/documentation/"
      ],
      "summary": "DSL for building complex data. Compiler uses `buildBlock` to transform code into operations that construct the final value."
    },
    {
      "id": "swift_76ae4455ed48",
      "front": "Swift Macros",
      "back": "",
      "code_example": null,
      "tags": [
        "Swift Macros"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "swift_5b8fc7f45dfe",
      "front": "Memory Management and ARC internals",
      "back": "",
      "code_example": null,
      "tags": [
        "Memory Management and ARC internals"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.swift.org/documentation/"
      ]
    },
    {
      "id": "swift_112850a42615",
      "front": "Explain Swift's Copy-on-Write (CoW) optimization, how it affects value types, and when it might *not* be effective. Give a practical code example.",
      "back": "CoW is a performance optimization where value types (structs, enums, tuples) are copied only when mutated.  Until then, multiple variables can share the same underlying data. This avoids unnecessary copying, improving performance, especially for large data structures. When a mutating method is called on a value type, Swift checks if the instance is uniquely referenced. If not, a copy is made *before* the mutation occurs. This ensures value semantics (each variable has its own independent copy). \n\nExample:\n```swift\nstruct MyData {\n    var items: [Int]\n}\n\nvar data1 = MyData(items: [1, 2, 3])\nvar data2 = data1 // data2 points to the same underlying array as data1\n\n// At this point, no copy has occurred.\n\ndata2.items.append(4) // Mutation triggers a copy for data2\n\nprint(data1.items) // Output: [1, 2, 3]\nprint(data2.items) // Output: [1, 2, 3, 4]\n```\n\n**Ineffective Scenarios:**\n\n1.  **Bridged Types (NSString, NSArray, etc.):**  Swift's CoW relies on its own internal data structures. When bridging to Objective-C types, CoW may not be fully optimized, as modifications might trigger copies more frequently due to the nature of those types.  However, Swift *does* attempt CoW on bridged types where possible.\n2.  **Frequent Modifications:** If a value type is mutated very frequently shortly after being copied, the overhead of checking for uniqueness and potentially copying can outweigh the benefits.  Consider using reference types (classes) if you need to share mutable state and performance is critical.\n3.  **Unsafe Pointers:** Using unsafe pointers to directly manipulate the underlying data of a value type can bypass CoW, leading to unexpected behavior and data corruption.  Avoid this unless absolutely necessary and with extreme caution.\n4.  **Inout parameters:** Passing a value type as an `inout` parameter *always* triggers a copy-in, copy-out behavior. This can negate CoW benefits if the parameter is modified within the function.\n\n**Alternatives:**\n\n*   **Classes:**  Use classes when you need shared mutable state. Be mindful of thread safety when using classes in concurrent environments.\n*   **`ManagedBuffer`:**  For advanced scenarios, `ManagedBuffer` provides a way to implement custom CoW behavior for your own data structures.\n\n**Common Pitfalls:**\n*   Assuming CoW always prevents copies. Be aware of the situations where it might not be effective.\n*   Incorrectly using `inout` parameters when you don't need to modify the original value.\n*   Forgetting that CoW is an *optimization*, not a guarantee.  Value types still maintain value semantics.\n*   Not considering thread safety when using reference types instead of value types.\n* Be very careful adding or removing `Copyable` from existing types, because it dramatically changes how they are used. If you\u2019re shipping code in a library, this will break your ABI.\n\nCoW is a crucial optimization that makes Swift's value types performant. Understanding when it works and when it doesn't is essential for writing efficient Swift code.",
      "code_example": null,
      "tags": [
        "swift",
        "copy-on-write",
        "performance",
        "value types",
        "struct",
        "optimization"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ],
      "summary": "CoW delays copying value types until modification. Multiple variables share data until one mutates, improving performance."
    },
    {
      "id": "swift_3264a6b95015",
      "front": "Explain the difference between `some Protocol` and `any Protocol` in Swift. When would you use each, and what are the performance implications?",
      "back": "In Swift, `some Protocol` (opaque type) and `any Protocol` (existential type) offer different ways to abstract concrete types behind a protocol. `some Protocol` creates a *reverse generic*. The function *chooses* the concrete type that conforms to the protocol, but the caller doesn't get to specify it. This allows the compiler to know the underlying type at compile time, enabling static dispatch and better performance. It guarantees that the *same* concrete type is used throughout. `any Protocol` creates an *existential container*. It can hold any type that conforms to the protocol, but the type is not known at compile time. This requires dynamic dispatch, which is slower. It allows you to store different conforming types in the same variable. Example: `func createVehicle() -> some Vehicle { Car() }` vs. `func processVehicle(vehicle: any Vehicle)`.  Common pitfall: using `any` unnecessarily when `some` would provide better performance. `some` is suitable when you need to hide implementation details but want to maintain type identity. `any` is needed when you truly need to work with different concrete types conforming to the same protocol, such as in a heterogeneous collection.  Since Swift 5.7, using `any` is more explicit and often required for existential types, highlighting the performance cost.  Alternatives: Generics (`<T: Protocol>`) offer compile-time type safety and static dispatch, but require the caller to specify the type. Opaque return types (`some Protocol`) hide the concrete type while preserving compile-time information. Existential types (`any Protocol`) provide runtime flexibility but sacrifice performance.",
      "code_example": null,
      "tags": [
        "swift",
        "opaque types",
        "existential types",
        "protocols",
        "performance",
        "generics"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.objc.io/issues/16-swift/power-of-swift/"
      ],
      "summary": "`some` preserves the concrete type for static dispatch & better performance; `any` allows different types, but uses slower dynamic dispatch."
    }
  ]
}