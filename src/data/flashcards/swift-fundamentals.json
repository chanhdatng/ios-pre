{
  "topic": "swift-fundamentals",
  "title": "Swift Language Fundamentals",
  "description": "Core Swift concepts for iOS interviews",
  "cards": [
    {
      "id": "swift-001",
      "front": "What's the difference between struct and class in Swift?",
      "back": "Struct: Value type, copied on assignment, stored on stack, no inheritance. Class: Reference type, passed by reference, stored on heap, supports inheritance.",
      "tags": [
        "value-types",
        "reference-types"
      ]
    },
    {
      "id": "swift-002",
      "front": "Explain copy-on-write (CoW) in Swift",
      "back": "Swift collections (Array, Dictionary, Set) use CoW for optimization. Data is only copied when mutated, not when assigned. Multiple variables share the same underlying storage until one modifies it.",
      "tags": [
        "value-types",
        "performance"
      ]
    },
    {
      "id": "swift-003",
      "front": "What are the different ways to unwrap an optional?",
      "back": "if let (conditional), guard let (early exit), ?? (nil coalescing), ! (force unwrap - avoid), ?. (optional chaining)",
      "tags": [
        "optionals"
      ]
    },
    {
      "id": "swift-004",
      "front": "When should you use [weak self] vs [unowned self]?",
      "back": "[weak self]: When self might be nil when closure executes (creates optional). [unowned self]: When certain self will exist (non-optional, crashes if nil). Use when closure and self have same lifecycle.",
      "tags": [
        "closures",
        "memory"
      ]
    },
    {
      "id": "swift-005",
      "front": "What is @escaping and when do you use it?",
      "back": "@escaping marks a closure that can outlive the function call. Required when: stored in a property, called asynchronously, passed to another @escaping closure.",
      "tags": [
        "closures"
      ]
    },
    {
      "id": "swift-006",
      "front": "Explain associated types in protocols",
      "back": "associatedtype is a placeholder type in a protocol. Conforming types specify the concrete type. Example: protocol Container { associatedtype Item; func add(_ item: Item) }",
      "tags": [
        "protocols",
        "generics"
      ]
    },
    {
      "id": "swift-007",
      "front": "What's the difference between 'any' and 'some' keywords?",
      "back": "some: Opaque type, compiler knows concrete type, better performance. any: Existential type, runtime type erasure, more flexible but slower. Prefer some when possible (Swift 5.7+).",
      "tags": [
        "protocols",
        "swift-5.7"
      ]
    },
    {
      "id": "swift-008",
      "front": "How does ARC work in Swift?",
      "back": "Automatic Reference Counting tracks strong references to class instances. When count reaches 0, instance is deallocated. Not garbage collection - deterministic, no runtime overhead.",
      "tags": [
        "memory",
        "arc"
      ]
    },
    {
      "id": "swift-009",
      "front": "What is a retain cycle and how do closures cause them?",
      "back": "A retain cycle occurs when two objects hold strong references to each other. Closures capture self strongly by default, so if a class stores a closure that references self, it creates a cycle. Fix with [weak self].",
      "tags": [
        "closures",
        "memory"
      ]
    },
    {
      "id": "swift-010",
      "front": "What's the difference between throws and rethrows?",
      "back": "throws: Function can throw errors. rethrows: Function only throws if its closure parameter throws. rethrows allows calling without try if closure doesn't throw.",
      "tags": [
        "error-handling"
      ]
    },
    {
      "id": "swift-011",
      "front": "Explain the difference between map, flatMap, and compactMap",
      "back": "map: Transforms each element. flatMap: Transforms and flattens nested collections. compactMap: Transforms and removes nil values from result.",
      "tags": [
        "functional",
        "collections"
      ]
    },
    {
      "id": "swift-012",
      "front": "What is Protocol-Oriented Programming (POP)?",
      "back": "Design pattern using protocols and extensions instead of inheritance. Benefits: composition over inheritance, value type support, protocol extensions provide default implementations, better testability.",
      "tags": [
        "protocols",
        "architecture"
      ]
    },
    {
      "id": "swift-013",
      "front": "What are property wrappers?",
      "back": "@propertyWrapper struct that encapsulates getter/setter logic. Examples: @State, @Published, @AppStorage. Reduces boilerplate by extracting common property patterns.",
      "tags": [
        "swift-5.1"
      ]
    },
    {
      "id": "swift-014",
      "front": "What is type erasure and why is it used?",
      "back": "Technique to hide concrete types behind a wrapper (e.g., AnyPublisher, AnySequence). Used when protocol has associated types but you need to store/return it without specifying concrete type.",
      "tags": [
        "protocols",
        "generics"
      ]
    },
    {
      "id": "swift-015",
      "front": "What are the access control levels in Swift?",
      "back": "open (most permissive), public, internal (default), fileprivate, private (most restrictive). open allows subclassing outside module, public doesn't.",
      "tags": [
        "access-control"
      ]
    },
    {
      "id": "swift_32865dacda56",
      "front": "Explain advanced Swift generics, specifically focusing on variadic generics and the impact of the 'any' keyword for existential types. Include a code example.",
      "back": "Variadic generics (Swift 5.9+) allow functions to accept a variable number of type parameters, removing previous limitations like the 10-view limit in SwiftUI.  Prior to this, generic functions required a fixed number of type parameters.  While variadic parameters existed, they had to use the same underlying type.\n\nExample:\n\n```swift\nfunc pairUp<each T>(firstPeople: repeat each T..., secondPeople: repeat each T...) -> [(repeat each T, repeat each T)] {\n    // Requires equal number of people\n    var result: [(repeat each T, repeat each T)] = []\n    let count = (\\[repeat each T].count(repeat: (each T))\n\n    for i in 0..<count {\n        result.append((firstPeople[i], secondPeople[i]))\n    }\n\n    return result\n}\n\nstruct FrontEndDev { var name: String }\nstruct BackEndDev { var name: String }\n\nlet johnny = FrontEndDev(name: \"Johnny\")\nlet kate = BackEndDev(name: \"Kate\")\n\n// pairUp(firstPeople: johnny, secondPeople: kate) // Error! Different types\n```\n\nTo fix this, use 'any':\n\n```swift\nfunc pairUpAny(firstPeople: any FrontEndDev..., secondPeople: any BackEndDev...) -> [(any FrontEndDev, any BackEndDev)] {\n    var result: [(any FrontEndDev, any BackEndDev)] = []\n    for i in 0..<firstPeople.count {\n        result.append((firstPeople[i], secondPeople[i]))\n    }\n    return result\n}\n\nlet result = pairUpAny(firstPeople: johnny, secondPeople: kate)\n```\n\nSwift 5.6 introduced the `any` keyword for existential types. An existential type (e.g., `Vehicle`) is a type that can hold any value of any type that conforms to a specific protocol.  Without `any`, the compiler implicitly treats protocols as existential types in certain contexts, which can lead to performance issues (dynamic dispatch instead of static dispatch) and unexpected behavior.\n\nUsing `any Vehicle` clarifies that you are using an existential type and forces dynamic dispatch. If possible, prefer generics or opaque types (`some Vehicle`) for better performance (static dispatch).  Generics allow the compiler to optimize based on the concrete type, while existentials require runtime type checking. Opaque Types (some) also preserve type identity without exposing the concrete type.\n\nCommon pitfalls include forgetting `any` where it's needed (will be a compile error in future Swift versions) and using `any` unnecessarily when a generic type constraint or opaque type would be more appropriate.  Overusing `any` can reduce performance and type safety.  Understand the trade-offs between static and dynamic dispatch and choose the appropriate tool for the job.",
      "code_example": null,
      "tags": [
        "swift",
        "generics",
        "type erasure",
        "existential types",
        "any",
        "variadic generics"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "swift_69325e446d81",
      "front": "Explain Property Wrappers in Swift, including their purpose, implementation details, and common use cases. Discuss potential performance considerations and alternatives. (Senior Level)",
      "back": "Property Wrappers encapsulate code for property access. They promote code reuse and separation of concerns by managing the storage and retrieval of a property's value.\n\n**Core Concept:**\nA property wrapper is a type that wraps a property. It manages the underlying storage and provides custom behavior when the property is accessed or modified. This allows you to encapsulate common property-related logic (like validation, lazy initialization, or thread safety) into a reusable component.\n\n**Implementation:**\nTo create a property wrapper, you define a `struct`, `class`, or `enum` and mark it with the `@propertyWrapper` attribute. The wrapper must have a `wrappedValue` property, which defines the value of the wrapped property. It can also have a `projectedValue` which is accessed using `$` before the property name.\n\n```swift\n@propertyWrapper\nstruct ClampedValue<T: Comparable> {\n    private var value: T\n    let range: ClosedRange<T>\n\n    init(wrappedValue initialValue: T, range: ClosedRange<T>) {\n        self.range = range\n        self.value = min(max(initialValue, range.lowerBound), range.upperBound)\n    }\n\n    var wrappedValue: T {\n        get { value }\n        set {\n            value = min(max(newValue, range.lowerBound), range.upperBound)\n        }\n    }\n}\n\nstruct Example {\n    @ClampedValue(range: 0...100)\n    var score: Int = 50\n}\n\nvar example = Example()\nexample.score = 200 // score will be clamped to 100\nprint(example.score) // Prints 100\nexample.score = -50  // score will be clamped to 0\nprint(example.score) // Prints 0\n```\n\n**Common Use Cases:**\n*   **Data Validation:** Enforcing constraints on property values (e.g., requiring a string to be a valid email address).\n*   **Lazy Initialization:** Delaying the creation of a property until it's first accessed.\n*   **Thread Safety:** Providing synchronized access to a property in a multithreaded environment.\n*   **User Defaults:** Simplifying the storage and retrieval of values from `UserDefaults`.\n*   **State Management:** SwiftUI's `@State`, `@ObservedObject`, `@EnvironmentObject` are all implemented using property wrappers.\n\n**Performance Considerations:**\nProperty wrappers introduce a level of indirection when accessing the underlying property. This can potentially impact performance, especially if the wrapper's logic is complex. However, in most cases, the performance overhead is negligible.\n\n**Common Pitfalls:**\n*   **Overuse:** Don't use property wrappers for simple properties that don't require any special logic.\n*   **Complex Logic:** Avoid putting too much complex logic inside a property wrapper, as it can make your code harder to understand and debug.\n*   **Incorrect Initialization:** Ensure the `init(wrappedValue:)` method handles all possible initial values correctly.\n*   **Memory Management:** If your property wrapper holds a reference to other objects, be mindful of memory management and potential retain cycles.\n\n**Alternatives:**\n*   **Computed Properties:** For simple transformations or calculations, computed properties can be a more lightweight alternative to property wrappers.\n*   **Custom Getters/Setters:** You can define custom getters and setters for properties to implement custom logic, but this approach doesn't promote code reuse as well as property wrappers.\n*   **Key-Value Observing (KVO):** For observing changes to properties, KVO can be used, but it's more complex than property wrappers and is primarily used in Objective-C code.\n\nIn summary, property wrappers are a powerful tool for encapsulating and reusing property-related logic in Swift. They promote code clarity and maintainability but should be used judiciously to avoid unnecessary complexity and performance overhead.",
      "code_example": null,
      "tags": [
        "swift",
        "property wrappers",
        "design patterns",
        "data validation",
        "swiftui"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "swift_5efaf49e1e55",
      "front": "Explain Swift Result Builders, their purpose, and provide a practical example. Discuss common pitfalls and alternative approaches.",
      "back": "Result builders are a powerful Swift feature that enables you to create declarative, domain-specific languages (DSLs) for constructing data structures in a readable and concise way.  Essentially, they're syntactic sugar that transforms a sequence of statements into a single value, typically an array or a more complex data structure.  At their core, they provide a way to accumulate partial results during the evaluation of a block of code.\n\n**Core Concept:**\nResult builders work by defining a type (usually a `struct` or `enum`) annotated with `@resultBuilder`. This type must then implement static methods that define how different types of statements within the builder's scope are transformed and combined.  Common methods include `buildBlock`, `buildOptional`, `buildEither`, and `buildArray`, each handling different control flow scenarios.\n\n**Practical Example (Custom HTML Builder):**\n```swift\n@resultBuilder\nstruct HTMLBuilder {\n    static func buildBlock(_ components: String...) -> String {\n        return components.joined(separator: \"\")\n    }\n\n    static func buildOptional(_ component: String?) -> String {\n        return component ?? \"\"\n    }\n\n    static func buildEither(first component: String) -> String {\n        return component\n    }\n\n    static func buildEither(second component: String) -> String {\n        return component\n    }\n    \n    static func buildArray(_ components: [String]) -> String {\n        return components.joined(separator: \"\")\n    }\n}\n\n@HTMLBuilder\nfunc createHTML() -> String {\n    \"<html>\"\n    \"<head>\"\n    \"<title>My Website</title>\"\n    \"</head>\"\n    \"<body>\"\n    if true {\n        \"<h1>Hello, world!</h1>\"\n    } else {\n        \"<p>This is a test.</p>\"\n    }\n    for i in 1...3 {\n      \"<p>Item \\(i)</p>\"\n    }\n    \"</body>\"\n    \"</html>\"\n}\n\nlet html = createHTML()\nprint(html)\n```\nIn this example, `HTMLBuilder` defines how strings are concatenated. The `@HTMLBuilder` attribute on `createHTML()` transforms the sequence of string literals, `if` statements, and `for` loops into a single HTML string.\n\n**Common Pitfalls:**\n*   **Complexity:** Overusing result builders can make code harder to understand if the underlying transformations are too complex.\n*   **Type Safety:** Ensure your builder methods handle all possible types within the block.\n*   **Performance:**  Excessive string concatenation within the builder can lead to performance issues. Use efficient string building techniques if needed (e.g., `StringBuilder` in other languages, or optimized string appending in Swift).\n\n**Alternatives:**\n*   **Manual Construction:** Building the data structure directly using loops, conditionals, and appending to arrays or other collections. This is more verbose but gives you explicit control.\n*   **Functions with Closures:** Using higher-order functions like `map`, `filter`, and `reduce` to transform data.  This can be a good alternative for simple transformations but becomes less readable for complex nested structures.\n\n**When to Use:**\nUse result builders when you want to create a DSL for constructing data structures in a declarative and readable way. They are particularly useful for:\n*   Generating UI layouts (e.g., SwiftUI's `ViewBuilder`).\n*   Creating HTML or XML documents.\n*   Building complex data structures with conditional logic and loops.\n\nAvoid using them when the construction logic is very simple or when the added complexity of a result builder outweighs the benefits of readability.\n\nIn summary, Result Builders are a powerful tool for creating DSLs, offering improved readability and conciseness. However, it's crucial to weigh the benefits against potential complexity and performance considerations. Choose the approach that best suits the specific problem and maintainability of your code.",
      "code_example": null,
      "tags": [
        "swift",
        "resultbuilders",
        "dsl",
        "metaprogramming"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.swift.org/documentation/",
        "https://www.hackingwithswift.com/articles/281/what-to-fix-in-ai-generated-swift-code"
      ]
    },
    {
      "id": "swift_76ae4455ed48",
      "front": "Explain Swift Macros, their purpose, and how they differ from C++ macros. Provide examples of ExpressionMacro and MemberAttributeMacro. Discuss their benefits and limitations.",
      "back": "Swift Macros, introduced in Swift 5.9, enable compile-time code transformation. Unlike C++ macros which are simple text replacements, Swift Macros are type-safe, operate on the SwiftSyntax tree, and run as external programs during the build phase. This allows for safer and more powerful code generation.\n\n*ExpressionMacro* creates a single expression. Example:\n```swift\n// Macro implementation (in a separate module)\npublic struct BuildDateMacro: ExpressionMacro {\n public static func expansion(\n of node: some FreestandingMacroExpansionSyntax,\n in context: some MacroExpansionContext\n ) -> ExprSyntax {\n let date = ISO8601DateFormatter().string(from: .now)\n return \"\\(raw: date)\"\n }\n}\n\n// Macro definition (in main target)\n@freestanding(expression)\nmacro buildDate() -> String = #externalMacro(module: \"MyMacrosPlugin\", type: \"BuildDateMacro\")\n\n// Usage\nprint(#buildDate) // Replaced with the build date string at compile time\n```\n*MemberAttributeMacro* adds attributes to each member of a type. Example:\n```swift\n// Macro implementation\npublic struct AllPublishedMacro: MemberAttributeMacro {\n public static func expansion(\n of node: AttributeSyntax,\n attachedTo declaration: some DeclGroupSyntax,\n providingAttributesFor member: some DeclSyntaxProtocol,\n in context: some MacroExpansionContext\n ) throws -> [AttributeSyntax] {\n return [AttributeSyntax(attributeName: SimpleTypeIdentifierSyntax(name: .identifier(\"Published\")))]\n }\n}\n\n//Usage:\n@AllPublished\nclass MyObservableObject {\n var name: String = \"\"\n var age: Int = 0\n} // Expands to adding @Published to name and age\n```\n\n**Benefits:**\n- Reduces boilerplate code.\n- Enhances code safety through type checking.\n- Enables creation of powerful DSLs.\n- Compile-time evaluation improves runtime performance.\n\n**Limitations:**\n- Increased build times due to macro execution.\n- Complex to debug due to compile-time nature.\n- Macros must operate within a sandbox, restricting external access.\n- Requires SwiftSyntax dependency.\n\n**Common Pitfalls:**\n- Overly complex macros can become unmaintainable.\n- Macros that produce inconsistent output can hinder incremental builds.\n- Incorrectly handling SwiftSyntax can lead to compilation errors.\n\n**Alternatives:**\n- Code generation tools (e.g., Sourcery) - More flexible but less integrated into the Swift language.\n- Function builders - Suitable for building DSLs for creating data structures, but less general than macros.\n\nMacros offer a powerful way to extend the Swift language and improve code generation, but they should be used judiciously, considering their complexity and potential impact on build times.",
      "code_example": null,
      "tags": [
        "swift",
        "macros",
        "compile-time",
        "swiftSyntax",
        "code generation"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9"
      ]
    },
    {
      "id": "swift_5b8fc7f45dfe",
      "front": "Memory Management and ARC internals",
      "back": "",
      "code_example": null,
      "tags": [
        "Memory Management and ARC internals"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/power-of-swift/",
        "https://www.hackingwithswift.com/articles/277/whats-new-in-swift-6-2",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.swift.org/documentation/"
      ]
    },
    {
      "id": "swift_112850a42615",
      "front": "Explain Swift's Copy-on-Write (CoW) optimization. How does it impact performance, and what data types benefit most?",
      "back": "CoW is a performance optimization used in Swift for value types (structs, enums, tuples). Instead of creating a completely new copy of a value when it's assigned or passed as an argument, Swift initially shares the same underlying memory. A true copy is only made when one of the copies is modified. \n\nImpact: CoW significantly reduces memory usage and improves performance, especially when dealing with large value types that are frequently copied but not always modified. Without CoW, each copy would require allocating new memory and duplicating the data, leading to overhead. \n\nBenefits: Collections (Arrays, Dictionaries, Sets) benefit greatly. Strings also use CoW. \n\nExample:\n```swift\nvar array1 = [1, 2, 3]\nvar array2 = array1 // array2 now points to the same memory as array1\n\narray2[0] = 4 // Now a copy is made before modification\n\nprint(array1) // Output: [1, 2, 3]\nprint(array2) // Output: [4, 2, 3]\n```\n\nPitfalls:\n- Understanding when a copy occurs is crucial. Unnecessary modifications will trigger copies, negating the benefits. \n- Mutating methods can trigger CoW. Be mindful of their performance impact. \n- For custom value types, ensure proper implementation of CoW if you're managing resources manually (rare in modern Swift). \n\nAlternatives & Considerations:\n- Reference types (classes) don't use CoW inherently.  Assigning a class instance creates another reference to the same object.  If you need CoW-like behavior with classes, you'd need to implement a custom copy mechanism (e.g., using `NSCopying` protocol or custom `copy()` method). This is more complex.\n- Consider using immutable data structures where appropriate, as they eliminate the need for CoW since no modifications occur.\n- Be aware of the trade-offs: CoW adds a slight overhead for checking if a copy is needed before modification. However, this overhead is usually much smaller than the cost of always copying.",
      "code_example": null,
      "tags": [
        "swift",
        "performance",
        "copy-on-write",
        "optimization",
        "value type"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/16-swift/power-of-swift/"
      ]
    },
    {
      "id": "swift_3264a6b95015",
      "front": "Explain the difference between `some` and `any` keywords when used with protocols in Swift. When would you use each?",
      "back": "Both `some` and `any` deal with protocols, but serve fundamentally different purposes. `some` creates an *opaque type*, while `any` denotes an *existential type*.\n\n`some ProtocolName` means the function returns a *specific* type that conforms to `ProtocolName`, but the caller doesn't know *which* type. The compiler knows the exact type, allowing for static dispatch and optimizations.  It guarantees type identity across multiple calls *within the same scope*. Think of it as a reverse generic.\n\n`any ProtocolName` means the function can return *any* type conforming to `ProtocolName`. The compiler doesn't know the specific type at compile time; it's determined at runtime (dynamic dispatch). This is less performant but more flexible, as the returned type can change.\n\n**Example:**\n\n```swift\nprotocol Drawable {\n    func draw() -> String\n}\n\nstruct Circle: Drawable {\n    func draw() -> String { return \"Circle\" }\n}\n\nstruct Square: Drawable {\n    func draw() -> String { return \"Square\" }\n}\n\n// Opaque type - returns a specific Drawable, but the caller doesn't know which.\nfunc createShape() -> some Drawable {\n    return Circle()\n}\n\n// Existential type - can return *any* Drawable.\nfunc createAnyShape(isCircle: Bool) -> any Drawable {\n    if isCircle {\n        return Circle()\n    } else {\n        return Square()\n    }\n}\n\nlet shape1 = createShape() // shape1 is *some* specific Drawable (Circle, in this case)\nlet shape2 = createAnyShape(isCircle: true) // shape2 is *any* Drawable\n\nprint(type(of: shape1)) // Prints Circle\nprint(type(of: shape2)) // Prints Circle (at runtime, but the type is existential)\n```\n\n**Pitfalls:**\n\n*   Using `any` unintentionally can lead to performance issues due to dynamic dispatch.\n*   `some` has restrictions.  For example, you can't return `some Drawable` if the function could return different `Drawable` types based on a condition *unless* you erase the type.\n*   Before Swift 5.6, `any` was implicit. Now, it's explicit to highlight the performance implications.\n\n**When to use:**\n\n*   Use `some` when you want to hide implementation details but need static dispatch and type guarantees.  This is common in SwiftUI (e.g., `some View`).\n*   Use `any` when you need maximum flexibility and the returned type can vary.  Be mindful of the performance cost.\n\n**Alternatives:**\n\n*   Generics: Can achieve similar results to `some` with more flexibility but can increase code complexity.\n*   Type erasure: Allows you to return different concrete types conforming to a protocol while presenting a unified type to the caller, but it involves manually implementing the type-erasing wrapper.\n",
      "code_example": null,
      "tags": [
        "swift",
        "protocols",
        "opaque types",
        "existential types",
        "some",
        "any"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/247/whats-new-in-swift-5-6",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/16-swift/power-of-swift/"
      ]
    }
  ]
}