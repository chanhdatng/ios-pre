{
  "topic": "architecture",
  "generated_at": "2026-01-08T03:55:15.486178+00:00",
  "cards": [
    {
      "id": "architecture_4f894e7dad6a",
      "front": "Explain Clean Architecture (VIPER) in iOS. What problem does it solve, and what are its core components? What are its advantages & disadvantages?",
      "back": "VIPER is Clean Architecture applied to iOS. It addresses \"Massive View Controllers\" by dividing responsibilities into distinct layers: View, Interactor, Presenter, Entity, and Router. \n\n**Advantages:** Improved testability, maintainability, and code reusability due to separation of concerns.\n\n**Disadvantages:** Increased complexity and boilerplate code, which can be overkill for small projects. A steep learning curve for teams unfamiliar with the pattern.",
      "code_example": null,
      "tags": [
        "architecture",
        "clean-architecture",
        "viper",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "architecture_366e8556ad43",
      "front": "Compare and contrast MVVM, MVC, and VIPER architectures, highlighting their strengths and weaknesses. When would you choose one over the others?",
      "back": "MVC is simple but often leads to massive view controllers. MVVM improves testability by separating view logic into a ViewModel. VIPER, using Clean Architecture, offers the best separation of concerns and testability but introduces complexity. \n\nChoose MVC for smaller apps.  MVVM for medium-sized apps needing better testability. VIPER for large, complex apps requiring strict separation of concerns and high testability.  Consider team size and project complexity when deciding.",
      "code_example": null,
      "tags": [
        "architecture",
        "MVVM",
        "MVC",
        "VIPER",
        "design patterns"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/13-architecture/mvvm/"
      ]
    },
    {
      "id": "architecture_97260008c4c7",
      "front": "Explain the core principles of VIPER architecture and how it addresses the 'Massive View Controller' problem. What are the benefits and drawbacks?",
      "back": "VIPER (View, Interactor, Presenter, Entity, Router) separates concerns into distinct layers, promoting testability and maintainability.  It solves 'MVC hell' by offloading logic from the ViewController.\n\nBenefits: Clear separation of concerns, improved testability, reusability, scalability.\n\nDrawbacks: Increased complexity, boilerplate code, steeper learning curve. Overkill for simple apps.\nExample: In a user profile screen, the View displays data, the Interactor handles fetching user data, the Presenter formats the data for the View, the Entity is the user data model, and the Router handles navigation to other screens.",
      "code_example": null,
      "tags": [
        "architecture",
        "viper",
        "ios",
        "design patterns"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "architecture_25deab4acb8a",
      "front": "Describe different Dependency Injection patterns in iOS and when you might choose one over another.",
      "back": "Constructor Injection (initializer): Dependencies are passed into the initializer. Good for required dependencies.  Property Injection: Dependencies are set on properties after object creation. Good for optional dependencies or when constructor injection is not feasible. Method Injection: Dependencies are passed as arguments to a method.  Useful when the dependency varies with each call. Avoid DI frameworks that require code changes. Use protocols to decouple.",
      "code_example": null,
      "tags": [
        "architecture",
        "dependency injection",
        "design patterns"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/dependency-injection/"
      ]
    },
    {
      "id": "architecture_be4bf94a271f",
      "front": "Discuss different modularization strategies in iOS development, including benefits and trade-offs of each. How does VIPER support modularity?",
      "back": "Strategies include: 1) Frameworks/Libraries: Reusable code packages, good for cross-project sharing. 2) Submodules (Git): Version-controlled dependencies, complex setup. 3) Local Swift Packages: Easier than frameworks, good for internal reuse. 4) Feature Flags: Toggle features without new deployments, good for A/B testing. 5) VIPER: Divides app into View, Interactor, Presenter, Entity, Router, promoting clear module boundaries and testability. \n\nTrade-offs: Increased complexity, build times, and initial setup vs. Improved maintainability, testability, reusability, and team collaboration.\n\nVIPER promotes modularity by defining clear responsibilities for each component, making it easy to isolate and test modules. Module interfaces (protocols) can be defined to expose module functionality to other parts of the application, promoting loose coupling.",
      "code_example": null,
      "tags": [
        "architecture",
        "modularization",
        "viper",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/dependency-injection/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/13-architecture/mvvm/"
      ]
    },
    {
      "id": "architecture_60fc4a6f7540",
      "front": "Explain protocol-oriented programming and its benefits in iOS architecture, especially compared to class-based inheritance.",
      "back": "POP focuses on defining behavior through protocols, allowing structs/enums/classes to conform. Benefits: avoids fragile base class problem, enables value-type semantics (better performance, thread safety), promotes composition over inheritance, improves testability through protocol mocking.  Example: define `Animatable` protocol instead of subclassing `UIView`.",
      "code_example": null,
      "tags": [
        "architecture",
        "protocol-oriented programming",
        "pop",
        "swift",
        "inheritance",
        "composition"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}