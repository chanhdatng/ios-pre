{
  "topic": "production-readiness",
  "title": "Production-Ready Code: Logging, Monitoring & Analytics",
  "description": "What separates hobby code from production code at scale",
  "cards": [
    {
      "id": "prod_001",
      "front": "Design a structured logging system for a fintech app. How do you prevent PII (credit card numbers, SSNs) from being logged?",
      "back": "**Secure Structured Logging System:**\n\n```swift\n// MARK: - Log Levels\nenum LogLevel: Int, Comparable {\n    case debug = 0, info, warning, error, critical\n    \n    static func < (lhs: LogLevel, rhs: LogLevel) -> Bool {\n        lhs.rawValue < rhs.rawValue\n    }\n}\n\n// MARK: - Structured Log Entry\nstruct LogEntry: Encodable {\n    let timestamp: Date\n    let level: String\n    let message: String\n    let context: [String: AnySendableEncodable]\n    let file: String\n    let function: String\n    let line: Int\n}\n\n// MARK: - PII Redaction\nprotocol PIIRedactable {\n    var redacted: String { get }\n}\n\nextension String: PIIRedactable {\n    var redacted: String { \"[REDACTED]\" }\n}\n\n// Credit card redaction\nstruct CreditCard: PIIRedactable, Encodable {\n    let number: String\n    \n    var redacted: String {\n        guard number.count >= 4 else { return \"****\" }\n        return \"****\" + number.suffix(4)\n    }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.singleValueContainer()\n        try container.encode(redacted) // Always encode redacted!\n    }\n}\n\n// SSN redaction\nstruct SSN: PIIRedactable, Encodable {\n    let value: String\n    var redacted: String { \"***-**-****\" }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.singleValueContainer()\n        try container.encode(redacted)\n    }\n}\n\n// MARK: - Secure Logger\nfinal class SecureLogger {\n    static let shared = SecureLogger()\n    \n    private let minimumLevel: LogLevel\n    private let piiPatterns: [NSRegularExpression]\n    \n    init(minimumLevel: LogLevel = .info) {\n        self.minimumLevel = minimumLevel\n        \n        // Patterns to catch accidental PII\n        self.piiPatterns = [\n            try! NSRegularExpression(pattern: \"\\\\b\\\\d{4}[- ]?\\\\d{4}[- ]?\\\\d{4}[- ]?\\\\d{4}\\\\b\"), // Credit card\n            try! NSRegularExpression(pattern: \"\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b\"), // SSN\n            try! NSRegularExpression(pattern: \"\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\\\\b\"), // Email\n        ]\n    }\n    \n    func log(\n        _ level: LogLevel,\n        _ message: String,\n        context: [String: Any] = [:],\n        file: String = #file,\n        function: String = #function,\n        line: Int = #line\n    ) {\n        guard level >= minimumLevel else { return }\n        \n        // Scrub message for accidental PII\n        let scrubbedMessage = scrubPII(message)\n        \n        // Convert context to safe encodable\n        let safeContext = context.mapValues { value -> AnySendableEncodable in\n            if let redactable = value as? PIIRedactable {\n                return AnySendableEncodable(redactable.redacted)\n            }\n            return AnySendableEncodable(value)\n        }\n        \n        let entry = LogEntry(\n            timestamp: Date(),\n            level: String(describing: level),\n            message: scrubbedMessage,\n            context: safeContext,\n            file: URL(fileURLWithPath: file).lastPathComponent,\n            function: function,\n            line: line\n        )\n        \n        // Output (console, file, remote service)\n        output(entry)\n    }\n    \n    private func scrubPII(_ text: String) -> String {\n        var result = text\n        for pattern in piiPatterns {\n            result = pattern.stringByReplacingMatches(\n                in: result,\n                range: NSRange(result.startIndex..., in: result),\n                withTemplate: \"[PII_REDACTED]\"\n            )\n        }\n        return result\n    }\n}\n\n// MARK: - Usage\nlet card = CreditCard(number: \"4111111111111111\")\nSecureLogger.shared.log(.info, \"Payment processed\", context: [\n    \"card\": card,  // Logs as \"****1111\"\n    \"amount\": 99.99,\n    \"userId\": \"user_123\"\n])\n```\n\n**Key Principles:**\n1. **Type-safe PII** - Wrapper types that auto-redact\n2. **Pattern scrubbing** - Catch accidental PII in strings\n3. **Structured context** - Easy to query/filter logs\n4. **Level filtering** - Debug logs only in dev",
      "tags": ["logging", "pii", "security", "fintech", "production"],
      "sources": ["https://developer.apple.com/documentation/os/logging"],
      "summary": "Use wrapper types that auto-redact (CreditCard, SSN). Regex scrub messages for accidental PII. Structured JSON logs for queryability."
    },
    {
      "id": "prod_002",
      "front": "A feature deployed to 10% of users silently fails (no crash, just silent failure). How would you detect this quickly using analytics?",
      "back": "**Detecting Silent Failures with Analytics:**\n\n**Strategy: Funnel Analytics with Success/Failure Events**\n\n```swift\n// MARK: - Feature Funnel Events\nenum CheckoutEvent: String {\n    // Funnel steps\n    case started = \"checkout_started\"\n    case addressEntered = \"checkout_address_entered\"\n    case paymentEntered = \"checkout_payment_entered\"\n    case submitted = \"checkout_submitted\"\n    \n    // Outcomes\n    case succeeded = \"checkout_succeeded\"\n    case failed = \"checkout_failed\"\n    case abandoned = \"checkout_abandoned\"\n}\n\nclass CheckoutAnalytics {\n    private let analytics: AnalyticsService\n    private var sessionId: String?\n    private var startTime: Date?\n    \n    func trackStart() {\n        sessionId = UUID().uuidString\n        startTime = Date()\n        \n        analytics.track(.started, properties: [\n            \"session_id\": sessionId!,\n            \"feature_flag\": FeatureFlags.newCheckoutEnabled ? \"new\" : \"old\",\n            \"app_version\": Bundle.main.appVersion\n        ])\n    }\n    \n    func trackSuccess(orderId: String) {\n        analytics.track(.succeeded, properties: [\n            \"session_id\": sessionId!,\n            \"order_id\": orderId,\n            \"duration_seconds\": Date().timeIntervalSince(startTime!),\n            \"feature_flag\": FeatureFlags.newCheckoutEnabled ? \"new\" : \"old\"\n        ])\n    }\n    \n    func trackFailure(reason: String, error: Error?) {\n        analytics.track(.failed, properties: [\n            \"session_id\": sessionId!,\n            \"failure_reason\": reason,\n            \"error_message\": error?.localizedDescription ?? \"unknown\",\n            \"error_domain\": (error as NSError?)?.domain ?? \"unknown\",\n            \"feature_flag\": FeatureFlags.newCheckoutEnabled ? \"new\" : \"old\"\n        ])\n    }\n}\n```\n\n**Dashboard Alerts:**\n\n```sql\n-- Alert: Success rate drops below threshold\nSELECT \n    feature_flag,\n    COUNT(CASE WHEN event = 'checkout_succeeded' THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN event = 'checkout_started' THEN 1 END) AS success_rate\nFROM events\nWHERE timestamp > NOW() - INTERVAL '1 hour'\nGROUP BY feature_flag\nHAVING success_rate < 90  -- Alert if below 90%\n```\n\n**Real-time Monitoring:**\n\n```swift\n// Track conversion ratio in real-time\nclass FeatureHealthMonitor {\n    func checkHealth() async {\n        let metrics = await analytics.query(\"\"\"\n            SELECT \n                feature_flag,\n                COUNT(*) FILTER (WHERE event = 'checkout_started') as starts,\n                COUNT(*) FILTER (WHERE event = 'checkout_succeeded') as successes\n            FROM events\n            WHERE timestamp > NOW() - INTERVAL '15 minutes'\n            GROUP BY feature_flag\n        \"\"\")\n        \n        for metric in metrics {\n            let successRate = Double(metric.successes) / Double(metric.starts)\n            \n            if successRate < 0.8 { // Below 80% success\n                alertOnCall(\n                    \"Feature \\(metric.featureFlag) success rate: \\(successRate * 100)%\"\n                )\n                \n                // Auto-disable if critical\n                if successRate < 0.5 {\n                    FeatureFlags.disable(metric.featureFlag)\n                }\n            }\n        }\n    }\n}\n```\n\n**Key Metrics to Track:**\n\n| Metric | Formula | Alert Threshold |\n|--------|---------|----------------|\n| Success Rate | succeeded / started | < 90% |\n| Error Rate | failed / started | > 5% |\n| Abandonment | abandoned / started | > 30% |\n| P95 Duration | 95th percentile time | > 10s |\n\n**Catching in Staging:**\n- Run synthetic tests with 100% feature flag coverage\n- Compare success rates between flag variants\n- Shadow mode: run both code paths, compare results",
      "tags": ["analytics", "monitoring", "feature-flags", "silent-failures", "funnel"],
      "sources": ["https://amplitude.com/blog/feature-flags-analytics"],
      "summary": "Track funnel events with feature flag context. Alert on success rate drops. Compare new vs old variants. Auto-disable if critical."
    },
    {
      "id": "prod_003",
      "front": "Your app integrates Firebase Crashlytics, Amplitude (analytics), and custom logging. How do you avoid sending duplicate/conflicting data?",
      "back": "**Unified Observability Architecture:**\n\n```swift\n// MARK: - Single Source of Truth\nprotocol EventDestination {\n    func track(event: TrackedEvent)\n    func identify(user: UserIdentity)\n    func log(entry: LogEntry)\n}\n\n// MARK: - Event Router (Facade Pattern)\nfinal class ObservabilityHub {\n    static let shared = ObservabilityHub()\n    \n    private var destinations: [EventDestination] = []\n    private var eventDeduplicator = EventDeduplicator()\n    \n    func register(_ destination: EventDestination) {\n        destinations.append(destination)\n    }\n    \n    func track(_ event: TrackedEvent) {\n        // Deduplicate rapid-fire events\n        guard eventDeduplicator.shouldSend(event) else { return }\n        \n        // Route to appropriate destinations\n        for destination in destinations {\n            switch event.type {\n            case .crash, .error:\n                if destination is CrashlyticsDestination {\n                    destination.track(event)\n                }\n            case .analytics:\n                if destination is AmplitudeDestination {\n                    destination.track(event)\n                }\n            case .all:\n                destination.track(event)\n            }\n        }\n    }\n}\n\n// MARK: - Event Deduplication\nclass EventDeduplicator {\n    private var recentEvents: [String: Date] = [:]\n    private let dedupeWindow: TimeInterval = 1.0 // 1 second\n    \n    func shouldSend(_ event: TrackedEvent) -> Bool {\n        let key = event.dedupeKey\n        let now = Date()\n        \n        if let lastSent = recentEvents[key],\n           now.timeIntervalSince(lastSent) < dedupeWindow {\n            return false // Duplicate!\n        }\n        \n        recentEvents[key] = now\n        return true\n    }\n}\n\n// MARK: - Crashlytics Adapter\nclass CrashlyticsDestination: EventDestination {\n    func track(event: TrackedEvent) {\n        // Add as breadcrumb\n        Crashlytics.crashlytics().log(event.name)\n        \n        if case .error(let error) = event.payload {\n            Crashlytics.crashlytics().record(error: error)\n        }\n    }\n    \n    func identify(user: UserIdentity) {\n        Crashlytics.crashlytics().setUserID(user.id)\n        Crashlytics.crashlytics().setCustomValue(user.plan, forKey: \"plan\")\n    }\n}\n\n// MARK: - Amplitude Adapter\nclass AmplitudeDestination: EventDestination {\n    func track(event: TrackedEvent) {\n        Amplitude.instance().logEvent(\n            event.name,\n            withEventProperties: event.properties\n        )\n    }\n    \n    func identify(user: UserIdentity) {\n        Amplitude.instance().setUserId(user.id)\n        Amplitude.instance().setUserProperties(user.traits)\n    }\n}\n\n// MARK: - Breadcrumb Strategy\nextension ObservabilityHub {\n    func addBreadcrumb(_ message: String, category: String) {\n        // Crashlytics: Custom logs\n        Crashlytics.crashlytics().log(\"[\\(category)] \\(message)\")\n        \n        // Amplitude: NOT sent (analytics ≠ debugging)\n        // Custom logger: File for support requests\n        FileLogger.shared.append(\"[\\(category)] \\(message)\")\n    }\n}\n\n// MARK: - Usage\nfunc setupObservability() {\n    let hub = ObservabilityHub.shared\n    hub.register(CrashlyticsDestination())\n    hub.register(AmplitudeDestination())\n    hub.register(ConsoleDestination())\n}\n\n// Track once, routes everywhere\nObservabilityHub.shared.track(TrackedEvent(\n    name: \"purchase_completed\",\n    type: .all,\n    properties: [\"amount\": 99.99]\n))\n```\n\n**Key Principles:**\n\n| Concern | Solution |\n|---------|----------|\n| Duplicate events | EventDeduplicator with time window |\n| Conflicting user IDs | Single identify() call routes to all |\n| Right data to right place | Event type routing |\n| Breadcrumbs | Crashlytics + file log, NOT analytics |",
      "tags": ["crashlytics", "amplitude", "analytics", "observability", "architecture"],
      "sources": ["https://firebase.google.com/docs/crashlytics"],
      "summary": "Single ObservabilityHub routes events. Deduplicate by time window. Route by event type (crashes→Crashlytics, analytics→Amplitude). Single identify() call."
    },
    {
      "id": "prod_004",
      "front": "Design the observability strategy (logging, metrics, traces) for a real-time order tracking app. What KPIs matter?",
      "back": "**Order Tracking App Observability:**\n\n**Three Pillars:**\n\n**1. LOGS - What happened**\n```swift\nstruct OrderLog {\n    let orderId: String\n    let event: String\n    let timestamp: Date\n    let metadata: [String: Any]\n}\n\n// Structured logs for each state transition\nlogger.info(\"Order state changed\", context: [\n    \"order_id\": order.id,\n    \"from_state\": oldState,\n    \"to_state\": newState,\n    \"driver_id\": driver?.id,\n    \"location\": location.redacted  // Don't log exact coords\n])\n```\n\n**2. METRICS - How much/how fast**\n```swift\nenum OrderMetric {\n    case orderCreated\n    case orderAccepted(waitTimeSeconds: Double)\n    case orderDelivered(totalTimeMinutes: Double)\n    case locationUpdateReceived(latencyMs: Double)\n    case mapRenderTime(ms: Double)\n}\n\nclass MetricsCollector {\n    func record(_ metric: OrderMetric) {\n        switch metric {\n        case .orderAccepted(let wait):\n            histogram(\"order.acceptance_time\", value: wait)\n        case .locationUpdateReceived(let latency):\n            histogram(\"location.update_latency\", value: latency)\n        case .mapRenderTime(let ms):\n            histogram(\"ui.map_render_time\", value: ms)\n        default:\n            counter(metric.name)\n        }\n    }\n}\n```\n\n**3. TRACES - Request flow**\n```swift\n// Distributed tracing for order lifecycle\nclass OrderTracer {\n    func startTrace(orderId: String) -> Trace {\n        let trace = Performance.startTrace(name: \"order_lifecycle\")\n        trace?.setValue(orderId, forAttribute: \"order_id\")\n        return trace!\n    }\n    \n    func addSpan(_ trace: Trace, name: String) {\n        // Track each phase\n        trace.incrementMetric(name, by: 1)\n    }\n}\n\n// Usage\nlet trace = tracer.startTrace(orderId: order.id)\ntrace.addSpan(\"driver_assigned\")\n// ... time passes ...\ntrace.addSpan(\"picked_up\")\n// ... time passes ...\ntrace.addSpan(\"delivered\")\ntrace.stop()\n```\n\n**Key KPIs for Order Tracking:**\n\n| KPI | Target | Alert Threshold |\n|-----|--------|----------------|\n| **Order Accept Rate** | > 95% | < 90% |\n| **Time to Accept** | < 30s | > 60s P95 |\n| **Location Update Latency** | < 500ms | > 2s P95 |\n| **Map Render Time** | < 100ms | > 500ms P95 |\n| **WebSocket Connection Success** | > 99% | < 95% |\n| **Push Notification Delivery** | > 98% | < 95% |\n| **Crash-Free Users** | > 99.5% | < 99% |\n| **ETA Accuracy** | ±5 min | ±15 min |\n\n**Dashboard Structure:**\n```\n┌─────────────────────────────────────────┐\n│  REAL-TIME ORDERS                        │\n│  Active: 1,234  |  Delayed: 23 (1.8%)   │\n├─────────────────────────────────────────┤\n│  PERFORMANCE (P95)                       │\n│  Location Latency: 340ms ✓              │\n│  Map Render: 89ms ✓                     │\n│  API Response: 120ms ✓                  │\n├─────────────────────────────────────────┤\n│  ERRORS (Last Hour)                      │\n│  WebSocket Disconnects: 12              │\n│  Failed Location Updates: 3             │\n│  Push Failures: 0                       │\n└─────────────────────────────────────────┘\n```\n\n**Implementation:**\n```swift\n// Combine all three pillars\nfunc orderStateChanged(order: Order, newState: OrderState) {\n    // LOG\n    logger.info(\"State changed\", context: [\"order\": order.id, \"state\": newState])\n    \n    // METRIC\n    metrics.record(.stateTransition(from: order.state, to: newState))\n    \n    // TRACE\n    activeTraces[order.id]?.addSpan(newState.rawValue)\n}\n```",
      "tags": ["observability", "metrics", "logging", "tracing", "kpi", "monitoring"],
      "sources": ["https://firebase.google.com/docs/perf-mon"],
      "summary": "Three pillars: Logs (what), Metrics (how much), Traces (flow). Key KPIs: accept rate, latency P95, crash-free rate, ETA accuracy."
    },
    {
      "id": "prod_005",
      "front": "You need to add analytics without compromising privacy (GDPR/CCPA compliant). What user data can you collect? How do you ensure consent?",
      "back": "**Privacy-Compliant Analytics:**\n\n**What You CAN Collect (Without Consent):**\n```swift\n// Aggregated, non-identifying data\nstruct AnonymousAnalytics {\n    let eventName: String\n    let timestamp: Date\n    let deviceType: String        // \"iPhone\", not model\n    let osVersion: String         // \"iOS 17\", not build\n    let appVersion: String\n    let screenName: String\n    let sessionDuration: TimeInterval\n    // NO user ID, NO device ID, NO location\n}\n```\n\n**What Requires Consent:**\n```swift\n// Personal data under GDPR/CCPA\nstruct PersonalAnalytics {\n    let userId: String            // Requires consent\n    let email: String             // Requires consent\n    let location: CLLocation      // Requires consent\n    let deviceId: String          // IDFA requires ATT\n    let purchaseHistory: [Order]  // Requires consent\n    let behaviorProfile: Profile  // Requires consent\n}\n```\n\n**Consent Implementation:**\n\n```swift\n// MARK: - Consent Manager\nenum ConsentType: String, CaseIterable {\n    case analytics = \"analytics\"\n    case personalization = \"personalization\"\n    case marketing = \"marketing\"\n    case thirdParty = \"third_party_sharing\"\n}\n\nclass ConsentManager {\n    private let storage = UserDefaults.standard\n    \n    var consents: [ConsentType: Bool] {\n        get {\n            var result: [ConsentType: Bool] = [:]\n            for type in ConsentType.allCases {\n                result[type] = storage.bool(forKey: \"consent_\\(type.rawValue)\")\n            }\n            return result\n        }\n    }\n    \n    func hasConsent(for type: ConsentType) -> Bool {\n        storage.bool(forKey: \"consent_\\(type.rawValue)\")\n    }\n    \n    func setConsent(_ granted: Bool, for type: ConsentType) {\n        storage.set(granted, forKey: \"consent_\\(type.rawValue)\")\n        \n        // Update analytics SDK\n        if type == .analytics {\n            Analytics.shared.setDataCollectionEnabled(granted)\n        }\n        \n        // Log consent change (meta-consent is allowed)\n        Analytics.shared.track(\"consent_changed\", properties: [\n            \"type\": type.rawValue,\n            \"granted\": granted\n        ])\n    }\n}\n\n// MARK: - App Tracking Transparency (IDFA)\nimport AppTrackingTransparency\n\nfunc requestTrackingPermission() async -> Bool {\n    let status = await ATTrackingManager.requestTrackingAuthorization()\n    return status == .authorized\n}\n\n// MARK: - Privacy-Safe Analytics\nclass PrivacyAnalytics {\n    private let consentManager: ConsentManager\n    \n    func track(_ event: String, properties: [String: Any]) {\n        var safeProperties = properties\n        \n        // Always strip PII\n        safeProperties.removeValue(forKey: \"email\")\n        safeProperties.removeValue(forKey: \"phone\")\n        safeProperties.removeValue(forKey: \"name\")\n        \n        // Only include user ID if consented\n        if !consentManager.hasConsent(for: .analytics) {\n            safeProperties.removeValue(forKey: \"userId\")\n        }\n        \n        // Only include location if consented\n        if !consentManager.hasConsent(for: .personalization) {\n            safeProperties.removeValue(forKey: \"location\")\n        }\n        \n        Analytics.shared.track(event, properties: safeProperties)\n    }\n}\n```\n\n**Consent UI Best Practices:**\n\n```swift\n// Show on first launch, not blocking\nstruct ConsentBanner: View {\n    @State private var showDetails = false\n    \n    var body: some View {\n        VStack {\n            Text(\"We use analytics to improve your experience\")\n            \n            HStack {\n                Button(\"Accept All\") {\n                    ConsentManager.shared.acceptAll()\n                }\n                Button(\"Customize\") {\n                    showDetails = true\n                }\n                Button(\"Reject All\") {\n                    ConsentManager.shared.rejectAll()\n                }\n            }\n        }\n    }\n}\n```\n\n**Key Requirements:**\n\n| Regulation | Key Requirement |\n|------------|----------------|\n| GDPR | Explicit opt-in consent, right to deletion |\n| CCPA | Opt-out link, disclose data sales |\n| ATT | System prompt for IDFA tracking |\n\n**Data Retention:**\n```swift\n// Anonymize or delete after retention period\nfunc anonymizeOldData() {\n    let cutoff = Date().addingTimeInterval(-90 * 24 * 60 * 60) // 90 days\n    database.execute(\"\"\"\n        UPDATE analytics \n        SET user_id = NULL, ip_address = NULL \n        WHERE timestamp < ?\n    \"\"\", [cutoff])\n}\n```",
      "tags": ["gdpr", "ccpa", "privacy", "consent", "analytics", "att"],
      "sources": ["https://developer.apple.com/documentation/apptrackingtransparency"],
      "summary": "Collect anonymous data freely. Personal data requires explicit consent. Use ATT for IDFA. Provide opt-out, right to deletion. Anonymize after retention."
    }
  ]
}
