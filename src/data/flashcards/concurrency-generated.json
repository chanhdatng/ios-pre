{
  "topic": "concurrency",
  "generated_at": "2026-01-12T04:20:49.156861+00:00",
  "cards": [
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain how `@MainActor` provides thread safety for UI updates. How does it relate to the general concept of global actors, and when would you create a custom global actor versus a standard actor?",
      "back": "### Core Concept\n\n`@MainActor` is a specific implementation of the `GlobalActor` protocol. A global actor provides a globally unique actor instance, creating a single, app-wide point of synchronization for any code isolated to it. `@MainActor`'s specific purpose is to represent the main dispatch queue (main thread).\n\nIts primary benefit is providing *compile-time* thread safety for UI code. By annotating a class, function, or property with `@MainActor`, you tell the Swift compiler it must only be accessed from the main thread. If you attempt to access it from a different concurrency context (e.g., a background `Task`), the compiler will raise an error, forcing you to use `await` to safely transition execution to the main actor. This statically prevents data races on UI components, a significant improvement over the manual, runtime-dependent `DispatchQueue.main.async` pattern.\n\n### Practical Code Example\n\n```swift\n// 1. Isolating an entire class to the MainActor ensures all its properties\n// and methods are protected and accessed on the main thread.\n@MainActor\nclass ContentViewModel: ObservableObject {\n    @Published var status: String = \"Initial State\"\n\n    // This method is implicitly on the MainActor.\n    func refreshData() {\n        // 2. We can safely start a background task for long-running work.\n        Task {\n            let newData = await fetchFromServer()\n            // 3. This update is guaranteed to be on the main thread because\n            // the entire class is isolated. No DispatchQueue.main.async needed.\n            self.status = newData\n        }\n    }\n\n    // This function is NOT on the main actor and can run concurrently.\n    private func fetchFromServer() async -> String {\n        try? await Task.sleep(for: .seconds(1)) // Simulate network latency\n        return \"Data Fetched Successfully!\"\n    }\n}\n\n// A custom global actor for a shared, app-wide resource like a logger.\n@globalActor\nstruct AnalyticsActor {\n  actor ActorType { }\n  static let shared = ActorType()\n}\n\n@AnalyticsActor\nfunc trackEvent(name: String) {\n    // All calls to this function are serialized through the AnalyticsActor.\n    print(\"Analytics Event: \\(name)\")\n}\n```\n\n### Common Pitfalls & Edge Cases\n\n*   **Over-isolation:** Marking large, complex services with `@MainActor` when only one or two properties need UI access can unnecessarily serialize non-UI work on the main thread, harming performance. Be specific about what needs main thread access.\n*   **Blocking the Main Thread:** `@MainActor` does not prevent you from writing blocking, synchronous code. A long-running synchronous calculation inside a `@MainActor` function will still freeze the UI.\n*   **Misunderstanding `nonisolated`:** Forgetting to use `nonisolated` for constants or pure functions within a MainActor-isolated type can lead to unnecessary actor-hopping (`await`) requirements from other main-actor contexts.\n\n### When to Use vs. Alternatives\n\n*   **`@MainActor`**: Use for any type or function that directly interacts with UI frameworks (UIKit/SwiftUI). It's the standard for ViewModels and other UI-driving components.\n*   **Custom Global Actor**: Use when you need to synchronize access to a *single, shared, global resource* from many unrelated parts of your app. Good candidates include a centralized logging service, a file manager singleton, or a specific database connection pool. It's for creating a single synchronization point for a specific domain.\n*   **Standard `actor`**: This is the most common and preferred choice. Use it to protect the mutable state of *individual instances* of a type. For example, if you have multiple `Document` objects, each should be its own actor to protect its own data. A global actor would be inappropriate as it would serialize access across *all* documents, creating a massive bottleneck.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "mainactor",
        "global-actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol and `@Sendable` closures enhance Swift's concurrency safety. What are the compiler's key checks, and how would you handle a non-`Sendable` type that must be passed across actor boundaries?",
      "back": "The `Sendable` protocol is a cornerstone of Swift's structured concurrency, acting as a marker protocol to statically guarantee that a type can be safely transferred across concurrency boundaries (e.g., between actors or threads) without introducing data races.\n\n**Core Concept Explanation:**\n\nA type can be `Sendable` in two primary ways:\n1.  **Value Types (`struct`, `enum`):** They conform implicitly if all their stored properties are also `Sendable`. Since value types are copied, passing them between actors creates a distinct, safe copy, preventing shared mutable state.\n2.  **Reference Types (`class`):** A class can conform if it's either immutable (all stored properties are `let` constants of `Sendable` types) or if it manages its own internal state synchronization (e.g., using locks, a concurrent queue, or being an actor itself). Actors are implicitly `Sendable`.\n\n`@Sendable` is an attribute for functions and closures, indicating they are safe to be executed concurrently. The compiler enforces that a `@Sendable` closure only captures `Sendable` values by value, or immutable `let` constants.\n\n**Practical Code Example:**\n\n```swift\n// This struct is implicitly Sendable because its properties are Sendable.\nstruct Transaction: Sendable {\n    let id: UUID\n    let amount: Double\n}\n\n// This class must manage its own thread safety to conform to Sendable.\n// Note: Actors are the modern, preferred way to handle this.\nfinal class Ledger: @unchecked Sendable { // Using @unchecked requires manual verification\n    private let lock = NSLock()\n    private var transactions: [Transaction] = []\n\n    func add(_ transaction: Transaction) {\n        lock.lock()\n        defer { lock.unlock() }\n        transactions.append(transaction)\n    }\n}\n\nactor Account {\n    let ledger = Ledger()\n\n    // This function requires a Sendable closure.\n    func processTransactions(block: @Sendable () -> Void) async {\n        // The closure can be safely run in this actor's context.\n        block()\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **`@unchecked Sendable` Abuse:** Using `@unchecked Sendable` to silence compiler warnings without implementing proper synchronization is a common mistake. It opts out of compiler safety checks and can easily reintroduce data races.\n*   **Implicit Conformance Failure:** A seemingly simple `struct` might not be `Sendable` if one of its properties, perhaps from an older library, doesn't conform. This forces you to either wrap or replace the non-compliant type.\n*   **Handling Non-`Sendable` Types:** The correct pattern is **confinement**, not force-conformance. A non-`Sendable` type (like a `UIView`) should be confined to a single actor, typically the `@MainActor`. To communicate with other actors, extract `Sendable` data (e.g., `label.text` which is a `String`) from it instead of passing the object itself. Trying to pass a non-`Sendable` type across actor boundaries will result in a compile-time error.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift structured concurrency",
        "sendable",
        "actors",
        "data races"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain how Swift's `actor` model provides thread safety. How does actor isolation differ from traditional lock-based mechanisms, and what potential reentrancy issues must a developer be aware of?",
      "back": "### Core Concept\n\nAn `actor` is a reference type in Swift that protects its mutable state from concurrent access, thus preventing data races. It achieves this through **actor isolation**. The Swift compiler ensures that all access to an actor's mutable properties and methods from outside the actor is asynchronous and mutually exclusive. \n\nInternally, each actor has a conceptual \"mailbox\" that queues incoming calls. The actor processes these messages one at a time, in a serial fashion. This guarantees that only one piece of code can manipulate the actor's state at any given moment, eliminating the need for manual locks (like `NSLock` or a serial `DispatchQueue`).\n\nThis differs from traditional locks in a crucial way: safety is enforced by the compiler, not by developer discipline. If you try to access an actor's isolated state from outside without using `await`, you'll get a compile-time error. This prevents common bugs like forgetting to acquire/release a lock or causing deadlocks through incorrect lock ordering.\n\n### Practical Code Example\n\n```swift\n// An actor to safely manage a user's score.\nactor ScoreManager {\n    private var score = 0\n\n    // This method is isolated. Only one task can execute it at a time.\n    func addPoints(_ points: Int) {\n        // State is safely mutated here.\n        score += points\n        print(\"New score: \\(score)\")\n    }\n\n    // To read the score from outside, the call must be async.\n    func getScore() -> Int {\n        return score\n    }\n}\n\nfunc updateScores() async {\n    let manager = ScoreManager()\n\n    // Use a TaskGroup to simulate concurrent updates.\n    await withTaskGroup(of: Void.self) { group in\n        for _ in 1...5 {\n            group.addTask {\n                // 'await' is required to cross the actor boundary.\n                // This signals a potential suspension point and lets the actor\n                // schedule this work on its serial executor.\n                await manager.addPoints(10)\n            }\n        }\n    }\n    // Final score will always be 50, guaranteed race-free.\n    let finalScore = await manager.getScore()\n    print(\"Final score is \\(finalScore)\")\n}\n```\n\n### Common Pitfalls: Actor Reentrancy\n\nA critical edge case is **actor reentrancy**. When an actor's method suspends (by using `await` on another async call), it can process other messages from its mailbox before the original method resumes. While the actor's state is consistent *at the suspension point*, it may have changed upon resumption. This can lead to logic errors if you make assumptions about state persistence across an `await`.\n\n```swift\n// Pitfall example:\nactor BalanceManager {\n    var balance = 100\n\n    func riskyWithdraw(_ amount: Int) async -> Bool {\n        if balance >= amount { // (1) Check balance\n            // (2) Await an async call (e.g., logging to a server)\n            await Task.sleep(nanoseconds: 1_000_000_000) // Simulate network call\n            // (3) Re-entry could happen here! Another call could modify 'balance'.\n            // The check from (1) is now stale.\n            balance -= amount // Potential bug: balance could go negative!\n            return true\n        }\n        return false\n    }\n}\n```\n**Solution:** Re-verify state after suspension or perform all state mutations in a single, non-suspending block.\n\n### When to Use vs. Alternatives\n\n*   **Use Actors:** When you need to protect a specific piece of mutable state that is accessed from multiple concurrent contexts (e.g., a cache, a data repository, a state machine). It's the modern, compiler-safe default for isolated state in Swift.\n*   **Alternatives:**\n    *   **Serial `DispatchQueue`:** The classic GCD approach. It also provides serialization but lacks compiler safety. It's easy to make mistakes like accessing state from outside the queue.\n    *   **Locks (`NSLock`, `os_unfair_lock`):** For performance-critical, low-level scenarios. They are faster when contention is low but are entirely manual, error-prone (deadlocks, priority inversion), and do not integrate with Swift's structured concurrency.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "thread-safety",
        "isolation",
        "reentrancy"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Explain how a `withThrowingTaskGroup` handles child task failures and cancellation. How does its 'first-failure' behavior work, and what strategy would you use to ensure all child tasks complete and you can collect all their results, regardless of individual failures?",
      "back": "A `withThrowingTaskGroup` provides structured concurrency for a dynamic number of child tasks. Its error handling and cancellation are fundamental to its design.\n\n**Core Concept: First-Failure and Implicit Cancellation**\nWhen a child task added to a `withThrowingTaskGroup` throws an error, the group immediately enters a cancelled state. This has two main effects:\n1.  **Cancellation Propagation:** All other running child tasks in the group are marked as cancelled. It is the responsibility of each task to check for cancellation (e.g., via `Task.isCancelled` or `Task.checkCancellation()`) and halt its work gracefully.\n2.  **Error Rethrowing:** The `withThrowingTaskGroup` scope will not wait for the other (now cancelled) tasks to finish. It immediately rethrows the error from the first task that failed. This ensures that errors are surfaced quickly.\n\nThis 'fail-fast' behavior is useful when the entire operation is considered failed if any single part of it fails.\n\n**Strategy: Collecting All Results with `Result`**\nTo bypass the 'first-failure' behavior and collect results from all tasks (both successes and failures), you must prevent any child task from throwing an error *out* of its closure. The standard pattern is to wrap the work of each child task in a `Result` type.\n\n```swift\n// Fetches data from multiple endpoints, collecting all results and errors.\nfunc fetchAllUserData(ids: [UUID]) async -> (users: [User], errors: [Error]) {\n    var successfulUsers: [User] = []\n    var failedErrors: [Error] = []\n\n    await withThrowingTaskGroup(of: Result<User, Error>.self) { group in\n        for id in ids {\n            // Add a new child task to the group.\n            group.addTask {\n                do {\n                    // Perform the throwing operation inside the task.\n                    let user = try await fetchUser(id: id)\n                    return .success(user)\n                } catch {\n                    // If it throws, catch the error and return it as a .failure case.\n                    // This prevents the group itself from throwing and cancelling others.\n                    return .failure(error)\n                }\n            }\n        }\n        \n        // Await each result as it completes and sort into successes/failures.\n        for await result in group {\n            switch result {\n            case .success(let user):\n                successfulUsers.append(user)\n            case .failure(let error):\n                failedErrors.append(error)\n            }\n        }\n    }\n    return (successfulUsers, failedErrors)\n}\n```\n\n**Common Pitfalls**\n*   **Ignoring Cancellation:** A long-running child task that doesn't check `Task.isCancelled` will continue to execute even after the group is cancelled, wasting system resources.\n*   **Mixing Throwing and `Result`:** Inconsistently handling errors within a group can lead to unexpected cancellations if one task accidentally throws while others return a `.failure`.\n\n**When to Use vs. Alternatives**\n*   **`TaskGroup`:** Ideal for a dynamic number of homogeneous, parallel tasks where you need to aggregate results. E.g., downloading a set of images defined by an API response.\n*   **`async let`:** Better for a fixed, small number of heterogeneous tasks known at compile time. It offers a simpler syntax for cases like fetching a user's profile and their settings concurrently. It lacks the dynamic nature of a `TaskGroup`.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "TaskGroup",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "A class managing a mutable shared state (e.g., an array) is accessed from multiple concurrent contexts. Describe and contrast three distinct Swift mechanisms to prevent data races, highlighting their trade-offs.",
      "back": "A data race occurs when multiple threads access shared mutable state simultaneously, with at least one access being a write, leading to unpredictable behavior. The core solution is to enforce mutual exclusion.\n\nHere are three common mechanisms in Swift:\n\n**1. Concurrent DispatchQueue with a Barrier (Readers-Writer Pattern)**\nThis approach uses a concurrent queue to allow multiple simultaneous reads, but employs a barrier for write operations. The barrier ensures that the write task is the only one executing on the queue at that moment, providing exclusive access.\n\n*   **Use Case:** Ideal for data structures that are read from frequently but written to infrequently.\n*   **Trade-offs:** Safer and more structured than manual locks. Good performance for read-heavy scenarios. However, it has higher overhead than a simple lock due to dispatching blocks to the queue.\n\n```swift\nclass ThreadSafeStore<T> {\n    private var items: [T] = []\n    // Use a concurrent queue for reads, and a barrier for writes\n    private let queue = DispatchQueue(label: \"com.example.threadSafeStore\", attributes: .concurrent)\n\n    func add(_ item: T) {\n        // .barrier ensures this block is the only one running on the queue\n        queue.async(flags: .barrier) {\n            self.items.append(item)\n        }\n    }\n\n    func item(at index: Int) -> T? {\n        var result: T?\n        // .sync waits for the read to complete\n        queue.sync {\n            guard items.indices.contains(index) else { return }\n            result = self.items[index]\n        }\n        return result\n    }\n}\n```\n\n**2. NSLock**\nThis is a low-level, explicit locking primitive. You manually acquire the lock before accessing the shared resource and release it afterward. It's crucial to release the lock on all code paths.\n\n*   **Use Case:** When protecting a very small, performance-critical section of code where the overhead of GCD is a concern.\n*   **Pitfall:** Highly error-prone. Forgetting to `unlock()` can cause a deadlock. The `defer` statement is essential for safety.\n\n```swift\nclass LockedStore<T> {\n    private var items: [T] = []\n    private let lock = NSLock()\n\n    func add(_ item: T) {\n        lock.lock()\n        defer { lock.unlock() } // Guarantees unlock is called, even if errors occur\n        items.append(item)\n    }\n\n    func item(at index: Int) -> T? {\n        lock.lock()\n        defer { lock.unlock() }\n        guard items.indices.contains(index) else { return nil }\n        return items[index]\n    }\n}\n```\n\n**3. Actor**\nActors are a modern Swift language feature that provides compiler-enforced isolation for state. Any access to an actor's mutable state from outside must be done asynchronously via `await`, which serializes access and eliminates data races by design.\n\n*   **Use Case:** The default choice in modern Swift codebases for any object with internal state that needs protection. It offers the highest level of safety.\n*   **Pitfall:** Actors are re-entrant. An actor can suspend on an `await` call, allowing another task to enter and run. This is different from a lock and requires careful state management to avoid logic errors based on invalid intermediate states.\n\n```swift\nactor ActorStore<T> {\n    private var items: [T] = []\n\n    // Methods can be called concurrently, but the actor serializes access to 'items'\n    func add(_ item: T) {\n        items.append(item)\n    }\n\n    func item(at index: Int) -> T? {\n        guard items.indices.contains(index) else { return nil }\n        return items[index]\n    }\n}\n\n// Usage:\n// let store = ActorStore<String>()\n// await store.add(\"Hello\")\n```",
      "code_example": null,
      "tags": [
        "Concurrency",
        "Swift",
        "Actors",
        "GCD",
        "Locks",
        "Data Race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Explain the relationship between `AsyncSequence` and `AsyncStream`. When would you choose to create a custom `AsyncStream` versus implementing the `AsyncSequence` protocol from scratch?",
      "back": "`AsyncSequence` is a protocol, analogous to `Sequence`, that defines a sequence of values you can iterate over asynchronously using `for await in`. To conform, a type must provide an `makeAsyncIterator()` method, which returns an `AsyncIteratorProtocol` that has an `async` `next()` method.\n\n`AsyncStream` is a concrete struct provided by the Swift standard library that conforms to `AsyncSequence`. Its primary purpose is to act as a bridge, adapting existing, non-structured asynchronous code (like delegate patterns, callbacks, or notifications) into the structured world of Swift Concurrency. It does this by providing a `continuation` which you use to manually push values (`yield`), signal completion (`finish`), or indicate failure.\n\n**Practical Code Example: Wrapping a Delegate-based API**\n\nLet's adapt a legacy `LocationManager` that provides location updates via a delegate into an `AsyncStream`.\n\n```swift\n// Legacy class we can't change\nclass LegacyLocationManager {\n    var onLocationUpdate: ((CLLocation) -> Void)?\n    func startUpdating() { /* Simulates starting updates */ }\n    func stopUpdating() { /* Simulates stopping updates */ }\n}\n\n// Our modern wrapper\nactor LocationProvider {\n    private let manager = LegacyLocationManager()\n\n    var locationUpdates: AsyncStream<CLLocation> {\n        AsyncStream { continuation in\n            // Set the callback to yield values to the stream\n            manager.onLocationUpdate = { location in\n                continuation.yield(location)\n            }\n            \n            // Handle cancellation from the consumer side\n            continuation.onTermination = { @Sendable _ in\n                self.manager.stopUpdating()\n            }\n            \n            manager.startUpdating()\n        }\n    }\n}\n\n// Usage:\nlet provider = LocationProvider()\nlet locationTask = Task {\n    for await location in await provider.locationUpdates {\n        print(\"New location: \\(location.coordinate)\")\n        if location.horizontalAccuracy < 10 { break } // Stop when accuracy is good\n    }\n    print(\"Location monitoring finished.\")\n}\n// To cancel: locationTask.cancel()\n```\n\n**Common Pitfalls:**\n\n1.  **Backpressure:** `AsyncStream` has a buffer. If the producer `yield`s values faster than the consumer consumes them, the buffer can fill up and values may be dropped, depending on the buffering policy. This must be considered for high-frequency event sources.\n2.  **Continuation Leaks:** The `continuation` must be stored and used carefully. Forgetting to call `finish()` can cause the `for await` loop to hang indefinitely.\n3.  **Thread Safety:** The `continuation` is not intrinsically thread-safe. If multiple threads can push values, you must synchronize access, for example by wrapping the logic in an actor.\n\n**When to Use vs. Alternatives:**\n\n*   **Choose `AsyncStream`** when you need to **adapt (or bridge)** existing code that follows a **push-based** model (delegates, callbacks, KVO, NotificationCenter). The external source pushes events *to* your code, and you use the continuation to forward them into the stream.\n\n*   **Implement `AsyncSequence` directly** when you are creating a new asynchronous data source from scratch that follows a **pull-based** model. The consumer `await`s the `next()` value, which gives your iterator direct control to perform work (e.g., fetch the next page from a web API) on-demand. This is often cleaner if you don't need to bridge an existing non-async interface.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "asyncsequence",
        "asyncstream",
        "structured-concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "Explain how Swift's Structured Concurrency fundamentally changes the management of asynchronous task lifetimes and error propagation compared to traditional approaches like GCD. What specific problems does it solve?",
      "back": "Swift's Structured Concurrency introduces a parent-child task hierarchy, where a task's lifetime is contained within its creation scope (e.g., a function body). A parent task cannot complete until all of its child tasks have finished, either by returning a value, throwing an error, or being cancelled. This is a compile-time guarantee that solves major problems from unstructured approaches like GCD:\n\n1.  **Leaked Tasks**: In GCD, it's easy to start a network request that outlives the view controller that initiated it, leading to wasted resources or crashes when trying to update a deallocated UI.\n2.  **Complex State Management**: With `DispatchGroup`, developers must manually `enter()` and `leave()` to track task completion. Forgetting one call leads to deadlocks or premature completion.\n3.  **Error & Cancellation Propagation**: There is no built-in way to propagate an error from one task in a `DispatchGroup` to others, or to cancel all running tasks if one fails. This requires complex, custom logic.\n\nStructured Concurrency solves this by making the data flow and control flow match. Errors thrown in a child task propagate up to the parent, and cancelling the parent task automatically cancels all its children.\n\n### Code Example: `async let`\n`async let` creates concurrent child tasks. The parent `fetchUserProfile` task suspends until both children complete, and an error from either will be caught.\n\n```swift\n// Fetches user data and a profile image concurrently.\nfunc fetchUserProfile(id: User.ID) async throws -> (User, UIImage) {\n    // Both child tasks start running in parallel immediately.\n    // Their lifetimes are scoped to this function.\n    async let user = fetchUser(id: id)\n    async let profileImage = fetchImage(for: id)\n\n    // 'await' pauses the parent task here until both children complete.\n    // If either 'user' or 'profileImage' task throws, the error propagates\n    // here and the other task is implicitly cancelled.\n    return try await (user, profileImage)\n}\n```\n\n### Common Pitfalls\n*   **Accidental Unstructured Tasks**: Using `Task { ... }` inside an async function creates a new, top-level task that is *not* a child of the current task. It breaks the structure and can lead to the very lifecycle issues Structured Concurrency aims to solve. Use `Task.detached` only when you explicitly need to break from the current actor context and priority.\n*   **Ignoring Cooperative Cancellation**: Cancellation is not preemptive. A long-running computation must periodically check `Task.isCancelled` and throw a `CancellationError` to terminate early. Without this, a cancelled task will run to completion.\n\n### When to use vs. Alternatives\n*   **Structured Concurrency**: The default for all new async code. It's safer, more readable, and handles complex control flow automatically.\n*   **GCD/DispatchGroup**: Use for legacy codebases, interfacing with older APIs that require completion handlers, or for specific low-level synchronization needs that actors don't cover (e.g., thread-specific storage).\n*   **OperationQueue**: Still valuable for its ability to model complex dependency graphs (`addDependency`) and to finely control the maximum number of concurrent operations, but `TaskGroup` and actors have largely superseded it.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "async-await",
        "tasks"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}