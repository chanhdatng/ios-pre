{
  "topic": "concurrency",
  "generated_at": "2026-01-10T03:57:26.895010+00:00",
  "cards": [
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Compare the Actor model in modern Swift Concurrency with traditional locking mechanisms (like NSLock or serial queues) for preventing data races. Discuss the trade-offs and when you would choose one over the other.",
      "back": "A data race occurs when multiple threads access shared mutable state without synchronization, with at least one access being a write. Both actors and locks solve this, but through different paradigms.\n\n**Core Concept: Locking vs. Actor Isolation**\n\n*   **Traditional Locking (e.g., `NSLock`, `DispatchQueue`):** This is an imperative approach. You manually acquire a lock before entering a *critical section* (code accessing shared state) and release it upon exit. A serial `DispatchQueue` achieves a similar effect by ensuring tasks execute one at a time. The responsibility for correctness lies entirely with the developer. You must remember to lock and unlock correctly everywhere.\n\n*   **Actors:** This is a declarative approach built into the Swift language. An `actor` is a reference type that protects its state from concurrent access. The compiler enforces that any access to an actor's mutable state from the *outside* must be asynchronous (`await`). This allows the actor's internal executor to serialize access, guaranteeing data integrity without manual locking.\n\n**Practical Code Example**\n\n```swift\n// Traditional approach with a private serial queue\nclass SafeCounter { \n    private var value = 0\n    private let queue = DispatchQueue(label: \"com.example.counter.queue\")\n\n    func increment(completion: @escaping (Int) -> Void) {\n        queue.async {\n            self.value += 1\n            completion(self.value)\n        }\n    }\n}\n\n// Modern approach with an actor\nactor ActorCounter {\n    private var value = 0\n\n    func increment() -> Int {\n        value += 1\n        return value\n    }\n}\n\n// Usage\nTask {\n    let counter = ActorCounter()\n    let newValue = await counter.increment() // 'await' enforces safe, serialized access\n    print(newValue)\n}\n```\n\n**Common Pitfalls & Edge Cases**\n\n*   **Locks:** \n    *   **Deadlocks:** Thread A locks resource X and waits for Y, while Thread B locks Y and waits for X. Both are stuck forever.\n    *   **Forgetting to Unlock:** Failing to release a lock, especially in an error path, can freeze threads. `defer` is crucial for safety.\n    *   **Priority Inversion:** A low-priority thread holds a lock needed by a high-priority thread, blocking important work.\n\n*   **Actors:**\n    *   **Re-entrancy:** When an actor `await`s another async call, it suspends. During this suspension, other calls can be made to the actor. This can lead to observing inconsistent state if not handled carefully. The actor is *not* locked during suspension.\n\n**When to Use vs. Alternatives**\n\n*   **Use Actors (Default Choice):** For any new Swift code that needs to manage shared, mutable state. The compile-time safety is a massive advantage over manual locking, eliminating an entire class of bugs. They integrate seamlessly with the `async/await` ecosystem.\n\n*   **Use Locks/Queues:** \n    1.  **Interoperability:** When working with legacy Objective-C APIs or libraries that are not actor-aware and require explicit synchronization.\n    2.  **Synchronous Context:** When you must synchronize access within a synchronous function. Note: This often points to a larger design issue that should be refactored to be asynchronous.\n    3.  **Fine-grained Performance:** In rare, highly-optimized scenarios where the overhead of actor context switching is a proven bottleneck (profile first!).",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift concurrency",
        "actors",
        "data race",
        "locking",
        "system design"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency fundamentally change the management of concurrent task lifetimes and error propagation compared to 'fire-and-forget' approaches like GCD?",
      "back": "Swift's Structured Concurrency introduces a parent-child relationship between tasks, forming a 'task tree'. The lifetime of a child task is constrained by the scope of its parent. This means a parent task cannot complete until all of its child tasks have finished, either by returning a value, throwing an error, or being cancelled.\n\nThis model is a stark contrast to older 'fire-and-forget' APIs like Grand Central Dispatch (GCD) or `Task.detached`, where dispatching a task severs its connection to the parent context. In those models, the developer is responsible for manually tracking tasks, propagating cancellation signals, and funneling errors back, which is complex and error-prone.\n\nStructured Concurrency solves this by baking lifetime management, cancellation, and error propagation directly into the language syntax.\n\n**Code Example:**\nUsing `async let` to fetch user data and their feed concurrently. The `fetchUserAndFeed` function is the parent task.\n\n```swift\nstruct User { let name: String }\nstruct Feed { let items: [String] }\n\nfunc fetchUser() async throws -> User { /* ... network call ... */ return User(name: \"Alex\") }\nfunc fetchFeed() async throws -> Feed { /* ... network call ... */ throw NetworkError.timeout }\n\nfunc fetchUserAndFeed() async {\n    print(\"Starting to fetch data...\")\n    do {\n        // 'async let' creates two child tasks that run in parallel.\n        // Their lifetimes are scoped to this 'do' block.\n        async let userTask = fetchUser()\n        async let feedTask = fetchFeed() // This task will throw an error.\n\n        // The parent task suspends here. 'await' waits for both children.\n        // If 'feedTask' throws, 'userTask' is automatically cancelled.\n        let (user, feed) = try await (userTask, feedTask)\n        print(\"Successfully fetched \\(user.name) and \\(feed.items.count) items.\")\n\n    } catch {\n        // The error from 'fetchFeed' is propagated up and caught here.\n        print(\"Failed to fetch data: \\(error)\")\n    }\n    print(\"Function finished.\")\n}\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` without awaiting its result creates a detached, unstructured task, breaking the parent-child hierarchy and its safety guarantees.\n- **Misusing `TaskGroup`:** Using a `TaskGroup` for a fixed, small number of heterogeneous tasks where the simpler `async let` syntax is more appropriate.\n- **Cancellation is Cooperative:** Structured Concurrency propagates the cancellation signal automatically, but the child task must periodically check for it via `Task.isCancelled` or `try Task.checkCancellation()` to actually stop its work.\n\n**When to Use vs. Alternatives:**\n- **Structured Concurrency (`async let`, `TaskGroup`):** The default choice for new concurrent code. It provides compile-time safety, prevents task leakage, and simplifies complex workflows.\n- **Unstructured Concurrency (`Task.detached`):** Use sparingly for tasks that must outlive the scope that created them, such as a background logging operation that must complete even if the UI is dismissed. It's an escape hatch, not the norm.\n- **GCD/OperationQueue:** Still valuable for legacy code, fine-grained control over execution (e.g., `maxConcurrentOperationCount`), or complex dependency graphs between operations. For most common concurrency patterns, Swift's structured approach is safer and more readable.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "async/await",
        "structured concurrency",
        "task"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Explain how `TaskGroup` facilitates dynamic parallelism. Describe its error handling mechanism, specifically the behavior of the group and its child tasks when one task throws an error.",
      "back": "A `TaskGroup` provides a structured way to create a dynamic number of child tasks that can run concurrently. It's a core component of Swift's structured concurrency, ensuring that the parent task's scope does not exit until all child tasks have completed.\n\n**Core Concept & Error Handling:**\nYou create a group using `withTaskGroup` or `withThrowingTaskGroup`. Inside the group's closure, you can call `addTask` in a loop to spin up a variable number of child tasks. These tasks begin executing immediately and in parallel.\n\nIf any child task throws an error, the `TaskGroup` immediately cancels all other running and pending child tasks in the group. The `for try await` loop (or a call to `await group.next()`) that collects results will then rethrow that first error, unwinding the call stack and ensuring failures are propagated correctly.\n\n**Code Example:**\n```swift\n// Fetches multiple images concurrently, failing if any download fails.\nfunc fetchImages(urls: [URL]) async throws -> [UIImage] {\n    var images: [UIImage] = []\n    images.reserveCapacity(urls.count)\n\n    // Use a throwing group for tasks that can fail.\n    try await withThrowingTaskGroup(of: UIImage.self) { group in\n        for url in urls {\n            // Dynamically add a new child task for each URL.\n            // These tasks start running concurrently immediately.\n            group.addTask { \n                // It's crucial to check for cancellation inside child tasks.\n                try Task.checkCancellation()\n                let (data, _) = try await URLSession.shared.data(from: url)\n                guard let image = UIImage(data: data) else { \n                    throw URLError(.cannotDecodeContentData)\n                }\n                return image\n            }\n        }\n\n        // Await and collect results as they complete.\n        // If any task throws, this loop rethrows the error and exits.\n        for try await image in group {\n            images.append(image)\n        }\n    } // The group implicitly awaits all tasks before this scope exits.\n    return images\n}\n```\n\n**Common Pitfalls:**\n1.  **Leaking the Group:** Forgetting to iterate over the group to consume all results (e.g., using `for try await` or `next()`) will cause the parent task to suspend indefinitely, as it waits for a group that never finishes.\n2.  **Ignoring Cancellation:** Child tasks that perform long-running work without periodically checking `Task.isCancelled` or calling `Task.checkCancellation()` will continue to run even after the group is cancelled, wasting system resources.\n\n**When to Use vs. Alternatives:**\n-   **`TaskGroup`:** Use when the number of concurrent tasks is dynamic or unknown at compile time (e.g., processing an array of items).\n-   **`async let`:** Use for a small, fixed number of concurrent tasks where each result is distinct and known at compile time. It offers a simpler syntax for this specific use case (e.g., `async let profile = fetchProfile()`, `async let friends = fetchFriends()`).",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "taskgroup",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain how `@MainActor` enforces main-thread execution. How does this relate to the broader concept of global actors, and what fundamental problem does it solve compared to traditional `DispatchQueue.main.async` calls?",
      "back": "### Core Concept\n\n`@MainActor` is a *global actor*, a specific kind of actor that provides a globally unique, mutually-exclusive execution context. Its purpose is to protect access to resources that must be used on the main thread, primarily UI components from UIKit and SwiftUI. \n\nWhen you annotate a type, function, or property with `@MainActor`, you are telling the Swift compiler that it must only be accessed from the main thread's execution context. The compiler enforces this isolation. Any attempt to call a `@MainActor`-isolated function from a different concurrency context (e.g., a background `Task`) is a compile-time error unless you explicitly use `await`. The `await` keyword signals a potential suspension point where the program can suspend the background task and resume the function's execution on the main actor's executor (the main thread). \n\nThis solves a fundamental problem with `DispatchQueue.main.async`: safety. The older GCD approach relies on the developer to remember to dispatch UI updates to the main queue. Forgetting to do so results in a runtime crash or undefined UI behavior. `@MainActor` shifts this safety check from runtime to compile time, eliminating an entire class of common concurrency bugs.\n\n### Practical Code Example\n\n```swift\n// A custom global actor for a shared, thread-sensitive resource.\n@globalActor\nactor AnalyticsManager {\n    static let shared = AnalyticsManager()\n    private init() {}\n    func logEvent(_ name: String) { print(\"[Analytics] Event: \\(name)\") }\n}\n\n@MainActor // Isolates this entire class to the main thread.\nclass ProfileViewModel: ObservableObject {\n    @Published var username: String = \"Loading...\"\n\n    // This method is guaranteed to run on the main thread.\n    func updateUsername(_ newName: String) {\n        self.username = newName\n    }\n\n    func fetchUser() {\n        // Create a new unstructured task that runs on a background thread.\n        Task {\n            let userData = await fetchFromServer() // async call on background thread\n            \n            // The compiler FORCES an 'await' here to hop back to the MainActor.\n            // Without 'await', this would be a compile-time error.\n            await updateUsername(userData)\n\n            // We can also hop to another global actor's context.\n            await AnalyticsManager.shared.logEvent(\"user_profile_loaded\")\n        }\n    }\n    \n    // Simulate a network request.\n    private func fetchFromServer() async -> String {\n        try? await Task.sleep(for: .seconds(1))\n        return \"senior.dev\"\n    }\n}\n```\n\n### Common Pitfalls & Edge Cases\n\n1.  **Blocking the Main Thread**: `@MainActor` ensures *where* code runs, not *how*. A long-running, synchronous computation inside a `@MainActor` function will still freeze the UI. Heavy work must be offloaded to a background task or a different actor.\n2.  **`nonisolated` Misuse**: You can use `nonisolated` to opt-out a method from actor isolation. This is useful for pure functions that don't access actor state. Incorrectly marking a method that accesses `@Published` properties as `nonisolated` will cause a compile-time error.\n3.  **Initializer Context**: An initializer of a `@MainActor` type runs on the main actor by default. However, if you create an instance from a non-isolated context, the initializer will run in that context, which can be a source of subtle bugs if the initializer touches UI.\n\n### When to Use vs. Alternatives\n\n-   **`@MainActor`**: The modern, preferred choice for all UI-related code in a Swift Concurrency context (e.g., SwiftUI Views, ViewModels, UIKit ViewControllers). It provides compile-time safety, making code easier to reason about and less error-prone.\n-   **`DispatchQueue.main.async`**: A legacy mechanism. It's still necessary for interoperability with older, completion-handler-based APIs that are not `async`/`await` aware. For new code, `@MainActor` is superior because it prevents accidental UI updates from background threads at compile time, rather than crashing at runtime.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "mainactor",
        "global-actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "How do `AsyncSequence` and `AsyncStream` differ, and when would you use `AsyncStream` to bridge older asynchronous APIs into Swift Concurrency?",
      "back": "`AsyncSequence` is a protocol, analogous to `Sequence`, that defines a way to iterate over a series of values that become available over time. You consume it with a `for-await-in` loop, which \"pulls\" values as it's ready for them.\n\n`AsyncStream` is a concrete type that creates an `AsyncSequence`. Its primary role is to act as a bridge, adapting \"push-based\" asynchronous APIs (like delegate callbacks, closures, or notifications) into the \"pull-based\" world of `AsyncSequence`. It does this via a `Continuation`, which you use to `yield` values into the stream or `finish` it.\n\n**Practical Code Example: Wrapping a Delegate**\nHere, we adapt the delegate-based `CLLocationManager` to provide a modern `AsyncSequence` of location updates.\n\n```swift\nimport CoreLocation\n\nactor LocationProvider: NSObject, CLLocationManagerDelegate {\n    private let manager = CLLocationManager()\n    private var continuation: AsyncStream<CLLocation>.Continuation?\n\n    override init() {\n        super.init()\n        manager.delegate = self\n    }\n\n    // This stream is the public, modern API\n    var locations: AsyncStream<CLLocation> {\n        AsyncStream { continuation in\n            self.continuation = continuation\n            // When the stream is terminated, this is called for cleanup\n            continuation.onTermination = { @Sendable [weak self] _ in\n                self?.manager.stopUpdatingLocation()\n            }\n            manager.requestWhenInUseAuthorization()\n            manager.startUpdatingLocation()\n        }\n    }\n\n    // The old delegate method \"pushes\" values into the stream\n    nonisolated func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        // We must hop back to the actor to safely access the continuation\n        Task { await self.yield(locations) }\n    }\n\n    private func yield(_ locations: [CLLocation]) {\n        locations.forEach { continuation?.yield($0) }\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Forgetting `continuation.finish()`:** If you don't explicitly finish the stream (e.g., on error or deinit), any `for-await-in` loop consuming it will hang forever, leaking resources.\n- **Ignoring Backpressure:** The `bufferingPolicy` parameter is critical. The default `.unbounded` can cause memory to grow indefinitely if values are produced faster than consumed. For UI updates, `.bufferingNewest(1)` is often a better choice.\n- **Continuation Thread Safety:** The continuation is not thread-safe. If callbacks can occur on different threads, you must synchronize access. Using an actor, as shown above, is the standard Swift Concurrency pattern to achieve this.\n\n**When to Use vs. Alternatives:**\n- **Use `AsyncStream`:** To adapt any non-`async` source of events (delegates, KVO, NotificationCenter, completion handlers) into an `AsyncSequence`. It's the primary tool for bridging legacy code.\n- **Alternatives:** For a finite set of concurrent jobs, use a `TaskGroup`. For reactive data flows in a Combine-heavy project, use a `Publisher` (which can be converted to an `AsyncSequence` via its `.values` property). `AsyncStream` is specifically for creating an ongoing, potentially infinite sequence of asynchronous values from a non-structured source.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "async-await",
        "asyncsequence"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "How do Swift actors prevent data races on shared mutable state, and what is the concept of 'actor isolation' that enables this safety at compile time?",
      "back": "Actors are a core component of Swift's structured concurrency model, designed to solve data races on shared mutable state. They act as 'islands of serialization' in a concurrent environment.\n\n**Core Concept:**\nAn actor is a reference type that encapsulates its state and ensures that only one task can access that state at a time. It achieves this by managing a 'mailbox' of incoming requests (method calls, property access) and executing them serially. This eliminates the need for manual locking (like `NSLock` or serial dispatch queues) and their associated pitfalls like deadlocks or priority inversions.\n\n'Actor isolation' is the set of compiler rules that enforces this safety. The compiler understands which code is 'on the actor' and which is not. \n1.  **External Access:** Any access to an actor's mutable properties or methods from outside its own context must be asynchronous and marked with `await`. This `await` signifies a potential suspension point where the calling task yields the thread, allowing the actor to process the request when it's free.\n2.  **Internal Access:** Code within an actor's methods can access its own properties and methods synchronously, as it's already operating within the protected, serial context.\n\n**Practical Code Example:**\n```swift\nactor BankAccount {\n    private var balance: Double\n\n    init(initialDeposit: Double) {\n        self.balance = initialDeposit\n    }\n\n    // This method is part of the actor's isolated context.\n    func deposit(amount: Double) {\n        balance += amount\n        logTransaction(type: \"Deposit\", amount: amount)\n    }\n\n    // Internal methods can be called synchronously from other isolated methods.\n    private func logTransaction(type: String, amount: Double) {\n        print(\"\\(type): $\\(amount), New Balance: $\\(balance)\")\n    }\n    \n    // Use 'nonisolated' for properties that are immutable (let) or don't need protection.\n    nonisolated let accountId: UUID = UUID()\n}\n\nfunc performTransactions() async {\n    let account = BankAccount(initialDeposit: 1000)\n\n    // External access to an actor's methods MUST be awaited.\n    // This suspends performTransactions and sends a message to the actor's mailbox.\n    await account.deposit(amount: 500)\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Reentrancy:** When an actor-isolated method `await`s another async call, it becomes reentrant. This means the actor can process other incoming messages while suspended. This can lead to unexpected state changes if not handled carefully, as the state might not be the same before and after the `await`. This is a key difference from a traditional lock, which would block the entire context.\n*   **Misusing `nonisolated`:** Declaring a method or a mutable `var` property as `nonisolated` breaks the actor's safety guarantees and can re-introduce data races. It should only be used for truly immutable state (`let` constants) or methods that don't touch the actor's isolated state.\n\n**When to Use vs. Alternatives:**\n*   **vs. Serial `DispatchQueue`:** Actors are the modern, safer choice for protecting instance state. The compiler enforces correct usage. A serial queue relies on developer discipline (`queue.async { ... }`) and provides no compile-time safety against accidental synchronous access from another thread.\n*   **vs. `NSLock`:** `NSLock` is a low-level, manual locking mechanism. It's error-prone (risk of deadlocks, forgetting to unlock) and doesn't integrate with structured concurrency. Use actors for state protection; reserve locks for fine-grained control over small, critical sections where actor overhead is a proven concern.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "structured-concurrency",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "How does the `Sendable` protocol, in conjunction with Swift's structured concurrency, prevent data races? Explain its compile-time checks and the implications of marking a custom type as `Sendable`.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's concurrency safety model. It's a marker protocol, meaning it has no requirements itself, but instead provides a semantic guarantee to the compiler: a type conforming to `Sendable` can be safely transferred from one concurrency domain to another (e.g., between actors or to a background `Task`).\n\n**Core Concept:**\nThe compiler uses `Sendable` conformance to statically verify that you are not creating shared mutable state, which is the primary cause of data races. A type can be `Sendable` if:\n1. It is a value type (`struct`, `enum`) where all its stored properties are also `Sendable`.\n2. It is a reference type (`class`) that is `final` and contains only immutable stored properties (`let`) of `Sendable` types.\n3. It is a reference type that ensures thread-safety through internal synchronization (e.g., using locks or a serial queue) and is explicitly marked `@unchecked Sendable`. This is an unsafe escape hatch that puts the responsibility on the developer.\nActors, by their nature of serializing access to their state, are implicitly `Sendable`.\n\n**Practical Code Example:**\n```swift\n// 1. Struct is implicitly Sendable because its members are.\nstruct UserProfile: Sendable {\n    let id: UUID\n    let score: Int\n}\n\n// 2. This class is NOT Sendable due to the mutable `var`.\nclass ScoreTracker {\n    var highScores: [String: Int] = [:] // Unsafe to share\n}\n\n// 3. A final class with only immutable 'let' properties can be Sendable.\nfinal class AppConfig: Sendable {\n    let apiBaseURL: URL\n    let featureFlags: Set<String>\n    init(apiBaseURL: URL, featureFlags: Set<String>) { /*...*/ }\n}\n\n// This function requires a Sendable type, ensuring safety.\nfunc processInBackground<T: Sendable>(_ data: T) async {\n    print(\"Processing \\(data) on a background thread.\")\n}\n\nTask {\n    let profile = UserProfile(id: UUID(), score: 100)\n    await processInBackground(profile) // \u2705 Compiles: UserProfile is Sendable\n    \n    let config = AppConfig(apiBaseURL: URL(string: \"...\")!, featureFlags: [\"newUI\"])\n    await processInBackground(config) // \u2705 Compiles: AppConfig is Sendable\n\n    // let tracker = ScoreTracker()\n    // await processInBackground(tracker) // \ud83d\uded1 Compile Error: ScoreTracker does not conform to Sendable\n}\n```\n\n**Common Pitfalls:**\n- **Misusing `@unchecked Sendable`**: This silences the compiler but does not add thread safety. It's a contract that you, the developer, have implemented synchronization. Forgetting a lock or getting it wrong will lead to data races that the compiler can no longer help you find.\n- **Implicit Conformance Trap**: A `struct` is only `Sendable` if *all* its stored properties are. Adding a single non-`Sendable` property (like a reference to a plain class) will break the implicit conformance, often leading to unexpected compiler errors elsewhere.\n- **Closure Captures**: Closures passed to concurrent contexts (like `Task.init`) must be `@Sendable`. This means they can only capture `Sendable` values. Capturing a non-`Sendable` class instance will result in a compile-time error.\n\n**When to Use vs. Alternatives:**\n- **Prefer Value Types**: The idiomatic Swift approach is to use `Sendable` structs and enums to communicate data between concurrent tasks. This avoids shared mutable state entirely by passing copies.\n- **Use Actors for Shared Mutable State**: When you truly need a single, mutable source of truth, encapsulate it within an actor. Actors are `Sendable` by nature, and the `await` keyword ensures that access to their internal state is synchronized and safe.\n- **Use `Sendable` Classes for Immutable Shared State**: For shared configuration or caches that are initialized once and never change, a `final class` with `let` properties is a lightweight and efficient `Sendable` type.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-structured-concurrency",
        "sendable",
        "actors",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}