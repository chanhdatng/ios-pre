{
  "topic": "concurrency",
  "generated_at": "2026-01-15T04:04:42.375014+00:00",
  "cards": [
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Explain how to use a `TaskGroup` to concurrently fetch heterogeneous data (e.g., a User profile and a list of Posts). How does it handle dynamic task creation, result aggregation, error propagation, and cancellation?",
      "back": "A `TaskGroup` is a core component of Swift's structured concurrency for managing a dynamic number of concurrent child tasks. It creates a scope where tasks can be added, and the group automatically waits for all tasks to complete before its scope is exited.\n\n**Core Concept:**\nYou use `withThrowingTaskGroup(of:returning:)` to create a group. Child tasks are added via `group.addTask { ... }`. The group acts as an `AsyncSequence`, allowing you to iterate over results as they complete, not necessarily in the order they were added. For heterogeneous data types, a common pattern is to use an enum with associated values as the group's `ChildTaskResult` type. If any child task throws an error, the group cancels all other unfinished tasks, waits for them to terminate, and then rethrows the original error.\n\n**Code Example:**\n```swift\n// Enum to handle different result types from the group's tasks\nenum DashboardData {\n    case profile(User)\n    case posts([Post])\n}\n\nfunc fetchDashboardData() async throws -> (User, [Post]) {\n    // The group's result type is our enum\n    return try await withThrowingTaskGroup(of: DashboardData.self) { group in\n        // Dynamically add tasks for each piece of data\n        group.addTask {\n            let user = try await api.fetchUserProfile()\n            return .profile(user)\n        }\n        group.addTask {\n            let posts = try await api.fetchRecentPosts()\n            return .posts(posts)\n        }\n\n        // Collect results as they complete\n        var userResult: User?\n        var postsResult: [Post]?\n        for try await result in group {\n            switch result {\n            case .profile(let user): userResult = user\n            case .posts(let posts): postsResult = posts\n            }\n        }\n\n        // Ensure all required data was fetched\n        guard let user = userResult, let posts = postsResult else {\n            throw MyError.missingDashboardData\n        }\n        return (user, posts)\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Result Ordering:** Results are not guaranteed to arrive in the order tasks were added. Code must be resilient to this.\n2.  **Cancellation:** If one task throws, all others are cancelled. Long-running child tasks should periodically check `Task.isCancelled` and throw a `CancellationError` to exit promptly.\n3.  **Forgetting `try await`:** The `for await` loop over a throwing group must be marked with `try` to handle potential errors from child tasks.\n4.  **Mutating Shared State:** Avoid mutating external state from within child tasks to prevent data races. Instead, return values from the tasks and aggregate them after the loop, as shown above.\n\n**When to Use vs. Alternatives:**\n*   **`TaskGroup`:** Use for a *dynamic* number of concurrent tasks, especially when the count isn't known at compile time (e.g., fetching images for a list of URLs) or when you want to process results as they arrive.\n*   **`async let`:** Use for a *fixed, small* number of concurrent tasks known at compile time. It has a simpler syntax (`async let user = ..., async let posts = ...`) but requires awaiting all results at once at the end.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "taskgroup"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Compare `NSLock`, a serial `DispatchQueue`, and `actor` for preventing data races on a shared mutable resource. Discuss their mechanisms, performance trade-offs, and common pitfalls.",
      "back": "A data race occurs when multiple threads access shared mutable state without synchronization, with at least one access being a write. Swift offers several mechanisms to prevent this, each with distinct trade-offs.\n\n**1. NSLock (Mutex Lock)**\nThis is a fundamental synchronization primitive. It ensures only one thread can execute a critical section of code at a time by acquiring a lock before entry and releasing it upon exit.\n- **Mechanism:** A thread calls `lock()`. If the lock is available, it takes it and proceeds. If not, the thread blocks until the lock is released. `unlock()` releases it.\n- **Use Case:** Protecting small, performance-sensitive critical sections. It's a lightweight, low-overhead option when contention is low.\n- **Pitfall:** Forgetting to call `unlock()`, especially in error paths, leads to a permanent lock. Always use `defer { lock.unlock() }`. Also, acquiring multiple locks in different orders across threads can cause deadlocks.\n\n**2. Serial DispatchQueue (GCD)**\nThis approach leverages Grand Central Dispatch to ensure tasks submitted to a specific serial queue execute one at a time, in FIFO order.\n- **Mechanism:** All reads and writes to the shared resource are dispatched (synchronously or asynchronously) to the same serial queue.\n- **Use Case:** A common pattern in older codebases for isolating access to properties or coordinating larger blocks of work that must be sequential.\n- **Pitfall:** Improper use of `sync` can lead to deadlocks. If you call `queue.sync` from a task already running on that same `queue`, your app will freeze. It can also cause priority inversion if a low-priority task on the queue blocks a high-priority one.\n\n**3. Actor (Swift Concurrency)**\nThe modern, compiler-enforced solution. An actor protects its mutable state by ensuring only one task can access it at a time.\n- **Mechanism:** The compiler guarantees that all access to an actor's state from the outside is asynchronous (`await`). This allows the actor to process one message at a time, creating a suspension point for callers and preventing interleaved access.\n- **Use Case:** The default choice for isolating state in modern Swift. It provides compile-time safety against data races, which is superior to manual locking.\n- **Pitfall:** Re-entrancy. An actor can suspend while `await`ing an async call. During this suspension, another task can enter the actor and modify its state, which can lead to logic errors if you assume state remains unchanged across an `await` point.\n\n**Code Example:**\n```swift\n// NSLock\nclass SafeCounterLock {\n    private var value = 0\n    private let lock = NSLock()\n    func increment() {\n        lock.lock()\n        defer { lock.unlock() } // Essential for safety\n        value += 1\n    }\n}\n\n// Serial DispatchQueue\nclass SafeCounterQueue {\n    private var value = 0\n    private let queue = DispatchQueue(label: \"counter.queue\")\n    func increment() {\n        queue.sync { // sync ensures write completes before returning\n            self.value += 1\n        }\n    }\n}\n\n// Actor\nactor SafeCounterActor {\n    private(set) var value = 0\n    func increment() {\n        value += 1\n    }\n}\n```\n\n**Conclusion:** Use `actor` by default in modern Swift projects for its compile-time safety. Use `DispatchQueue` for serializing larger workflows or in GCD-heavy codebases. Reserve `NSLock` for specific, low-level performance optimizations where you can manually manage the risks.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "gcd",
        "locking",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Explain the relationship between AsyncSequence and AsyncStream. When would you use AsyncStream to bridge older APIs, and what are the critical considerations regarding backpressure and continuation management?",
      "back": "### Core Concept\n`AsyncSequence` is a protocol, analogous to `Sequence`, but for the asynchronous world. It defines a standard way to produce a sequence of values over time, allowing consumption via a `for await...in` loop. It's the abstraction you should use in your public APIs.\n\n`AsyncStream` is a concrete type that conforms to `AsyncSequence`. Its primary role is to act as a bridge, adapting existing, non-async code (like delegate patterns, KVO, or callback-based APIs) into the modern structured concurrency paradigm. It provides a `continuation` which you can imperatively call to `yield` values, `finish` the stream, or throw an error.\n\n### Practical Code Example\nLet's wrap a delegate-based `LocationManager` that provides location updates into an `AsyncStream`.\n\n```swift\n// 1. A typical delegate-based class\nclass LocationManager {\n    var onLocationUpdate: ((CLLocation) -> Void)?\n    func startUpdating() { /* Simulates starting updates */ }\n}\n\n// 2. The bridging function using AsyncStream\nfunc locationUpdates() -> AsyncStream<CLLocation> {\n    let manager = LocationManager()\n    return AsyncStream { continuation in\n        // Set the callback to yield values to the stream\n        manager.onLocationUpdate = { location in\n            continuation.yield(location)\n        }\n        // Define cleanup for when the stream is cancelled\n        continuation.onTermination = { @Sendable _ in\n            // Stop updates to prevent resource leaks\n            print(\"Stream terminated. Cleaning up.\")\n        }\n        manager.startUpdating()\n    }\n}\n\n// 3. Consuming the stream\nTask {\n    for await location in locationUpdates() {\n        print(\"New location: \\(location)\")\n        // The loop will run indefinitely until the task is cancelled\n    }\n}\n```\n\n### Common Pitfalls\n- **Backpressure:** `AsyncStream` has an internal, unbounded buffer. If the producer (e.g., the delegate) `yield`s values much faster than the consumer (`for await` loop) processes them, this buffer can grow indefinitely, leading to high memory usage. Be mindful of this with high-frequency event sources.\n- **Continuation Management:** The continuation must be handled carefully. You must call `finish()` to terminate the stream gracefully. Calling `yield()` after `finish()` is a fatal error. Ensure all code paths eventually lead to a `finish()` call if the source is finite.\n- **Thread Safety:** The continuation is not thread-safe. If your callbacks can arrive on different threads, you must synchronize access to the continuation, for example by using an actor.\n\n### When to Use vs. Alternatives\n- **Use `AsyncStream`:** Ideal for wrapping callback/delegate APIs, KVO notifications, or any imperative event source into a modern `AsyncSequence`.\n- **Alternatives:** For transforming existing async sequences, use operators like `map` and `filter`. For one-off async results, a simple `async` function is better. Combine's `Publisher` serves a similar purpose but is part of a separate framework; `AsyncSequence` is the native Swift Concurrency tool.",
      "code_example": null,
      "tags": [
        "concurrency",
        "async-await",
        "swift",
        "structured-concurrency",
        "asyncsequence"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency fundamentally change error handling and resource management compared to older models like GCD or completion handlers?",
      "back": "Swift's Structured Concurrency introduces a new paradigm where concurrent tasks are organized in a hierarchy, or tree. A task can have child tasks, but the parent task's scope cannot exit until all its child tasks have completed. This parent-child relationship provides compile-time safety and guarantees that are difficult to achieve with older APIs like GCD or `OperationQueue`.\n\n**Core Concept:**\nThe core idea is *scoped lifetimes*. When you create child tasks using `async let` or a `TaskGroup`, their lifetimes are bound to the scope of the parent task. This structure provides three main benefits:\n1.  **Error Propagation**: If any child task throws an error, it's automatically propagated up to the parent. The parent's `TaskGroup` or `await` on an `async let` binding will rethrow the error, and all sibling tasks are implicitly cancelled.\n2.  **Cancellation Propagation**: If a parent task is cancelled, the cancellation is automatically cascaded down to all its children. This prevents orphaned tasks from continuing to run and waste resources.\n3.  **Resource Management**: Because a parent waits for all children, you can safely manage resources. For example, a file handle opened at the start of a scope is guaranteed to be usable by all child tasks and can be safely closed when the scope exits, as all children will have finished by then.\n\n**Practical Code Example:**\nFetching a user profile and their posts concurrently using a `TaskGroup`.\n```swift\nstruct UserProfile { let name: String }\nstruct Post { let title: String }\n\nenum FetchResult {\n    case profile(UserProfile)\n    case posts([Post])\n}\n\nfunc fetchUserData(for userID: String) async throws -> (UserProfile, [Post]) {\n    // A TaskGroup provides a scope for a dynamic number of child tasks.\n    // If any child throws, the group is cancelled and the error is rethrown.\n    return try await withThrowingTaskGroup(of: FetchResult.self) { group in\n        group.addTask {\n            // Simulating network call for profile\n            return .profile(try await fetchProfile(for: userID))\n        }\n        group.addTask {\n            // Simulating network call for posts\n            return .posts(try await fetchPosts(for: userID))\n        }\n\n        var profile: UserProfile?\n        var posts: [Post]?\n\n        // The group awaits all children. The loop finishes when all tasks are done.\n        for try await result in group {\n            switch result {\n            case .profile(let p): profile = p\n            case .posts(let ps): posts = ps\n            }\n        }\n\n        guard let finalProfile = profile, let finalPosts = posts else {\n            throw URLError(.badServerResponse) // Or a custom error\n        }\n        return (finalProfile, finalPosts)\n    }\n}\n```\n\n**Common Pitfalls:**\n-   **Accidental Unstructured Tasks**: Using `Task { ... }` inside an async function creates a new, detached, top-level task, breaking the parent-child structure. For structured concurrency, you must use `async let` or a `TaskGroup`.\n-   **Misunderstanding Cancellation**: A single thrown error in a `TaskGroup` cancels all other running sibling tasks. Developers must be prepared to handle `CancellationError` in their async functions if cleanup is required.\n-   **`async let` vs. `TaskGroup`**: Using a `TaskGroup` for a small, fixed number of heterogeneous tasks is verbose. `async let` is better suited for that. Use `TaskGroup` for a dynamic number of tasks, often created in a loop.\n\n**When to Use vs. Alternatives:**\n-   **vs. `DispatchGroup`**: `DispatchGroup` requires manual `enter()`/`leave()` calls, manual error collection in a thread-safe way, and has no built-in cancellation propagation. Structured Concurrency automates all of this, making code safer and easier to reason about.\n-   **vs. `OperationQueue`**: `OperationQueue` provides dependency management, but it lacks the compile-time safety and automatic cancellation/error propagation of the new concurrency model. It's a heavier, object-oriented approach compared to the lightweight, value-based nature of tasks.",
      "code_example": null,
      "tags": [
        "Concurrency",
        "Swift Concurrency",
        "Structured Concurrency",
        "async/await",
        "TaskGroup"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain how `@MainActor` provides main-thread safety compared to `DispatchQueue.main`. How would you extend this actor-based isolation to protect another app-wide shared resource, like a database connection?",
      "back": "The `@MainActor` attribute designates that a type or function must execute on the main thread. It's a *global actor*, a mechanism in Swift Concurrency that provides mutually exclusive access to a shared resource\u2014in this case, the main thread. The key differentiator from `DispatchQueue.main` is that `@MainActor` provides **compile-time safety**. The Swift compiler understands this attribute and will produce an error if you attempt to call a `@MainActor`-isolated function from a non-isolated context without `await`, effectively preventing data races on UI components before the app even runs.\n\n`DispatchQueue.main.async` is a runtime mechanism. It ensures a block of code runs on the main thread, but the compiler offers no guarantees that you've remembered to use it everywhere necessary. This leaves the responsibility entirely on the developer, making it prone to error.\n\nTo protect another app-wide resource, you can define a custom global actor. This pattern is ideal for resources that are inherently singular, like a file manager, a logger, or a database access layer.\n\n```swift\n// 1. Using @MainActor for a ViewModel\n@MainActor\nclass ProfileViewModel: ObservableObject {\n    @Published var username: String = \"\"\n\n    // This method is guaranteed to run on the main thread.\n    func updateUsername(to newName: String) {\n        self.username = newName\n    }\n\n    func fetchUser() {\n        Task {\n            // Background work happens here\n            let fetchedName = await ApiClient.fetchUserName()\n            // This call is safely marshalled back to the main thread\n            // due to the class-level @MainActor attribute.\n            updateUsername(to: fetchedName)\n        }\n    }\n}\n\n// 2. Creating a custom global actor for database access\n@globalActor\nstruct DatabaseActor {\n    // The shared actor instance that serializes access.\n    static let shared = ActorType()\n    typealias ActorType = Actor\n}\n\n@DatabaseActor\nclass DatabaseManager {\n    // All methods in this class are now isolated to the DatabaseActor.\n    func save(record: String) async {\n        // ... safe database write operations\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Blocking:** `@MainActor` isolation doesn't prevent you from writing blocking synchronous code. A long-running calculation on the main actor will still freeze the UI.\n- **Overuse of `nonisolated`:** Using the `nonisolated` keyword to bypass actor protection on a function that mutates shared state defeats the safety model.\n- **Global vs. Instance Actors:** Using a global actor when a regular instance actor would suffice. Global actors are for truly singular, system-wide resources. For protecting the state of an object instance, use a standard `actor`.\n\n**When to Use:**\n- **`@MainActor`:** The modern standard for any code that touches UIKit/SwiftUI. Use it on ViewModels, ViewControllers, and SwiftUI Views.\n- **Custom Global Actor:** For a single, shared resource like a logger, keychain wrapper, or analytics manager that needs coordinated access from anywhere in the app.\n- **`DispatchQueue.main`:** For legacy code, interacting with non-async frameworks, or simple, one-off dispatches where full type isolation is overkill.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "mainactor",
        "gcd"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain how an actor's isolation mechanism prevents data races at compile time. Contrast this with traditional lock-based or serial queue synchronization on a class, and discuss the concept of actor re-entrancy.",
      "back": "### Core Concept\nAn `actor` is a reference type in Swift that protects its mutable state from concurrent access, a problem known as data races. It achieves this through **actor isolation**. The core principle is that all of an actor's mutable state can only be accessed from its own isolated context. Internally, an actor manages a serial executor (often conceptualized as a \"mailbox\") that processes incoming method calls one at a time, in the order they are received.\n\nThe Swift compiler enforces this isolation. When code outside the actor tries to access its properties or methods, it must do so asynchronously using `await`. This keyword signifies a potential suspension point. The calling task is suspended, its request is added to the actor's mailbox, and the actor processes it when it's free. This compile-time check is the key advantage over older methods.\n\n### Contrast with Alternatives\n- **Serial `DispatchQueue`:** A common pattern was a `class` with a private serial queue to synchronize access to properties. This relies on developer discipline. The compiler won't stop you from forgetting the `queue.sync/async` call and accessing a property directly, creating a data race. Actors make such an error a compile-time failure.\n- **`NSLock`:** This is a lower-level primitive. It requires manually locking and unlocking around critical sections. It's error-prone (forgetting to unlock, deadlocks) and can be less efficient as it blocks threads, whereas actors suspend tasks, allowing the thread to do other work.\n\n### Code Example\n```swift\nactor TemperatureSensor {\n    private var measurements: [Double] = []\n    var high: Double = -Double.infinity\n\n    // External access MUST use 'await'. This is a compiler guarantee.\n    func record(measurement: Double) {\n        measurements.append(measurement)\n        if measurement > high {\n            // Synchronous access is safe inside the actor.\n            high = measurement\n        }\n    }\n\n    // A non-mutating method also requires await from the outside.\n    func getAverage() -> Double {\n        guard !measurements.isEmpty else { return 0.0 }\n        return measurements.reduce(0, +) / Double(measurements.count)\n    }\n}\n\nfunc monitor(sensor: TemperatureSensor) async {\n    // Compile Error: Actor-isolated 'record' can only be called from an async context\n    // sensor.record(measurement: 98.6)\n\n    // Correct: Use 'await' to cross the actor isolation boundary.\n    await sensor.record(measurement: 98.6)\n    let average = await sensor.getAverage()\n    print(\"Average temperature: \\(average)\")\n}\n```\n\n### Common Pitfalls: Actor Re-entrancy\nA critical concept to understand is **re-entrancy**. When an actor's method suspends (by calling `await` on another async function), it relinquishes its thread. While suspended, other calls in its mailbox can be processed. This means the actor's state can change *during* the suspension point of a method. This is unlike a lock, which would block other access entirely. Developers must not assume state is unchanged across an `await` call within an actor method, as this can lead to subtle bugs.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "data-race-safety",
        "re-entrancy"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "How does the `Sendable` protocol prevent data races in Swift's concurrency model? Describe its requirements, how the compiler enforces thread-safety, and the specific rules for value types, actors, and classes.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's concurrency safety model. It's a marker protocol, meaning it has no required methods or properties; its purpose is to signal to the compiler that values of a conforming type can be safely copied and shared across concurrency boundaries (e.g., between actors or from a non-isolated context to a `Task`). This allows the compiler to statically detect potential data races.\n\n**Core Concept & Enforcement:**\n- **Value Types (Structs, Enums):** Are implicitly `Sendable` if all their stored properties are also `Sendable`. Since value types are copied, there's no shared mutable state, preventing data races by design.\n- **Actors:** Are implicitly `Sendable` because they encapsulate their state and only allow access through their synchronized, `async` interface, ensuring no data races occur.\n- **Classes:** Conformance is manual and requires strict guarantees. A class can be `Sendable` if it's a `final` class with only immutable (`let`) stored properties of `Sendable` types, or if it internally manages synchronization for all its mutable state (e.g., using a private lock or a serial dispatch queue).\n\n**Practical Code Example:**\n```swift\n// A class with mutable state that needs internal synchronization to be Sendable.\nfinal class ScoreCounter: Sendable {\n    // A private serial queue ensures all access to _score is synchronized.\n    private let syncQueue = DispatchQueue(label: \"com.score.sync\")\n    private var _score = 0\n\n    func increment() {\n        syncQueue.async {\n            self._score += 1\n        }\n    }\n\n    var score: Int {\n        // sync is used for reads to get the value back immediately.\n        syncQueue.sync { _score }\n    }\n}\n\nactor Game {\n    let scoreCounter = ScoreCounter()\n\n    // This is safe because ScoreCounter is Sendable.\n    func updateScore() async {\n        scoreCounter.increment()\n    }\n}\n```\n\n**Common Pitfalls:**\n- **`@unchecked Sendable`:** This attribute silences compiler warnings and forces a type to be treated as `Sendable`. It's a dangerous escape hatch that should only be used when you can manually prove thread-safety (e.g., for an Objective-C class documented as thread-safe). Misusing it reintroduces the risk of data races.\n- **Implicit Conformance Failure:** A struct containing a non-`Sendable` property (like a plain `class` instance) will lose its implicit `Sendable` conformance, which can cause unexpected compiler errors higher up in your data model.\n\n**When to Use vs. Alternatives:**\n`Sendable` is not optional when working with Swift's modern concurrency features like actors and tasks. It's the primary mechanism for ensuring type safety across concurrency domains. The alternative is to revert to older concurrency patterns like manual GCD, `NSLock`, or `NSOperationQueue` without the benefit of compile-time safety checks. `Sendable` provides a superior, safer model by shifting data race detection from runtime (via crashes or the Thread Sanitizer) to compile time.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "sendable",
        "data race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}