{
  "topic": "concurrency",
  "generated_at": "2026-01-14T04:19:33.241982+00:00",
  "cards": [
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol helps prevent data races in Swift Concurrency. Describe a scenario where you'd need to use `@unchecked Sendable` and the risks involved.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's modern concurrency model, designed to provide compile-time guarantees against data races. It acts as a 'marker' protocol, indicating that a type's values can be safely copied and shared between different actors or tasks without introducing shared mutable state.\n\n**Core Concept:**\nA data race occurs when multiple threads access the same memory location concurrently, and at least one access is a write. `Sendable` prevents this by ensuring that any type passed across a concurrency boundary is either a value type (like a struct or enum) whose members are also `Sendable`, or a reference type (class) that is immutable or internally synchronized. The compiler enforces this, flagging attempts to pass non-`Sendable` types into actors or `Task` closures as errors.\n\n**Practical Code Example:**\n```swift\n// Structs with Sendable members are implicitly Sendable.\nstruct UserProfile: Sendable {\n    let id: Int\n    let username: String\n}\n\n// This class is NOT Sendable due to the 'var' property.\nclass UserSettings {\n    var isDarkMode: Bool = false\n}\n\n// This wrapper uses a lock, but the compiler can't see it.\n// We must manually and carefully assert its thread-safety.\nfinal class ThreadSafeSettings: @unchecked Sendable {\n    private let lock = NSLock()\n    private var _isDarkMode: Bool = false\n\n    var isDarkMode: Bool {\n        get { lock.withLock { _isDarkMode } }\n        set { lock.withLock { _isDarkMode = newValue } }\n    }\n}\n\nactor AccountManager {\n    private var settings = ThreadSafeSettings()\n\n    // OK: UserProfile is Sendable.\n    func updateProfile(_ profile: UserProfile) { /* ... */ }\n\n    // ERROR: Non-Sendable type 'UserSettings' passed across actor boundary.\n    // func updateUnsafeSettings(_ settings: UserSettings) { /* ... */ }\n\n    // OK: We've promised the compiler this is safe.\n    func updateSafeSettings(_ newSettings: ThreadSafeSettings) {\n        self.settings = newSettings\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\nThe most significant pitfall is misusing `@unchecked Sendable`. This directive overrides the compiler's safety checks. You are making a promise that you have ensured thread safety through other means (e.g., internal locking). If this promise is broken, you re-introduce the potential for data races that Swift Concurrency aims to eliminate. It's typically reserved for wrapping legacy, thread-safe Objective-C classes or complex custom synchronization patterns.\n\n**When to Use:**\nYou don't 'choose' to use `Sendable` as an alternative to something else; it's a fundamental requirement for passing data between actors and tasks in Swift Concurrency. The real choice is between designing your types to conform to `Sendable` (preferring value types like structs) versus falling back to older, manual synchronization primitives like locks or serial dispatch queues. Adhering to `Sendable` allows the compiler to reason about your code and provide powerful safety guarantees, which is strongly preferred over manual, error-prone locking mechanisms.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "sendable",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "How do `TaskGroup`s enable dynamic, structured concurrency in Swift, and what are the key considerations for error handling and cancellation within a group?",
      "back": "A `TaskGroup` provides a structured way to perform a dynamic number of concurrent child tasks. It's a cornerstone of structured concurrency, guaranteeing that the parent task will not continue until all child tasks in the group have completed.\n\n**Core Concept:**\nYou create a task group using `withTaskGroup` or `withThrowingTaskGroup`. Inside the group's closure, you can dynamically add child tasks using `group.addTask()`. The group acts as an asynchronous sequence, allowing you to iterate over the results as they complete. If any child task in a `withThrowingTaskGroup` throws an error, the group is automatically cancelled, and all other running child tasks will be notified of the cancellation. The `for try await` loop will then rethrow the original error.\n\n**Practical Code Example:**\n```swift\n// Fetches multiple image URLs concurrently and returns the downloaded images.\nfunc fetchImages(from urls: [URL]) async throws -> [UIImage] {\n    return try await withThrowingTaskGroup(of: UIImage.self) { group in\n        // Dynamically add a task for each URL.\n        for url in urls {\n            group.addTask { \n                let (data, _) = try await URLSession.shared.data(from: url)\n                // Check for cancellation before doing expensive work.\n                try Task.checkCancellation()\n                guard let image = UIImage(data: data) else {\n                    throw URLError(.badServerResponse) // Or a custom error\n                }\n                return image\n            }\n        }\n\n        // Collect results as they finish. `reduce` is a concise way to do this.\n        return try await group.reduce(into: [UIImage]()) { $0.append($1) }\n    }\n}\n```\n**Common Pitfalls & Edge Cases:**\n1.  **Implicit Cancellation:** If one task in a `withThrowingTaskGroup` throws, all other tasks are implicitly cancelled. You must check for cancellation (`try Task.checkCancellation()` or `Task.isCancelled`) within your child tasks to stop work early.\n2.  **Forgetting to Await Results:** The group's scope (`with...TaskGroup`) does not exit until all child tasks are complete, but you must explicitly `await` the results (e.g., via a `for try await` loop or `reduce`) to use them.\n3.  **Unstructured Tasks:** Calling `Task { ... }` inside a group breaks structured concurrency. Always use `group.addTask { ... }` to ensure the child task's lifetime is scoped to the group.\n\n**When to Use vs. Alternatives:**\n-   **Use `TaskGroup`:** When the number of concurrent tasks is **dynamic** or unknown at compile time (e.g., fetching data for a list of IDs).\n-   **Use `async let`:** When you have a **fixed, small number** of concurrent tasks known at compile time. The syntax is more lightweight and declarative for this specific scenario.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "taskgroup",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Describe how `@MainActor` enforces main-thread-only access at compile time. How does this differ from runtime checks, and when would you define a custom global actor for a non-UI-related shared resource?",
      "back": "### Core Concept\n\n`@MainActor` is a global actor that guarantees its code executes on the main thread. It achieves this through Swift's actor isolation model. When a type, function, or property is annotated with `@MainActor`, the compiler enforces that it can only be accessed from a context that is also on the main actor. Any attempt to access it from a different concurrency context (like a `Task` on a background thread) requires an `await` to safely transfer execution, or it will result in a compile-time error. This is a fundamental shift from the older `DispatchQueue.main.async` pattern, which was a runtime mechanism. With GCD, you could forget to dispatch to the main queue, leading to runtime crashes or UI glitches that the compiler couldn't detect.\n\nCustom global actors generalize this concept. They allow you to define a globally unique actor to serialize access to any shared resource, not just the UI. This is useful for resources like a database connection, a file logger, or a keychain wrapper that must be accessed serially from various parts of your application.\n\n### Code Example\n\n```swift\n// 1. Define a custom global actor for a logging resource\n@globalActor\nstruct LoggerActor {\n    actor ActorType {}\n    static let shared = ActorType()\n}\n\n@MainActor // This entire class is isolated to the main actor\nclass ContentViewModel: ObservableObject {\n    @Published var data: String = \"Loading...\"\n\n    // This property can only be mutated from the main actor.\n    // The compiler will enforce this.\n\n    func fetchData() {\n        Task {\n            // This task runs on a background thread by default\n            let result = await performNetworkRequest()\n            \n            // Compile Error if you just write `updateData(with: result)`!\n            // Must 'await' to hop back to the MainActor\n            await updateData(with: result)\n            \n            await logCompletion()\n        }\n    }\n\n    private func performNetworkRequest() async -> String {\n        try? await Task.sleep(nanoseconds: 1_000_000_000) // Simulate network\n        return \"Data Loaded!\"\n    }\n    \n    // Because the class is @MainActor, this method is too.\n    private func updateData(with result: String) {\n        self.data = result\n    }\n    \n    // 2. Use the custom global actor to isolate logging calls\n    @LoggerActor\n    private func logCompletion() {\n        // This code is now guaranteed to run serially on the LoggerActor\n        print(\"Logging operation complete.\")\n    }\n}\n```\n\n### Common Pitfalls\n\n*   **Over-isolation:** Marking an entire large class with `@MainActor` can be problematic if it contains heavy, non-UI logic. This can inadvertently lead to blocking the main thread. It's often better to isolate only the specific properties or methods that require main-thread access.\n*   **Misunderstanding `await`:** `await` on a `@MainActor` function doesn't make the work non-blocking; it suspends the current task and re-schedules it on the main actor's executor. If the main thread is already blocked, the task will have to wait.\n*   **`nonisolated`:** Forgetting to use `nonisolated` for thread-safe properties (like constants) or synchronous, pure functions within an actor-isolated type can lead to unnecessary `await` requirements and potential deadlocks.\n\n### When to Use vs. Alternatives\n\n*   **`@MainActor` vs. `DispatchQueue.main.async`:** Always prefer `@MainActor` in modern Swift Concurrency code. It provides compile-time safety and makes the developer's intent explicit and verifiable. `DispatchQueue.main.async` should be reserved for legacy codebases or when interfacing with frameworks that don't yet support async/await.\n*   **Custom Global Actor vs. Standard `actor`:**\n    *   Use a standard `actor` when you need multiple, independent instances of a type that protects its own state (e.g., `actor BankAccount`).\n    *   Use a *global* actor when you have a single, app-wide resource that needs to be accessed serially from many unrelated types (e.g., a central logging service, a database connection pool). The global actor provides a convenient annotation (`@MyGlobalActor`) to achieve this without dependency injection.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "actors",
        "mainactor",
        "global-actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "How does the Swift `actor` model prevent data races, and what are the key differences between its compiler-enforced isolation and traditional lock-based synchronization? Discuss the role and risks of using `nonisolated`.",
      "back": "Swift's `actor` model provides data race safety by creating a synchronization boundary around its mutable state. An actor is a reference type that ensures only one task can access its state at a time, effectively creating a serial queue for its methods and properties.\n\n**Core Concept: Actor Isolation**\nAn actor protects its data by allowing only its own code to access it synchronously. Any access from outside the actor must be done asynchronously via an `await` call. This `await` is a potential suspension point, which signals to the Swift runtime that it must wait for the actor to become available to execute the request. This compiler-enforced mechanism, known as actor isolation, eliminates the need for manual locking (like mutexes or dispatch queues) and prevents entire classes of data race bugs at compile time.\n\n**Contrast with Locks:**\n- **Safety:** Actors are compiler-enforced, making it impossible to forget to 'lock' or 'unlock'. Traditional locks are manual and error-prone.\n- **Performance:** When a task `await`s an actor, its thread is not blocked. It can be used for other work, improving system throughput. A traditional lock blocks the thread entirely until the lock is released, wasting resources.\n- **Deadlocks:** While actors significantly reduce deadlock risk, they don't eliminate it (e.g., two actors awaiting each other). However, they avoid common lock-ordering deadlocks found with mutexes.\n\n```swift\nactor BankAccount {\n    private var balance: Double\n    // nonisolated allows synchronous access to immutable data\n    nonisolated let accountID: String\n\n    init(id: String, initialDeposit: Double) {\n        self.accountID = id\n        self.balance = initialDeposit\n    }\n\n    // This method is isolated to the actor's serial executor.\n    func withdraw(amount: Double) -> Double {\n        if balance >= amount {\n            balance -= amount\n            return balance\n        }\n        return balance // Not enough funds\n    }\n}\n\nfunc performTransactions(account: BankAccount) {\n    Task {\n        // 'await' is required to cross the actor boundary.\n        // This is a suspension point.\n        let newBalance = await account.withdraw(amount: 50.0)\n        print(\"New balance: \\(newBalance)\")\n        // The compiler would error here if we tried to access balance directly.\n        // print(account.balance) // Error: Actor-isolated property 'balance' can only be referenced from inside the actor\n    }\n}\n```\n\n**Role and Risks of `nonisolated`:**\nThe `nonisolated` keyword explicitly opts-out of actor isolation for a specific declaration. \n- **When to Use:** It's safe for immutable properties (`let`) or methods that only access immutable state or are otherwise thread-safe. This allows synchronous, non-awaiting access, which can be a useful performance optimization.\n- **Common Pitfalls:** The biggest risk is incorrectly marking a method as `nonisolated` when it accesses or mutates the actor's state. This completely bypasses the actor's protection, re-introducing the possibility of data races the actor was designed to prevent. It is a sharp tool that breaks the safety model if misused.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "data-race",
        "isolation"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency improve upon older concurrency models like GCD/Operations, particularly regarding task lifetime, cancellation, and error handling?",
      "back": "Swift's Structured Concurrency fundamentally rethinks asynchronous programming by imposing a hierarchical structure on concurrent tasks, a concept largely absent in Grand Central Dispatch (GCD) or Operation Queues.\n\n**Core Concept:**\nThe central idea is that every asynchronous task exists within a specific scope and has a defined lifetime tied to that scope. When a parent task creates child tasks (e.g., using `async let` or a `TaskGroup`), the parent cannot complete until all its children have finished. This parent-child relationship is enforced by the compiler and runtime, eliminating a whole class of bugs like leaked tasks or accessing data from a completed operation.\n\n- **Task Lifetime:** A child task cannot outlive its parent. This prevents resource leaks and ensures cleanup happens predictably.\n- **Cancellation:** If a parent task is cancelled, cancellation is automatically propagated down to all its child tasks. This is a significant improvement over the manual cancellation token management required with `Operation`.\n- **Error Handling:** Errors thrown by child tasks are automatically propagated up to the parent, where they can be handled using familiar `do-catch` blocks. If one child in an `async let` group throws, the other children are implicitly cancelled.\n\n**Practical Code Example:**\n```swift\nstruct UserProfile {\n    let info: UserInfo\n    let posts: [Post]\n}\n\n// Fetches user info and their posts concurrently.\nfunc fetchUserProfile(for userID: String) async throws -> UserProfile {\n    print(\"Parent task started.\")\n    // 'async let' creates two concurrent child tasks scoped to this function.\n    async let userInfo = fetchUserInfo(userID) // Child task 1\n    async let userPosts = fetchPosts(for: userID) // Child task 2\n\n    // The parent task implicitly waits here for both children to complete.\n    // If either child throws an error, it's caught here and the other child\n    // is automatically cancelled by the system.\n    let profile = try await UserProfile(info: userInfo, posts: userPosts)\n    print(\"Both child tasks completed.\")\n    return profile\n} // Parent scope ends; compiler guarantees children are finished.\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` instead of `async let` or a `TaskGroup` creates a new, detached top-level task. This breaks the parent-child hierarchy, losing automatic cancellation and error propagation from the original context.\n- **Ignoring Cooperative Cancellation:** Cancellation is not preemptive. A long-running child task must periodically check `Task.isCancelled` and throw a `CancellationError` to halt its execution gracefully.\n\n**When to use vs. Alternatives:**\n- **Structured Concurrency:** The modern default for any new asynchronous work in Swift. Ideal for operations with a clear beginning and end, like network requests or data processing.\n- **GCD/OperationQueue:** Still useful for legacy codebases, fine-grained control over execution contexts (e.g., a serial queue for a critical section), or complex dependency graphs that don't fit a simple parent-child model. However, they lack the compile-time safety and clarity of the new system.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured-concurrency",
        "async-await",
        "actors"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Beyond a simple lock, compare and contrast modern Swift mechanisms for preventing data races, like Actors and serial DispatchQueues. What are the trade-offs of each approach in terms of performance, safety, and complexity?",
      "back": "A data race occurs when multiple threads access shared mutable state without synchronization, with at least one access being a write. This leads to corrupted data and undefined behavior. Swift provides several mechanisms to ensure mutual exclusion.\n\n**Core Concepts & Comparison:**\n- **Serial `DispatchQueue`:** A classic GCD primitive. It executes tasks one at a time in FIFO order. By dispatching all read/write operations for a shared resource onto the same serial queue, you guarantee mutual exclusion at runtime. It's a robust and flexible pattern.\n- **Actors:** A Swift Concurrency feature. An actor is a reference type that protects its internal state from concurrent access. The Swift compiler enforces that any access to an actor's state from outside must be asynchronous (`await`) and serialized through the actor's executor. This provides powerful compile-time safety, making data races a compile error in many cases.\n\n**Practical Code Example (Actor):**\n```swift\n// An actor protects its state from data races.\nactor BankAccount {\n    private(set) var balance: Double\n\n    init(initialDeposit: Double) { self.balance = initialDeposit }\n\n    // This method is guaranteed to have exclusive access to `balance`.\n    func withdraw(_ amount: Double) {\n        if balance >= amount {\n            balance -= amount\n        }\n    }\n}\n\n// Usage is safe even with concurrent calls.\nlet account = BankAccount(initialDeposit: 500.0)\nTask { await account.withdraw(100.0) }\nTask { await account.withdraw(200.0) }\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Deadlocks:** Still a risk, especially with serial queues if you `sync` from one queue to another that is waiting on the first. Actors can also deadlock if two actors wait on each other.\n- **Actor Reentrancy:** When an actor `await`s a call, it is suspended, and other tasks can enter the actor. This can break state invariants if not handled carefully, a subtle issue that doesn't exist with non-reentrant serial queues.\n- **Performance Overhead:** `os_unfair_lock` is fastest for fine-grained locking. GCD queues and Actors have scheduling overhead. Over-synchronizing can serialize your code and eliminate parallelism.\n\n**When to Use vs. Alternatives:**\n- **Actors:** The default choice in modern Swift Concurrency. Ideal for modeling stateful objects. The compile-time safety is a major advantage for new development.\n- **Serial `DispatchQueue`:** A great choice for non-`async/await` code, interfacing with older APIs, or when you need more control (e.g., using barrier flags for a reader-writer pattern).\n- **Locks (`NSLock`, `os_unfair_lock`):** For performance-critical code where you've profiled and found GCD/Actor overhead to be a bottleneck. Requires careful manual management and is error-prone.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "gcd",
        "data race",
        "swift concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "When would you implement a custom `AsyncSequence` versus using `AsyncStream`? Explain `AsyncStream`'s role in bridging legacy APIs into Swift Concurrency.",
      "back": "An `AsyncSequence` is a protocol for a sequence of values that are produced asynchronously over time, which you can iterate using a `for await in` loop. While you can create a custom type conforming to `AsyncSequence` and its `AsyncIteratorProtocol`, this involves manually managing the iterator's state, which can be complex.\n\n`AsyncStream` is a concrete type that conforms to `AsyncSequence` and serves as a powerful bridge to adapt non-structured, event-driven APIs into the structured world of Swift Concurrency. It provides a `Continuation` which you use to imperatively push values (`yield`), signal completion (`finish`), or throw an error from within a non-async context, like a delegate method or a closure callback.\n\n**Practical Example: Bridging a Delegate-based API**\nImagine a legacy `LocationManager` that provides updates via a delegate. We can wrap it in an `AsyncThrowingStream` to provide a modern async interface.\n\n```swift\n// Assume a legacy LocationManager with a delegate pattern\nclass LocationManager {\n    // ... details omitted ...\n    func start() { /* ... */ }\n    func stop() { /* ... */ }\n}\n\n// Bridge to an AsyncSequence\nfunc locationStream() -> AsyncThrowingStream<CLLocation, Error> {\n    return AsyncThrowingStream { continuation in\n        // Create a delegate object that holds the continuation\n        let locationDelegate = LocationDelegate(continuation: continuation)\n        let manager = LocationManager(delegate: locationDelegate)\n        \n        // onTermination is critical for cleanup to prevent leaks\n        continuation.onTermination = { @Sendable _ in\n            manager.stop()\n            print(\"Location stream terminated and manager stopped.\")\n        }\n        \n        manager.start()\n    }\n}\n\n// Helper class to act as the delegate\nprivate class LocationDelegate: LocationManagerDelegate {\n    let continuation: AsyncThrowingStream<CLLocation, Error>.Continuation\n\n    init(continuation: AsyncThrowingStream<CLLocation, Error>.Continuation) {\n        self.continuation = continuation\n    }\n\n    func locationManager(_ manager: LocationManager, didUpdateLocation location: CLLocation) {\n        // Push a new value into the stream\n        continuation.yield(location)\n    }\n\n    func locationManager(_ manager: LocationManager, didFailWithError error: Error) {\n        // Finish the stream with an error\n        continuation.finish(throwing: error)\n    }\n}\n```\n\n**Common Pitfalls:**\n1.  **Backpressure:** `AsyncStream` has a buffer. If you `yield` values faster than the consumer can process them, the buffer may overflow and values can be dropped, depending on the `bufferingPolicy`.\n2.  **Leaking Resources:** Forgetting to implement cleanup logic in the `onTermination` closure is a common mistake that leads to resource leaks (e.g., the `LocationManager` never stops).\n3.  **Continuation Misuse:** The continuation must not be used after `finish` has been called. This will result in a runtime crash.\n\n**When to Use vs. Alternatives:**\n-   **Use `AsyncStream`:** The go-to choice for adapting existing, non-async code. Perfect for `NotificationCenter`, delegate patterns, KVO, or any callback-based API.\n-   **Implement custom `AsyncSequence`:** When you need full control over the iteration logic and state, especially when the sequence generation is self-contained (not driven by external events). A good example is an `AsyncSequence` that handles API pagination, where each call to `next()` fetches the next page.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "async-await",
        "asyncsequence",
        "asyncstream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}