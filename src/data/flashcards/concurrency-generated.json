{
  "topic": "concurrency",
  "generated_at": "2026-01-09T07:04:34.069256+00:00",
  "cards": [
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Structured Concurrency in Swift improve upon older models like GCD and OperationQueue, particularly regarding task lifetime, cancellation, and error handling?",
      "back": "Structured Concurrency fundamentally changes how we reason about concurrent code by introducing a clear, hierarchical relationship between tasks. Unlike GCD or OperationQueue, where tasks are often 'fire-and-forget' and exist independently, structured concurrency creates a 'task tree'.\n\n**Core Concept:**\nA parent task's scope completely contains the lifetime of any child tasks it creates (using `async let` or `TaskGroup`). This provides three key guarantees:\n1.  **Scoped Lifetime:** The parent task cannot finish until all its child tasks have completed. This eliminates a common source of bugs where a function returns while its dispatched work is still running, potentially leading to race conditions or resource leaks.\n2.  **Automatic Cancellation:** If a parent task is cancelled, Swift automatically propagates the cancellation signal down to all its child tasks. This is a massive improvement over the manual, error-prone process of checking an `isCancelled` flag in `NSOperation` or managing custom cancellation tokens with GCD.\n3.  **Error Propagation:** If a child task throws an error, it is immediately propagated up to the parent task's scope, where it can be caught and handled. This prevents errors from being silently lost, which can happen with detached GCD blocks.\n\n**Practical Code Example:**\n```swift\nstruct UserProfile {\n    let info: UserInfo\n    let posts: [Post]\n}\n\nfunc fetchUserProfile(for userID: String) async throws -> UserProfile {\n    // A TaskGroup creates a scope for dynamic child tasks.\n    return try await withThrowingTaskGroup(of: UserProfileComponent.self) { group in\n        // Child task to fetch user info\n        group.addTask {\n            let info = try await api.fetchUserInfo(userID)\n            return .info(info)\n        }\n        \n        // Child task to fetch posts\n        group.addTask {\n            let posts = try await api.fetchPosts(userID)\n            return .posts(posts)\n        }\n        \n        // The group's scope will not exit until both tasks complete.\n        var userInfo: UserInfo?\n        var posts: [Post]?\n        \n        // Await results as they complete.\n        for try await component in group {\n            switch component {\n            case .info(let info): userInfo = info\n            case .posts(let p): posts = p\n            }\n        }\n\n        // If a task throws, the error propagates here, the group is cancelled,\n        // and remaining results are discarded.\n        guard let userInfo, let posts else {\n            throw APIError.incompleteData\n        }\n        \n        return UserProfile(info: userInfo, posts: posts)\n    }\n}\nenum UserProfileComponent { case info(UserInfo), posts([Post]) } // Helper enum\n```\n\n**Common Pitfalls:**\n- **Accidental Unstructured Tasks:** Using `Task { ... }` inside an async function creates a new, detached task tree, breaking the parent-child relationship. This task can outlive the function scope, losing the guarantees of structured concurrency. Use `Task.init` only for bridging to non-async contexts or for tasks that must outlive the current scope.\n- **Misunderstanding Cancellation:** Cancellation is cooperative, not preemptive. A long-running child task must periodically check `Task.isCancelled` and throw a `CancellationError` to halt its execution promptly.\n\n**When to Use vs. Alternatives:**\n- **Structured Concurrency (`async let`, `TaskGroup`):** The default choice for all new concurrent Swift code. It's safer, more readable, and less error-prone. Use it whenever a task's work is relevant only within the scope that creates it.\n- **Unstructured Concurrency (`Task.init`):** Use when a task must outlive its originating scope, such as a fire-and-forget analytics event or a background task tied to the application's lifecycle.\n- **GCD/OperationQueue:** Primarily for maintaining legacy code, interacting with older frameworks that require it, or for specific features like `maxConcurrentOperationCount`. For new features, prefer Swift's native concurrency.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured concurrency",
        "async/await",
        "taskgroup"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain how Swift's `actor` model provides thread safety, contrasting it with traditional lock-based concurrency. What are the key rules of 'actor isolation' and how does the compiler enforce them?",
      "back": "Swift's `actor` model provides thread safety by creating a 'concurrency domain' around its mutable state. Unlike traditional mechanisms like `NSLock` or `DispatchQueue.sync`, which require manual and careful management to prevent issues like deadlocks and priority inversion, actors automate this protection at the language level.\n\n**Core Concept:**\nAn actor is a reference type that ensures only one task can access its mutable state at a time. It achieves this by serializing all incoming requests to its properties and methods in a conceptual 'mailbox'. The actor processes these messages one by one, preventing data races by design. The compiler enforces this safety through a set of rules called **Actor Isolation**:\n1.  **Internal Access:** Code within an actor's methods can access its own properties and methods synchronously (`self.balance`).\n2.  **External Access:** Any code outside the actor must access its mutable state or non-`nonisolated` methods asynchronously using `await`. This `await` is a suspension point, indicating that the calling task is yielding to the actor's executor to run the code when it's safe.\n3.  **Sendable Types:** Data passed into or out of an actor's isolated context must conform to the `Sendable` protocol, ensuring the data itself is thread-safe.\n\n**Code Example:**\n```swift\nactor ScoreCounter {\n    private var score = 0\n\n    // Internal access is synchronous and safe.\n    func increment() {\n        score += 1\n    }\n\n    // This function can be called from outside the actor.\n    func getScore() -> Int {\n        return score\n    }\n}\n\nfunc updateScores(counter: ScoreCounter) async {\n    // ERROR: Actor-isolated 'increment' can only be called on 'self'\n    // counter.increment() // This would be a sync call, which is forbidden.\n\n    // CORRECT: Use 'await' to cross the isolation boundary asynchronously.\n    await counter.increment()\n    let currentScore = await counter.getScore()\n    print(\"Current score: \\(currentScore)\")\n}\n```\n\n**Common Pitfalls:**\n- **Re-entrancy:** The most subtle issue. When an actor `await`s another async function, it can process other messages from its mailbox before the original function resumes. This means the actor's state can change across an `await`. You must not assume state is unchanged after a suspension point.\n- **Deadlocks:** While actors reduce many deadlock scenarios, you can still create them. For example, Actor A `await`s a result from Actor B, while Actor B simultaneously `await`s a result from Actor A.\n\n**When to Use vs. Alternatives:**\n- **Use Actors:** For encapsulating and managing mutable state that needs to be accessed from multiple concurrent contexts (e.g., a data cache, a state manager, a repository).\n- **Alternatives:**\n  - **Locks/Queues:** Use for fine-grained control or legacy code. More error-prone and complex.\n  - **`@MainActor`:** A global actor specifically for ensuring code runs on the main thread for UI updates.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "thread-safety",
        "data-races"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "A class needs to safely manage a mutable property accessed from multiple threads. Compare and contrast using `NSLock`, a serial `DispatchQueue`, and an `actor` to prevent data races. Discuss the trade-offs of each approach.",
      "back": "A data race occurs when multiple threads access a shared resource without synchronization, and at least one access is a write. This leads to unpredictable behavior. `NSLock`, serial `DispatchQueue`, and `actor` are three mechanisms to ensure mutual exclusion and prevent this.\n\n**1. NSLock**\nA low-level, traditional locking mechanism. It provides exclusive access to a critical section by requiring a thread to acquire the lock before entering and release it upon exit. It's synchronous and blocking.\n- **Pros:** High performance with low overhead for uncontended locks. Fine-grained control.\n- **Cons:** Manual lock management is error-prone (forgetting to `unlock`). Prone to deadlocks if not handled carefully.\n\n**2. Serial DispatchQueue**\nA Grand Central Dispatch (GCD) queue that executes tasks one at a time in FIFO order. By dispatching all read/write operations to this queue, you guarantee serialized access.\n- **Pros:** Simple, declarative API. Less prone to simple deadlocks than manual locks.\n- **Cons:** Higher overhead than `NSLock`. Using `sync` can lead to deadlocks if called from the same queue. \n\n**3. Actor**\nA Swift concurrency feature that protects its state from concurrent access. The compiler enforces that access to an actor's mutable state from the outside must be done asynchronously (`await`), ensuring serialized access.\n- **Pros:** **Compile-time safety**. The compiler prevents data races by construction. Part of modern structured concurrency.\n- **Cons:** Requires an `async` context to interact with. An `await` inside an actor method can suspend it, re-entrantly allowing other calls to run, which requires careful state management across suspension points.\n\n```swift\n// Shared mutable resource example\nclass ThreadSafeCounter {\n    private let lock = NSLock()\n    private var _count = 0\n    func increment() { // Using NSLock\n        lock.lock()\n        defer { lock.unlock() } // Guarantees unlock even if errors occur\n        _count += 1\n    }\n}\n\nclass QueueSafeCounter {\n    private let queue = DispatchQueue(label: \"com.example.counter.queue\")\n    private var _count = 0\n    func increment() { // Using serial DispatchQueue\n        queue.sync { // sync ensures the operation completes before returning\n            self._count += 1\n        }\n    }\n}\n\nactor ActorSafeCounter {\n    private var count = 0\n    func increment() { // Actor automatically isolates its state\n        count += 1\n    }\n    func getCount() -> Int {\n        return count\n    }\n}\n```\n\n**When to Use:**\n- **NSLock:** Use for performance-critical, synchronous code sections or when interacting with older Objective-C APIs. Be disciplined with `defer`.\n- **DispatchQueue:** A great general-purpose solution. The readers-writer pattern (concurrent queue + barriers) is a common, powerful optimization.\n- **Actor:** The preferred, modern Swift approach. Use for any new code modeling isolated, mutable state. It provides the highest level of safety.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "gcd",
        "threading",
        "data_race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain the purpose of global actors in Swift, using `@MainActor` as a primary example. When would you create a custom global actor instead of using a standard actor instance to manage shared mutable state?",
      "back": "A global actor is a mechanism in Swift Concurrency that provides a globally unique, serial execution context to protect shared mutable state from data races. Any function, type, or property marked with a global actor's attribute (e.g., `@MainActor`) is said to be 'isolated' to that actor, meaning the compiler ensures it can only be accessed from that actor's context.\n\n**Core Concept:**\nThe most prominent example is `@MainActor`, which represents the main thread. It guarantees that any code marked with it (like UI updates in SwiftUI or UIKit) runs on the main thread, enforced at compile time. This prevents common UI-related race conditions and crashes. When you call a `@MainActor`-isolated function from a different context, you must use `await`, which allows the system to suspend the current task and resume it later on the main thread's executor.\n\nCustom global actors extend this concept to any domain. You define one by creating a type marked with `@globalActor` that provides a shared actor instance.\n\n**Practical Code Example:**\n```swift\n// 1. Define a custom global actor for a shared resource, like a logger.\n@globalActor\nstruct AnalyticsActor {\n    static let shared = ActorType()\n    typealias ActorType = Actor\n}\n\n// 2. Isolate a class to this global actor.\n// All methods and properties will be protected by AnalyticsActor.\n@AnalyticsActor\nclass AnalyticsManager {\n    private var sessionEvents: [String] = []\n\n    func logEvent(_ event: String) {\n        print(\"Logging event: \\(event)\")\n        sessionEvents.append(event)\n    }\n}\n\n// 3. In UI code, access requires an 'await' to hop to the actor's executor.\nclass ContentViewModel: ObservableObject {\n    @MainActor @Published var status = \"Ready\"\n\n    func onButtonTapped() async {\n        // Hop from MainActor to AnalyticsActor\n        await AnalyticsManager().logEvent(\"Button Tapped\")\n        \n        // Hop back to MainActor to update UI\n        await MainActor.run { \n            self.status = \"Event Logged\"\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Overuse:** Creating global actors for state that isn't truly global. This leads to unnecessary contention and tight coupling. Most state is better managed by a standard actor instance passed via dependency injection.\n- **Blocking:** Performing long-running synchronous work on a global actor can starve other tasks waiting for it. On `@MainActor`, this freezes the UI.\n- **`nonisolated` Misuse:** Using `nonisolated` to bypass actor protection on mutable state can re-introduce data races. It should primarily be used for immutable state (`let` constants) or internally thread-safe operations.\n\n**When to Use vs. Alternatives:**\n- **Custom Global Actor:** Use for state that is fundamentally singular and global in your application, like a centralized logging service, a file coordinator for a shared directory, or a database connection pool. It's essentially a compile-time safe singleton.\n- **Standard Actor Instance:** This should be your default choice. Use it to protect the internal state of a class/struct instance. It promotes better encapsulation, testability (you can mock it or create multiple instances), and follows dependency injection principles. It's ideal for a network client, a feature-specific repository, or any stateful object that isn't a global singleton.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-structured-concurrency",
        "actors",
        "global-actor",
        "mainactor"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain how the `Sendable` protocol helps prevent data races in Swift Concurrency. Describe the conditions for implicit conformance and the safety considerations required when explicitly marking a class `@unchecked Sendable`.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's modern concurrency model, designed to statically verify that types can be safely shared across different threads or actors without introducing data races.\n\n**Core Concept Explanation:**\n`Sendable` acts as a contract with the compiler. It doesn't add any methods or properties; it simply marks a type, promising that its values can be safely copied and passed between concurrency domains (e.g., from your main actor to a background task). The compiler enforces this contract, issuing an error if you try to share a non-`Sendable` type across such boundaries. This shifts thread-safety from a runtime problem (crashes, unpredictable behavior) to a compile-time guarantee.\n\nA type implicitly conforms to `Sendable` if it meets these criteria:\n1. It's a value type (struct or enum).\n2. All its stored properties are also `Sendable`.\n3. For enums, all associated values must be `Sendable`.\n4. It's a final class with only immutable (`let`) stored properties of `Sendable` types.\n\n**Practical Code Example:**\n```swift\n// 1. Implicitly Sendable struct\nstruct UserProfile: Sendable {\n    let id: UUID // UUID is Sendable\n    let username: String // String is Sendable\n}\n\n// 2. A class that is NOT Sendable due to mutable state\nclass UnsafeCounter {\n    var value = 0 // Mutable property makes it non-Sendable\n    func increment() { value += 1 }\n}\n\n// 3. A final class marked @unchecked Sendable with internal synchronization\nfinal class SafeCounter: @unchecked Sendable { // We promise the compiler it's safe\n    private var value = 0\n    private let lock = NSLock()\n\n    func increment() {\n        lock.lock()\n        defer { lock.unlock() }\n        value += 1\n    }\n    \n    func getValue() -> Int {\n        lock.lock()\n        defer { lock.unlock() }\n        return value\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Misusing `@unchecked Sendable`:** The most dangerous pitfall is marking a class `@unchecked Sendable` without implementing proper internal synchronization (e.g., using locks, a serial queue). This silences the compiler but reintroduces the risk of data races.\n- **Function Types:** Closures and functions passed across actor boundaries must be `@Sendable`. This means they cannot capture mutable, non-`Sendable` state from their enclosing scope.\n- **Generics:** Generic types must be constrained to `Sendable` (`<T: Sendable>`) if they are to be used in a context that requires `Sendable` conformance.\n\n**When to Use vs. Alternatives:**\n- **Prefer Value Types:** The easiest path to safety is using `struct`s and `enum`s, which are often implicitly `Sendable`.\n- **Use Actors:** If you need shared mutable state, an `actor` is the preferred solution. It encapsulates its state and ensures all access is synchronized, making it inherently safe to interact with from any concurrency domain.\n- **Use `@unchecked Sendable` on Classes:** Reserve this for legacy Objective-C classes or custom classes where you need fine-grained control over locking and performance, and you can manually verify and guarantee thread safety.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "sendable",
        "thread-safety",
        "data-race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}