{
  "topic": "concurrency",
  "generated_at": "2026-01-08T04:59:58.553469+00:00",
  "cards": [
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "Structured Concurrency",
      "back": "",
      "code_example": null,
      "tags": [
        "Structured Concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Actors and Actor isolation",
      "back": "",
      "code_example": null,
      "tags": [
        "Actors and Actor isolation"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain the Sendable protocol and its role in Swift concurrency. How does it help prevent data races, and what are some common ways to adopt it?",
      "back": "The `Sendable` protocol (Swift 5.5+) is a marker protocol indicating that a type's values are safe to be shared between concurrent execution contexts (e.g., different threads or actors). It prevents data races by ensuring that only immutable or properly synchronized data is accessed concurrently.  Types conforming to `Sendable` guarantee that instances can be copied without introducing concurrency issues.  \n\n**Core Concept:**\n`Sendable` doesn't enforce any specific synchronization mechanism itself. Instead, it's a *promise* that the type inherently manages its state safely when shared concurrently. The Swift compiler uses this promise to enforce compile-time checks and warnings about potential data races.\n\n**Adoption:**\n1. **Immutable Types:** Structs and enums with only immutable stored properties are implicitly `Sendable`.  No explicit conformance is needed.\n\n2. **Value Types:**  Value types that are thread-safe are also implicitly `Sendable`.\n\n3. **Classes:** Classes are generally *not* implicitly `Sendable` because they have mutable state and reference semantics.  To make a class `Sendable`, you must use synchronization mechanisms like locks or actors to protect its mutable state.  Even then, you MUST mark the class as `@unchecked Sendable`. This tells the compiler that *you* have ensured thread safety, even though it can't verify it automatically. Misusing `@unchecked Sendable` is dangerous and can lead to data races.\n\n4. **Actors:** Actors inherently provide mutual exclusion for their state, so actor types are implicitly `Sendable`.\n\n**Code Example:**\n```swift\n// Implicit Sendable (struct with immutable properties)\nstruct Point: Sendable {\n    let x: Int\n    let y: Int\n}\n\n// Implicit Sendable (enum)\nenum State: Sendable {\n    case idle\n    case running\n    case completed\n}\n\n// Class - requires explicit synchronization and @unchecked Sendable\nclass Counter {\n    private var value: Int = 0\n    private let lock = NSLock()\n\n    func increment() {\n        lock.lock()\n        defer { lock.unlock() }\n        value += 1\n    }\n\n    func getValue() -> Int {\n        lock.lock()\n        defer { lock.unlock() }\n        return value\n    }\n}\n\nextension Counter: @unchecked Sendable {}\n\n// Actor - inherently Sendable\nactor MyActor {\n    private var count: Int = 0\n\n    func increment() {\n        count += 1\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n```\n\n**Common Pitfalls:**\n*   Forgetting synchronization in classes and marking them `@unchecked Sendable` without proper protection.  This is a major source of data races.\n*   Assuming a type is `Sendable` without verifying its thread safety.\n*   Passing non-`Sendable` data across actor boundaries or to concurrent tasks without proper isolation.\n\n**Alternatives:**\n*   **Data Isolation:** Instead of sharing mutable state, consider copying data or using immutable data structures.\n*   **Actors:** Actors provide a higher-level concurrency model that simplifies thread safety.\n*   **DispatchQueues (with caution):**  While possible, using `DispatchQueue.sync` to protect data is error-prone and can lead to deadlocks.  Actors are generally preferred.\n\n`Sendable` is crucial for writing safe concurrent code in Swift.  It provides a compile-time safety net to help prevent data races, but it requires careful consideration of the thread safety of your types.",
      "code_example": null,
      "tags": [
        "concurrency",
        "sendable",
        "actors",
        "thread safety",
        "data race",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Task Groups",
      "back": "",
      "code_example": null,
      "tags": [
        "Task Groups"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "AsyncSequence and AsyncStream",
      "back": "",
      "code_example": null,
      "tags": [
        "AsyncSequence and AsyncStream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain the purpose of MainActor and global actors in Swift concurrency, including how they ensure thread safety and how they differ from GCD. Provide a practical example.",
      "back": "MainActor and global actors address thread safety in Swift's concurrent environment.  \n\n**Core Concept:**\n\n*   **Data Races:**  Occur when multiple threads access and modify the same data concurrently, leading to unpredictable behavior. Actors isolate state, ensuring that only one thread can access it at a time.\n*   **MainActor:** A global actor that executes code on the main thread. UI updates *must* occur on the main thread.  `@MainActor` ensures code runs on the main thread.\n*   **Global Actors:** Custom actors that provide isolation similar to MainActor, but for other contexts. They define a specific execution context.\n\n**Code Example:**\n\n```swift\nimport Foundation\n\nactor Counter {\n    private var count = 0\n\n    func increment() -> Int {\n        count += 1\n        return count\n    }\n}\n\n@MainActor\nclass MyViewController: UIViewController {\n    let counter = Counter()\n    @IBOutlet weak var label: UILabel!\n\n    func updateUI() async {\n        let newCount = await counter.increment()\n        label.text = \"Count: \\(newCount)\"\n    }\n\n    @IBAction func buttonTapped(_ sender: UIButton) {\n        Task {\n            await updateUI()\n        }\n    }\n}\n```\n\n**Explanation:**\n\n1.  `Counter` is an actor, protecting its `count` property from concurrent access. Only one task can call `increment` at a time.\n2.  `MyViewController` is a UIViewController that needs to update the label, which *must* occur on the main thread. `@MainActor` attribute ensures that the `MyViewController` will run on the main thread.\n3.  `buttonTapped` starts a `Task` to increment the counter and update the UI.\n4.  `updateUI` is marked `async` because it needs to `await` the result of `counter.increment()`.  Because `MyViewController` is running on MainActor, the UI updates are also performed on the main thread.\n\n**Common Pitfalls:**\n\n*   **Forgetting `await`:**  When calling an actor's method, you *must* use `await`.  Failing to do so will result in a compiler error.\n*   **Deadlocks:**  Be careful when calling `await` from within an actor.  If two actors are waiting for each other, a deadlock can occur.\n*   **Overuse of MainActor:** Performing long-running tasks on the main thread will block the UI. Offload intensive work to background tasks or global actors.\n\n**When to Use vs. Alternatives (GCD):**\n\n*   **Actors:**  Ideal for managing state and ensuring thread safety. They provide compile-time safety, preventing data races.  Actors are preferred when data isolation and preventing race conditions are paramount.\n*   **GCD:**  Lower-level API for managing concurrent tasks. More flexible but requires manual synchronization (locks, semaphores) to avoid data races. GCD is still useful for dispatching tasks to background queues, but for state management, actors are generally safer and easier to use.\n\n**Key Differences from GCD:**\n\n*   **Compile-time Safety:** Actors provide compile-time guarantees about thread safety. GCD requires manual synchronization, which is prone to errors.\n*   **Data Isolation:** Actors inherently isolate their state. GCD requires explicit locking mechanisms.\n*   **Simplicity:** Actors simplify concurrent programming by handling the synchronization details internally.\n\nIn summary, `MainActor` ensures UI updates occur on the main thread, while global actors create isolated contexts for thread-safe concurrent operations, offering a safer and more manageable alternative to GCD's manual synchronization.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "mainactor",
        "global actor",
        "thread safety",
        "gcd"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}