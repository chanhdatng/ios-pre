{
  "topic": "concurrency",
  "generated_at": "2026-01-19T04:22:05.538096+00:00",
  "cards": [
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Contrast `AsyncSequence` and `AsyncStream`. When would you implement a custom `AsyncSequence` versus using `AsyncStream` to adapt an existing, non-async API?",
      "back": "`AsyncSequence` is a protocol, the asynchronous equivalent of `Sequence`. It defines a sequence of values that are generated over time. You consume it with a `for await...in` loop, which 'pulls' values by suspending until the next one is available. You'd implement the protocol directly when you have a natural, pull-based source of data, like fetching paginated API results where the consumer drives the iteration.\n\n`AsyncStream` is a concrete type conforming to `AsyncSequence`. Its primary purpose is to act as a bridge or adapter for code that isn't naturally asynchronous. It's ideal for converting 'push-based' systems (like delegates, callbacks, or notifications) into a 'pull-based' `AsyncSequence`. It works by providing a continuation that you use to push values, errors, or a completion event into the stream from your legacy code.\n\n**Practical Code Example (Adapting `CLLocationManager`):**\n```swift\n// A wrapper to provide location updates as an AsyncStream\nclass LocationProvider: NSObject, CLLocationManagerDelegate {\n    private let manager = CLLocationManager()\n    private var continuation: AsyncStream<CLLocation>.Continuation?\n\n    var locations: AsyncStream<CLLocation> {\n        AsyncStream { continuation in\n            self.continuation = continuation\n            // onTermination is crucial for cleanup\n            continuation.onTermination = { @Sendable [weak self] _ in\n                self?.manager.stopUpdatingLocation()\n            }\n            self.manager.delegate = self\n            self.manager.startUpdatingLocation()\n        }\n    }\n\n    // Delegate method 'pushes' updates into the stream\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        locations.forEach { continuation?.yield($0) }\n    }\n}\n\n// Usage:\nfunc observeLocation() async {\n    let provider = LocationProvider()\n    // Consumer 'pulls' values using for-await\n    for await location in provider.locations {\n        print(\"New location: \\(location.coordinate)\")\n        // The loop will suspend here until a new value is yielded\n    }\n}\n```\n\n**Common Pitfalls:**\n1.  **Backpressure:** If the producer (delegate) generates values faster than the consumer (`for await` loop) processes them, `AsyncStream` will buffer them. An unbounded buffer can cause memory bloat. You can specify a buffering policy (e.g., `.bufferingNewest(1)`) to manage this.\n2.  **Continuation Mismanagement:** The continuation must be handled carefully. Failing to call `finish()` on the continuation when the source completes can cause the `for await` loop to hang indefinitely. Forgetting to capture and use it will result in an empty stream.\n3.  **Thread Safety:** The continuation is not inherently thread-safe. If multiple threads can push values, you must synchronize access, for example by wrapping the provider logic in an `actor`.\n\n**When to Use vs. Alternatives:**\n-   **Implement Custom `AsyncSequence`:** Choose this when you can define the iteration logic yourself. It's perfect for pull-based sources, like a paginated API client where the `AsyncIterator`'s `next()` method fetches the next page on demand.\n-   **Use `AsyncStream`:** Use this as an adapter for existing, event-driven APIs. It excels at converting delegates, closures, KVO, or `NotificationCenter` events into a modern, structured concurrency interface.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "async-await",
        "structured-concurrency",
        "asyncsequence"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "An `actor` is often described as a 'class that's safe for concurrency.' Deconstruct this. What compiler-enforced rules create actor isolation, and what are the trade-offs compared to traditional lock-based synchronization?",
      "back": "An actor is a reference type that provides a synchronization mechanism for its mutable state, making it safe to use across concurrent contexts. This safety is not magic; it's a set of compiler-enforced rules known as **actor isolation**.\n\n**Core Concept: Actor Isolation**\n\n1.  **Mutual Exclusion:** At its core, an actor allows only one task to execute its code and access its mutable state at a time. It achieves this by processing incoming method calls serially from a conceptual \u201cmailbox\u201d or queue.\n\n2.  **Compiler Enforcement:** The key difference from manual locks is that the compiler understands and enforces the isolation boundary.\n    *   **External Access is `async`:** Any attempt to access an actor's mutable properties or methods from outside its own context must be marked with `await`. This `await` represents a potential suspension point where the calling task yields the thread, allowing the actor to process other work.\n    *   **Internal Access is Synchronous:** Within an actor's own methods, you can access its properties (`self.property`) synchronously, as you are already on the actor's isolated context.\n    *   **`nonisolated` Escape Hatch:** You can mark properties or methods with `nonisolated` if they do not access the actor's mutable state (e.g., immutable constants or pure functions). This allows for synchronous, non-isolated access, avoiding unnecessary `await`s.\n\n```swift\nactor BankAccount {\n    private var balance: Double\n    nonisolated let accountID: String // Immutable, so it can be nonisolated\n\n    init(initialDeposit: Double, accountID: String) {\n        self.balance = initialDeposit\n        self.accountID = accountID\n    }\n\n    // This method is isolated to the actor.\n    func deposit(amount: Double) {\n        balance += amount\n    }\n\n    // A potential re-entrancy issue is demonstrated here.\n    func transfer(amount: Double, to otherAccount: BankAccount) async throws {\n        guard balance >= amount else { throw BankError.insufficientFunds }\n        // 1. State is checked here.\n        print(\"Balance OK. Preparing to transfer $\\(amount).\")\n\n        // 2. AWAIT: The actor is now suspended. It can process other messages.\n        // Another task could call withdraw() here, changing the balance.\n        await otherAccount.deposit(amount: amount)\n\n        // 3. This line operates on potentially STALE state.\n        // The balance check from step 1 may no longer be valid.\n        balance -= amount // DANGER: Could go negative if balance changed during await.\n    }\n}\n\n// Usage from an outside context\nfunc performTransactions() async {\n    let account = BankAccount(initialDeposit: 1000, accountID: \"12345\")\n\n    // Must 'await' to cross the actor isolation boundary.\n    await account.deposit(amount: 500)\n    print(\"Accessed nonisolated property synchronously: \\(account.accountID)\")\n}\n```\n\n**Common Pitfalls:**\n\n*   **Re-entrancy:** The biggest pitfall. When an actor `await`s an async function, it suspends its work and can process other incoming calls. If the code after the `await` relies on state checked before the `await`, that state may have changed in the interim, leading to logic errors. The `transfer` method above demonstrates this vulnerability.\n*   **Actor Deadlocks:** If Actor A `await`s a result from Actor B, and Actor B simultaneously `await`s a result from Actor A, they will be stuck waiting for each other, causing a deadlock.\n\n**When to Use vs. Alternatives:**\n\n*   **Actors vs. Locks (`NSLock`, `os_unfair_lock`):** Locks are a low-level primitive. They can be more performant for very short, contended critical sections but are fraught with peril: you must remember to unlock, they can cause deadlocks if acquired in the wrong order, and they are invisible to the compiler. Actors provide a higher-level, safer abstraction where the compiler eliminates most data races by construction.\n*   **Actors vs. Serial `DispatchQueue`:** The pre-actor pattern of using a serial queue to protect state is conceptually similar. However, it relies on developer discipline. It's easy to forget to dispatch to the queue and access state directly, causing a data race. Actor isolation makes this a compile-time error, providing much stronger safety guarantees.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "data-race",
        "isolation"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "How does a `TaskGroup` facilitate dynamic, structured concurrency in Swift? Discuss its error handling, cancellation behavior, and a common pitfall developers face when using it.",
      "back": "A `TaskGroup` is a fundamental tool in Swift's structured concurrency model for managing a dynamic number of concurrent child tasks. It guarantees that the parent task will not continue until all child tasks have completed, preventing orphaned or 'leaked' tasks.\n\n**Core Concept:**\nYou create a task group using `withTaskGroup` or `withThrowingTaskGroup`. Inside the group's closure, you can call `group.addTask()` in a loop or based on conditions to spin up multiple child tasks. The group acts as a container, and the `with...TaskGroup` scope will only exit after every task added to the group has finished. You can then iterate over the results asynchronously as they complete.\n\n**Code Example:**\nFetching multiple data objects concurrently, where the number of objects is determined at runtime.\n```swift\nfunc fetchThumbnails(for ids: [String]) async throws -> [String: UIImage] {\n    var thumbnails: [String: UIImage] = [:]\n\n    try await withThrowingTaskGroup(of: (String, UIImage).self) { group in\n        // 1. Dynamically add a child task for each ID.\n        for id in ids {\n            group.addTask {\n                let url = URL(string: \"https://example.com/thumbnails/\\(id).jpg\")!\n                let (data, _) = try await URLSession.shared.data(from: url)\n                guard let image = UIImage(data: data) else { \n                    throw URLError(.cannotDecodeContentData)\n                }\n                // Return a tuple to associate the result with its ID.\n                return (id, image)\n            }\n        }\n\n        // 2. Await and collect results as they complete.\n        // If any task throws, this loop is exited and the group rethrows the error.\n        for try await (id, image) in group {\n            thumbnails[id] = image\n        }\n    }\n    // 3. The group scope ends here, after all tasks are complete.\n    return thumbnails\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Forgetting to await results:** The most common mistake is calling `group.addTask()` but not consuming the group's results (e.g., with a `for await` loop). If you don't await the group, the `withTaskGroup` scope can exit immediately, which implicitly cancels all of its unfinished child tasks. This leads to a 'fire and forget' behavior that violates structured concurrency.\n- **Error Handling:** In a `withThrowingTaskGroup`, the *first* child task that throws an error causes the group to cancel all other running tasks. The group then waits for them to complete (often by throwing a `CancellationError`) before rethrowing the original error. You only get the first error that occurred.\n\n**When to Use vs. Alternatives:**\n- **Use `TaskGroup`** for a *dynamic* number of child tasks, especially when they perform the same kind of work (e.g., fetching items for an array of IDs).\n- **Use `async let`** for a *fixed, small* number of concurrent tasks known at compile time, especially when they return different types. It offers a much simpler syntax for these static cases.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Compare and contrast using a concurrent dispatch queue with barriers versus using an Actor to protect a shared resource. What are the trade-offs, and when would you choose one over the other?",
      "back": "A data race occurs when multiple threads access a shared resource simultaneously, and at least one access is a write. Both dispatch barriers and actors are powerful tools to prevent this, but they operate differently.\n\n**Core Concept: Dispatch Queue with Barriers**\nThis is a classic Grand Central Dispatch (GCD) pattern for solving the \"readers-writers problem.\" You use a concurrent queue to manage access to the resource. Read operations are dispatched as regular asynchronous or synchronous tasks, allowing multiple reads to occur in parallel. Write operations are dispatched with a `.barrier` flag. This barrier task waits for all currently executing read tasks to finish, then runs exclusively, preventing any other task (read or write) from starting. Once the barrier task is complete, the queue returns to its normal concurrent behavior.\n\n**Core Concept: Actors**\nActors are a fundamental part of the new Swift Concurrency model (Swift 5.5+). An actor is a reference type that encapsulates and protects its state from concurrent access. The actor's internal executor ensures that only one task can access its mutable state at a time, effectively serializing all access and eliminating data races by design. Any interaction with an actor's state from the outside must be done asynchronously via `await`, which signals a potential suspension point where the actor can switch to another task.\n\n**Practical Code Example:**\n```swift\n// GCD Barrier for a thread-safe dictionary\nclass CacheGcd {\n    private var items: [String: Any] = [:]\n    private let queue = DispatchQueue(label: \"com.cache.barrier\", attributes: .concurrent)\n\n    func read(key: String) -> Any? {\n        // Multiple reads can happen concurrently\n        queue.sync { items[key] }\n    }\n\n    func write(key: String, value: Any) {\n        // Barrier ensures this is the *only* operation on the queue\n        queue.async(flags: .barrier) {\n            self.items[key] = value\n        }\n    }\n}\n\n// Actor equivalent\nactor CacheActor {\n    private var items: [String: Any] = [:]\n\n    func read(key: String) -> Any? {\n        // Actor automatically serializes access. No concurrent reads.\n        items[key]\n    }\n\n    func write(key: String, value: Any) {\n        // Also serialized. No other task can run on the actor simultaneously.\n        items[key] = value\n    }\n}\n```\n\n**Trade-offs & When to Use:**\n*   **Dispatch Barriers:** Choose this for performance-critical, read-heavy scenarios in a GCD-based architecture. It allows true parallelism for reads, which can be a significant performance win. However, it's a manual pattern; you must remember to use the barrier flag for all writes, making it more error-prone.\n*   **Actors:** This is the preferred, safer, and more modern approach for any code using `async/await`. The compiler enforces actor isolation, preventing data races at compile time. While it serializes all access (reads and writes), the safety guarantees and simpler mental model are a massive advantage. For most applications, the performance difference is negligible compared to the increased safety and code clarity.",
      "code_example": null,
      "tags": [
        "concurrency",
        "gcd",
        "actors",
        "thread-safety",
        "swift-concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency improve upon traditional concurrency models like GCD/OperationQueue regarding task lifetime, error handling, and cancellation?",
      "back": "Swift's Structured Concurrency introduces a paradigm where concurrent tasks are managed within a hierarchical scope, fundamentally improving safety and clarity over older models like GCD.\n\n**Core Concept Explanation:**\nThe central idea is that every concurrent task has a lifetime confined to a specific scope. When you create concurrent work using `async let` or a `TaskGroup`, these child tasks are bound to the parent task's scope. The parent task cannot finish until all its child tasks have completed. This structure provides three key guarantees:\n1.  **Lifetime Management:** A child task never outlives its parent. This prevents tasks from running indefinitely and leaking resources if the context they were created in is no longer valid.\n2.  **Error Propagation:** If any child task throws an error, that error is automatically propagated up to the parent. The parent can then handle it, and the system can implicitly cancel sibling tasks.\n3.  **Cancellation Propagation:** If the parent task is cancelled, the cancellation is automatically propagated down to all its children. This is a massive improvement over manually checking an `isCancelled` flag, as was common with `Operation`.\n\n**Practical Code Example:**\n```swift\n// Represents fetching data for a user's profile screen.\nfunc fetchScreenData(for userID: String) async throws -> (Profile, [Post]) {\n    // 'async let' creates child tasks that run concurrently within this function's scope.\n    async let profileTask = fetchProfile(userID: userID)\n    async let postsTask = fetchRecentPosts(userID: userID)\n\n    do {\n        // The function suspends here until both child tasks complete.\n        // If either 'profileTask' or 'postsTask' throws, the other is automatically cancelled\n        // and the error is caught in the catch block.\n        let profile = try await profileTask\n        let posts = try await postsTask\n        return (profile, posts)\n    } catch {\n        // A single point to handle errors from any child task.\n        print(\"Failed to fetch screen data: \\(error)\")\n        throw error\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n*   **Accidental Unstructured Tasks:** Using `Task { ... }` inside an async function creates a new, unstructured top-level task that is *not* a child of the current task. It will outlive the function scope, breaking the structural guarantees. Use `async let` or `TaskGroup` to maintain the hierarchy.\n*   **Ignoring `async let` Results:** Failing to `await` the result of an `async let` binding. This can cause any error thrown by the child task to be silently ignored, leading to a runtime warning and unpredictable state.\n*   **`Task.detached` Overuse:** Using `Task.detached` breaks the parent-child structure, actor context, and priority inheritance. It should only be used for tasks that are truly independent of their creation context.\n\n**When to use vs Alternatives:**\n*   **Structured Concurrency (`async let`, `TaskGroup`):** The default for all new concurrent code in Swift. Use when tasks are logically related and their lifetimes should be coupled. Ideal for performing parallel work whose results are needed to proceed.\n*   **GCD/OperationQueue:** Still necessary for interfacing with older Objective-C APIs, legacy codebases, or for specific features like `NSOperation` dependencies or GCD barrier tasks for thread-safe writes. However, for new features, prefer the safety of structured concurrency.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "structured-concurrency",
        "async-await",
        "tasks"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "How does `@MainActor` prevent data races on UI components at compile time, and how would you create a custom global actor to provide similar protection for a non-UI, shared resource like a file logger?",
      "back": "### Core Concept\n\n`@MainActor` is a global actor that represents the main thread. By annotating a type, function, or property with `@MainActor`, you tell the Swift compiler that this code must only be executed on the main thread. The compiler then enforces this rule at compile time, a significant improvement over the runtime checks of `DispatchQueue.main.async`.\n\nThis works through actor isolation. Any call to a `@MainActor`-isolated function from a non-isolated context (or a different actor) must be done asynchronously via `await`. This suspension point allows the concurrency runtime to switch execution to the main thread before resuming the function. This prevents data races on UI components by ensuring all mutations and reads happen serially on the main thread.\n\nCustom global actors extend this concept. You can define your own global actor to protect any shared resource that requires serialized access, such as a file handle, a database connection, or a network client. It creates a globally unique execution context, and the compiler enforces serialized access to any code marked with your custom actor's attribute, just as it does for `@MainActor`.\n\n### Practical Code Example\n\n```swift\n// 1. A custom global actor for a shared file logging resource.\n@globalActor\nactor FileLogger {\n    static let shared = FileLogger()\n    private let fileHandle = FileHandle.standardOutput // Placeholder for a real file\n\n    func log(_ message: String) {\n        // This internal method is protected by the actor's isolation.\n        let timestamp = ISO8601DateFormatter().string(from: Date())\n        fileHandle.write(\"\\(timestamp): \\(message)\\n\".data(using: .utf8)!)\n    }\n}\n\n// 2. A ViewModel using @MainActor for UI properties.\n@MainActor\nclass ContentViewModel: ObservableObject {\n    @Published var data: String = \"Loading...\"\n\n    // This function is implicitly on the main actor because the class is.\n    func fetchData() async {\n        // Simulate a network call on a background thread.\n        let result = await fetchFromServer()\n        self.data = result\n        \n        // Safely call the globally-isolated logger.\n        await FileLogger.shared.log(\"Data fetched and UI updated.\")\n    }\n    \n    private func fetchFromServer() async -> String {\n        // This function is NOT on the main actor.\n        try? await Task.sleep(nanoseconds: 1_000_000_000)\n        return \"Hello, from the server!\"\n    }\n}\n```\n\n### Common Pitfalls\n\n*   **Over-synchronization:** Marking an entire complex class with `@MainActor` can unnecessarily force CPU-intensive work onto the main thread, causing UI stutters. Be selective; only isolate the properties and methods that directly interact with UI.\n*   **Deadlocks:** Creating a dependency cycle between global actors (e.g., `@MainActor` code awaits a result from `@FileLogger`, which in turn awaits something from `@MainActor`) can cause a deadlock. Be mindful of actor interactions.\n*   **Misunderstanding `nonisolated`**: Using `nonisolated` can be an effective optimization for read-only or thread-safe operations, but incorrectly marking a mutable property as `nonisolated` defeats the purpose of actor safety and re-introduces the risk of data races.\n\n### When to Use vs. Alternatives\n\n*   **`@MainActor`**: The default choice for any code that touches UIKit or SwiftUI. Use it on `ViewModel` classes, `UIView` subclasses, and any functions that update `@Published` properties bound to the UI.\n*   **Custom Global Actor**: Use for a *truly global, singular resource* that needs serialized access from disparate parts of your application (e.g., a central database connection manager, a shared analytics service).\n*   **Regular `actor`**: Prefer a regular `actor` when you need to protect the state of a *specific object instance*, not a global singleton. If you have multiple instances of a class that each need their own internal state protected, use a regular `actor`. Global actors can become a bottleneck if overused.",
      "code_example": null,
      "tags": [
        "swift",
        "concurrency",
        "actors",
        "mainactor",
        "globalactor"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "How does the `Sendable` protocol prevent data races in Swift's concurrency model? Describe how compiler checks work and provide a practical example of when and how you would manually conform a custom class to `Sendable`.",
      "back": "The `Sendable` protocol is a cornerstone of Swift's compile-time data race safety. It's a marker protocol, meaning it has no requirements of its own; it simply labels types that can be safely shared across concurrency domains (e.g., between actors or Tasks).\n\n**Core Concept:**\nA type is `Sendable` if it meets one of these criteria:\n1. It's a value type (struct, enum) whose stored properties are all `Sendable`.\n2. It's a final class with only immutable (`let`) stored properties of `Sendable` types.\n3. It's a class (or actor) that internally synchronizes all access to its mutable state.\n\nThe Swift compiler uses `Sendable` conformance to police types that cross concurrency boundaries. When you pass a variable to an actor method or capture it in a `@Sendable` closure (like in a `Task`), the compiler verifies that the variable's type conforms to `Sendable`. If it doesn't, you get a compile-time error, preventing potential data races before the code even runs.\n\n**Practical Code Example:**\nImagine a shared cache that needs to be accessed from different concurrent tasks. A plain class is not `Sendable` because its mutable state (`cache` dictionary) is not protected. We can make it `Sendable` by adding internal synchronization using a lock.\n\n```swift\n// A thread-safe cache, manually conformed to Sendable.\nfinal class ThreadSafeCache: Sendable {\n    // A private lock to synchronize access to the cache.\n    private let lock = NSLock()\n    \n    // The mutable state that needs protection.\n    private var cache: [String: Data] = [:]\n\n    func set(_ value: Data, forKey key: String) {\n        // withLock ensures the lock is acquired before the block\n        // and released after, even if an error is thrown.\n        lock.withLock {\n            cache[key] = value\n        }\n    }\n\n    func get(forKey key: String) -> Data? {\n        // All access, read or write, must be synchronized.\n        lock.withLock {\n            cache[key]\n        }\n    }\n}\n\n// Usage in a concurrent environment\nfunc updateUserAvatar(cache: ThreadSafeCache, userId: String) async {\n    // We can safely pass 'cache' to a detached task because it's Sendable.\n    let avatarData = await Task.detached {\n        // ... fetch avatar data from network ...\n        let data = Data() // Placeholder for fetched data\n        cache.set(data, forKey: \"avatar_\\(userId)\")\n        return data\n    }.value\n}\n```\n\n**Common Pitfalls:**\n- **Incorrect Conformance:** Conforming a class to `Sendable` without actually making it thread-safe. This silences the compiler but reintroduces the risk of data races at runtime.\n- **Overusing `@unchecked Sendable`:** This is an escape hatch that tells the compiler to trust you. It should be a last resort, used only when you are absolutely certain of thread safety but cannot prove it to the compiler (e.g., wrapping an old C library).\n- **Capturing non-`Sendable` `self`:** A frequent error is trying to call a method on `self` from a `@Sendable` closure when the class itself isn't `Sendable`.\n\n**When to Use vs. Alternatives:**\nUse manual `Sendable` conformance for classes when you must share mutable state and need to manage synchronization yourself, often when integrating with older code or specific locking patterns. The modern Swift concurrency alternative is often better: encapsulate the state within an `actor`. An actor provides built-in synchronization, making its managed state safe by default without needing manual locks.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "actors",
        "sendable",
        "data race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}