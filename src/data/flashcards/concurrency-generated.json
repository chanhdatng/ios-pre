{
  "topic": "concurrency",
  "generated_at": "2026-01-08T05:23:57.290828+00:00",
  "cards": [
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "Explain Swift's Structured Concurrency. How does it improve upon older concurrency models like GCD, and what are its core components (async/await, Tasks, Actors)?",
      "back": "Structured concurrency ensures predictable execution and simplifies error handling by creating explicit parent-child relationships between concurrent tasks. It improves upon GCD by enforcing compile-time checks for proper task management, preventing issues like orphaned tasks and unhandled errors.\n\n**Core Components:**\n\n*   **async/await:**  `async` marks a function as potentially suspending, while `await` pauses execution until the async function returns. This makes asynchronous code look and behave like synchronous code.\n\n```swift\nfunc fetchData(from url: URL) async throws -> Data {\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\n*   **Tasks:** Represent a unit of asynchronous work.  Tasks can be created using `Task {}` or by detaching a closure with `Task.detached {}`. Detached tasks are not part of the current structured concurrency scope and require manual management.\n\n```swift\nfunc processData() async {\n    async let data1 = fetchData(from: URL(string: \"...\")!)\n    async let data2 = fetchData(from: URL(string: \"...\")!)\n\n    do {\n        let result1 = try await data1\n        let result2 = try await data2\n        // Process results\n    } catch {\n        // Handle errors\n    }\n}\n```\n\n*   **Actors:** Protect mutable state from concurrent access. Only one task can access an actor's state at a time, preventing data races. Accessing an actor's properties or methods requires using `await`.\n\n```swift\nactor Counter {\n    private var count = 0\n\n    func increment() async {\n        count += 1\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n\nlet counter = Counter()\n\nTask {\n    await counter.increment()\n    print(counter.getCount())\n}\n```\n\n**Common Pitfalls:**\n\n*   **Ignoring Errors:**  Failing to handle errors thrown by `async` functions can lead to unexpected behavior.\n*   **Deadlocks:**  Occur when two or more tasks are blocked indefinitely, waiting for each other. Avoid circular dependencies between actors and tasks.\n*   **Over-using detached tasks:** Detached tasks lose the benefits of structured concurrency, making error handling and cancellation more difficult. Use them sparingly and only when truly necessary.\n\n**When to Use vs. Alternatives:**\n\n*   **Structured Concurrency (async/await, Tasks, Actors):**  Preferred for new projects or when refactoring existing code. Offers better readability, error handling, and data race prevention compared to GCD and Operation Queues.\n*   **GCD:**  Useful for simple background tasks and dispatching work to specific queues. Can be more efficient for very low-level operations where performance is critical.\n*   **Operation Queues:**  Suitable for managing complex dependencies between tasks and controlling concurrency levels.  Offers more control over task execution order and cancellation than GCD, but less safety than structured concurrency.\n\nStructured concurrency provides a safer and more maintainable way to write concurrent code in Swift, reducing the risk of common concurrency issues and improving overall application stability.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "async/await",
        "tasks",
        "actors",
        "GCD"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Swift's structured concurrency uses async/await, Tasks, and Actors for safer, predictable concurrency, improving upon GCD's manual management."
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "Explain Actors in Swift's concurrency model. What problem do they solve, and how does actor isolation work? Provide an example and discuss potential pitfalls.",
      "back": "Actors address data races in concurrent environments by providing a safe way to encapsulate state and ensure exclusive access. An actor is a reference type that protects its mutable state, allowing only one thread to access its properties or methods at a time.\n\n**Core Concept:**\nActors enforce *actor isolation*.  This means that any access to an actor's state must go through its methods, and these methods are executed serially, preventing data races.  The compiler enforces this isolation at compile time.\n\n**Code Example:**\n```swift\nactor Counter {\n    private var count = 0\n\n    func increment() async {\n        count += 1\n        print(\"Count is now: \\(count)\")\n    }\n\n    nonisolated func currentCount() -> Int {\n        return count\n    }\n}\n\nfunc testCounter() async {\n    let counter = Counter()\n    \n    await withTaskGroup(of: Void.self) { group in\n        for _ in 0..<100 {\n            group.addTask {\n                await counter.increment()\n            }\n        }\n    }\n\n    print(\"Final count: \\(counter.currentCount())\")\n}\n```\nIn this example, `Counter` is an actor. The `increment()` method is automatically isolated to the actor instance. Multiple tasks can call `increment()` concurrently, but the actor ensures that they are executed one at a time, preventing race conditions on `count`. The `currentCount()` method is marked `nonisolated` because it only returns the value of count, without modifying it, and it can be accessed without requiring an `await`.  This is useful for read-only access.\n\n**Common Pitfalls:**\n*   **Deadlocks:**  If two actors are waiting for each other, a deadlock can occur.  This often happens when one actor calls an `async` method on another actor while holding a lock or waiting for something else.  Careful design is needed to avoid circular dependencies.\n*   **Reentrancy:** While an actor is processing an `async` function, it *can* be re-entered via another `async` call.  If the state changes during the first `async` call, the second call might see unexpected results.  Always ensure that your actor's methods are reentrant-safe.\n*   **Forgetting `await`:**  When calling an `async` method on an actor from outside the actor, you *must* use `await`.  Forgetting `await` will cause a compiler error.\n*   **Performance:** Because actor methods are executed serially, excessive contention can lead to performance bottlenecks. Consider using finer-grained actors or other concurrency mechanisms if needed.\n\n**When to Use vs. Alternatives:**\n*   **Use Actors:** When you have mutable state that needs to be accessed concurrently and you want to avoid data races. Actors are excellent for encapsulating data and ensuring thread safety.\n*   **Alternatives:**\n    *   **DispatchQueues with Barriers:**  Can be used for managing concurrent access to shared resources, but require manual locking and are more prone to errors.  Actors provide a higher-level, safer abstraction.\n    *   **NSLock/NSRecursiveLock:** Low-level locking mechanisms that require careful management to avoid deadlocks.  Actors provide a more structured approach to concurrency.\n    *   **Atomic Properties (Objective-C):** Atomic properties provide basic thread safety, but can be less performant than actors and don't prevent all types of race conditions.\n    *   **Immutable Data Structures:** If possible, using immutable data structures eliminates the need for locking altogether.\n\nActors are a powerful tool for writing safe and efficient concurrent code in Swift. By understanding their core principles and potential pitfalls, you can leverage them to build robust and scalable applications.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "actor isolation",
        "swift",
        "async/await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Actors prevent data races by serializing access to their state, ensuring only one thread can access it at a time (actor isolation)."
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Sendable protocol",
      "back": "",
      "code_example": null,
      "tags": [
        "Sendable protocol"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "How do Task Groups in Swift concurrency help manage child tasks and propagate results, and what are their advantages over dispatch groups?",
      "back": "Task Groups enable structured concurrency, allowing you to create dynamic child tasks within a parent task. They provide a scope where child tasks execute concurrently, and the parent task waits for all children to complete before continuing. Results can be collected and aggregated. Task Groups offer better error handling and cancellation compared to dispatch groups.\n\n```swift\nfunc processData() async throws -> [Int] {\n    await withTaskGroup(of: Int.self, returning: [Int].self) { group in\n        for i in 1...5 {\n            group.addTask {\n                // Simulate some work\n                try? await Task.sleep(nanoseconds: UInt64(i * 100_000_000))\n                if i == 3 { throw MyError.simulatedError }\n                return i * 2\n            }\n        }\n\n        var results: [Int] = []\n        for await result in group {\n            results.append(result)\n        }\n\n        return results\n    }\n}\n\nenum MyError: Error {\n    case simulatedError\n}\n\n//Usage\nTask {\n    do {\n        let processedData = try await processData()\n        print(\"Processed data: \\(processedData)\")\n    } catch {\n        print(\"Error processing data: \\(error)\")\n    }\n}\n```\n\n**Core Concept:** Task Groups provide a structured way to manage concurrent child tasks.  `withTaskGroup` creates the group, `addTask` adds work, and the `await` on the group waits for completion.\n\n**Advantages over Dispatch Groups:**\n*   **Structured Concurrency:** Task Groups enforce a clear parent-child relationship, improving code clarity and error handling.\n*   **Cancellation Propagation:**  Cancelling the parent task automatically cancels child tasks.\n*   **Error Propagation:** Errors thrown by child tasks are automatically propagated to the parent task, simplifying error handling. DispatchGroups require manual error tracking.\n*   **Type Safety:** Task Groups are type-safe, ensuring that the results returned by child tasks are of the expected type.\n\n**Common Pitfalls:**\n*   Not awaiting all child tasks: If you don't iterate over the TaskGroup, the parent task might complete before all children are done.\n*   Ignoring errors:  Make sure to handle errors propagated from child tasks using `try await` or `try? await` when adding tasks, and then handling the error in the `do/catch` block.\n*   Accidental synchronous work: Ensure work within `addTask` is truly asynchronous to avoid blocking the Task Group.\n\n**When to Use:**\nUse Task Groups when you need to perform multiple independent asynchronous operations concurrently and aggregate their results.  Use Dispatch Groups for lower-level concurrency management when finer-grained control is needed and structured concurrency isn't a priority.",
      "code_example": null,
      "tags": [
        "concurrency",
        "taskgroup",
        "swift",
        "async",
        "structured concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Task Groups enable structured concurrency to manage child tasks, propagate results, and offer superior error handling compared to dispatch groups."
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Explain `AsyncSequence` and `AsyncStream` in Swift. How do they facilitate asynchronous data processing, and what are their key differences and use cases?",
      "back": "`AsyncSequence` and `AsyncStream` are Swift's answer to dealing with asynchronous data streams. Think of `AsyncSequence` as the asynchronous counterpart to `Sequence`. It represents a series of values produced over time, asynchronously. You can iterate over it using `for await in`. `AsyncStream`, on the other hand, is a type that lets you create an `AsyncSequence` by manually yielding values to it.\n\nKey Differences:\n*   `AsyncSequence`: A protocol defining the structure of an asynchronous sequence.  You *consume* data from an `AsyncSequence`.\n*   `AsyncStream`: A concrete type that *produces* an asynchronous sequence. It acts as a bridge between synchronous and asynchronous code.\n\nUse Cases:\n*   `AsyncSequence`: Ideal for representing data feeds like network streams, file reads, or sensor data.\n*   `AsyncStream`: Useful when you need to adapt existing synchronous APIs to the async/await world or when you have complex logic for producing asynchronous values.\n\nExample:\n\n```swift\n// Using AsyncStream to create an asynchronous sequence of numbers\nlet stream = AsyncStream<Int> { continuation in\n    Task {\n        for i in 1...5 {\n            continuation.yield(i)\n            try? await Task.sleep(nanoseconds: 1_000_000_000) // Simulate delay\n        }\n        continuation.finish()\n    }\n}\n\n// Consuming the AsyncStream using AsyncSequence\nTask {\n    for await number in stream {\n        print(\"Received: \\(number)\")\n    }\n    print(\"Stream finished\")\n}\n```\n\nCommon Pitfalls:\n*   Forgetting to call `continuation.finish()` in `AsyncStream` can lead to infinite loops.\n*   Not handling errors properly within the `AsyncStream`'s closure can cause unexpected behavior.\n*   Over-yielding values in `AsyncStream` without proper backpressure handling can lead to memory issues.\n\nAlternatives:\n*   Combine framework: Offers more powerful operators for transforming and combining asynchronous data streams, but has a steeper learning curve.\n*   GCD: Lower-level API for managing concurrency, suitable for simple asynchronous tasks but requires more manual management.\n\nWhen to Use:\n*   Use `AsyncSequence` and `AsyncStream` when you have a clear need for asynchronous data streams and want to leverage the simplicity and readability of async/await.\n*   Choose Combine for complex data transformations and reactive programming.\n*   Consider GCD for simple, low-level asynchronous operations.",
      "code_example": null,
      "tags": [
        "concurrency",
        "async/await",
        "AsyncSequence",
        "AsyncStream"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ],
      "summary": "`AsyncSequence` is a protocol for async data streams. `AsyncStream` creates one by yielding values, bridging sync/async code."
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain MainActor and global actors. How do they ensure thread safety and what are their use cases? Provide a code example.",
      "back": "MainActor and global actors in Swift concurrency manage shared mutable state safely across threads.\n\nMainActor:  Ensures code executes on the main thread, vital for UI updates and avoiding UI freezes.  It's a global actor implicitly used for UI-related tasks. All UI updates MUST happen on the MainActor.\n\nGlobal Actors:  Enable you to define custom execution contexts (similar to dispatch queues) to isolate specific resources or data. Accessing data guarded by an actor is always serialized, preventing race conditions.  You can create multiple instances of global actors.\n\nThread Safety: Actors achieve thread safety by serializing access to their internal state.  Only one task can access an actor's mutable state at a time. This prevents data races and ensures consistency.\n\nUse Cases:\n* MainActor: All UI updates, interacting with UIKit/AppKit.\n* Global Actors: Managing access to shared resources (e.g., a database connection pool, a file system).  Performing long-running tasks on background threads while ensuring data consistency.\n\nExample:\n```swift\nimport Foundation\n\nactor Counter {\n    private var count = 0\n\n    func increment() async -> Int {\n        count += 1\n        return count\n    }\n\n    func getCount() -> Int {\n        return count\n    }\n}\n\n@MainActor\nclass MyViewController {\n    let counter = Counter()\n\n    func updateUI() async {\n        let newCount = await counter.increment()\n        // Safely update UI on the main thread\n        print(\"Count: \\(newCount)\")\n    }\n}\n\n// Usage\nlet viewController = MyViewController()\nTask {\n    await viewController.updateUI()\n}\n```\n\nCommon Pitfalls:\n* Deadlocks:  Occur when two or more tasks are blocked indefinitely, waiting for each other.  Avoid circular dependencies between actors.\n* Actor reentrancy: An actor can re-enter itself if it suspends during a call and another task calls it before the first task resumes. Be mindful of state changes during suspension points.\n* Forgetting `await`: If you forget `await` when calling an `async` function on an actor, the compiler will likely warn you, but the code will execute synchronously, potentially blocking the current thread.\n\nAlternatives:\n* GCD:  Lower-level, requires manual thread management and synchronization (e.g., locks).  More error-prone than actors.\n* OperationQueues: Higher-level than GCD, but still requires manual synchronization for shared mutable state.\n\nActors are generally preferred for managing shared mutable state due to their built-in thread safety and ease of use.  GCD and OperationQueues are useful for general concurrency tasks where shared mutable state is not a primary concern.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "MainActor",
        "global actors",
        "thread safety",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "MainActor ensures UI updates happen on the main thread. Global actors serialize access to shared data, preventing race conditions."
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Explain data races in concurrent programming and describe strategies to prevent them in Swift.  Include common pitfalls and alternative solutions.",
      "back": "Data races occur when multiple threads access and modify the same memory location concurrently, without proper synchronization, leading to unpredictable behavior.  To prevent them, we ensure exclusive access to shared resources.\n\n**Strategies:**\n\n1.  **Locks (Mutexes):** Provide mutual exclusion. Only one thread can hold the lock at a time.\n    ```swift\n    import Foundation\n\n    class SafeCounter {\n        private var counter = 0\n        private let lock = NSRecursiveLock()\n\n        func increment() {\n            lock.lock()\n            defer { lock.unlock() }\n            counter += 1\n        }\n\n        func value() -> Int {\n            lock.lock()\n            defer { lock.unlock() }\n            return counter\n        }\n    }\n    ```\n    *   `NSRecursiveLock` allows the same thread to acquire the lock multiple times (recursion).\n    *   `defer` ensures the lock is always released, even if errors occur.\n\n2.  **Serial Dispatch Queues:** GCD serial queues execute tasks one at a time, eliminating concurrent access.\n    ```swift\n    let serialQueue = DispatchQueue(label: \"com.example.serial\", qos: .default)\n    var sharedResource = 0\n\n    serialQueue.async {\n        // Access and modify sharedResource safely\n        sharedResource += 1\n    }\n\n    serialQueue.async {\n        // Access and modify sharedResource safely\n        sharedResource *= 2\n    }\n    ```\n\n3.  **Dispatch Barriers:** Used with concurrent queues to create exclusive write access.  Multiple readers can access concurrently, but a writer gets exclusive access.\n    ```swift\n    let concurrentQueue = DispatchQueue(label: \"com.example.concurrent\", attributes: .concurrent)\n    var data = [Int]()\n\n    func readData() {\n        concurrentQueue.async {\n            // Read data safely\n            print(data)\n        }\n    }\n\n    func writeData(newValue: Int) {\n        concurrentQueue.async(flags: .barrier) {\n            // Write data exclusively\n            data.append(newValue)\n        }\n    }\n    ```\n\n4.  **Atomic Operations:**  Provide low-level primitives for thread-safe operations on single variables (e.g., using `OSAtomic` functions or `Atomic` property wrappers in newer Swift versions).\n\n5.  **Actors (Swift 5.5+):**  Provide a higher-level concurrency model that isolates state and ensures that only one task can access the actor's state at a time.\n    ```swift\n    actor Counter {\n        private var count = 0\n\n        func increment() {\n            count += 1\n        }\n\n        func getCount() -> Int {\n            return count\n        }\n    }\n\n    let counter = Counter()\n\n    Task {\n        await counter.increment()\n        print(await counter.getCount())\n    }\n    ```\n\n**Common Pitfalls:**\n\n*   **Deadlocks:** Occur when threads are blocked indefinitely, waiting for each other to release locks.  Avoid circular dependencies in lock acquisition.\n*   **Priority Inversion:** A low-priority thread holds a lock needed by a high-priority thread.  Use priority inheritance or adjust thread priorities.\n*   **Over-locking:**  Holding locks for too long reduces concurrency. Minimize the critical section.\n*   **Forgetting to unlock:** Always ensure locks are released, even in error conditions (using `defer`).\n*   **Incorrect Queue Usage:** Using the wrong type of queue (e.g., concurrent instead of serial) can lead to data races.\n\n**Alternatives:**\n\n*   **Immutable Data Structures:**  If data is immutable, no synchronization is needed.\n*   **Message Passing:** Threads communicate by sending messages, avoiding direct shared memory access.\n\n**When to Use:**\n\n*   Locks: When you need fine-grained control over synchronization and have complex data structures.\n*   Serial Queues:  When you need to ensure sequential execution of tasks that access shared resources.\n*   Dispatch Barriers: When you have a mix of read and write operations and want to allow concurrent reads but exclusive writes.\n*   Actors:  When you want a higher-level, safer concurrency model with isolated state.  Generally preferred for new code in Swift 5.5+.\n\nChoosing the right strategy depends on the specific requirements of your application and the complexity of the data being shared.",
      "code_example": null,
      "tags": [
        "concurrency",
        "data race",
        "mutex",
        "gcd",
        "dispatch barrier",
        "actor",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ],
      "summary": "Data races: unsynchronized concurrent access to shared memory. Prevent with locks, serial queues, barriers, or atomics."
    }
  ]
}