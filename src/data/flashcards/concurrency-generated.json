{
  "topic": "concurrency",
  "generated_at": "2026-01-17T03:55:34.001141+00:00",
  "cards": [
    {
      "id": "concurrency_ef63c6d3be70",
      "front": "How does Swift's Structured Concurrency, using `async let` and Task Groups, fundamentally change how we manage the lifecycle, cancellation, and error propagation of concurrent operations compared to traditional 'unstructured' approaches like GCD?",
      "back": "Structured Concurrency introduces a paradigm where concurrent tasks have a defined scope and lifetime, forming a hierarchy or tree. A parent task cannot complete until all of its child tasks have finished. This structure provides compile-time safety and guarantees that are difficult to achieve with unstructured approaches like GCD or OperationQueue.\n\n**Core Concepts:**\n1.  **Scoped Lifetime:** A child task, created with `async let` or within a Task Group, cannot outlive its parent's scope. This prevents tasks from leaking and running indefinitely after they are no longer needed.\n2.  **Automatic Error Propagation:** If a child task throws an error, that error is automatically propagated up to the parent task at the point it is awaited. This simplifies error handling immensely compared to manual tracking with DispatchGroups.\n3.  **Automatic Cancellation Propagation:** If a parent task is cancelled, the cancellation is automatically and immediately propagated down to all its child tasks. The children can then check for cancellation and halt their work gracefully.\n\n**Practical Code Example:**\nFetching a user's profile and their posts concurrently. With Structured Concurrency, the code is declarative and safe.\n```swift\nstruct UserProfile { let name: String }\nstruct Post { let title: String }\n\nfunc fetchUserData() async throws -> (UserProfile, [Post]) {\n    // 'async let' creates two child tasks that run concurrently.\n    // The 'fetchUserData' function is the parent task.\n    async let userProfile = api.fetchUserProfile() // Child task 1\n    async let userPosts = api.fetchUserPosts()     // Child task 2\n\n    // 'await' suspends the parent task until the children complete.\n    // If either child throws, the error propagates here and the other\n    // child task is automatically cancelled.\n    let profile = try await userProfile\n    let posts = try await userPosts\n\n    return (profile, posts)\n}\n```\n\n**Common Pitfalls:**\n- **Creating Unstructured Tasks:** Using `Task { ... }` inside a structured context creates a new, detached task. It breaks the parent-child relationship, losing automatic cancellation and error propagation. This is a common source of bugs.\n- **Ignoring `async let` Results:** If you define an `async let` binding but never `await` it, any error it throws will be silently discarded, potentially hiding critical issues. The compiler now provides warnings for this.\n- **Blocking in Task Groups:** Performing blocking work inside a Task Group's `addTask` closure can monopolize the limited number of threads in the cooperative pool, potentially leading to deadlocks or thread starvation.\n\n**When to Use vs. Alternatives:**\n- **`async let`:** Ideal for a fixed, known number of concurrent child tasks, especially when they return different types.\n- **Task Groups:** Use for a dynamic number of concurrent child tasks, typically when they all perform similar work and return the same type.\n- **Unstructured `Task`:** Reserve for tasks that must outlive the current scope, like a 'fire-and-forget' background sync. You are then responsible for manually managing its entire lifecycle.\n- **GCD/`OperationQueue`:** Still useful for legacy code or specific features like `Operation` dependencies and `maxConcurrentOperationCount`. However, for new concurrent code, Structured Concurrency is the safer, more expressive, and preferred choice.",
      "code_example": null,
      "tags": [
        "concurrency",
        "structured-concurrency",
        "async-await",
        "task",
        "gcd"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_63f51f17b095",
      "front": "Explain how `@MainActor` ensures UI safety. How does it differ from a custom global actor, and when would you choose to create your own global actor over a regular one?",
      "back": "The `@MainActor` is a global actor that represents the main dispatch queue, providing a crucial mechanism for ensuring that UI updates and other main-thread-only operations are performed safely within Swift's modern concurrency system.\n\n**Core Concept:**\n`@MainActor` is a type attribute that isolates designated code to the main thread. The Swift compiler enforces this isolation. Any attempt to access a `@MainActor`-isolated property or method from a different concurrency context (e.g., a background actor or a detached task) will result in a compile-time error unless the call is bridged with `await`. This `await` signals a potential suspension point where the execution can be 'hopped' over to the main actor's executor (the main thread) to safely run the code.\n\nA custom `global actor` follows the same principle but for a different, user-defined global context. You define a singleton actor instance that serves as the synchronization point for any code annotated with your custom global actor attribute. This is useful for centralizing access to a shared resource across the entire application, like a logger or a database connection.\n\n**Practical Code Example:**\n```swift\n// 1. @MainActor for UI-related state management\n@MainActor\nclass ContentViewModel: ObservableObject {\n    @Published var status: String = \"Initial\"\n\n    // This method is guaranteed to run on the main thread.\n    func updateStatus(to newStatus: String) {\n        self.status = newStatus\n    }\n}\n\n// 2. Custom global actor for a shared, non-UI resource like logging\n@globalActor\nstruct FileLogger {\n    static let shared = ActorType()\n    typealias ActorType = Actor\n}\n\n@FileLogger\nfunc writeToLog(_ message: String) {\n    // This function is globally serialized. It's safe to perform\n    // operations here that are not thread-safe, like writing to a file.\n    // print(\"LOG: \\(message)\")\n}\n\n// Example usage from a non-main actor\nactor DataProcessor {\n    let viewModel: ContentViewModel\n    \n    init(viewModel: ContentViewModel) { self.viewModel = viewModel }\n    \n    func processData() async {\n        await writeToLog(\"Starting data processing...\")\n        // Simulate network call\n        let result = \"Data Loaded Successfully\"\n        \n        // 'await' is required to hop from DataProcessor to MainActor\n        await viewModel.updateStatus(to: result)\n        \n        await writeToLog(\"Finished data processing.\")\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Blocking Main Thread:** Placing long-running, synchronous code inside a `@MainActor` function. While the context is correct, it will still freeze the UI. Offload heavy computation to a background task or actor and then hop back.\n- **Over-Annotation:** Marking types or functions with `@MainActor` unnecessarily, leading to excessive and inefficient context switching between threads.\n- **`nonisolated` Misuse:** Using `nonisolated` on properties or methods that are not truly thread-safe, which subverts the compiler's protection and can re-introduce data races.\n\n**When to Use vs. Alternatives:**\n- **`@MainActor`**: Use for any type or function that directly interacts with UIKit/SwiftUI or manages state that is bound to the UI.\n- **Custom Global Actor**: Use when you need to synchronize access to a single, shared resource from many unrelated parts of your app (e.g., a centralized analytics engine, a file-based cache). It's for creating a new global serialization context.\n- **Regular Actor**: Use for protecting the state of a specific *instance* of a class. This is the most common use case. Each instance gets its own protection domain, allowing for higher parallelism than a global actor. Choose a regular actor unless the resource is truly a global singleton.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift-concurrency",
        "MainActor",
        "interview"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_c4f511d6cdf5",
      "front": "Explain the role of the `Sendable` protocol in Swift's concurrency model. How does it help prevent data races, and what are the rules a custom type must follow to conform to it?",
      "back": "The `Sendable` protocol is a cornerstone of Swift's structured concurrency, acting as a compile-time safeguard against data races. It's a marker protocol, meaning it has no required methods or properties. Instead, it serves as a promise to the compiler that a type can be safely transferred from one concurrency domain to another (e.g., from the main thread to a background `Task` or between actors).\n\n**Core Concept:**\nA data race occurs when multiple threads access the same memory without synchronization, and at least one access is a write. `Sendable` prevents this by ensuring that any type passed across a concurrency boundary is either a value type (which gets copied) or an immutable/internally-synchronized reference type. The compiler enforces this, issuing warnings or errors if you try to share a non-`Sendable` type.\n\nTypes gain `Sendable` conformance in several ways:\n1.  **Value Types:** `struct`s and `enum`s are implicitly `Sendable` if all their stored properties/associated values are also `Sendable`.\n2.  **Actors:** Actors are inherently `Sendable` as they manage their own state synchronization.\n3.  **Classes:** A class can be `Sendable` if it's `final` and all its stored properties are immutable (`let`) constants of `Sendable` types.\n4.  **Functions/Closures:** A closure is `Sendable` if it captures only `Sendable` values by value and doesn't mutate its captures.\n\n**Practical Code Example:**\n```swift\n// This struct is implicitly Sendable because its members (String, Int) are Sendable.\nstruct UserProfile: Sendable {\n    let name: String\n    let loginCount: Int\n}\n\n// This class is NOT Sendable because it has a mutable 'var' property.\nclass SessionManager {\n    var activeToken: String? // Unsafe to share across threads\n}\n\nactor UserProcessor {\n    private var processedUsers: [String] = []\n\n    // This is SAFE: UserProfile is a Sendable value type, so a copy is passed.\n    func process(user: UserProfile) {\n        print(\"Processing \\(user.name)\")\n        processedUsers.append(user.name)\n    }\n\n    // The compiler would flag this if you tried to pass a non-Sendable type.\n    // func setSession(_ session: SessionManager) { /* ... */ }\n}\n\nTask {\n    let processor = UserProcessor()\n    let profile = UserProfile(name: \"Alice\", loginCount: 5)\n    await processor.process(user: profile) // No error\n    \n    // let session = SessionManager()\n    // await processor.setSession(session) // COMPILER ERROR: non-sendable type passed across actor boundary\n}\n```\n\n**Common Pitfalls:**\n*   **Implicit Conformance Failure:** A `struct` containing a non-`Sendable` property (like a plain class instance) will not be implicitly `Sendable`.\n*   **Misusing `@unchecked Sendable`:** This attribute silences the compiler, forcing a type to conform. It should only be used as an escape hatch when you can manually guarantee thread safety (e.g., by using internal locks), as it shifts the responsibility for preventing data races entirely to you.\n*   **Classes and Inheritance:** Forgetting to mark a `Sendable`-conforming class as `final` is a common mistake. Without `final`, a subclass could introduce mutable state, violating the `Sendable` contract.\n\n**When to Use vs. Alternatives:**\n*   **Use `Sendable`:** For types that represent data to be passed between actors or tasks, such as DTOs, value models, or configuration objects.\n*   **Alternative (Actor Encapsulation):** If you have shared *mutable* state, do not try to make it `Sendable`. Instead, encapsulate that state within an `actor`. The actor becomes the single source of truth and serializes all access to its state, providing safety through isolation rather than transferability.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "sendable",
        "actor",
        "data race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_adf2fcd2570c",
      "front": "Explain how a `TaskGroup` handles failures and cancellation. What happens to other running tasks if one child task throws an error, and how is the error propagated?",
      "back": "A `TaskGroup` is a cornerstone of structured concurrency in Swift, enabling dynamic creation of parallel child tasks within a defined scope. Its behavior regarding failures and cancellation is critical to its robustness.\n\n### Core Concept: Cancellation Propagation\n\nWhen you use a `withThrowingTaskGroup`, the group adheres to strict error handling and cancellation rules. If any child task added via `addTask` throws an error, the group immediately performs two actions:\n1.  **Implicit Cancellation:** It cancels all other running and pending child tasks in the group. This is a key feature of structured concurrency, preventing wasted work and ensuring the system fails fast.\n2.  **Error Propagation:** The `for await` loop over the group's results will terminate, and the entire `withThrowingTaskGroup` block will rethrow the error that was thrown by the first child task to fail.\n\nThis means the group doesn't wait for all tasks to finish before propagating the failure. The first error wins and triggers a cascade of cancellations.\n\n### Practical Code Example\n\n```swift\n// Simulates fetching data from a URL, with some failing.\nfunc fetchData(from url: String) async throws -> String {\n    print(\"Starting fetch for \\(url)\")\n    if url.contains(\"fail\") {\n        try await Task.sleep(nanoseconds: 100_000_000) // 0.1s\n        print(\"\u274c Fetch failed for \\(url)\")\n        throw URLError(.badServerResponse)\n    }\n    // This task is long-running to demonstrate it gets cancelled.\n    try await Task.sleep(nanoseconds: 2_000_000_000) // 2s\n    // This check is crucial for cooperative cancellation.\n    try Task.checkCancellation()\n    print(\"\u2705 Fetch succeeded for \\(url)\")\n    return \"Data from \\(url)\"\n}\n\nfunc fetchAllData() async {\n    let urls = [\"url1.com\", \"url2-fail.com\", \"url3.com\"]\n    do {\n        let allData = try await withThrowingTaskGroup(of: String.self) { group -> [String] in\n            for url in urls {\n                group.addTask { await try fetchData(from: url) }\n            }\n            \n            var results = [String]()\n            // This loop will be broken when an error is thrown.\n            for try await result in group {\n                results.append(result)\n            }\n            return results\n        }\n        print(\"All data fetched: \\(allData)\")\n    } catch {\n        print(\"Caught an error in the group: \\(error)\")\n    }\n}\n\n// Console Output:\n// Starting fetch for url1.com\n// Starting fetch for url2-fail.com\n// Starting fetch for url3.com\n// \u274c Fetch failed for url2-fail.com\n// Caught an error in the group: The operation couldn\u2019t be completed. (Foundation.URLError error -1011.)\n```\nIn this example, `url2-fail.com` throws an error. The group immediately cancels the tasks for `url1.com` and `url3.com`. Because `fetchData` calls `Task.checkCancellation()`, those tasks will terminate early instead of running for their full 2 seconds.\n\n### Common Pitfalls\n\n*   **Forgetting Cooperative Cancellation:** A task will only stop early if it periodically checks `Task.isCancelled` or calls `Task.checkCancellation()`. Without this, a cancelled task will run to completion, wasting CPU and memory.\n*   **Unstructured Tasks:** Creating a detached `Task { ... }` inside a group's child task breaks the structured concurrency model. This new task is not part of the group and will not be cancelled if the group is cancelled.\n*   **Result Order:** Assuming results from `for try await` will arrive in the order tasks were added. They arrive in completion order.\n\n### When to Use vs. Alternatives\n\n*   **Use `TaskGroup`:** When the number of concurrent tasks is dynamic and determined at runtime (e.g., iterating over an array). It's perfect for homogeneous work where you need to collect all results or handle a single failure.\n*   **Use `async let`:** When you have a small, fixed number of heterogeneous tasks known at compile time. The syntax is cleaner for cases like `async let user = fetchUser()` and `async let feed = fetchFeed()`.",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift-concurrency",
        "structured-concurrency",
        "taskgroup",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_dbfc3f91d97e",
      "front": "Compare and contrast using a serial `DispatchQueue`, `NSLock`, and Swift's `actor` model for protecting a shared mutable resource. Discuss the trade-offs in terms of performance, safety, and API design.",
      "back": "These three mechanisms protect shared mutable state from data races, but with significant trade-offs.\n\n**1. NSLock (Mutex)**\nA low-level, blocking synchronization primitive. It's fast but entirely manual, making it error-prone.\n\n*   **Concept:** A thread must acquire the lock before entering a critical section and release it upon exit. Other threads attempting to acquire the lock will block until it's free.\n*   **Use Case:** Best for very short, performance-critical synchronous code paths where the overhead of dispatching to a queue is too high.\n*   **Pitfalls:** Forgetting to `unlock()` causes a deadlock. Using `defer` is crucial for safety. Holding a lock across an `await` is a major anti-pattern that can lead to deadlocks or thread explosion.\n\n```swift\nclass BankAccountLock {\n    private var _balance = 0\n    private let lock = NSLock()\n\n    var balance: Int {\n        lock.lock()\n        defer { lock.unlock() } // Guarantees unlock is called\n        return _balance\n    }\n\n    func deposit(amount: Int) {\n        lock.lock()\n        defer { lock.unlock() }\n        _balance += amount\n    }\n}\n```\n\n**2. Serial DispatchQueue**\nA classic GCD approach that executes tasks in a First-In-First-Out (FIFO) order, ensuring mutual exclusion without manual locking.\n\n*   **Concept:** All access to the shared resource is dispatched onto a single serial queue. For writes, use `async(flags: .barrier)` on a concurrent queue for a more performant reader-writer pattern.\n*   **Use Case:** A robust, general-purpose solution, especially in older GCD-heavy codebases. Safer and easier to reason about than manual locks.\n*   **Pitfalls:** Calling `sync` on a queue from a task already running on that same queue will cause an immediate deadlock. There's performance overhead from block creation and dispatching.\n\n```swift\nclass BankAccountQueue {\n    private var _balance = 0\n    private let queue = DispatchQueue(label: \"com.bank.account.queue\")\n\n    var balance: Int {\n        // sync is used to return the value immediately\n        queue.sync { _balance }\n    }\n\n    func deposit(amount: Int) {\n        // async for fire-and-forget write operation\n        queue.async { self._balance += amount }\n    }\n}\n```\n\n**3. Actor**\nA language-level construct from modern Swift Concurrency that provides data race safety at compile time.\n\n*   **Concept:** An actor protects its state by ensuring only one task can access it at a time. All external access to its mutable state or methods must be asynchronous (`await`), allowing the Swift runtime to manage a mailbox of requests.\n*   **Use Case:** The default, preferred choice for all new Swift code. It offers the highest level of safety by turning potential runtime errors into compiler errors.\n*   **Pitfalls:** Actor re-entrancy. If an actor method suspends (e.g., on an `await`), other methods can be interleaved, potentially leading to inconsistent state if not handled carefully. This is a new concurrency challenge to be aware of.\n\n```swift\nactor BankAccountActor {\n    private var _balance = 0\n\n    var balance: Int {\n        // No lock or queue needed; actor isolation handles it.\n        _balance\n    }\n\n    func deposit(amount: Int) {\n        _balance += amount\n    }\n}\n\n// Usage:\n// let account = BankAccountActor()\n// await account.deposit(amount: 100)\n// let currentBalance = await account.balance\n```",
      "code_example": null,
      "tags": [
        "concurrency",
        "swift",
        "gcd",
        "actors",
        "locking",
        "data race"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_0a59c109c99a",
      "front": "How do actors in Swift prevent data races, and what are the key compiler-enforced rules of actor isolation? Explain the roles of `await` and `nonisolated`.",
      "back": "### Core Concept Explanation\nActors are a fundamental part of Swift's structured concurrency, designed to prevent data races at compile time. An actor is a reference type that encapsulates its mutable state, protecting it from concurrent access. This protection is called \"actor isolation.\"\n\nThe compiler enforces a key rule: any access to an actor's mutable properties or methods from outside its own context must be asynchronous and marked with `await`. Internally, each actor has a \"mailbox\" for incoming calls, which it processes sequentially on its own serial executor. This ensures that only one piece of code can modify the actor's state at any given time, eliminating the need for manual locks (like mutexes or semaphores) and the associated risks of deadlocks or forgotten unlocks.\n\nThe `nonisolated` keyword provides an escape hatch. It can be applied to properties or methods that do not interact with the actor's mutable state (e.g., immutable constants or pure functions). These can then be accessed synchronously from any context without `await`, as they pose no risk of data races.\n\n### Practical Code Example\n```swift\nactor BankAccount {\n    private var balance: Double\n    // 'nonisolated' allows synchronous access because it's an immutable constant.\n    nonisolated let accountID: UUID\n\n    init(initialDeposit: Double, id: UUID) {\n        self.balance = initialDeposit\n        self.accountID = id\n    }\n\n    // This method mutates the actor's state and is thus isolated.\n    func deposit(amount: Double) {\n        balance += amount\n    }\n\n    // To read the balance from outside, the call must be awaited.\n    func getBalance() -> Double {\n        return balance\n    }\n}\n\n// Usage from an asynchronous context\nfunc performTransactions() async {\n    let account = BankAccount(initialDeposit: 1000.0, id: UUID())\n    \n    // OK: Accessing a nonisolated property is synchronous.\n    print(\"Account ID: \\(account.accountID)\")\n\n    // To call methods that access mutable state, we must 'await'.\n    // This suspends the current task and sends a message to the actor's mailbox.\n    await account.deposit(amount: 500.0)\n    \n    let currentBalance = await account.getBalance()\n    print(\"Current Balance: \\(currentBalance)\") // Prints 1500.0\n}\n```\n\n### Common Pitfalls & Edge Cases\n- **Re-entrancy:** This is a critical concept. If an actor-isolated method suspends (by using `await` on another async call), the actor is free to process other messages from its mailbox. When the original method resumes, the actor's state may have changed. This is unlike a traditional lock, which would block the thread entirely. You must not assume state is unchanged across an `await`.\n- **Deadlocks:** Actors don't prevent all deadlocks. If Actor A `await`s a result from Actor B, and Actor B simultaneously `await`s a result from Actor A, they will wait forever.\n- **Misusing `nonisolated`:** Applying `nonisolated` to a property or method that is not inherently thread-safe (e.g., a mutable class instance) breaks the actor's protection and re-introduces the risk of data races.\n\n### When to Use vs. Alternatives\n- **Use Actors:** When you need to protect a specific piece of mutable state that is accessed from multiple concurrent contexts. They are the modern, safe default in Swift for state synchronization.\n- **Alternatives (Legacy):\n  - **Serial `DispatchQueue`:** An actor is essentially a type-safe, compiler-aware wrapper around this concept. Prefer actors in new Swift code for better static safety.\n  - **Locks (`NSLock`, etc.):** Use for low-level control or when interoperating with older Objective-C code. They are manual, error-prone (forgetting to unlock, deadlocks), and don't benefit from compiler checks.",
      "code_example": null,
      "tags": [
        "concurrency",
        "actors",
        "swift",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    },
    {
      "id": "concurrency_b2a458c2caac",
      "front": "Explain how `AsyncSequence` and `AsyncStream` bridge non-structured concurrency into Swift's `async/await` world. Describe a practical use case and discuss the critical role of backpressure management.",
      "back": "### Core Concept\n`AsyncSequence` is a protocol analogous to `Sequence`, but its `next()` method is `async`. This allows a consuming `for await...in` loop to suspend until the next value is available, making it ideal for handling a series of events over time, like notifications, data chunks from a download, or location updates.\n\n`AsyncStream` is a concrete implementation that acts as a bridge from older concurrency patterns (delegates, completion handlers, KVO) into the structured `async/await` world. You create it with a closure that provides a `continuation`. This continuation is a handle you use to manually push values (`yield`), terminate the stream (`finish`), or handle cancellation from the consumer.\n\n### Practical Code Example\nHere's how to wrap `CLLocationManager`'s delegate-based updates into an `AsyncStream`:\n\n```swift\nimport CoreLocation\n\nclass LocationProvider: NSObject, CLLocationManagerDelegate {\n    private let manager = CLLocationManager()\n    private var continuation: AsyncStream<CLLocation>.Continuation?\n\n    lazy var locations: AsyncStream<CLLocation> = {\n        AsyncStream { continuation in\n            self.continuation = continuation\n            self.manager.delegate = self\n            self.manager.startUpdatingLocation()\n            \n            continuation.onTermination = { @Sendable [weak self] _ in\n                self?.manager.stopUpdatingLocation()\n            }\n        }\n    }()\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        locations.forEach { continuation?.yield($0) }\n    }\n}\n\n// Usage:\nlet provider = LocationProvider()\nlet locationTask = Task {\n    for await location in provider.locations {\n        print(\"New location: \\(location.coordinate)\")\n        if location.horizontalAccuracy < 10 { break } // Stop when accuracy is good\n    }\n    print(\"Location task finished.\")\n}\n\n// To cancel from outside:\n// locationTask.cancel()\n```\n\n### Common Pitfalls & Edge Cases\n1.  **Backpressure:** `AsyncStream` has a buffering policy for when values are produced faster than they are consumed. The default is an unbounded buffer, which can lead to uncontrolled memory growth. For high-frequency producers, you should specify a bounded buffer and a policy for handling overflow (e.g., `.bufferingNewest(10)`).\n2.  **Continuation Lifecycle:** You *must* call `continuation.finish()` to signal the end of the stream. Otherwise, the consuming `for await` loop will suspend forever, leaking resources. Ensure `finish()` is called on all code paths that terminate the event source (e.g., in a `deinit` or a `stop()` method).\n3.  **Thread Safety:** The `continuation` is not thread-safe. If the underlying API can call back on multiple threads, you must synchronize access to the continuation.\n\n### When to Use vs. Alternatives\n*   **vs. `async func` returning `[Value]`:** Use `AsyncStream` for event sequences that are long-running, potentially infinite, or where processing each item immediately is more important than waiting for the entire collection. Use a simple `async` function for finite operations where the full result set is needed before proceeding.\n*   **vs. Combine `Publisher`:** `AsyncStream` is the native Swift Concurrency tool for this job. Prefer it when working primarily within an `async/await` context for cleaner integration. Combine remains powerful for complex reactive chains and in projects already heavily invested in its ecosystem.",
      "code_example": null,
      "tags": [
        "concurrency",
        "async-await",
        "structured-concurrency",
        "asyncsequence"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/"
      ]
    }
  ]
}