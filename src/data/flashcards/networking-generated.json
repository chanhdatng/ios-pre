{
  "topic": "networking",
  "generated_at": "2026-01-17T03:55:34.001170+00:00",
  "cards": [
    {
      "id": "networking_88601ef8bf23",
      "front": "Explain how HTTP/2 and HTTP/3 address head-of-line blocking compared to HTTP/1.1. What are the practical implications for an iOS developer using URLSession, and what networking anti-patterns do these newer protocols eliminate?",
      "back": "### Core Concept\n\n**HTTP/1.1** suffers from head-of-line (HOL) blocking because it processes requests sequentially over a single TCP connection. If a slow request is in progress, all subsequent requests on that connection are blocked. Browsers and apps mitigated this by opening multiple TCP connections (typically 6-8) to a single host.\n\n**HTTP/2** addresses this with **multiplexing**. It allows multiple request/response streams to be interleaved over a *single* TCP connection. This solves the HTTP-level HOL blocking; a slow response for one stream doesn't block others. However, it's still susceptible to TCP-level HOL blocking. If a single TCP packet is lost, the entire connection stalls until that packet is retransmitted, blocking all active streams.\n\n**HTTP/3** completely eliminates HOL blocking by using **QUIC**, a new transport protocol built on top of UDP. QUIC re-implements streams independently at the transport layer. If a packet for one stream is lost, it only affects that specific stream. Other streams on the same connection can continue processing data, which is a massive advantage on lossy networks like mobile.\n\nFor an iOS developer, **`URLSession` handles this protocol negotiation transparently** via Application-Layer Protocol Negotiation (ALPN). You don't need to change your code to benefit from HTTP/2 or HTTP/3; if the server supports it, `URLSession` will use it automatically.\n\n### Practical Code Example\n\nThe beauty is that standard `URLSession` code requires no changes to leverage these modern protocols.\n\n```swift\n// This code is protocol-agnostic. URLSession handles the upgrade.\nfunc fetchData() {\n    guard let url = URL(string: \"https://api.example.com/data\") else { return }\n\n    let task = URLSession.shared.dataTask(with: url) { data, response, error in\n        // The 'response' object is a URLResponse, which can be cast to\n        // HTTPURLResponse to inspect headers, status code, etc.\n        // The underlying protocol (H1, H2, H3) is abstracted away.\n        if let httpResponse = response as? HTTPURLResponse {\n            print(\"Status Code: \\(httpResponse.statusCode)\")\n            // You won't typically see the protocol version here directly,\n            // but network debugging tools like Charles or Wireshark will show it.\n        }\n    }\n    \n    // When this task is resumed, URLSession performs a TLS handshake with the\n    // server. During this handshake (using ALPN), they negotiate the best\n    // supported protocol. If the server supports HTTP/3, it will be used.\n    // Otherwise, it falls back to HTTP/2, then HTTP/1.1.\n    task.resume()\n}\n```\n\n### Common Pitfalls & Anti-Patterns\n\n1.  **Domain Sharding:** An old technique for HTTP/1.1 where assets were hosted on multiple subdomains (`assets1.host.com`, `assets2.host.com`) to bypass the per-domain connection limit. With HTTP/2 and HTTP/3, this is an **anti-pattern**. It breaks the single-connection model, preventing effective multiplexing and header compression, thereby worsening performance.\n2.  **Asset Bundling:** Concatenating multiple CSS or JS files into one large file was a best practice to reduce the number of HTTP/1.1 requests. With HTTP/2 and HTTP/3, many small requests are cheap. Over-bundling can harm caching efficiency, as a small change to one file invalidates the entire bundle.\n3.  **Ignoring Server Configuration:** The benefits are entirely dependent on the server and any intermediate infrastructure (CDNs, load balancers) supporting these protocols. As an iOS developer, you must collaborate with your backend team to ensure they are enabled.\n\n### When to Use vs. Alternatives\n\nYou should always architect your networking layer to let `URLSession` use its default behavior, which is to prefer the most modern protocol available. The decision isn't made in the app's code but rather on the server infrastructure. The alternative is being stuck on HTTP/1.1, which is what happens by default if the server doesn't support newer versions. For standard REST/GraphQL APIs, relying on `URLSession`'s automatic negotiation is the correct approach. For real-time, low-latency needs (e.g., VoIP, gaming), you might consider WebSockets or raw UDP, but HTTP/3 now covers many use cases that previously required these alternatives.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "urlsession",
        "performance",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "When using `URLSession` with delegates, you provide a delegate queue. Explain its role, the implications of using different queue types (e.g., main, serial, concurrent), and how to safely handle state and UI updates from delegate callbacks.",
      "back": "### Core Concept\n\n`URLSession` performs network I/O on its own private background threads. The `delegateQueue` is an `OperationQueue` you provide to specify where the session's delegate methods should be invoked. This decouples your code from the session's internal threading model, giving you explicit control over the execution context for handling network events.\n\nBy default (if you pass `nil`), `URLSession` creates a private serial `OperationQueue` for you. The choice of queue has significant implications:\n\n1.  **Main Queue (`OperationQueue.main`):** Callbacks run on the main thread. This is convenient for direct, lightweight UI updates but is dangerous if you perform any synchronous, long-running work (like parsing large data), as it will freeze the UI.\n\n2.  **Custom Serial Queue (`maxConcurrentOperationCount = 1`):** This is the safest and often best choice. It guarantees that delegate methods for a given session are called one at a time, in order. This serial execution eliminates race conditions when modifying shared state, such as appending to a data buffer, without requiring manual locking.\n\n3.  **Custom Concurrent Queue (`maxConcurrentOperationCount > 1`):** Allows multiple delegate callbacks to run in parallel. This can improve throughput if you're handling many tasks simultaneously, but it requires you to implement thread-safe access to any shared state (e.g., using locks, actors, or other synchronization primitives) to prevent race conditions.\n\n### Practical Code Example\n\n```swift\nclass NetworkManager: NSObject, URLSessionDataDelegate {\n    private var session: URLSession!\n    private var responseData = Data()\n\n    override init() {\n        super.init()\n        // Use a custom serial queue for thread-safe delegate callbacks.\n        let delegateQueue = OperationQueue()\n        delegateQueue.maxConcurrentOperationCount = 1\n        delegateQueue.name = \"com.myapp.networkmanager.delegatequeue\"\n\n        let configuration = URLSessionConfiguration.default\n        self.session = URLSession(configuration: configuration, delegate: self, delegateQueue: delegateQueue)\n    }\n\n    func fetchData() {\n        let url = URL(string: \"https://api.example.com/data\")!\n        let task = session.dataTask(with: url)\n        task.resume()\n    }\n\n    // This is guaranteed to be called serially on our delegateQueue.\n    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {\n        // It's safe to append to responseData without a lock due to the serial queue.\n        responseData.append(data)\n    }\n\n    // Called when the task is complete.\n    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n        // Switch to the main queue to update UI or deliver final result.\n        DispatchQueue.main.async {\n            if let error = error {\n                print(\"Request failed: \\(error.localizedDescription)\")\n            } else {\n                print(\"Request finished, received \\(self.responseData.count) bytes.\")\n                // Pass the data to the UI layer for processing.\n            }\n        }\n    }\n}\n```\n\n### Common Pitfalls\n\n*   **Blocking the Delegate Queue:** Performing CPU-intensive work (e.g., large JSON parsing, image decompression) on the delegate queue can block subsequent callbacks, stalling other network operations within the same session.\n*   **Unsafe State Mutation:** Using a concurrent delegate queue without proper synchronization for shared properties like a data buffer will lead to race conditions and crashes.\n*   **Forgetting to Dispatch to Main:** Any UI updates from a background delegate queue *must* be dispatched to `DispatchQueue.main`. Failing to do so results in unpredictable behavior and crashes.\n\n### When to Use vs. Alternatives\n\n*   **Use Delegates:** For fine-grained control over the networking process. Essential for handling authentication challenges, streaming large responses, monitoring upload/download progress, and implementing background sessions.\n*   **Use Completion Handlers:** For simple, one-off requests. It's less boilerplate, but the handler still runs on the delegate queue, so thread safety rules apply.\n*   **Use Async/Await (Swift 5.5+):** The modern, preferred choice for most requests. It offers the best ergonomics, eliminates completion handlers, and integrates with Swift's structured concurrency. Use this unless you specifically need the advanced control offered by the delegate pattern.",
      "code_example": null,
      "tags": [
        "networking",
        "concurrency",
        "URLSession",
        "threading"
      ],
      "sources": [
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Describe how you would architect a robust WebSocket client in a modern iOS app. Discuss connection lifecycle management, message handling, and strategies for maintaining a stable connection.",
      "back": "A robust WebSocket client architecture centers on a dedicated manager class, often an `actor`, to ensure thread-safe handling of the connection state and messages.\n\n**Core Concept:**\nThe foundation is `URLSessionWebSocketTask`, Apple's native API for WebSocket communication. A manager class encapsulates this task, exposing a clean interface for connecting, disconnecting, and sending messages, while hiding the underlying complexity. It manages the connection lifecycle, including handling unexpected disconnects and maintaining the connection's health.\n\n**Practical Code Example (Actor-based Manager):**\n```swift\nactor WebSocketManager {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private let url: URL\n\n    init(url: URL) {\n        self.url = url\n    }\n\n    func connect() {\n        let session = URLSession(configuration: .default, delegate: nil, delegateQueue: nil)\n        webSocketTask = session.webSocketTask(with: url)\n        listenForMessages()\n        webSocketTask?.resume()\n        schedulePing()\n    }\n\n    private func listenForMessages() {\n        Task {\n            // The receive() method suspends until a message is received or an error occurs.\n            while let task = await webSocketTask, task.state == .running {\n                do {\n                    let message = try await task.receive()\n                    // Process the message (e.g., decode JSON, update UI via a delegate/closure)\n                    print(\"Received message: \\(message)\")\n                } catch {\n                    print(\"Error receiving message: \\(error). Reconnecting...\")\n                    disconnectAndReconnect()\n                    break\n                }\n            }\n        }\n    }\n\n    func send(message: String) async throws {\n        try await webSocketTask?.send(.string(message))\n    }\n    \n    // Schedules a ping to keep the connection alive.\n    private func schedulePing() {\n        Task {\n            try await Task.sleep(nanoseconds: 30 * 1_000_000_000) // 30 seconds\n            if await webSocketTask?.state == .running {\n                self.webSocketTask?.sendPing { error in\n                    if error != nil {\n                        // Ping failed, connection might be dead.\n                        Task { await self.disconnectAndReconnect() }\n                    }\n                }\n                schedulePing() // Reschedule the next ping\n            }\n        }\n    }\n\n    private func disconnectAndReconnect() { \n        webSocketTask?.cancel(with: .goingAway, reason: nil)\n        webSocketTask = nil\n        // TODO: Implement exponential backoff before calling connect() again.\n        connect()\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Connection Liveness:** Network proxies or routers can terminate idle connections. Regularly sending pings via `sendPing(pongReceiveHandler:)` is crucial to keep the connection alive and quickly detect when it has dropped.\n*   **Reconnection Storms:** If the server is down, repeatedly trying to reconnect immediately will flood the server upon its recovery and waste battery. Implement an exponential backoff strategy (e.g., wait 1s, 2s, 4s, 8s) to gracefully handle outages.\n*   **Thread Safety:** State like the connection status and the `webSocketTask` itself must be accessed safely. Using an `actor` is the modern Swift solution to prevent data races. Without actors, manual locking (e.g., `NSLock`) is required.\n\n**When to use vs Alternatives:**\n*   **Use WebSockets:** For real-time, low-latency, bidirectional communication like chat apps, live sports tickers, collaborative editing, or multiplayer games.\n*   **Alternatives:**\n    *   **HTTP Long Polling:** Higher latency and overhead. A fallback if WebSockets are not supported by infrastructure.\n    *   **Server-Sent Events (SSE):** Ideal for unidirectional server-to-client streams (e.g., news feeds). Simpler protocol than WebSockets.\n    *   **Push Notifications (APNs):** For delivering information when the app is in the background, not for active, real-time in-app communication.",
      "code_example": null,
      "tags": [
        "networking",
        "websocket",
        "urlsession",
        "concurrency",
        "actor"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Your app needs to download large files that must continue even if the user backgrounds or terminates the app. How would you architect this using URLSession, and what are the key lifecycle events and delegates you must handle for reliability?",
      "back": "To handle large, resilient transfers, you must use a background `URLSession`. The system hands off the networking to a separate daemon (`nsurlsessiond`), which continues the transfer even if your app is suspended, crashes, or is terminated by the user.\n\n**Core Concept:**\nThe architecture revolves around three key components:\n1.  `URLSessionConfiguration.background(withIdentifier:)`: The unique identifier is crucial. It allows your app to find and reconnect to the same session when it's relaunched.\n2.  `UIApplicationDelegate`: The `application(_:handleEventsForBackgroundURLSession:completionHandler:)` method is called when the app is relaunched in the background. You must capture the `completionHandler` and call it when all session events have been delivered.\n3.  `URLSessionDownloadDelegate`: The `urlSession(_:downloadTask:didFinishDownloadingTo:)` method is where you handle the completed download. The file is at a temporary URL and must be moved to a permanent location before this method returns.\n\n**Code Example:**\n```swift\n// In your NetworkManager or a dedicated background service\nprivate lazy var backgroundSession: URLSession = {\n    // The identifier must be unique to your app.\n    let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundtransfer\")\n    config.isDiscretionary = true // Let the system optimize for performance, e.g., wait for Wi-Fi\n    config.sessionSendsLaunchEvents = true\n    return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n}()\n\nfunc startBackgroundDownload() {\n    let url = URL(string: \"https://example.com/largefile.zip\")!\n    let downloadTask = backgroundSession.downloadTask(with: url)\n    downloadTask.resume()\n}\n\n// In your AppDelegate.swift\nvar backgroundSessionCompletionHandler: (() -> Void)?\n\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the completion handler to be called when all events are processed.\n    backgroundSessionCompletionHandler = completionHandler\n}\n\n// In your URLSessionDownloadDelegate implementation\nfunc urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n    // Move the file from the temporary location to a permanent one.\n    guard let destinationURL = /* construct a path in Documents directory */ else { return }\n    try? FileManager.default.moveItem(at: location, to: destinationURL)\n}\n\nfunc urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    // This is called after all events for the session have been delivered.\n    DispatchQueue.main.async {\n        // Call the stored completion handler.\n        guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, \n              let handler = appDelegate.backgroundSessionCompletionHandler else { return }\n        appDelegate.backgroundSessionCompletionHandler = nil\n        handler()\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Forgetting to store and call the `completionHandler`:** If you don't call the completion handler from `handleEventsForBackgroundURLSession`, your app will be penalized by the OS for background activity and may be terminated.\n*   **Not moving the downloaded file:** The file at the `location` URL in `didFinishDownloadingTo` is temporary. It will be deleted after the delegate method returns. You must move or copy it immediately.\n*   **Creating the `URLSession` with a `delegateQueue`:** Using a custom delegate queue is complex with background sessions. It's safer to use `nil`, which defaults to a serial operation queue, and dispatch to other queues as needed from within the delegate methods.\n\n**When to Use vs. Alternatives:**\n*   **Use Background `URLSession`:** For any network transfer that is non-trivial in size and must survive the app being backgrounded or terminated (e.g., downloading video, podcasts, or offline map data).\n*   **Alternative - Standard `URLSession` with `beginBackgroundTask`:** For tasks that need a few extra seconds (~30s) to finish after the app enters the background. This is much simpler but not resilient to termination or longer transfer times.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "background",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Describe how to implement certificate pinning using `URLSession`. Compare pinning the full certificate vs. the public key, and explain how to mitigate the significant operational risks like certificate rotation.",
      "back": "Certificate pinning is a security technique that hardcodes the identity of a remote server into the client application. Instead of trusting any certificate signed by a trusted Certificate Authority (CA), the app will only trust a specific certificate or public key.\n\n**Core Concept:** This mitigates Man-in-the-Middle (MITM) attacks where an attacker uses a fraudulent certificate (e.g., from a compromised CA) to intercept TLS traffic. The app bypasses the CA chain and directly validates the server's identity against the 'pinned' value.\n\n**Implementation with `URLSession`:**\nYou implement pinning in the `urlSession(_:didReceive:completionHandler:)` delegate method. The system calls this method during the TLS handshake, allowing you to perform custom server trust evaluation.\n\n```swift\n// 1. Pinned SPKI (Subject Public Key Info) hashes (Base64 encoded)\nprivate let pinnedHashes = [\n    \"hxqAl31/kYwV5KYSyvK0sFrna6a0K6QBBTM+kHBSsFo=\", // Primary Pin\n    \"PlM3JyzEVsydqgE5Jk433324TPA5zJg+h3n2e1ECoSA=\"  // Backup Pin\n]\n\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n\n    // 2. Ensure it's a server trust challenge\n    guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n          let serverTrust = challenge.serverTrust else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n\n    // 3. Extract the public key from the certificate chain\n    if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0),\n       let serverPublicKey = SecCertificateCopyKey(serverCertificate) {\n\n        // 4. Get the public key data in SPKI format and hash it\n        var error: Unmanaged<CFError>?\n        if let spkiData = SecKeyCopyExternalRepresentation(serverPublicKey, &error) as Data?,\n           let receivedHash = sha256(data: spkiData) {\n            \n            // 5. Compare the server's key hash with our pinned hashes\n            if pinnedHashes.contains(receivedHash) {\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                return\n            }\n        }\n    }\n    \n    // 6. If no match, reject the connection\n    completionHandler(.cancelAuthenticationChallenge, nil)\n}\n\n// Helper to create a SHA256 hash and Base64 encode it\nprivate func sha256(data: Data) -> String {\n    var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n    data.withUnsafeBytes { _ = CC_SHA256($0.baseAddress, CC_LONG(data.count), &hash) }\n    return Data(hash).base64EncodedString()\n}\n```\n\n**Certificate vs. Public Key Pinning:**\n-   **Certificate Pinning:** You pin the entire certificate. This is brittle. When the certificate expires and is renewed, the app breaks, even if the underlying key pair is the same.\n-   **Public Key Pinning (Recommended):** You pin the Subject Public Key Info (SPKI). This is more flexible because you can issue a new certificate with the same public key. It survives certificate renewal.\n\n**Risks & Mitigation:**\n-   **Pitfall: App Bricking.** The biggest risk is if the server's certificate/key is rotated and the app doesn't have the new pin. All network requests will fail, rendering the app useless until an update is pushed.\n-   **Mitigation 1: Backup Pins.** Always include at least one backup pin for a future key. When you need to rotate the server key, you can deploy the new certificate corresponding to the backup pin without needing an immediate app update.\n-   **Mitigation 2: Phased Rollout.** When rotating keys, ensure the server supports both the old and new certificates for a transition period, giving users time to update the app.\n\n**When to Use:** Use pinning for high-security applications (banking, healthcare) where the risk and consequence of a targeted MITM attack are high. For most apps, standard App Transport Security (ATS) provides sufficient protection with far less maintenance overhead.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Network layer architecture",
      "back": "",
      "code_example": null,
      "tags": [
        "Network layer architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Contrast REST and GraphQL from an iOS client perspective. Discuss the trade-offs regarding data fetching efficiency, client-side complexity, and long-term API maintainability.",
      "back": "REST (Representational State Transfer) is an architectural style where the client interacts with resources via standard HTTP verbs (GET, POST, DELETE) and URLs. The server dictates the structure of the response. GraphQL is a query language for APIs, allowing the client to request a specific data shape from a single endpoint.\n\n**Core Concept Explanation**\n\nWith REST, fetching related data often requires multiple network round trips. For example, to get a user and their blog posts, you might first hit `/users/1` and then `/users/1/posts`. This is known as **under-fetching** or the \"N+1 problem.\" Conversely, a single REST endpoint might return a large object with many fields the client doesn't need, which is **over-fetching**.\n\nGraphQL solves this by exposing a single endpoint. The client sends a query specifying the exact fields and relationships it needs, and the server returns a JSON object matching that structure. This empowers the client to get all required data in a single, efficient request.\n\n**Practical Code Example**\n\n```swift\n// --- REST Example: Multiple requests for related data ---\nfunc fetchUserAndPostsWithREST(userId: Int) async throws -> (User, [Post]) {\n    // 1. First request to get the user\n    let userURL = URL(string: \"https://api.example.com/v1/users/\\(userId)\")!\n    let (userData, _) = try await URLSession.shared.data(from: userURL)\n    let user = try JSONDecoder().decode(User.self, from: userData)\n    \n    // 2. Second request to get their posts\n    let postsURL = URL(string: \"https://api.example.com/v1/users/\\(userId)/posts\")!\n    let (postsData, _) = try await URLSession.shared.data(from: postsURL)\n    let posts = try JSONDecoder().decode([Post].self, from: postsData)\n    \n    return (user, posts)\n}\n\n// --- GraphQL Example: Single, precise request ---\n// Using a hypothetical client like Apollo\nfunc fetchUserAndPostsWithGraphQL(userId: String) async throws -> User? {\n    let query = \"\"\"\n    query GetUserAndPosts($id: ID!) {\n      user(id: $id) {\n        name\n        posts {\n          title\n        }\n      }\n    }\n    \"\"\"\n    // The client tooling generates typed models from the query.\n    // A single network call fetches the user and their post titles.\n    let result = await graphQLClient.fetch(query: GetUserAndPostsQuery(id: userId))\n    return result.data?.user\n}\n```\n\n**Common Pitfalls & Edge Cases**\n\n*   **REST:** API versioning (`/v2/`) can become cumbersome, leading to fragmented client codebases. Over-fetching can waste bandwidth, which is critical on mobile. Under-fetching leads to slower UI rendering due to multiple network latencies.\n*   **GraphQL:** Caching is more complex. REST leverages standard HTTP caching, but GraphQL typically uses a single POST endpoint, requiring client-side caching strategies (e.g., normalized caches like Apollo's). Server-side complexity increases, as poorly optimized resolvers can lead to performance bottlenecks. Unrestricted query depth can also expose the server to denial-of-service attacks.\n\n**When to use vs Alternatives**\n\n*   **Use REST when:** The API is simple, resource-oriented, and the data models are relatively flat and stable. It's excellent for public APIs where the standards of HTTP (status codes, caching headers) provide a clear, well-understood contract.\n*   **Use GraphQL when:** The application has complex, nested data requirements (e.g., a social feed). It's ideal when you have multiple clients (iOS, Web, Android) with varying data needs, as it decouples the client from the server's data structure and eliminates the need for backend changes to support new UI screens.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "rest",
        "graphql",
        "api"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}