{
  "topic": "networking",
  "generated_at": "2026-01-13T04:04:10.582316+00:00",
  "cards": [
    {
      "id": "networking_431f69c77375",
      "front": "Your app needs to download large video files. How would you architect this to ensure downloads continue reliably even if the user backgrounds or terminates the app? Describe the key components and the event lifecycle.",
      "back": "For reliable, large background transfers that survive app termination, the core component is a `URLSession` configured with `URLSessionConfiguration.background(withIdentifier:)`. This hands off the networking to the OS, which manages the transfer in a separate process.\n\n**Core Concept:**\nThe lifecycle is crucial. When you create a background download task, the system takes over. If the app is terminated, the OS continues the download. Upon completion (or failure), the OS relaunches your app in the background and calls the `AppDelegate` method `application(_:handleEventsForBackgroundURLSession:completionHandler:)`. You must save the provided `completionHandler`, re-establish the `URLSession` with the same identifier, and let its delegate handle the results. Once all session events are processed, you must call the saved completion handler to signal to the OS that your app is finished.\n\n**Practical Code Example:**\n```swift\n// 1. Create a session with a background configuration\nlazy var backgroundSession: URLSession = {\n    // The identifier is crucial for re-associating the session later.\n    let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundtransfer\")\n    config.isDiscretionary = true // Let the system optimize for performance/battery\n    config.sessionSendsLaunchEvents = true\n    return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n}()\n\n// 2. In AppDelegate, handle the system callback\nfunc application(_ application: UIApplication,\n                 handleEventsForBackgroundURLSession identifier: String,\n                 completionHandler: @escaping () -> Void) {\n    // Save the handler to call when all transfers are done.\n    self.backgroundCompletionHandler = completionHandler\n}\n\n// 3. Implement URLSessionDownloadDelegate\nfunc urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n    // Handle the completed file at the temporary location.\n    print(\"Download finished: \\(location)\")\n}\n\nfunc urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    // This is called when all tasks for the session are complete.\n    DispatchQueue.main.async {\n        self.backgroundCompletionHandler?()\n        self.backgroundCompletionHandler = nil\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Not calling the completion handler:** The OS will penalize or terminate your app for not calling the completion handler provided in `handleEventsForBackgroundURLSession`.\n- **Non-unique identifiers:** The background session identifier must be unique. Reusing one improperly can lead to conflicts.\n- **Using closure-based tasks:** Background sessions *must* use a delegate to receive events; completion handler-based `URLSession` tasks are not supported.\n\n**When to Use vs. Alternatives:**\n- **Use Background Transfers:** For large, long-running tasks (> 30 seconds) that are not time-critical and need to survive app termination (e.g., downloading offline maps, exporting videos).\n- **Alternative (`beginBackgroundTask`):** For short tasks that need to finish after the app is backgrounded (e.g., finishing an upload). This provides only a few minutes and does not survive app termination.",
      "code_example": null,
      "tags": [
        "networking",
        "background-tasks",
        "urlsession",
        "ios",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "How would you design and implement a robust and resilient WebSocket client in an iOS app, detailing its lifecycle management, error handling, and strategies for maintaining connectivity?",
      "back": "A robust WebSocket client requires more than just connecting and sending messages. It's about managing the entire connection lifecycle resiliently.\n\n**Core Concept:**\nThe foundation is `URLSessionWebSocketTask`, introduced in iOS 13. It provides a native API for WebSocket communication. A resilient implementation wraps this task in a manager class that handles state, reconnection, and keep-alive mechanisms.\n\nKey responsibilities of this manager include:\n1.  **State Management:** Maintain a state machine (e.g., `connecting`, `connected`, `disconnecting`, `disconnected`) to prevent invalid operations, like sending a message while disconnected.\n2.  **Connection Lifecycle:** Encapsulate the `resume()`, `cancel(with:reason:)`, `send()`, and `receive()` calls.\n3.  **Reconnection Logic:** Implement an exponential backoff strategy to avoid overwhelming the server after a network drop or server-side issue.\n4.  **Keep-Alive:** Although `URLSession` handles some keep-alive, sending periodic pings ensures the connection stays open through stateful firewalls or proxies and confirms the server is responsive.\n\n**Practical Code Example (using async/await):**\n```swift\nclass WebSocketManager: NSObject, URLSessionWebSocketDelegate {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private let session = URLSession(configuration: .default)\n    private let url = URL(string: \"wss://your.server.com/socket\")!\n\n    func connect() {\n        guard webSocketTask == nil else { return }\n        webSocketTask = session.webSocketTask(with: url)\n        webSocketTask?.delegate = self\n        webSocketTask?.resume()\n        listen()\n    }\n\n    private func listen() {\n        Task {\n            do {\n                // The receive() method suspends until a message is received.\n                let message = try await webSocketTask?.receive()\n                switch message {\n                case .string(let text):\n                    print(\"Received string: \\(text)\")\n                case .data(let data):\n                    print(\"Received data: \\(data)\")\n                @unknown default:\n                    fatalError()\n                }\n                listen() // Recursive call to listen for the next message\n            } catch {\n                print(\"WebSocket receive error: \\(error)\")\n                // Handle disconnection and schedule reconnection here\n                disconnect()\n            }\n        }\n    }\n\n    func send(message: String) async throws {\n        try await webSocketTask?.send(.string(message))\n    }\n\n    func disconnect() {\n        webSocketTask?.cancel(with: .goingAway, reason: nil)\n        webSocketTask = nil\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Naive Reconnection:** Immediately retrying to connect after a failure can lead to a tight loop, draining battery and spamming the server. Use an exponential backoff with jitter.\n*   **Ignoring Network Path:** Relying solely on connection errors is reactive. Use `NWPathMonitor` to proactively detect network changes (e.g., Wi-Fi to Cellular, loss of connectivity) and manage the WebSocket state accordingly.\n*   **App Backgrounding:** Standard `URLSession` tasks are suspended when the app enters the background. The WebSocket connection will drop. For persistent background connections (e.g., VoIP), you need a special entitlement and a background-capable `URLSessionConfiguration`.\n*   **Message Serialization/Deserialization:** The raw task deals with `String` or `Data`. A robust solution involves a serialization layer (e.g., using `Codable`) to handle typed messages and parsing errors gracefully.\n\n**When to Use vs. Alternatives:**\n*   **Use WebSockets for:** Real-time, bi-directional, low-latency communication like chat applications, collaborative editing tools, or live financial data streams.\n*   **Alternatives:**\n    *   **HTTP Long Polling:** Less efficient due to repeated connection overhead, but a viable fallback for environments where WebSockets are blocked.\n    *   **Server-Sent Events (SSE):** Ideal for *unidirectional* server-to-client data pushes (e.g., news feeds). Simpler protocol than WebSockets.\n    *   **Push Notifications:** Best for infrequent, low-priority updates or for waking the app to initiate a data fetch. Not suitable for real-time, high-frequency communication.",
      "code_example": null,
      "tags": [
        "networking",
        "websocket",
        "URLSession",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "How would you design a networking layer using `URLSession` to handle custom server trust evaluation, background downloads, and fine-grained task-level metrics?",
      "back": "A robust networking layer leverages the separation of configuration and event handling in `URLSession`. The `URLSessionConfiguration` object sets the static policies for a session, while the `URLSessionDelegate` protocol provides hooks to respond to events dynamically during a request's lifecycle.\n\n**Core Concept:**\n- **`URLSessionConfiguration`**: This object defines the behavior and policies for a `URLSession`. You create a session with a specific configuration. For background downloads, you'd use `.background(withIdentifier:)`. For custom caching or cookie policies, you'd set properties on a `.default` or `.ephemeral` configuration.\n- **`URLSessionDelegate`**: By assigning a delegate to your `URLSession`, you can intercept various events. This is essential for advanced features. Key delegate methods include:\n  - `urlSession(_:didReceive:completionHandler:)`: Handles authentication challenges, including server trust evaluation where you can validate certificates against a pinned public key.\n  - `urlSession(_:task:didFinishCollecting:)`: Provides a `URLSessionTaskMetrics` object with detailed performance data (DNS lookup, TCP connect, TLS handshake times, etc.).\n  - `urlSessionDidFinishEvents(forBackgroundURLSession:)`: Notifies you when all events for a background session have been delivered after the app was relaunched.\n\n**Code Example:**\n```swift\nclass AdvancedNetworkManager: NSObject, URLSessionDelegate, URLSessionTaskDelegate {\n    lazy var session: URLSession = {\n        // 1. Use a background configuration for out-of-process downloads.\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.background.downloader\")\n        config.waitsForConnectivity = true // Wait for network before failing.\n        config.httpMaximumConnectionsPerHost = 5\n\n        // 2. Initialize the session with the configuration and a delegate.\n        // The delegate queue is set to nil, so URLSession creates its own serial queue.\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    // 3. Delegate method for authentication challenges (e.g., certificate pinning).\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge,\n                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.performDefaultHandling, nil)\n            return\n        }\n        // TODO: Implement custom server trust evaluation (certificate pinning).\n        // For now, we perform default handling.\n        completionHandler(.performDefaultHandling, URLCredential(trust: serverTrust))\n    }\n\n    // 4. Delegate method to collect detailed performance metrics.\n    func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {\n        print(\"Task metrics for \\(task.originalRequest?.url?.absoluteString ?? \"N/A\"):\")\n        print(\"  - Total time: \\(metrics.taskInterval.duration)s\")\n        print(\"  - DNS lookup: \\(metrics.transactionMetrics.last?.domainLookupEndDate?.timeIntervalSince(metrics.transactionMetrics.last!.domainLookupStartDate!) ?? 0)s\")\n    }\n    \n    deinit {\n        // Invalidate the session to release the delegate and avoid leaks.\n        session.finishTasksAndInvalidate()\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Retain Cycles**: `URLSession` holds a strong reference to its delegate. If the delegate class also holds a strong reference to the session, you create a retain cycle. You must explicitly call `invalidateAndCancel()` or `finishTasksAndInvalidate()` to break this cycle when the session is no longer needed.\n- **Delegate Queue**: Using `delegateQueue: nil` is common, but it creates a serial queue. Long-running operations on this queue will block all subsequent delegate callbacks for that session. For heavy processing, dispatch work to another queue.\n- **Background Session Limitations**: Background configurations are highly restricted. They only support HTTP/HTTPS, and uploads must be from a file. The session must have a unique identifier for re-association when the app relaunches.\n\n**When to Use vs. Alternatives:**\n- **Delegate-based `URLSession`**: The only way to achieve custom authentication handling, background transfers, and detailed metrics. It offers maximum control.\n- **`async/await` (`URLSession.shared.data(for:)`)**: Ideal for simple, one-off GET requests where you don't need fine-grained control or lifecycle events. It simplifies concurrency but abstracts away the delegate's power.\n- **Third-Party Libraries (e.g., Alamofire)**: These are powerful wrappers around `URLSession`. Use them to reduce boilerplate for common tasks like routing, validation, and response serialization. However, for deep customization like certificate pinning, you'll still interact with underlying `URLSession` concepts they expose.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "concurrency",
        "architecture",
        "security"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Certificate pinning",
      "back": "",
      "code_example": null,
      "tags": [
        "Certificate pinning"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Architect a generic, protocol-oriented network layer for a modern iOS app. What are its key components, how do they ensure type safety, and how does this design facilitate testing and scalability?",
      "back": "A modern, protocol-oriented network layer abstracts away the complexities of `URLSession` and provides a scalable, type-safe, and highly testable interface for making API calls.\n\n**Core Concept Explanation:**\nThis architecture is built on the Single Responsibility Principle and is composed of three main components:\n\n1.  **Endpoint (or Router):** A protocol that defines all the necessary information for a single API request: base URL, path, HTTP method, headers, and parameters/body. This is often implemented as an enum, where each case represents a specific endpoint. This centralizes API contract details, preventing scattered magic strings.\n\n2.  **NetworkService:** A generic class or actor responsible for executing the request defined by an `Endpoint`. It takes an endpoint, constructs a `URLRequest`, uses `URLSession` to perform the network call, and decodes the response into a generic, `Decodable` model. Using generics (`<T: Decodable>`) ensures compile-time type safety.\n\n3.  **Custom Error Type:** A dedicated enum for network-related errors (e.g., `invalidURL`, `badStatusCode`, `decodingFailed`). This provides clear, actionable error information to the call site, rather than an opaque `Error` type.\n\nThis design facilitates testing by allowing the `NetworkService` to be protocol-based and accept a `URLSession` via dependency injection. In tests, we can inject a mock `URLSession` that returns stubbed data, allowing us to test business logic without making real network calls.\n\n**Practical Code Example:**\n```swift\n// 1. Endpoint Protocol\nprotocol Endpoint {\n    var path: String { get }\n    var method: String { get }\n    // ... headers, parameters, etc.\n}\n\n// 2. Concrete Endpoint Enum\nenum MovieEndpoint: Endpoint {\n    case popular\n    var path: String { \"/movie/popular\" }\n    var method: String { \"GET\" }\n}\n\n// 3. Network Service\nclass NetworkService {\n    private let session: URLSession\n    private let decoder = JSONDecoder()\n\n    init(session: URLSession = .shared) {\n        self.session = session\n    }\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        // Construct URLRequest from endpoint...\n        let url = URL(string: \"https://api.themoviedb.org/3\" + endpoint.path)!\n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method\n        // Add headers, API key etc.\n\n        // Execute request\n        let (data, response) = try await session.data(for: request)\n\n        // Validate response and decode\n        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.badStatusCode\n        }\n        return try decoder.decode(T.self, from: data)\n    }\n}\nenum NetworkError: Error { case badStatusCode, decodingFailed }\n```\n\n**Common Pitfalls:**\n*   **God Object API Manager:** Creating a single massive class that knows how to fetch every type of model. This violates SRP and becomes a bottleneck.\n*   **Hardcoding URLs:** Scattering URL strings throughout the app makes maintenance difficult. The `Endpoint` enum solves this.\n*   **Ignoring Dependency Injection:** Using `URLSession.shared` directly inside the service makes it untestable. Injecting the session allows for mocking.\n*   **Vague Error Handling:** Catching a generic `Error` and not providing context. A custom error enum is far more useful.\n\n**When to Use vs. Alternatives:**\n*   **Use This Pattern:** For almost any app consuming a RESTful API. It's the standard for building scalable, testable, and maintainable networking code in a modern Swift app.\n*   **Alternatives:**\n    *   **Third-party Libraries (e.g., Alamofire):** Can be useful for complex requirements like certificate pinning, advanced request retrying, or multipart form data uploads. However, for standard JSON APIs, native `URLSession` with `async/await` is often sufficient and avoids an external dependency.\n    *   **GraphQL (e.g., Apollo):** A different query language and architecture. Use this only when your backend is a GraphQL server.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "async-await",
        "testing",
        "SOLID"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Explain the key architectural differences between REST and GraphQL. When would you advocate for GraphQL over REST for an iOS app, and what challenges might you anticipate?",
      "back": "REST (Representational State Transfer) is an architectural style based on resources. Clients interact with these resources via standard HTTP verbs (GET, POST, PUT, DELETE) at different URL endpoints (e.g., `/users`, `/posts`). The server defines the structure of the response, which is fixed for each endpoint. This can lead to over-fetching (receiving more data than needed) or under-fetching (needing multiple API calls to gather all data for a single screen).\n\nGraphQL is a query language and server-side runtime for APIs. It exposes a single endpoint (e.g., `/graphql`) and allows the client to specify exactly what data it needs in a single request. This client-driven approach solves the over/under-fetching problem, reducing network payload and the number of round trips.\n\n**Code Example:** Fetching a user and their post titles.\n\n**REST Approach:**\n```swift\n// 1. First, fetch the user\nlet userURL = URL(string: \"https://api.example.com/users/123\")!\nlet userRequest = URLRequest(url: userURL)\n// ... execute request\n\n// 2. Then, fetch their posts (another round trip)\nlet postsURL = URL(string: \"https://api.example.com/users/123/posts\")!\nlet postsRequest = URLRequest(url: postsURL)\n// ... execute request and manually combine data\n```\n\n**GraphQL Approach:**\n```swift\nlet graphqlURL = URL(string: \"https://api.example.com/graphql\")!\nvar request = URLRequest(url: graphqlURL)\nrequest.httpMethod = \"POST\"\n\n// Client specifies exactly the needed fields in one query\nlet query = \"\"\"\nquery GetUserAndPosts { \n  user(id: \"123\") { \n    name \n    posts { \n      title \n    } \n  } \n}\n\"\"\"\nrequest.httpBody = try? JSONSerialization.data(withJSONObject: [\"query\": query])\n// ... execute single request\n```\n\n**When to use GraphQL:**\nAdvocate for GraphQL when the app has complex views that aggregate data from multiple sources (e.g., a social feed), when network performance on mobile is critical, or when the frontend team needs to iterate on UI quickly without waiting for backend API changes. It decouples the client from the server's data models.\n\n**Common Pitfalls/Challenges:**\n- **Caching:** GraphQL complicates caching. With REST, you can use standard HTTP caching based on URLs. GraphQL's single endpoint makes this harder, often requiring more sophisticated client-side caching libraries like Apollo.\n- **Backend Complexity:** Can introduce N+1 query problems on the server if not implemented carefully with tools like data loaders.\n- **Error Handling:** A GraphQL request can partially succeed, returning a 200 OK status with an `errors` array in the JSON payload, requiring more robust client-side error parsing.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "REST",
        "GraphQL",
        "API"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Explain the key advantages of HTTP/2 and HTTP/3 for iOS apps. How does `URLSession` handle these protocols, and what are the implications for your networking layer design, particularly regarding head-of-line blocking?",
      "back": "**Core Concept:**\nHTTP/2 and HTTP/3 are major upgrades to the HTTP protocol, primarily focused on reducing latency, a critical factor for mobile apps.\n\n*   **HTTP/2:** Its main advantage is **multiplexing**, allowing multiple requests and responses to be sent concurrently over a single TCP connection. This solves the application-level head-of-line (HOL) blocking of HTTP/1.1, where a slow request would block subsequent requests on the same connection. It also uses header compression (HPACK) to reduce overhead. However, it's still built on TCP, so if a single TCP packet is lost, all multiplexed streams must wait for its retransmission, creating TCP-level HOL blocking.\n\n*   **HTTP/3:** This version fundamentally changes the transport layer by using **QUIC**, which runs over UDP. QUIC re-implements streams independently. If a packet for one stream is lost, it only blocks that specific stream, not others. This completely solves the TCP HOL blocking problem, making it far more resilient and performant on unreliable mobile networks. It also features a faster connection setup (0-RTT).\n\nFor iOS apps, `URLSession` handles this protocol negotiation transparently. If the server supports a newer protocol, `URLSession` will automatically use it without any required code changes.\n\n**Practical Code Example:**\nYour networking request code remains the same. `URLSession` abstracts the protocol details away.\n\n```swift\nguard let url = URL(string: \"https://api.example.com/data\") else { return }\n\n// URLSession automatically negotiates HTTP/2 or HTTP/3 if the server supports it.\n// No special configuration is needed to enable this behavior.\nlet task = URLSession.shared.dataTask(with: url) { data, response, error in\n    // The underlying protocol is transparent to your data handling logic.\n    // For debugging, you can inspect the response's protocol version.\n    if let httpResponse = response as? HTTPURLResponse {\n        // Note: As of iOS 15, `httpVersion` may still report HTTP/2 even if\n        // HTTP/3 (QUIC) was used, as it's a transport-level detail.\n        print(\"Server supports at least: \\(httpResponse.httpVersion)\") \n    }\n    // Handle response data...\n}\ntask.resume()\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Server-Side Dependency:** Your app only reaps these benefits if your backend servers support HTTP/2 or HTTP/3. It's not a client-only change.\n*   **Network Interference:** Corporate firewalls or misconfigured proxies can sometimes block QUIC (UDP traffic on port 443), forcing a fallback to HTTP/2 over TCP.\n*   **Misunderstanding HOL Blocking:** A key senior distinction is knowing that HTTP/2 solves *application-level* HOL blocking but is still susceptible to *TCP-level* HOL blocking, which HTTP/3 solves.\n\n**When to Use vs. Alternatives:**\nYou don't choose the protocol in client code; you enable it on the server. For any modern app, ensuring your backend supports HTTP/2 and ideally HTTP/3 is a critical performance optimization. This is especially true for apps with many small, concurrent API calls (e.g., loading a dashboard with images, user data, and lists). The alternative, HTTP/1.1, is a performance bottleneck for modern mobile applications.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "performance",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}