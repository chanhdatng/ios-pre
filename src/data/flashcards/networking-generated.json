{
  "topic": "networking",
  "generated_at": "2026-01-16T04:04:09.898345+00:00",
  "cards": [
    {
      "id": "networking_a38f04f89b89",
      "front": "How would you design a modern, scalable, and testable networking layer in Swift? Describe the key components, their responsibilities, and how they interact.",
      "back": "A robust networking layer should be built on the principles of Separation of Concerns and Dependency Inversion, making it decoupled from business logic and highly testable.\n\n**Core Concept Explanation:**\nMy approach consists of three main components:\n1.  **Endpoint/Router:** A protocol-based definition for API requests. Each endpoint encapsulates everything needed to build a `URLRequest`: base URL, path, HTTP method, headers, and parameters. This makes adding new endpoints type-safe and isolates API-specific knowledge.\n2.  **Network Service:** A generic client responsible for executing requests defined by the Endpoint protocol. It takes an endpoint, constructs a `URLRequest`, performs the network call (using `URLSession`), validates the response (e.g., status codes), and attempts to decode the data. It knows *how* to make a request, but not *what* the request is.\n3.  **Parser/Decoder:** This component handles the transformation of raw `Data` into `Decodable` models or custom error types. Using a standard `JSONDecoder` is common, but abstracting it allows for custom decoding strategies or different formats.\n\nThis architecture ensures that ViewModels or Interactors only interact with a clean, high-level service interface, providing an endpoint and receiving a typed result (`async throws -> Model` or `Result<Model, NetworkError>`).\n\n**Practical Code Example:**\n```swift\n// 1. Endpoint Protocol\nprotocol Endpoint {\n    var baseURL: URL { get }\n    var path: String { get }\n    var method: String { get }\n    var headers: [String: String]? { get }\n    // ... parameters, etc.\n}\n\n// 2. Concrete Endpoint Implementation\nenum UserEndpoint: Endpoint {\n    case fetchUser(id: String)\n    // ... other user-related cases\n    \n    var path: String {\n        switch self {\n        case .fetchUser(let id): return \"/users/\\(id)\"\n        }\n    }\n    // ... implement other properties\n}\n\n// 3. Generic Network Service\nclass NetworkService {\n    private let session: URLSession\n\n    init(session: URLSession = .shared) {\n        self.session = session\n    }\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        let urlRequest = try buildRequest(from: endpoint)\n        \n        // Execute request using async/await\n        let (data, response) = try await session.data(for: urlRequest)\n        \n        // Validate response\n        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.serverError // Or decode a specific error model\n        }\n        \n        // Decode and return the model\n        do {\n            return try JSONDecoder().decode(T.self, from: data)\n        } catch {\n            throw NetworkError.decodingFailed(error)\n        }\n    }\n    \n    private func buildRequest(from endpoint: Endpoint) throws -> URLRequest { /* ... */ return URLRequest(url: URL(string: \"google.com\")!) }\n}\n\nenum NetworkError: Error { case serverError, decodingFailed(Error) }\n```\n\n**Common Pitfalls:**\n*   **Tight Coupling:** Placing `URLSession` calls directly inside ViewModels or ViewControllers. This makes the code untestable and violates SRP.\n*   **Inadequate Error Handling:** Simply returning `nil` on failure. A dedicated, typed error enum provides rich context for failure cases (e.g., `noConnection`, `authenticationFailed`, `serverError(statusCode: Int)`).\n*   **Ignoring Testability:** Not using protocols and dependency injection. The `NetworkService` should be injectable so it can be replaced with a mock during unit tests.\n\n**When to use vs. Alternatives:**\n*   **This Architecture:** Best for medium-to-large scale applications where maintainability, scalability, and testability are paramount.\n*   **Third-Party Libraries (e.g., Alamofire):** Excellent for simplifying boilerplate, request retrying, and complex multipart form data. You can still use the same architecture, but with Alamofire powering the `NetworkService` instead of raw `URLSession`.\n*   **Direct `URLSession`:** Only suitable for very small projects or prototypes where the overhead of building an abstraction layer isn't justified.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "async-await",
        "testing",
        "design-patterns"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "How would you design a robust WebSocket client in a modern iOS app using `URLSessionWebSocketTask`? Discuss connection lifecycle management, message handling, and error recovery.",
      "back": "A robust WebSocket client design centers on a dedicated service layer that encapsulates all connection logic, shielding the rest of the app from its complexity.\n\n**Core Concept Explanation:**\n`URLSessionWebSocketTask`, introduced in iOS 13, is Apple's native API for WebSocket communication. It provides a modern, async/await-friendly interface for establishing a persistent, full-duplex connection. The key is managing its state: connecting, sending, receiving, and handling disconnections.\n\nA typical implementation involves a manager/service class (often an `actor` for thread safety) that holds the `webSocketTask`. The connection is established, and a listening method is started. This method uses a loop with `try await task.receive()` to wait for incoming messages. Crucially, after processing a message, the loop continues, calling `receive()` again to listen for the next one. Error recovery involves catching failures, closing the connection cleanly, and initiating a reconnection strategy, like exponential backoff, to avoid spamming the server.\n\n**Practical Code Example:**\n```swift\nactor WebSocketManager: NSObject, URLSessionWebSocketDelegate {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private var urlSession: URLSession!\n\n    override init() {\n        super.init()\n        self.urlSession = URLSession(configuration: .default, delegate: self, delegateQueue: nil)\n    }\n\n    func connect(url: URL) {\n        guard webSocketTask == nil else { return }\n        webSocketTask = urlSession.webSocketTask(with: url)\n        webSocketTask?.resume()\n        listenForMessages()\n    }\n\n    private func listenForMessages() {\n        Task {\n            guard let task = webSocketTask else { return }\n            while let task = self.webSocketTask, task.closeCode == .invalid {\n                do {\n                    let message = try await task.receive()\n                    // Handle incoming message (e.g., decode JSON)\n                    print(\"Received: \\(message)\")\n                } catch {\n                    // Connection lost, handle error\n                    print(\"Error receiving message: \\(error)\")\n                    disconnect() // Or attempt reconnect\n                    break\n                }\n            }\n        }\n    }\n\n    func send(message: String) async throws {\n        try await webSocketTask?.send(.string(message))\n    }\n\n    func disconnect() {\n        webSocketTask?.cancel(with: .goingAway, reason: nil)\n        webSocketTask = nil\n    }\n    \n    // MARK: - URLSessionWebSocketDelegate\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?) {\n        print(\"WebSocket disconnected: \\(closeCode)\")\n        self.webSocketTask = nil\n        // Initiate reconnection logic here\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Forgetting to Re-Listen:** `task.receive()` is a one-shot operation. Failing to call it again in a loop after receiving a message will result in missing all subsequent messages.\n2.  **Reconnection Storms:** Immediately retrying to connect after a failure can drain the battery and overload the server. Implement an exponential backoff strategy (e.g., wait 1s, 2s, 4s, etc.) with jitter.\n3.  **App State Changes:** The app going to the background can terminate the connection. You must handle this by listening to `UIApplication.didEnterBackgroundNotification` to disconnect gracefully and reconnect on foregrounding.\n4.  **Silent Connection Drops:** Firewalls or NATs can drop idle connections. While `URLSessionWebSocketTask` handles basic keep-alives, you can use `task.sendPing` to periodically check liveness and handle timeouts.\n\n**When to Use vs. Alternatives:**\n-   **Use WebSockets for:** Real-time, low-latency, bidirectional communication like chat apps, live-updating dashboards, or collaborative tools.\n-   **Alternatives:**\n    -   **Server-Sent Events (SSE):** Simpler, for server-to-client streaming only (e.g., news feeds).\n    -   **HTTP Long Polling:** A fallback with higher overhead where the server holds a request open. Less efficient than WebSockets.\n    -   **Push Notifications (APNs):** For delivering data when the app is not active. Not suitable for in-app, real-time updates.",
      "code_example": null,
      "tags": [
        "networking",
        "websockets",
        "URLSession",
        "concurrency",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Your team is building an app with a complex, evolving feed. How would you argue for using GraphQL over REST, and what client-side challenges, like caching and error handling, would you anticipate?",
      "back": "I'd argue for GraphQL by focusing on its efficiency and flexibility for a complex feed. Unlike REST, where we'd hit multiple endpoints (`/users/:id`, `/posts/:id`, `/posts/:id/comments`) and stitch data together, GraphQL allows us to fetch all necessary nested data in a single, declarative query. This reduces network round-trips and eliminates over-fetching, as we only request the fields the UI currently displays. This empowers the iOS team to iterate on the UI without waiting for backend API changes.\n\nHowever, this choice introduces specific client-side challenges:\n\n**1. Caching:** REST leverages standard HTTP caching based on URLs, which is simple and effective for static resources. GraphQL typically uses a single endpoint (`/graphql`), rendering HTTP caching ineffective. We'd need to implement a more sophisticated, normalized caching strategy on the client. Libraries like Apollo iOS handle this by creating a local, graph-aware store, but it requires careful configuration for cache invalidation and updates (e.g., after a mutation).\n\n**2. Error Handling:** A REST API typically signals an error with a non-2xx status code. A GraphQL request can be partially successful, returning a 200 OK status with both a `data` object and an `errors` array. Our networking layer must be built to parse this structure and decide how to present partial data to the user, which is more complex than a simple success/fail state.\n\n**3. Tooling & Complexity:** Adopting GraphQL requires more initial setup, including a client library like Apollo, a schema definition, and code generation tools to create type-safe models and queries. This adds a learning curve and build-step complexity compared to using `URLSession` with `Codable` for REST.\n\n**Code Example Contrast:**\n\n// REST: Multiple, chained requests\nfunc fetchPostDetails(for postID: Int) {\n  // 1. Fetch Post\n  fetch(\"/posts/\\(postID)\") { (post: Post) in\n    // 2. Fetch User\n    fetch(\"/users/\\(post.authorID)\") { (user: User) in\n      // 3. Fetch Comments\n      fetch(\"/posts/\\(postID)/comments\") { (comments: [Comment]) in\n        // Finally, update UI\n      }\n    }\n  }\n}\n\n// GraphQL: Single, declarative request using a client library\nlet query = PostDetailsQuery(postID: \"123\")\n\napolloClient.fetch(query: query) { result in\n  // result contains post, its author, and comments in one go\n  // No need for client-side data stitching\n  switch result {\n    case .success(let graphQLResult):\n      // Update UI with graphQLResult.data\n    case .failure(let error):\n      // Handle network or parsing error\n  }\n}",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "rest",
        "graphql"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Explain how HTTP/2 and HTTP/3 improve performance over HTTP/1.1. How does this impact your networking layer architecture in an iOS app, and what role does `URLSession` play?",
      "back": "HTTP/1.1 suffers from head-of-line (HOL) blocking, where multiple requests to the same host are either pipelined over a single, slow connection or require multiple TCP connections, which is resource-intensive. \n\n**HTTP/2 Core Concepts:**\nIt introduces multiplexing, allowing multiple requests and responses to be sent concurrently over a single TCP connection. Each request/response pair is a 'stream'. This eliminates HOL blocking at the application layer. It also adds header compression (HPACK) to reduce overhead.\n\n**HTTP/3 Core Concepts:**\nThis version moves from TCP to a new protocol called QUIC, which runs on top of UDP. This solves the TCP-level HOL blocking problem; if one packet is lost, it only blocks its specific stream, not all streams on the connection. QUIC also features a faster, 0-RTT (zero round-trip time) connection setup for subsequent connections, reducing latency.\n\n**Architectural Impact & `URLSession`:**\n`URLSession` handles protocol negotiation transparently. You don't need to enable it; if the server supports HTTP/3 or HTTP/2, `URLSession` will use it. This fundamentally changes how we should architect our networking:\n\n- **Move away from monolithic requests:** Instead of one large API call fetching all data for a screen, you can confidently make several smaller, independent requests. This is efficient because multiplexing handles them over a single connection.\n- **Deprecate old workarounds:** Practices like domain sharding (using cdn1.domain.com, cdn2.domain.com) or asset bundling are now anti-patterns that defeat the benefits of a single, multiplexed connection.\n\n```swift\n// URLSession transparently handles protocol negotiation.\n// No special configuration is needed to enable HTTP/2 or HTTP/3.\nlet session = URLSession(configuration: .default)\n\n// ARCHITECTURAL SHIFT: Instead of one giant request, we make several small ones.\n// These will be multiplexed efficiently over a single connection.\nfunc fetchScreenData(completion: @escaping (Profile?, Feed?) -> Void) {\n    let group = DispatchGroup()\n    \n    var profile: Profile?\n    group.enter()\n    session.dataTask(with: URL(string: \"https://api.myapp.com/profile\")!) { data, _, _ in\n        // profile = decode(data)\n        group.leave()\n    }.resume()\n    \n    var feed: Feed?\n    group.enter()\n    session.dataTask(with: URL(string: \"https://api.myapp.com/feed\")!) { data, _, _ in\n        // feed = decode(data)\n        group.leave()\n    }.resume()\n    \n    group.notify(queue: .main) {\n        completion(profile, feed)\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Server-Side Dependency:** Your app only benefits if your backend servers are configured to support HTTP/2 or HTTP/3.\n- **Network Blocking:** Corporate firewalls or older proxies might block UDP traffic, preventing HTTP/3 from working and forcing a fallback to HTTP/2 (TCP).\n- **Debugging:** Network debuggers like Charles or Proxyman are needed to inspect multiplexed traffic, as traditional tools may not interpret it correctly.\n\n**When to Use vs. Alternatives:**\n- **Use:** Ideal for apps with many small, concurrent asset or API requests to the same domain (e.g., image-heavy feeds, microservice-backed UIs).\n- **Alternatives:** For real-time, bidirectional communication (like a chat app), **WebSockets** are still superior. For strictly-defined, high-performance inter-service communication, **gRPC** (which uses HTTP/2 as a transport) is a powerful alternative.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "performance",
        "urlsession",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Your app needs to download large files that must continue even if the app is backgrounded or terminated. Describe the architecture using `URLSession`, focusing on session configuration, delegate handling, and the app's lifecycle.",
      "back": "A background transfer is orchestrated by `URLSession` but managed by a system-level daemon (`nsurlsessiond`). This allows transfers to continue even if your app is suspended, terminated by the user, or crashes. The key is to correctly configure the session and handle being woken up by the OS.\n\n**Core Concept:**\n1.  **Configuration:** You must create a `URLSessionConfiguration` using `.background(withIdentifier:)`. The identifier is crucial; it's how your app reconnects to the ongoing session when it's relaunched.\n2.  **Daemon Handoff:** Once a task is created with this session, the networking is handed off to the system daemon. Your app can be suspended without affecting the transfer.\n3.  **Delegate Model:** Background sessions *require* a delegate. Completion handlers are not supported. The OS will launch your app in the background and deliver events (completion, authentication challenges) to your session delegate.\n4.  **App Lifecycle:** Your `AppDelegate` must implement `application(_:handleEventsForBackgroundURLSession:completionHandler:)`. When the OS relaunches your app for a background event, this method is called. You must store the `completionHandler`, re-create the `URLSession` with the *exact same identifier*, and the session will then reconnect and deliver pending delegate messages.\n\n**Code Example:**\n```swift\n// In your AppDelegate\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the handler to call when all events are processed.\n    backgroundSessionCompletionHandler = completionHandler\n}\n\n// In your NetworkManager or relevant class\nprivate lazy var backgroundSession: URLSession = {\n    // The identifier MUST be unique to your app and session.\n    let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundtransfer\")\n    config.isDiscretionary = true // Allows system to optimize for performance, e.g., wait for Wi-Fi & power.\n    config.sessionSendsLaunchEvents = true\n    return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n}()\n\nfunc startBackgroundDownload() {\n    let url = URL(string: \"https://example.com/largefile.zip\")!\n    let downloadTask = backgroundSession.downloadTask(with: url)\n    downloadTask.resume()\n}\n\n// In your URLSessionDownloadDelegate implementation\nfunc urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n    // This file is temporary. You MUST move it before this method returns.\n    let destinationURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(\"largefile.zip\")\n    try? FileManager.default.moveItem(at: location, to: destinationURL)\n}\n\nfunc urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    // Called when all messages for a background session have been delivered.\n    DispatchQueue.main.async {\n        // Fetch and call the stored completion handler from the AppDelegate.\n        guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let handler = appDelegate.backgroundSessionCompletionHandler else { return }\n        appDelegate.backgroundSessionCompletionHandler = nil\n        handler()\n    }\n}\n```\n\n**Common Pitfalls:**\n-   **Mismatched Identifiers:** Failing to use the exact same identifier when re-instantiating the session in a new app launch. This prevents the session from reconnecting to its delegate.\n-   **Using Completion Handlers:** Calling task methods with completion handler blocks on a background session will result in an error. You must use the delegate pattern.\n-   **Not Moving the File:** The file at the `location` URL in `didFinishDownloadingTo` is in a temporary directory. It will be deleted after the delegate method returns. You must move or copy it to a permanent location.\n-   **Forgetting the Completion Handler:** Not calling the `completionHandler` provided in the `AppDelegate` method. This tells the OS your app is done processing events, allowing it to take a new snapshot of your UI and return to a suspended state. Failing to call it can impact performance and battery life.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "background",
        "app-lifecycle"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "How would you implement certificate pinning using `URLSession`? Discuss the trade-offs between pinning a leaf certificate, an intermediate certificate, or a public key, and strategies for handling certificate rotation.",
      "back": "Certificate pinning is a security mechanism that mitigates Man-in-the-Middle (MITM) attacks by ensuring an app only communicates with a server presenting a specific, known certificate or public key. This bypasses the traditional chain of trust (CAs), which could be compromised.\n\n**Core Concept:**\nYou implement this using the `URLSessionDelegate` method `urlSession(_:didReceive:completionHandler:)`. When the server presents its certificate, this delegate method is called with an `URLAuthenticationChallenge`. You then inspect the server's certificate chain (`SecTrust`) and compare it against a certificate or public key hash bundled within your app. If they match, you trust the connection; otherwise, you reject it.\n\n**Code Example (Public Key Pinning):**\n```swift\nclass NetworkService: NSObject, URLSessionDelegate {\n    // Base64-encoded SHA-256 hash of the server's public key (SPKI)\n    private let pinnedPublicKeyHash = \"hpfPyi7b6a7hW+S9yG2sT5x3A48aYd4zXn4uLwRQ2gI=\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Ensure it's a server trust evaluation\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.performDefaultHandling, nil)\n            return\n        }\n\n        // Get the server's leaf certificate from the trust chain\n        if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0) {\n            // Extract the public key from the certificate\n            if let serverPublicKey = SecCertificateCopyKey(serverCertificate),\n               let serverPublicKeyData = SecKeyCopyExternalRepresentation(serverPublicKey, nil) as Data? {\n                \n                // Hash the public key (SHA-256)\n                let keyHash = sha256(data: serverPublicKeyData)\n                let keyHashBase64 = keyHash.base64EncodedString()\n\n                // Compare with our pinned hash\n                if keyHashBase64 == pinnedPublicKeyHash {\n                    // Success: Trust this server\n                    completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                    return\n                }\n            }\n        }\n        \n        // Failure: The key doesn't match, reject the connection\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n    // sha256 helper function would be defined elsewhere\n}\n```\n\n**Trade-offs & Strategies:**\n*   **Pinning the Leaf Certificate:** Most specific and secure, but also the most brittle. If the server certificate is renewed or changed for any reason, the app will break until it's updated with the new certificate. This can effectively \"brick\" your app for all users.\n*   **Pinning an Intermediate Certificate:** A good compromise. It trusts any certificate issued by a specific intermediate authority you control. This allows for server certificate rotation without requiring an app update. The risk is that if the intermediate CA is compromised, any certificate it signs will be trusted.\n*   **Pinning the Public Key (SPKI Pinning):** The recommended modern approach. A public key can be maintained across certificate renewals. This provides strong security without the brittleness of leaf certificate pinning, making it robust against certificate expiration.\n\n**Common Pitfalls:**\n*   **No Backup Pin:** Failing to include a backup pin for a future certificate or a different CA is a critical error. If your primary pin becomes invalid, the backup can prevent your app from becoming unusable.\n*   **Incorrect Domain Filtering:** Applying pinning logic to third-party domains can break essential services (analytics, ads, etc.). Pinning logic should be strictly limited to your own API endpoints.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "How would you configure a `URLSession` to handle custom server trust evaluation (e.g., SSL pinning) and also support background downloads? Detail the key delegates and configuration settings involved.",
      "back": "To achieve this, you need to combine a background session configuration with a custom delegate that handles authentication challenges.\n\n**Core Concept Explanation:**\n\n1.  **`URLSessionConfiguration`**: You must use `.background(withIdentifier:)`. This configuration creates a session that hands off upload/download tasks to the OS, allowing them to continue even if your app is suspended or terminated. A unique identifier is required for the system to reconnect your app to the session later.\n\n2.  **`URLSessionDelegate` & `URLSessionTaskDelegate`**: Background sessions *require* a delegate. You cannot use completion handler-based methods. For custom server trust evaluation, your delegate must conform to `URLSessionTaskDelegate` and implement the `urlSession(_:task:didReceive:completionHandler:)` method. This method is invoked when the server requires authentication, including evaluating its certificate chain.\n\n3.  **App Delegate Integration**: When a background task completes, the OS relaunches your app in the background. You must implement `application(_:handleEventsForBackgroundURLSession:completionHandler:)` in your `AppDelegate` to capture the session identifier and store the completion handler. This allows `URLSession` to reconnect and deliver any pending delegate events.\n\n**Practical Code Example:**\n\n```swift\n// In your NetworkManager or a dedicated class\nclass NetworkService: NSObject, URLSessionTaskDelegate, URLSessionDownloadDelegate {\n    lazy var backgroundSession: URLSession = {\n        // Identifier must be unique\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundService\")\n        config.isDiscretionary = true // Let the system optimize for performance/battery\n        config.sessionSendsLaunchEvents = true\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil) // nil queue means a new serial queue\n    }()\n\n    func startBackgroundDownload() {\n        let url = URL(string: \"https://example.com/largefile.zip\")!\n        let task = backgroundSession.downloadTask(with: url)\n        task.resume()\n    }\n\n    // 1. Handle Server Trust Evaluation (SSL Pinning)\n    func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust, \n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.performDefaultHandling, nil)\n            return\n        }\n\n        // TODO: Implement your SSL pinning logic here.\n        // e.g., Compare serverTrust's public key with a known, bundled public key.\n        let isTrusted = customTrustEvaluation(serverTrust)\n        \n        if isTrusted {\n            completionHandler(.useCredential, URLCredential(trust: serverTrust))\n        } else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n    \n    // 2. Handle Download Completion\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move file from temporary location to a permanent one\n        print(\"Download finished, file at: \\(location.path)\")\n    }\n}\n\n// In your AppDelegate.swift\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Reconnect the session and store the completion handler to call later\n    // This is crucial for letting the OS know you've handled all events.\n}\n```\n\n**Common Pitfalls:**\n\n*   **Blocking Delegate Queue**: Delegate methods are called on a serial operation queue. Performing long-running or synchronous work here will block all subsequent delegate callbacks for that session.\n*   **Retain Cycles**: The `URLSession` object maintains a strong reference to its delegate. If your delegate (e.g., a manager class) also holds a strong reference to the session, you'll create a retain cycle. You must explicitly call `finishTasksAndInvalidate()` or `invalidateAndCancel()` on the session when it's no longer needed.\n*   **Forgetting `AppDelegate` Handler**: Failing to implement `handleEventsForBackgroundURLSession` or failing to call its `completionHandler` can cause your app to be penalized by the OS for improper background execution.\n\n**When to Use vs. Alternatives:**\n\n*   **Delegates vs. `async/await`**: For simple requests, `async/await` (e.g., `URLSession.shared.data(for:)`) is cleaner and preferred. However, the delegate pattern is non-negotiable for background sessions and remains the only way to get fine-grained control over metrics, authentication challenges, and streaming data.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "concurrency",
        "background-tasks",
        "security"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    }
  ]
}