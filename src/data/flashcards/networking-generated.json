{
  "topic": "networking",
  "generated_at": "2026-01-10T03:57:26.895045+00:00",
  "cards": [
    {
      "id": "networking_6431b3cd68e4",
      "front": "How would you implement certificate pinning to prevent MITM attacks, and what are the critical operational trade-offs and maintenance challenges a senior developer must consider?",
      "back": "Certificate pinning is a security technique that hardcodes the server's certificate or public key within the client application. During a TLS handshake, the app compares the server's certificate against this embedded copy. If they don't match, the connection is terminated. This prevents Man-in-the-Middle (MITM) attacks, even if a device's trust store is compromised by a malicious Certificate Authority (CA).\n\n**Core Concept:**\nImplementation is done within the `URLSessionDelegate`'s `urlSession(_:didReceive:completionHandler:)` method. We inspect the `serverTrust` object from the authentication challenge, extract the server's certificate chain, and compare it (or its public key) to our pinned, trusted certificate.\n\n**Code Example (Public Key Pinning):**\n```swift\nclass NetworkService: NSObject, URLSessionDelegate {\n    // Pinned public key hash (e.g., Base64-encoded SHA-256)\n    let pinnedPublicKeyHash = \"hpf...YOUR_KEY_HASH...Xi0=\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        \n        guard let serverTrust = challenge.protectionSpace.serverTrust,\n              SecTrustEvaluateWithError(serverTrust, nil) else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        // Extract public key from the server's leaf certificate\n        guard let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0),\n              let serverPublicKey = SecCertificateCopyKey(serverCertificate),\n              let serverPublicKeyData = SecKeyCopyExternalRepresentation(serverPublicKey, nil) as Data? else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        // Hash the server's public key (SHA-256)\n        var sha256 = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n        serverPublicKeyData.withUnsafeBytes { \n            _ = CC_SHA256($0.baseAddress, CC_LONG(serverPublicKeyData.count), &sha256)\n        }\n        let serverPublicKeyHash = Data(sha256).base64EncodedString()\n\n        // Compare hashes\n        if serverPublicKeyHash == pinnedPublicKeyHash {\n            // Success: Trust this server\n            completionHandler(.useCredential, URLCredential(trust: serverTrust))\n        } else {\n            // Failure: Mismatch, likely a MITM attack\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n}\n```\n**Common Pitfalls & Challenges:**\n1.  **Certificate Expiration:** This is the biggest operational risk. If the pinned certificate expires and the app isn't updated with the new one, all network requests will fail, effectively bricking the app's online functionality. A robust key rotation strategy is essential.\n2.  **Brittle Implementation:** Pinning the entire certificate is fragile. Pinning the public key hash (as shown above) is more flexible, as the certificate can be renewed with the same key pair.\n3.  **Key Rollover:** You must plan for key rotation. A common strategy is to pin to both the current and the next (future) public key to allow for a smooth transition without forcing an immediate app update.\n\n**When to Use vs. Alternatives:**\n- **Use When:** Required for high-security applications like banking, finance, or healthcare, where data integrity and confidentiality during transit are paramount.\n- **Alternatives:** For most apps, standard TLS validation with App Transport Security (ATS) is sufficient. Certificate Transparency (CT) is a complementary mechanism that provides public logs of issued certificates, helping detect rogue CAs, but it doesn't prevent active MITM attacks on a client like pinning does.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "urlsession",
        "mitm"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Your team is building a feature with complex, nested data requirements. How would you evaluate choosing GraphQL over a traditional REST architecture, and what are the primary client-side challenges?",
      "back": "REST (Representational State Transfer) is an architectural style based on accessing resources via predefined endpoints using standard HTTP verbs. The server dictates the structure of the response. GraphQL is a query language for APIs where the client specifies exactly what data it needs from a single endpoint, receiving a JSON response that mirrors the query structure.\n\n**Evaluation for Complex Data:**\nFor a feature with nested data (e.g., a user, their posts, and comments on each post), a REST approach often leads to under-fetching and multiple round trips (the N+1 problem) or over-fetching from a bloated, pre-aggregated endpoint. GraphQL solves this by allowing the client to craft a single query to fetch all required data in one request, reducing latency and data usage—critical for mobile apps.\n\n**Code Example:**\n\n**REST: Multiple Requests**\n```swift\n// 1. Fetch user\nlet user = await networkService.fetch(\"/users/123\")\n// 2. Fetch user's posts (another network call)\nlet posts = await networkService.fetch(\"/users/123/posts\")\n// 3. Fetch comments for each post (N more calls)\nfor post in posts { let comments = await networkService.fetch(\"/posts/\\(post.id)/comments\") }\n```\n\n**GraphQL: Single Request**\n```swift\n// Using a library like Apollo iOS\nlet userProfileQuery = \"\"\"\n  query GetUserProfile($userId: ID!) {\n    user(id: $userId) {\n      id\n      name\n      posts {\n        id\n        title\n        comments {\n          body\n        }\n      }\n    }\n  }\n\"\"\"\n// A single network call fetches everything\nlet result = await apolloClient.fetch(query: userProfileQuery, variables: [\"userId\": 123])\n```\n\n**Client-Side Challenges with GraphQL:**\n1.  **Caching:** Simple URL-based HTTP caching is ineffective. GraphQL requires a sophisticated, normalized cache on the client (like the one in Apollo iOS) to store the graph data, handle updates from mutations, and provide UI consistency. This adds complexity.\n2.  **Tooling & Setup:** Integrating GraphQL often involves adding significant dependencies (e.g., Apollo), including code generation steps that transform `.graphql` files into Swift models. This can complicate the build process and requires team buy-in.\n3.  **Error Handling:** A single GraphQL request can partially succeed, returning both a `data` object and an `errors` array. Client code must be robust enough to handle this, which is more complex than checking a single HTTP status code.\n\n**When to Use:**\n- **GraphQL:** Best for applications with diverse clients (mobile, web) having different data requirements, a complex and interconnected data model, or where minimizing network payload is paramount.\n- **REST:** Remains a solid choice for simpler, resource-oriented APIs, public-facing APIs where simplicity is key, or when leveraging standard HTTP caching is a priority.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "graphql",
        "rest"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Design a scalable and testable network layer for a large iOS app. Describe its key components, their responsibilities, and how they ensure separation of concerns.",
      "back": "A scalable network layer abstracts network operations, promoting testability and separation of concerns. It typically consists of several distinct components:\n\n**Core Concepts & Components:**\n1.  **Endpoint/Router:** A protocol-based definition of an API request. This component is responsible for providing all the necessary information to build a `URLRequest`, such as the path, HTTP method, headers, and parameters. Using an enum that conforms to this protocol provides a type-safe way to represent all possible API calls.\n2.  **Network Service (API Client):** The workhorse of the layer. This generic class or struct takes an `Endpoint`, constructs the `URLRequest`, executes it (e.g., using `URLSession`), handles initial response validation (like checking status codes), and decodes the data into a specified `Decodable` model. It is completely agnostic to the specific endpoints or models it's handling.\n3.  **Models:** Simple `Codable` structs that mirror the JSON structure of the API responses. They are plain data containers with no networking logic.\n4.  **Custom Errors:** A dedicated enum for network-related errors (e.g., `invalidURL`, `decodingFailed`, `serverError(statusCode: Int)`) to provide clear, actionable feedback to the caller.\n\nThis separation ensures that the view model or interactor only knows about the service's high-level methods, the service only knows how to execute a request defined by an endpoint, and endpoints only know how to describe themselves.\n\n**Practical Code Example:**\n```swift\n// 1. Defines the contract for any API endpoint\nprotocol Endpoint {\n    var path: String { get }\n    var method: String { get }\n    // ... headers, body, etc.\n}\n\n// 2. A type-safe representation of a specific API call\nenum UserEndpoint: Endpoint {\n    case fetch(id: String)\n    var path: String { \"/users/\\(id)\" }\n    var method: String { \"GET\" }\n}\n\n// 3. The generic service that executes any endpoint request\nactor NetworkService {\n    private let session = URLSession.shared\n    private let decoder = JSONDecoder()\n    private let baseURL = URL(string: \"https://api.example.com\")!\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        let url = baseURL.appendingPathComponent(endpoint.path)\n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method\n        \n        let (data, _) = try await session.data(for: request)\n        // Add HTTP status code validation here\n        return try decoder.decode(T.self, from: data)\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Singleton Abuse:** Using a global `APIManager.shared` singleton tightly couples your app and makes unit testing difficult. Instead, use dependency injection to provide a network service instance.\n*   **Fat Service Layer:** Putting all logic—request creation, parsing, caching, retrying—into a single massive class. This violates the Single Responsibility Principle.\n*   **Not Using Protocols:** Directly depending on a concrete `NetworkService` class prevents you from easily creating mock versions for testing.\n\n**When to Use vs. Alternatives:**\n*   **Use This Architecture:** For any medium-to-large scale application where maintainability and testability are priorities. The upfront effort pays dividends as the number of endpoints grows.\n*   **Alternatives:**\n    *   **Direct `URLSession`:** Suitable only for trivial apps or prototypes. It quickly leads to boilerplate and unmanageable code.\n    *   **Third-Party Libraries (e.g., Alamofire):** Excellent for simplifying the implementation details within the `NetworkService`. However, you should still wrap the library with this protocol-oriented architecture to isolate your app from the dependency and maintain a clean, testable design.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "design patterns",
        "async/await",
        "testing"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Describe how you would architect a robust, reusable WebSocket client in a modern Swift application. What key lifecycle events and error conditions must be handled, and how would you ensure connection stability?",
      "back": "A robust WebSocket client architecture should abstract the low-level `URLSessionWebSocketTask` into a higher-level service, often implemented as an `actor` for thread-safe state management. This service is responsible for the entire connection lifecycle.\n\n**Core Concept:**\nThe manager should maintain a state machine (e.g., `connecting`, `connected`, `disconnecting`, `disconnected`). It initiates the connection via `urlSession.webSocketTask(with: url)` and uses a long-running `async` task to listen for incoming messages with `task.receive()`. Outgoing messages are sent via `task.send()`. Crucially, it must handle connection drops by implementing a resilience strategy, like an exponential backoff algorithm for reconnection attempts, to avoid overwhelming the server.\n\n**Practical Code Example:**\n```swift\nactor WebSocketManager {\n    private var task: URLSessionWebSocketTask?\n    private let url: URL\n    private let session = URLSession(configuration: .default)\n    \n    // Use an AsyncThrowingStream to broadcast messages to multiple listeners\n    private(set) var messageStream: AsyncThrowingStream<URLSessionWebSocketTask.Message, Error> {\n        get {\n            AsyncThrowingStream { continuation in\n                self.continuation = continuation\n            }\n        }\n        set {}\n    }\n    private var continuation: AsyncThrowingStream<URLSessionWebSocketTask.Message, Error>.Continuation?\n\n    init(url: URL) {\n        self.url = url\n    }\n\n    func connect() {\n        guard task == nil else { return }\n        task = session.webSocketTask(with: url)\n        listenForMessages()\n        task?.resume()\n    }\n\n    private func listenForMessages() {\n        task?.receive {\n            [weak self] result in\n            guard let self else { return }\n            \n            Task {\n                await self.handle(result: result)\n            }\n        }\n    }\n    \n    private func handle(result: Result<URLSessionWebSocketTask.Message, Error>) {\n        switch result {\n        case .success(let message):\n            continuation?.yield(message)\n            listenForMessages() // Continue listening for the next message\n        case .failure(let error):\n            continuation?.finish(throwing: error)\n            disconnect() // Or trigger reconnect logic\n        }\n    }\n    \n    func disconnect() {\n        task?.cancel(with: .goingAway, reason: nil)\n        continuation?.finish()\n        task = nil\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Lack of Reconnection Logic:** The most common failure is not handling unexpected disconnects (e.g., network path changes, server restarts). The `listenForMessages` `failure` case should trigger a retry strategy with exponential backoff.\n2.  **Ignoring Keep-Alives:** Connections can be dropped by firewalls or load balancers due to inactivity. `URLSessionWebSocketTask` automatically handles ping/pong responses, but you can also schedule periodic pings (`task.sendPing`) to ensure the connection stays alive.\n3.  **Race Conditions:** Managing state like `isConnected` without synchronization can lead to bugs. Using an `actor` is the modern Swift solution to guarantee serialized access to the `task` and other state variables.\n\n**When to Use vs. Alternatives:**\n-   **Use WebSockets:** For full-duplex, real-time, low-latency communication like chat apps, live data feeds (stocks, sports scores), and collaborative editing.\n-   **Alternatives:**\n    -   **Server-Sent Events (SSE):** Preferable for unidirectional (server-to-client) updates like news feeds. It's simpler and works over standard HTTP.\n    -   **HTTP Long Polling:** A legacy fallback where the client holds a request open. It has high overhead and latency compared to WebSockets.",
      "code_example": null,
      "tags": [
        "networking",
        "websockets",
        "URLSession",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Explain the lifecycle of a `URLSession` background transfer. How does the system manage the process when the app is suspended or terminated, and what are the developer's key responsibilities for ensuring a successful transfer?",
      "back": "A `URLSession` background transfer allows network tasks to continue even when the app is not in the foreground. The entire process is managed by the OS, providing resilience against app suspension, crashes, or termination.\n\n**Core Concept:**\nThe lifecycle begins by creating a `URLSession` with a `URLSessionConfiguration.background(withIdentifier:)`. This unique identifier is critical, as it allows the OS to reconnect the session to your app. Once a task is created and resumed, control is handed over to a system daemon (`nsurlsessiond`), which performs the actual transfer. Because the OS handles the transfer, it can proceed efficiently without the app running.\n\nWhen the task completes (successfully or with an error), or if authentication is required, the OS relaunches the app in the background. It then calls the `AppDelegate`'s `application(_:handleEventsForBackgroundURLSession:completionHandler:)` method. At this point, the developer's primary responsibility is to recreate the `URLSession` with the *exact same identifier*. This re-establishes the connection, allowing the session's delegate to receive pending events, such as `urlSession(_:downloadTask:didFinishDownloadingTo:)`.\n\n**Practical Code Example:**\n```swift\n// In your AppDelegate\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the handler to call when all events are processed.\n    BackgroundTransferManager.shared.backgroundCompletionHandler = completionHandler\n}\n\n// In a dedicated manager class\nclass BackgroundTransferManager: NSObject, URLSessionDownloadDelegate, URLSessionDelegate {\n    static let shared = BackgroundTransferManager()\n    static let identifier = \"com.yourapp.backgroundSession\"\n\n    var backgroundCompletionHandler: (() -> Void)?\n\n    private lazy var backgroundSession: URLSession = {\n        let config = URLSessionConfiguration.background(withIdentifier: Self.identifier)\n        config.isDiscretionary = true // Allow system to optimize\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    func startDownload(url: URL) {\n        let task = backgroundSession.downloadTask(with: url)\n        task.resume()\n    }\n\n    // Delegate: Called on successful download\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move the temporary file to a permanent location\n        print(\"Download finished at: \\(location.path)\")\n    }\n\n    // Delegate: Called when all events for this session are delivered\n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        DispatchQueue.main.async {\n            self.backgroundCompletionHandler?()\n            self.backgroundCompletionHandler = nil\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting the Completion Handler:** You *must* eventually call the `completionHandler` provided in the `AppDelegate`. The ideal place is in `urlSessionDidFinishEvents(forBackgroundURLSession:)`. Failing to call it penalizes your app's future background execution time.\n- **Using Task-Level Completion Handlers:** Background sessions strictly require a delegate. Creating tasks with a completion block (e.g., `downloadTask(with:completionHandler:)`) will cause a crash.\n- **Mismatched Identifiers:** The session identifier must be consistent across app launches.\n\n**When to Use vs. Alternatives:**\n- **Use Background Transfer:** For large, non-urgent files (e.g., video content, backups) that can take minutes or hours and must survive app termination.\n- **Use `beginBackgroundTask`:** For short, critical tasks (under 30 seconds) that must complete before the app is suspended, like saving user data. It does not survive app termination.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "background-modes",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "How would you architect a custom networking layer using `URLSession` to handle custom authentication, monitor performance metrics, and manage background downloads?",
      "back": "To build a robust, custom networking layer, you leverage the delegate-based architecture of `URLSession`. This provides granular control over the entire lifecycle of a network request.\n\n**Core Concept:**\nThe key is to separate configuration, execution, and event handling:\n1.  **`URLSessionConfiguration`**: This is the blueprint for your session. Use `.default` for standard behavior, `.ephemeral` for private/incognito sessions, and `.background(withIdentifier:)` for transfers that can continue when the app is not running. The identifier is crucial for reconnecting to the session later.\n2.  **`URLSession`**: The session object itself, which creates and manages tasks. It's initialized with a configuration, a delegate, and a delegate queue. The delegate queue is an `OperationQueue` where all delegate callbacks will be executed. Using `nil` creates a default serial queue, which is a safe choice to avoid race conditions in your delegate methods.\n3.  **`URLSessionDelegate` & Sub-protocols**: A custom delegate object (e.g., your `NetworkManager`) conforms to these protocols to intercept events. \n    - `URLSessionDelegate`: Handles session-level events, including authentication challenges (`urlSession(_:didReceive:completionHandler:)`).\n    - `URLSessionTaskDelegate`: Handles task-level events, like collecting performance metrics (`urlSession(_:task:didFinishCollecting:)`).\n    - `URLSessionDownloadDelegate`: Manages background downloads, reporting progress and completion location.\n\n**Practical Code Example:**\n```swift\nclass NetworkManager: NSObject, URLSessionDelegate, URLSessionTaskDelegate {\n    private lazy var session: URLSession = {\n        // For background tasks, use: .background(withIdentifier: \"com.myapp.downloader\")\n        let configuration = URLSessionConfiguration.default\n        configuration.waitsForConnectivity = true // A useful option\n        // Using self as delegate and nil for the queue, which creates a serial OperationQueue for us.\n        return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)\n    }()\n\n    func fetchData(from url: URL) {\n        let task = session.dataTask(with: url)\n        task.resume()\n    }\n\n    // 1. Handle Authentication Challenges\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Example: Trusting a specific self-signed certificate\n        guard let serverTrust = challenge.protectionSpace.serverTrust, SecTrustGetCertificateCount(serverTrust) > 0 else {\n            completionHandler(.performDefaultHandling, nil)\n            return\n        }\n        // Custom trust evaluation logic here...\n        completionHandler(.useCredential, URLCredential(trust: serverTrust))\n    }\n\n    // 2. Monitor Performance Metrics\n    func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {\n        let totalTime = metrics.taskInterval.duration\n        print(\"Task for \\(task.originalRequest?.url?.absoluteString ?? \"\") took \\(totalTime)s\")\n        // You can inspect metrics.transactionMetrics for DNS lookup, connect time, etc.\n    }\n    \n    // Remember to invalidate the session to avoid memory leaks.\n    deinit {\n        session.finishTasksAndInvalidate()\n    }\n}\n```\n\n**Common Pitfalls:**\n-   **Memory Leaks**: `URLSession` holds a strong reference to its delegate. If your delegate (e.g., `NetworkManager`) also holds a strong reference to the session, you create a retain cycle. You must explicitly invalidate the session (e.g., with `finishTasksAndInvalidate()` in `deinit`) to break this cycle.\n-   **Background Session Rules**: Background sessions have strict rules. You *must* use delegates (completion handlers are not supported), and you must provide a unique identifier. All tasks must also be created before the app is backgrounded.\n-   **Delegate Queue Blocking**: If you set the delegate queue to `OperationQueue.main`, any long-running delegate method will freeze your UI. It's safer to use a background queue and dispatch back to main only when updating the UI.\n\n**When to Use vs. Alternatives:**\n-   **Use Delegates**: For complex needs: custom server trust evaluation, client certificate authentication, fine-grained performance monitoring, or background uploads/downloads.\n-   **Use `async/await`**: For most common network calls (`URLSession.shared.data(for:)`). It's simpler, avoids delegate boilerplate, and integrates seamlessly into modern Swift Concurrency. This is the preferred modern approach for simple requests.\n-   **Use Combine**: When you want to integrate network responses into a reactive data stream using `dataTaskPublisher`.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Beyond faster speeds, how do HTTP/2's multiplexing and header compression change networking best practices in iOS apps compared to HTTP/1.1? And what key problem does HTTP/3 solve on top of this?",
      "back": "HTTP/2 and HTTP/3 represent significant upgrades over HTTP/1.1, and understanding their mechanics is crucial for writing performant networking code. `URLSession` handles the protocol negotiation automatically, but our strategies must adapt.\n\n**Core Concept Explanation:**\n\n*   **HTTP/1.1 Limitations:** It suffered from head-of-line (HOL) blocking, where requests were processed serially over a connection. Browsers and clients worked around this by opening multiple (usually 6) TCP connections per host, a practice called **domain sharding**. This had significant overhead (TCP slow start, TLS handshakes).\n\n*   **HTTP/2's Solution (Multiplexing):** HTTP/2 introduces multiplexing, allowing multiple request/response streams to flow concurrently over a single TCP connection. This completely eliminates HTTP-level HOL blocking. As a result, the old workarounds are now anti-patterns. Opening many connections is wasteful, and bundling multiple API calls into one large request to save connections is no longer necessary and can be less efficient.\n    *   **HPACK Header Compression:** Further reduces latency by compressing redundant HTTP headers.\n\n*   **HTTP/3's Advancement (QUIC):** While HTTP/2 solved HOL blocking at the application layer, it was still vulnerable to **TCP-level HOL blocking**. If a single TCP packet is lost, the entire connection stalls, blocking all multiplexed streams until it's retransmitted. HTTP/3 solves this by running on QUIC, a transport protocol built on UDP. QUIC handles streams independently, so a lost packet for one stream doesn't block others. This is a massive win for mobile networks, which often have higher packet loss.\n\n**Practical Code Example:**\nWith HTTP/2+, the best practice is to fire off many small, independent requests concurrently. `URLSession` will efficiently manage them over a single connection.\n\n```swift\nfunc fetchDashboardData() {\n    let urls = [\n        URL(string: \"https://api.example.com/user/profile\")!,\n        URL(string: \"https://api.example.com/user/feed\")!,\n        URL(string: \"https://api.example.com/config\")!\n    ]\n\n    // With HTTP/2, we can fire these requests in parallel without penalty.\n    // URLSession will multiplex them over a single, persistent connection.\n    // This is far more efficient than the old HTTP/1.1 connection-per-request model.\n    let group = DispatchGroup()\n\n    for url in urls {\n        group.enter()\n        URLSession.shared.dataTask(with: url) { data, response, error in\n            // Process response...\n            print(\"Finished fetching \\(url.path)\")\n            group.leave()\n        }.resume()\n    }\n\n    group.notify(queue: .main) {\n        print(\"All dashboard data fetched.\")\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Continuing Old Habits:** Developers accustomed to HTTP/1.1 might still bundle assets or API calls. This is now an anti-pattern that prevents parallel processing and can slow down the UI.\n*   **Ignoring Server Support:** Your app will only benefit if the server supports these protocols. `URLSession` gracefully falls back to HTTP/1.1, but you won't see the performance gains.\n*   **Misunderstanding HOL Blocking:** Confusing HTTP-level HOL blocking (solved by H2) with TCP-level HOL blocking (solved by H3/QUIC). Understanding the distinction is key for diagnosing network performance on unreliable connections.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "performance",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}