{
  "topic": "networking",
  "generated_at": "2026-01-14T04:19:33.242011+00:00",
  "cards": [
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Architect a robust, reusable WebSocket service in a modern Swift app. Describe its key components, state management, connection lifecycle, and error handling strategies.",
      "back": "A robust WebSocket service centralizes logic in a dedicated manager, often an `actor` to ensure thread-safe state management. This manager is responsible for the entire connection lifecycle.\n\n**Core Concepts:**\n1.  **State Machine:** The service's state should be explicitly managed using an enum (e.g., `.disconnected`, `.connecting`, `.connected`, `.disconnecting`). This prevents invalid operations, like sending a message while disconnected.\n2.  **Connection Manager:** A central class (e.g., `WebSocketManager`) handles creating and managing the `URLSessionWebSocketTask`.\n3.  **I/O Handling:** Use `async/await` to listen for incoming messages in a loop. This avoids callback hell and simplifies the logic. An `AsyncStream` is ideal for broadcasting received messages to multiple subscribers in the app.\n4.  **Reconnection Logic:** Implement an automatic reconnection strategy with exponential backoff and jitter to avoid overwhelming the server or draining the battery during network instability.\n\n**Practical Code Example:**\n```swift\nactor WebSocketManager {\n    private var task: URLSessionWebSocketTask?\n    private let url: URL\n    \n    enum ConnectionState { case disconnected, connecting, connected }\n    private(set) var state: ConnectionState = .disconnected\n\n    // Use an AsyncStream to broadcast messages to observers\n    private let (stream, continuation) = AsyncStream<URLSessionWebSocketTask.Message>.makeStream(of: URLSessionWebSocketTask.Message.self)\n\n    init(url: URL) { self.url = url }\n\n    func connect() {\n        guard state == .disconnected else { return }\n        state = .connecting\n        let session = URLSession(configuration: .default)\n        task = session.webSocketTask(with: url)\n        task?.resume()\n        state = .connected\n        \n        // Start listening for messages in a new Task\n        Task { await listen() }\n    }\n\n    private func listen() async {\n        guard let task = task else { return }\n        do {\n            // The for-await loop runs until the connection is closed\n            for try await message in task {\n                continuation.yield(message) // Broadcast received message\n            }\n        } catch {\n            // Handle connection errors and trigger reconnection logic\n            self.disconnect(reason: .connectionError)\n        }\n    }\n\n    func send(message: String) async throws {\n        guard state == .connected else { throw MyError.notConnected }\n        try await task?.send(.string(message))\n    }\n    \n    func disconnect(reason: URLSessionWebSocketTask.CloseCode = .normalClosure) {\n        state = .disconnected\n        task?.cancel(with: reason, reason: nil)\n        task = nil\n        continuation.finish()\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Reconnection Storms:** Naively retrying to connect in a tight loop after failure can spam the server. Use exponential backoff (e.g., wait 1s, 2s, 4s, 8s...) with jitter to spread out reconnection attempts.\n*   **App Backgrounding:** The system will sever TCP connections when the app is suspended. You must detect app foregrounding (`willEnterForegroundNotification`) to re-establish the connection. `URLSessionWebSocketTask` does not work in the background.\n*   **Silent Disconnects:** Network routers can drop connections silently. `URLSessionWebSocketTask` handles ping/pong keep-alives automatically to detect this, but you must handle the resulting `disconnect` error in your `listen()` method to trigger a reconnect.\n\n**When to Use vs. Alternatives:**\n*   **WebSockets:** Use for low-latency, bi-directional, real-time communication (e.g., chat apps, collaborative editing, live game data).\n*   **HTTP Long Polling:** A fallback for environments where WebSockets are blocked. Less efficient due to connection setup overhead for each message.\n*   **Server-Sent Events (SSE):** Ideal for one-way, server-to-client data streams (e.g., stock tickers, live news feeds). Simpler protocol than WebSockets.\n*   **Push Notifications (APNs):** For delivering infrequent notifications when the app is not active. Not a substitute for real-time in-app communication.",
      "code_example": null,
      "tags": [
        "networking",
        "websocket",
        "urlsession",
        "architecture",
        "concurrency",
        "async-await"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Design a scalable and testable network layer for a large-scale iOS app. Describe its components, their responsibilities, and how they interact.",
      "back": "A scalable network layer architecture isolates responsibilities into distinct components, promoting testability and maintainability.\n\n**Core Concept:**\nThe architecture is typically composed of three layers:\n1.  **Endpoint/Request Layer:** Defines *what* to fetch. Using a protocol (e.g., `Endpoint`), each API call becomes a self-contained, type-safe struct. This object is responsible for providing the path, HTTP method, headers, and body for a specific request. This prevents stringly-typed errors and makes API definitions easy to find and manage.\n\n2.  **API Client/Service Layer:** Defines *how* to fetch. A generic client takes an `Endpoint` object, constructs a `URLRequest`, executes it using `URLSession`, and handles decoding the response. By using generics and `async/await`, this client remains completely agnostic to the specific data being fetched, making it highly reusable.\n\n3.  **Repository Layer:** Acts as a facade between the business logic (ViewModels, Interactors) and the data source. It uses the API Client to perform network requests but hides the implementation details. This layer is the single source of truth for a specific data model and can be extended to handle caching, data aggregation, or switching between remote and local data sources.\n\n**Practical Code Example:**\n```swift\n// 1. Endpoint Layer\nprotocol Endpoint {\n    var path: String { get }\n    var method: String { get }\n    // ... headers, body parameters etc.\n}\n\nstruct UserEndpoint: Endpoint {\n    let userId: String\n    var path: String { \"/users/\\(userId)\" }\n    var method: String { \"GET\" }\n}\n\n// 2. API Client Layer (Generic)\nactor APIClient {\n    private let session = URLSession.shared\n    private let decoder = JSONDecoder()\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        // Logic to construct URLRequest from endpoint...\n        let url = URL(string: \"https://api.example.com\" + endpoint.path)!\n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method\n        \n        let (data, response) = try await session.data(for: request)\n        // ...validate response status code\n        return try decoder.decode(T.self, from: data)\n    }\n}\n\n// 3. Repository Layer\nclass UserRepository {\n    private let client = APIClient()\n    \n    func fetchUser(id: String) async throws -> User {\n        let endpoint = UserEndpoint(userId: id)\n        // Business logic only interacts with the repository\n        return try await client.request(endpoint: endpoint)\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Monolithic API Manager:** Creating a single `APIManager` class with a specific function for every API call (e.g., `fetchUsers()`, `postComment()`). This violates the Single Responsibility Principle and becomes bloated and untestable.\n- **No Abstraction:** Making `URLSession` calls directly from ViewModels or ViewControllers, tightly coupling UI to network implementation.\n- **Poor Error Handling:** Not distinguishing between network errors (no connectivity), server errors (4xx, 5xx), and decoding errors, leading to a poor user experience.\n\n**When to use vs. Alternatives:**\n- **Use This Pattern:** For most medium-to-large scale applications where testability, scalability, and clear separation of concerns are critical.\n- **Alternatives:** Third-party libraries like **Moya** formalize this endpoint-based approach with its `TargetType` protocol. **Alamofire** can replace the `URLSession` logic within the APIClient for more complex needs like request retrying, but the overall architecture remains the same.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "design patterns",
        "async/await",
        "repository pattern"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Your app's security audit recommends certificate pinning. Describe the difference between pinning the leaf certificate vs. an intermediate/root certificate or public key, and analyze the operational trade-offs of each approach.",
      "back": "Certificate pinning is a security technique that hardcodes the server's certificate or public key within the client application. During the TLS handshake, the app compares the server's presented certificate against its pinned copy, bypassing the device's default chain of trust. This mitigates Man-in-the-Middle (MITM) attacks using fraudulent certificates issued by a compromised Certificate Authority (CA).\n\n**Pinning Strategies & Trade-offs:**\n\n1.  **Leaf Certificate:** Pinning the server's end-entity certificate. \n    *   **Pro:** Most specific; guarantees you're talking to the exact server instance.\n    *   **Con:** Extremely brittle. When the certificate expires and is renewed (even with the same key), the app will break. This creates high operational overhead, requiring a mandatory app update for every certificate renewal.\n\n2.  **Intermediate/Root Certificate:** Pinning the certificate of the CA that issued the server's certificate.\n    *   **Pro:** More flexible. The server's leaf certificate can be renewed as long as it's signed by the same pinned issuer.\n    *   **Con:** Less secure. If the pinned CA is compromised, an attacker could issue a valid certificate for your domain and successfully perform a MITM attack.\n\n3.  **Public Key:** Pinning the `SubjectPublicKeyInfo` of the certificate.\n    *   **Pro:** The best balance of security and flexibility. The server's certificate can be renewed with a new expiry date, serial number, etc., as long as the underlying cryptographic key pair remains the same. This is the most common and recommended approach.\n    *   **Con:** Still requires careful key rotation management.\n\n```swift\n// Example using URLSessionDelegate to pin a public key hash\nclass NetworkService: NSObject, URLSessionDelegate {\n    // Pre-calculated SHA-256 hash of the server's public key (SPKI)\n    let pinnedKeyHash = \"base64EncodedSHA256HashOfPublicKey==\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Ensure it's a server trust challenge\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        // Get the public key from the server's certificate\n        if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0),\n           let serverPublicKey = SecCertificateCopyKey(serverCertificate),\n           let serverPublicKeyData = SecKeyCopyExternalRepresentation(serverPublicKey, nil) as Data? {\n            \n            // Hash the server's public key\n            let serverHash = sha256(data: serverPublicKeyData)\n\n            // Compare with our pinned hash\n            if serverHash == pinnedKeyHash {\n                // Success: The key matches our pin.\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                return\n            }\n        }\n        \n        // Failure: Key does not match. Reject the connection.\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n    \n    private func sha256(data: Data) -> String {\n        // Hashing logic using CryptoKit or CommonCrypto...\n        return \"...\"\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **No Backup Pin:** Failing to pin a backup public key. If the primary key is compromised, you cannot update the app to trust a new key, effectively bricking it.\n*   **Poor Key Rotation:** Not coordinating server certificate renewals with app releases, causing older app versions to fail.\n*   **Forgetting Third Parties:** Pinning can break network calls made by third-party SDKs that don't use your configured `URLSession`.\n\n**When to Use:** Use for high-security apps (banking, health) where MITM risk is high. For most other apps, relying on the OS's default trust evaluation and Certificate Transparency is often sufficient and avoids the operational complexity.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "URLSession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "How do HTTP/2 and HTTP/3 change network request patterns in iOS apps compared to HTTP/1.1, and what `URLSession` considerations are involved in leveraging them?",
      "back": "HTTP/2 and HTTP/3 fundamentally improve performance by addressing the limitations of HTTP/1.1, which required multiple TCP connections for concurrency, leading to slow starts and head-of-line blocking.\n\n**Core Concept:**\n*   **HTTP/1.1:** Sends requests sequentially over separate TCP connections (browsers typically open ~6 per domain). If one request is slow, it blocks others on the same connection (Head-of-Line blocking).\n*   **HTTP/2:** Introduces multiplexing, allowing multiple requests and responses to be interleaved over a single TCP connection. This eliminates the need for multiple connections to a single host and resolves the HTTP-level HOL blocking. It also uses HPACK for efficient header compression.\n*   **HTTP/3:** Goes a step further by replacing TCP with QUIC, a transport protocol built on UDP. This solves the TCP-level head-of-line blocking problem. If one packet is lost in a TCP stream, the entire stream must wait for retransmission. With QUIC, only the affected stream is paused. It also features 0-RTT connection setup and seamless connection migration (e.g., switching from Wi-Fi to Cellular without dropping the connection).\n\n**Practical Code Example:**\nFor an iOS developer, `URLSession` abstracts away most of the complexity. HTTP/2 is the default for `URLSession.shared` and `URLSessionConfiguration.default` since iOS 9, and HTTP/3 support is being progressively rolled out. You benefit automatically if the server supports it.\n\n```swift\n// No special code is needed to enable HTTP/2 or HTTP/3.\n// URLSession negotiates the best protocol supported by the server.\nlet config = URLSessionConfiguration.default\n\n// For demonstration: you *could* disable HTTP/2 by disallowing cellular access\n// on older systems, but there's no direct 'disable H2' flag.\n// The main point is that the default configuration is already optimized.\n\nlet session = URLSession(configuration: config)\nlet url = URL(string: \"https://api.your-modern-service.com/data\")!\n\n// Your request code remains unchanged. The performance gains are at the transport layer.\nlet task = session.dataTask(with: url) { data, response, error in\n    guard let httpResponse = response as? HTTPURLResponse, error == nil else {\n        // Handle error\n        return\n    }\n    // You can't directly check the protocol version easily from the response object.\n    // Verification is typically done with network analysis tools like Wireshark or server logs.\n    print(\"Request finished with status code: \\(httpResponse.statusCode)\")\n}\ntask.resume()\n```\n\n**Common Pitfalls:**\n*   **Anti-Patterns:** Techniques like \"domain sharding\" (using cdn1.domain.com, cdn2.domain.com) were workarounds for HTTP/1.1's connection limit. This is an anti-pattern for HTTP/2 and HTTP/3, as it prevents connection reuse and multiplexing benefits.\n*   **TCP Head-of-Line Blocking:** Misunderstanding that HTTP/2 solves *all* HOL blocking. It solves it at the application layer, but TCP's transport-layer HOL blocking remains, which is what HTTP/3/QUIC addresses.\n*   **Network Environment:** Corporate firewalls or proxies might block UDP traffic, causing HTTP/3 to fail and fall back to HTTP/2 over TCP.\n\n**When to Use vs. Alternatives:**\nYou don't \"choose\" a protocol in your app's code. `URLSession` handles the negotiation. The key is ensuring your backend infrastructure supports modern protocols. For a senior developer, this means advocating for server upgrades to HTTP/2 and eventually HTTP/3 to improve app performance, especially for asset-heavy applications or those used in variable network conditions.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "urlsession",
        "performance"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "Your app needs to download large files in the background, handle custom server authentication, and mock network responses for testing. How would you architect this using `URLSession`, and which specific delegate methods and configuration settings are critical?",
      "back": "For a robust networking layer handling these requirements, you'd leverage the advanced, delegate-based customization of `URLSession`.\n\n**Core Concept Explanation:**\n\n1.  **Background Downloads:** Use a `URLSessionConfiguration.background(withIdentifier:)`. This configuration creates a session that runs in a separate process, allowing downloads to continue even if the app is suspended or terminated. It's crucial to use the delegate pattern here, as completion handlers are not supported for background tasks. The system will relaunch your app in the background to call delegate methods like `urlSession(_:downloadTask:didFinishDownloadingTo:)`.\n\n2.  **Custom Authentication:** To handle custom server authentication (like client certificate challenges or custom credential logic), you must implement the `URLSessionTaskDelegate` protocol. The key method is `urlSession(_:task:didReceive:completionHandler:)`. This delegate method is invoked when the server requests authentication, allowing you to provide credentials or evaluate the server's trust.\n\n3.  **Mocking for Tests:** The most powerful way to mock network responses transparently is by subclassing `URLProtocol`. You can register your custom protocol class with a `URLSessionConfiguration`. This allows you to intercept outgoing requests, prevent them from hitting the network, and return fabricated `URLResponse` and `Data` objects, which is invaluable for unit and UI testing.\n\n**Practical Code Example:**\n\n```swift\nclass NetworkManager: NSObject, URLSessionTaskDelegate, URLSessionDownloadDelegate {\n    lazy var backgroundSession: URLSession = {\n        // 1. Background Configuration\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundDownloader\")\n        config.waitsForConnectivity = true // Good practice for large files\n        config.protocolClasses = [MockURLProtocol.self] // 3. Registering mock protocol\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    // 2. Custom Authentication Handling\n    func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Example: Trusting a specific self-signed certificate\n        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {\n            if let serverTrust = challenge.protectionSpace.serverTrust {\n                // In a real app, you would perform proper certificate pinning/validation here.\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                return\n            }\n        }\n        completionHandler(.performDefaultHandling, nil)\n    }\n\n    // Delegate method for background download completion\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move file from temporary location to a permanent one\n        print(\"Download finished, file at: \\(location)\")\n    }\n    \n    // Remember to handle other required delegate methods...\n}\n```\n\n**Common Pitfalls:**\n\n*   **Retain Cycles:** The `URLSession` maintains a strong reference to its delegate. If the delegate (e.g., `NetworkManager`) also holds a strong reference to the session, a retain cycle is created. You must explicitly invalidate the session (e.g., `session.finishTasksAndInvalidate()`) when the manager is deallocated.\n*   **Background Session Misconfiguration:** Background sessions *must* have a delegate. Attempting to use them with completion handlers or async/await `data(for:)` methods will fail.\n*   **`URLProtocol` Caching:** Be careful to disable `URLProtocol` registration in production builds to avoid accidentally serving mock data to users.\n\n**When to Use vs. Alternatives:**\n\n*   **Delegates vs. Async/Await:** Use async/await for simple, one-off requests where you don't need fine-grained control. Use the delegate pattern for background tasks, streaming data, progress tracking, or handling complex authentication/redirect logic across many tasks.\n*   **`URLProtocol` vs. Dependency Injection:** For unit testing, injecting a mock network service protocol can be simpler. `URLProtocol` is better for integration or UI tests where you want to mock the entire network stack transparently without modifying the application code.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "concurrency",
        "architecture",
        "testing"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Your app needs to download a large file (e.g., 1GB) that must continue even if the user backgrounds the app or the system terminates it. How would you architect this, and what are the critical delegate methods to handle the process?",
      "back": "For transfers that must survive app termination, a background `URLSession` is essential. Unlike standard sessions, which are tied to the app's process, a background session hands off the transfer management to a separate system daemon (`nsurlsessiond`).\n\n**Core Concept:**\nYou create the session using `URLSessionConfiguration.background(withIdentifier:)`. The unique identifier is critical; it's how the system tracks your tasks and how your app, upon relaunch, can reconnect to the same session to receive events. Background sessions require the delegate pattern; you cannot use completion handlers or `async/await` to create tasks.\n\nWhen a task finishes or requires authentication, the system relaunches your app in the background and calls `application(_:handleEventsForBackgroundURLSession:completionHandler:)` in your `AppDelegate`. You must capture this completion handler and call it later.\n\n**Code Example:**\n```swift\n// In AppDelegate.swift\nvar backgroundCompletionHandler: (() -> Void)?\n\nfunc application(_ app: UIApplication, handleEventsForBackgroundURLSession id: String, completionHandler: @escaping () -> Void) {\n    // Store the handler. It must be called later.\n    self.backgroundCompletionHandler = completionHandler\n}\n\n// In your networking layer (as a delegate)\nclass NetworkManager: NSObject, URLSessionDownloadDelegate {\n    lazy var backgroundSession: URLSession = {\n        // The identifier MUST be unique and the same across app launches.\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.bgtask\")\n        config.isDiscretionary = true // Let the system optimize for performance/battery.\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    func startBackgroundDownload() {\n        let url = URL(string: \"https://example.com/largefile.zip\")!\n        backgroundSession.downloadTask(with: url).resume()\n    }\n\n    // 1. Called when the download task finishes.\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move the temporary file at `location` to a permanent location.\n        print(\"File downloaded to: \\(location)\")\n    }\n\n    // 2. Called when all events for the session have been delivered.\n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        DispatchQueue.main.async {\n            guard let appDelegate = UIApplication.shared.delegate as? AppDelegate,\n                  let handler = appDelegate.backgroundCompletionHandler else { return }\n            appDelegate.backgroundCompletionHandler = nil\n            handler() // Signal to the OS that our app has finished handling events.\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting the Completion Handler:** You *must* eventually call the completion handler from `handleEventsForBackgroundURLSession`. The ideal place is in `urlSessionDidFinishEvents`. Forgetting this tells the OS you're still processing, which can lead to your app being penalized or terminated.\n- **Recreating the Session:** Upon relaunch, you must re-initialize the `URLSession` with the *exact same* identifier to receive delegate callbacks for the ongoing tasks.\n- **UI Updates:** The app is launched in the background, so you cannot perform UI updates. Use local notifications to alert the user of completion.\n\n**When to Use vs. Alternatives:**\n- **Background Session:** For large, critical transfers that must survive app termination.\n- **Standard `URLSession`:** For all in-app network requests. Simpler API (supports `async/await`).\n- **`beginBackgroundTask`:** For short-running tasks (e.g., finishing an upload) that need a few extra seconds to complete after the app is backgrounded. It does not survive app termination.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "background-tasks",
        "concurrency",
        "appdelegate"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "A new project has rapidly evolving client-side data needs and multiple client platforms. Justify your choice between REST and GraphQL for its API architecture, highlighting the trade-offs for an iOS client.",
      "back": "REST (Representational State Transfer) is an architectural style where clients interact with resources via unique URLs and standard HTTP verbs (GET, POST, etc.). Each endpoint returns a fixed data structure, which often leads to two problems for mobile clients:\n1.  **Over-fetching:** The endpoint returns more data than the UI needs, wasting bandwidth.\n2.  **Under-fetching:** The endpoint doesn't return enough data, forcing the client to make multiple API calls to build a single screen, increasing latency.\n\nGraphQL is a query language for APIs. It exposes a single endpoint and a strongly-typed schema describing the data model. The client sends a query specifying the exact fields it needs, and the server responds with a JSON object matching that structure. This solves over/under-fetching by empowering the client to shape the data response.\n\n**Practical Code Example:**\nFetching a user's name and their post titles.\n\n```swift\n// --- REST Approach (Under-fetching) ---\n// 1. Fetch user data\nlet userURL = URL(string: \"https://api.example.com/v1/users/123\")!\nlet (userData, _) = try await URLSession.shared.data(from: userURL)\n\n// 2. Fetch user's posts after the first call completes\nlet postsURL = URL(string: \"https://api.example.com/v1/users/123/posts\")!\nlet (postsData, _) = try await URLSession.shared.data(from: postsURL)\n// Requires two separate network round trips.\n\n// --- GraphQL Approach (Single Request) ---\nlet graphqlURL = URL(string: \"https://api.example.com/graphql\")!\nvar request = URLRequest(url: graphqlURL)\nrequest.httpMethod = \"POST\"\nrequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\nlet query = \"\"\"\n{ \"query\": \"query { user(id: \\\"123\\\") { name posts { title } } }\" }\n\"\"\"\nrequest.httpBody = query.data(using: .utf8)\nlet (data, _) = try await URLSession.shared.data(for: request)\n// Gets all required data in one trip.\n```\n\n**Common Pitfalls & Edge Cases:**\n-   **Caching:** REST leverages standard HTTP caching via URLs and headers. GraphQL's single-endpoint POST model makes this difficult, often requiring sophisticated client-side normalized caching libraries (e.g., Apollo).\n-   **Error Handling:** REST uses HTTP status codes (404 Not Found, 500 Server Error). GraphQL typically returns a 200 OK even if there are errors, embedding them in an `errors` array in the JSON response, which requires special client parsing.\n-   **Server Complexity:** GraphQL can hide server complexity. A seemingly simple query could trigger expensive database joins (the N+1 problem), which must be mitigated on the backend using techniques like data loaders.\n\n**When to Use vs. Alternatives:**\n-   **Choose REST** for simple, resource-centric APIs, when HTTP caching is a priority, or for public APIs where ease of use is paramount.\n-   **Choose GraphQL** for applications with complex, interconnected data and evolving UI requirements. It's ideal for mobile clients to minimize network latency and payload size, and allows front-end teams to iterate faster without waiting for new backend endpoints.",
      "code_example": null,
      "tags": [
        "networking",
        "api",
        "rest",
        "graphql",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}