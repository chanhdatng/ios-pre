{
  "topic": "networking",
  "generated_at": "2026-01-18T04:17:57.524031+00:00",
  "cards": [
    {
      "id": "networking_af7f793e90df",
      "front": "How would you implement a large file download using `URLSession` that continues after the app is backgrounded? Describe the key components, delegate methods, and the process for reconnecting to the session when the app relaunches.",
      "back": "To implement resilient, large file downloads, you must use a background `URLSession`. The OS's `nsurlsessiond` daemon takes over the transfer, allowing it to continue even if your app is suspended or terminated. This requires a specific setup.\n\n**Core Concept:**\nThe key is `URLSessionConfiguration.background(withIdentifier:)`. This identifier is a unique string that allows your app to find and reconnect to the session later. Background sessions *require* the use of delegates; completion handler-based APIs are not supported for these tasks.\n\nThe flow is:\n1.  Create a `URLSession` with a background configuration and a delegate.\n2.  Initiate a `URLSessionDownloadTask`.\n3.  If the app is terminated and relaunched by the OS upon task completion, the `AppDelegate`'s `application(_:handleEventsForBackgroundURLSession:completionHandler:)` is called.\n4.  Inside this method, you must re-create the `URLSession` with the *exact same identifier* to receive the pending delegate events.\n5.  The `completionHandler` provided by the system must be stored and called after all events for that session have been delivered (in `urlSessionDidFinishEvents(forBackgroundURLSession:)`).\n\n**Code Example:**\n```swift\n// In your networking service\nclass Downloader: NSObject, URLSessionDownloadDelegate {\n    private lazy var session: URLSession = {\n        // The identifier MUST be unique to your app.\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundDownloader\")\n        config.isDiscretionary = true // Allows OS to optimize for performance, etc.\n        config.sessionSendsLaunchEvents = true\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    func startDownload(url: URL) {\n        let task = session.downloadTask(with: url)\n        task.resume()\n    }\n\n    // Delegate method for completion\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move the file from the temporary location to a permanent one.\n        // The file at `location` will be deleted after this method returns.\n    }\n\n    // Delegate method for handling all events for the session\n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        // Call the saved completion handler from AppDelegate\n        DispatchQueue.main.async {\n            AppDelegate.shared.backgroundCompletionHandler?()\n            AppDelegate.shared.backgroundCompletionHandler = nil\n        }\n    }\n}\n\n// In your AppDelegate\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    static let shared = UIApplication.shared.delegate as! AppDelegate\n    var backgroundCompletionHandler: (() -> Void)?\n\n    func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n        // Store the handler to be called when all events are processed.\n        self.backgroundCompletionHandler = completionHandler\n        // You might also need to re-instantiate your Downloader here if it's not a singleton.\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting the `completionHandler`:** Failing to eventually call the system-provided `completionHandler` can lead to your app being penalized by the OS for background activity.\n- **Using a non-unique identifier:** This can cause conflicts and unpredictable behavior.\n- **Not moving the file:** The downloaded file is in a temporary location. You *must* move or copy it before `didFinishDownloadingTo` returns, or it will be deleted.\n- **Using completion blocks:** Background sessions do not support completion handlers on tasks. You must use the delegate pattern.\n\n**When to Use vs. Alternatives:**\n- **Use Background Session:** For long-running, non-urgent transfers of large data (e.g., offline maps, video episodes) that should be resilient to app termination.\n- **Alternative (Standard Task):** For foreground, user-initiated requests where immediate feedback is needed. Use Swift Concurrency (`async/await`) for simpler code.\n- **Alternative (Finite-Length Task):** Use `UIApplication.beginBackgroundTask` for short, critical tasks (<30s) that must complete before the app is fully suspended, not for large downloads.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "background-tasks",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Compare and contrast REST and GraphQL from an iOS client perspective. What are the key architectural trade-offs you'd consider when choosing one for a new project?",
      "back": "REST (REpresentational State Transfer) is an architectural style where the client interacts with resource-based URLs (e.g., `/users/123/posts`) using standard HTTP verbs. Each endpoint returns a predefined, static data structure. This simplicity is its strength but can lead to inefficiencies. An iOS app might need to call multiple endpoints to build a single screen (under-fetching) or receive large JSON payloads with unused fields (over-fetching), wasting bandwidth and battery.\n\nGraphQL is a query language for your API. It exposes a single endpoint (e.g., `/graphql`). The client sends a POST request with a query specifying the exact data fields and relationships it needs. This empowers the client to fetch all required data in one round trip, solving the over/under-fetching problem and improving performance on mobile networks.\n\n**Practical Example:**\nFetching a user's name and their post titles.\n\n```swift\n// --- REST Approach (Multiple Requests) ---\n// 1. Fetch user\nlet userURL = URL(string: \"/api/users/1\")! \n// ... URLSession call to get user object with all fields (id, name, email, etc.)\n\n// 2. Fetch user's posts\nlet postsURL = URL(string: \"/api/users/1/posts\")!\n// ... another URLSession call to get an array of post objects\n\n// --- GraphQL Approach (Single Request) ---\nlet graphqlEndpoint = URL(string: \"/graphql\")!\nvar request = URLRequest(url: graphqlEndpoint)\nrequest.httpMethod = \"POST\"\nrequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n\nlet query = \"\"\"\nquery GetUserAndPosts {\n  user(id: \"1\") {\n    name\n    posts {\n      title\n    }\n  }\n}\n\"\"\"\n\nlet body: [String: Any] = [\"query\": query]\nrequest.httpBody = try? JSONSerialization.data(withJSONObject: body)\n\n// ... a single URLSession call gets exactly the data needed\n```\n\n**Common Pitfalls & Trade-offs:**\n*   **Caching:** REST leverages standard HTTP caching out-of-the-box (ETags, Cache-Control), which is simple and effective. GraphQL's single POST endpoint makes HTTP caching difficult, often requiring sophisticated client-side caching libraries (like Apollo iOS) to manage a normalized cache.\n*   **Complexity:** REST is conceptually simpler to implement initially. GraphQL requires a schema definition on the server and more setup on the client to build queries. However, this upfront investment simplifies client-side data fetching logic long-term.\n*   **Error Handling:** REST uses HTTP status codes to indicate success or failure. GraphQL typically returns a 200 OK status even if there are errors, embedding an `errors` array within the JSON response, which requires custom client-side parsing.\n\n**When to Use:**\n*   **REST:** Best for simple, resource-oriented APIs, public APIs where HTTP caching is a major benefit, or in microservice architectures where each service exposes a clear set of resources.\n*   **GraphQL:** Ideal for complex apps with interconnected data, mobile clients where minimizing network requests is critical, and when multiple clients (iOS, Web) have different data requirements from the same backend.",
      "code_example": null,
      "tags": [
        "networking",
        "api",
        "rest",
        "graphql",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Architecting a feature with real-time, bidirectional communication, what are the key challenges in implementing and maintaining a robust WebSocket connection using `URLSessionWebSocketTask`, and how do you address them?",
      "back": "Implementing a robust WebSocket connection using `URLSessionWebSocketTask` goes beyond simply opening a connection. The primary challenges are maintaining its state through the app and network lifecycle.\n\n**Core Concept:**\nWebSockets provide a persistent, full-duplex communication channel over a single TCP connection, ideal for low-latency, real-time features like chat or live data feeds. `URLSessionWebSocketTask`, introduced in iOS 13, is Apple's native API for this, integrating seamlessly with the `URLSession` ecosystem.\n\n**Practical Code Example:**\n```swift\nclass WebSocketManager: NSObject, URLSessionWebSocketDelegate {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private var session: URLSession!\n\n    override init() {\n        super.init()\n        // Use a delegate queue to handle callbacks off the main thread.\n        session = URLSession(configuration: .default, delegate: self, delegateQueue: OperationQueue())\n    }\n\n    func connect(url: URL) {\n        webSocketTask = session.webSocketTask(with: url)\n        webSocketTask?.resume()\n        listen()\n    }\n\n    private func listen() {\n        webSocketTask?.receive { [weak self] result in\n            switch result {\n            case .failure(let error):\n                print(\"WebSocket receive error: \\(error)\")\n                // Implement reconnection logic here\n            case .success(let message):\n                self?.handleMessage(message)\n                self?.listen() // Recursive call to continue listening\n            }\n        }\n    }\n\n    private func handleMessage(_ message: URLSessionWebSocketTask.Message) {\n        // Process incoming message (e.g., decode JSON)\n        // and dispatch UI updates to the main queue.\n        DispatchQueue.main.async {\n            // Update UI\n        }\n    }\n\n    func send(data: Data) {\n        webSocketTask?.send(.data(data)) { error in\n            if let error = error {\n                print(\"WebSocket send error: \\(error)\")\n            }\n        }\n    }\n    \n    // Required delegate method for pings\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?) {\n        print(\"WebSocket connected\")\n    }\n\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?) {\n        print(\"WebSocket disconnected\")\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Lifecycle Management:** The app going to the background or foreground requires handling the connection. A common strategy is to disconnect on backgrounding and reconnect on foregrounding to conserve resources. Use `NotificationCenter` to observe `UIApplication.willResignActiveNotification` and `UIApplication.didBecomeActiveNotification`.\n2.  **Reconnection Strategy:** Naively retrying to connect on failure can spam the server and drain battery. Implement an exponential backoff algorithm (e.g., retry after 1s, 2s, 4s...) with jitter to prevent thundering herd problems.\n3.  **Keep-Alive:** Network intermediaries (NATs, firewalls) can drop idle connections. Use `webSocketTask.sendPing` periodically (e.g., every 30 seconds) to ensure the connection remains active and to detect a dead connection faster than standard TCP timeouts.\n4.  **Thread Safety:** `URLSession` callbacks occur on a background delegate queue. All state mutations within your manager should be synchronized (e.g., using a serial dispatch queue), and any UI updates must be dispatched to `DispatchQueue.main`.\n\n**When to Use vs. Alternatives:**\n-   **WebSockets:** Best for true, low-latency, bidirectional communication (chat, real-time gaming, collaborative editing).\n-   **Server-Sent Events (SSE):** A simpler, HTTP-based alternative for unidirectional server-to-client data pushes (live news feeds, stock tickers). Not suitable when the client needs to send frequent messages.\n-   **HTTP Long Polling:** A fallback for environments where WebSockets are blocked. It's less efficient due to connection setup overhead for each message from the server.\n-   **Push Notifications (APNs):** For delivering critical, infrequent updates, especially when the app is in the background. Not a substitute for in-app real-time communication.",
      "code_example": null,
      "tags": [
        "networking",
        "websocket",
        "URLSession",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "How would you design a scalable, testable, and maintainable networking layer for a modern iOS application? Describe the key components and their responsibilities.",
      "back": "For a scalable and testable networking layer, I would implement a multi-layered architecture based on the principle of Separation of Concerns, making heavy use of protocols and dependency injection.\n\n**Core Concept Explanation:**\nThe architecture consists of several distinct components:\n1.  **Endpoint Definition:** A protocol or enum (e.g., `Endpoint`) defines the contract for an API request. It specifies the `path`, `httpMethod`, `headers`, and `parameters`. This approach makes adding new endpoints type-safe and self-contained.\n2.  **Network Service (Executor):** A generic class responsible for executing requests. It takes an `Endpoint` object, constructs a `URLRequest`, uses a `URLSession` to perform the request, handles generic response validation (like checking status codes), and decodes the data into a generic `Decodable` type. It depends on a `URLSession` protocol, not a concrete instance, for testability.\n3.  **API Client (Feature-Specific):** This layer provides a clean, domain-specific interface for the rest of the app (e.g., ViewModels or Interactors). For example, a `UserClient` would have a method like `fetchUserProfile(id: String) async throws -> User`. It uses the generic Network Service to perform the actual network call, mapping specific methods to specific `Endpoint` definitions.\n\nThis design ensures that ViewModels don't know about `URLRequest` or JSON decoding, the Network Service doesn't know about specific user or product endpoints, and the entire stack can be easily mocked for unit testing.\n\n**Practical Code Example:**\n```swift\n// 1. Endpoint Definition\nprotocol Endpoint {\n    var path: String { get }\n    var method: String { get }\n    // ... headers, body, etc.\n}\n\n// 2. Generic Network Service\nactor NetworkService {\n    private let session: URLSession\n\n    init(session: URLSession = .shared) {\n        self.session = session\n    }\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        let url = URL(string: \"https://api.example.com\" + endpoint.path)!\n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method\n\n        let (data, response) = try await session.data(for: request)\n        guard let httpResponse = response as? HTTPURLResponse, \n              (200...299).contains(httpResponse.statusCode) else {\n            throw URLError(.badServerResponse)\n        }\n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n\n// 3. API Client for a specific feature\nstruct UserClient {\n    private let networkService: NetworkService\n    init(networkService: NetworkService) { self.networkService = networkService }\n    \n    private enum UserEndpoint: Endpoint { /* ... cases for fetch, update, etc. */ \n        case fetch(id: String)\n        var path: String { /* ... */ return \"/users/\\(id)\" }\n        var method: String { \"GET\" }\n    }\n\n    func fetchUser(id: String) async throws -> User {\n        return try await networkService.request(endpoint: UserEndpoint.fetch(id: id))\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n*   **The God Object:** Creating a single massive `APIManager` that handles all network requests for the entire app. This violates the Single Responsibility Principle and becomes a bottleneck for development.\n*   **Direct URLSession Usage:** Calling `URLSession.shared.dataTask` directly within ViewModels or ViewControllers. This tightly couples the UI layer to networking implementation, making it nearly impossible to unit test.\n*   **Inadequate Error Handling:** Not defining a clear, custom error model to represent different failure states (e.g., decoding errors, server errors, no connection), leading to poor user experience.\n\n**When to use vs Alternatives:**\nThis layered approach is ideal for medium-to-large scale applications with multiple features and endpoints. For a very simple app with only one or two API calls, it might be overkill, and a simpler service class could suffice. However, establishing this pattern early scales well. For GraphQL APIs, using a dedicated client like Apollo is preferable, though the principle of abstracting the client behind a repository or service layer remains the same.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "design patterns",
        "async-await",
        "testing"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Your app makes numerous small, concurrent API calls, causing network latency. Explain how migrating from HTTP/1.1 to HTTP/2 and HTTP/3 would address this, detailing the key differences and implications for an iOS client.",
      "back": "The core issue with HTTP/1.1 for numerous small requests is **Head-of-Line (HOL) blocking**. Each TCP connection can only handle one request/response at a time. To achieve parallelism, clients open multiple connections (e.g., 6 per host), which is inefficient due to the overhead of TCP handshakes.\n\n**HTTP/2** addresses this directly with **multiplexing**. It allows multiple requests and responses to be interleaved as binary frames over a single TCP connection. This eliminates the HTTP-layer HOL blocking, drastically reducing latency for applications with many parallel requests. For iOS clients using `URLSession`, this is a transparent upgrade; if the server supports HTTP/2, `URLSession` will automatically negotiate and use it without any code changes.\n\n**HTTP/3** evolves this further by tackling the **TCP-level HOL blocking** that still affects HTTP/2. In HTTP/2, if a single TCP packet is lost, the entire connection stalls while waiting for retransmission, blocking all multiplexed streams. HTTP/3 replaces TCP with a new transport protocol called **QUIC**, which runs over UDP. QUIC's streams are independent; a lost packet for one stream does not block others. This is a massive advantage on unreliable mobile networks. It also offers faster connection setup (0-RTT).\n\n```swift\n// On the client-side, URLSession abstracts away the protocol details.\n// This code works seamlessly with HTTP/1.1, HTTP/2, and HTTP/3 servers.\nfunc fetchData() {\n    let url = URL(string: \"https://api.your-modern-server.com/items\")!\n\n    let task = URLSession.shared.dataTask(with: url) { data, response, error in\n        // The magic happens under the hood. URLSession negotiates the best\n        // available protocol (HTTP/3 > HTTP/2 > HTTP/1.1) with the server.\n        // There is no public API to directly check the protocol version used.\n        // Verification requires network inspection tools like Charles or Proxyman.\n        if let httpResponse = response as? HTTPURLResponse {\n            print(\"Received response with status: \\(httpResponse.statusCode)\")\n        }\n    }\n    task.resume()\n}\n```\n\n**Common Pitfalls:**\n- **Thinking client code needs to change:** The primary work is on the server. `URLSession` handles the client-side negotiation automatically.\n- **Ignoring network intermediaries:** Corporate firewalls or proxies might block UDP traffic, preventing HTTP/3 from working and forcing a fallback to HTTP/2 over TCP.\n- **Applying HTTP/1.1 optimizations:** Techniques like domain sharding or asset bundling are anti-patterns for HTTP/2 and HTTP/3, as they interfere with multiplexing's benefits.\n\n**When to Use:** The benefits are most significant for apps with many small, concurrent asset or API requests (e.g., microservice architectures, image-heavy feeds). HTTP/3 provides the most robust performance, especially on mobile networks prone to packet loss.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "performance",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Certificate pinning",
      "back": "",
      "code_example": null,
      "tags": [
        "Certificate pinning"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Explain the lifecycle of a background `URLSessionTask`. How does the system manage it when the app is suspended or terminated, and how does your app regain control to handle the results?",
      "back": "A background `URLSession` is configured with `URLSessionConfiguration.background(withIdentifier:)`. This identifier is crucial for the system to associate transfer tasks with your app.\n\n**Core Concept:**\nWhen a task is initiated with a background session, the networking is handed off to a system daemon (`nsurlsessiond`). This daemon manages the transfer independently of your app's lifecycle. It continues even if the app is suspended, terminated by the user, or crashes.\n\nUpon task completion (or if authentication is required), the system wakes up or relaunches your app into the background. It then calls the `application(_:handleEventsForBackgroundURLSession:completionHandler:)` method in your `AppDelegate`. Inside this method, you must store the provided `completionHandler` and re-create the `URLSession` with the same identifier to reconnect to the now-completed tasks. The session's delegate methods (e.g., `urlSession(_:downloadTask:didFinishDownloadingTo:)`) will then be called, allowing you to process the results. Finally, you must call the stored `completionHandler` within `urlSessionDidFinishEvents(forBackgroundURLSession:)` to signal to the OS that you've finished handling all events for that session.\n\n**Practical Code Example:**\n```swift\n// 1. In your AppDelegate\nvar backgroundSessionCompletionHandler: (() -> Void)?\n\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the handler. It must be called when all events are processed.\n    self.backgroundSessionCompletionHandler = completionHandler\n}\n\n// 2. In your networking layer (e.g., a singleton NetworkManager)\nprivate lazy var backgroundSession: URLSession = {\n    // The identifier MUST match the one you check in the AppDelegate.\n    let config = URLSessionConfiguration.background(withIdentifier: \"com.yourapp.background.transfer\")\n    // Recommended for timely event delivery.\n    config.isDiscretionary = false \n    config.sessionSendsLaunchEvents = true\n    // The delegate receives callbacks, even after app relaunch.\n    return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n}()\n\n// 3. In your URLSessionDelegate conformance\nfunc urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    DispatchQueue.main.async {\n        guard let appDelegate = UIApplication.shared.delegate as? AppDelegate,\n              let handler = appDelegate.backgroundSessionCompletionHandler else {\n            return\n        }\n        // Call the completion handler to let the OS know you're done.\n        handler()\n        appDelegate.backgroundSessionCompletionHandler = nil\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting to call the `completionHandler`:** This can negatively impact your app's battery performance and prevent the OS from taking a new UI snapshot.\n- **Using completion blocks:** Background sessions do not support tasks created with completion handlers (e.g., `dataTask(with:completionHandler:)`). You *must* use the delegate pattern.\n- **Identifier mismatch:** The identifier used to create the session must be unique and consistently used when reconnecting in the `AppDelegate`.\n- **UI updates on background threads:** Delegate methods are not called on the main thread. All UI work must be dispatched back to `DispatchQueue.main`.\n\n**When to use vs. Alternatives:**\n- **Use Background Transfers:** For large, long-running downloads or uploads (e.g., videos, podcasts, backups) that are critical to complete regardless of the app's state.\n- **Use Standard `URLSession`:** For all typical, short-lived API calls that are only relevant while the app is in the foreground.\n- **Use `BackgroundTasks` Framework:** For deferrable, non-urgent work like database cleanup or pre-fetching content. It schedules work, but doesn't guarantee uninterrupted execution like a background `URLSession` does for transfers.",
      "code_example": null,
      "tags": [
        "networking",
        "background-modes",
        "URLSession",
        "app-lifecycle"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    }
  ]
}