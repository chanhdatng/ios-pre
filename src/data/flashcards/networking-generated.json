{
  "topic": "networking",
  "generated_at": "2026-01-19T04:22:05.538129+00:00",
  "cards": [
    {
      "id": "networking_af7f793e90df",
      "front": "How would you design a robust networking layer using URLSession to support features like background downloads, custom authentication, and request cancellation?",
      "back": "A robust networking layer moves beyond simple data tasks with completion handlers and leverages the full power of the `URLSession` delegate pattern. This provides fine-grained control over the entire networking process.\n\n**Core Concept:**\nThe key is to initialize a `URLSession` with a `URLSessionConfiguration` and a delegate. The configuration sets up behaviors like caching policies, timeouts, and background session capabilities. The delegate, an object conforming to protocols like `URLSessionTaskDelegate` and `URLSessionDataDelegate`, receives callbacks for events like authentication challenges, receiving data chunks, and task completion. Using a dedicated `delegateQueue` (an `OperationQueue`) ensures these callbacks don't block the main thread.\n\n**Code Example:**\n```swift\nclass NetworkManager: NSObject, URLSessionDelegate, URLSessionTaskDelegate {\n    private lazy var session: URLSession = {\n        // Use a background configuration for out-of-process downloads\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.downloader\")\n        config.isDiscretionary = true // Let the system optimize for performance\n        config.sessionSendsLaunchEvents = true\n        // Create a non-main operation queue for delegate callbacks\n        return URLSession(configuration: config, delegate: self, delegateQueue: OperationQueue())\n    }()\n\n    // Example: Initiate a download\n    func downloadFile(from url: URL) -> URLSessionDownloadTask {\n        let task = session.downloadTask(with: url)\n        task.resume()\n        return task // Return the task so it can be cancelled\n    }\n\n    // Delegate method for authentication challenges\n    func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Handle server trust, client certificates, or other auth\n        guard let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n        // In a real app, you would perform trust evaluation here\n        let credential = URLCredential(trust: serverTrust)\n        completionHandler(.useCredential, credential)\n    }\n    \n    deinit {\n        // Invalidate the session to break retain cycles and release resources\n        session.finishTasksAndInvalidate()\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Retain Cycles:** The `URLSession` maintains a strong reference to its delegate. If the delegate also holds a strong reference to the session, a retain cycle is created. Always invalidate the session (e.g., in `deinit`) by calling `finishTasksAndInvalidate()` or `invalidateAndCancel()` to break this cycle.\n- **Blocking the Delegate Queue:** Performing heavy processing within delegate methods on a serial delegate queue can bottleneck subsequent network events.\n- **Forgetting `completionHandler`:** Many delegate methods provide a `completionHandler` that *must* be called. Forgetting to do so can lead to stalled requests and resource leaks.\n\n**When to Use vs. Alternatives:**\n- **Delegate Pattern:** Use for complex needs: background transfers, streaming, custom authentication, certificate pinning, or precise progress tracking.\n- **Async/Await (`URLSession.shared.data(for:)`):** The modern default for simple requests in a Swift Concurrency context. It offers clean, linear code but abstracts away the fine-grained control of the delegate pattern.\n- **Completion Handlers (`dataTask(with:completionHandler:)`):** Good for simple, one-off requests when not using Swift Concurrency. Less control than delegates.",
      "code_example": null,
      "tags": [
        "Networking",
        "URLSession",
        "Concurrency",
        "Architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/16-swift/swift-functions/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Describe how you would design a scalable and testable network layer for a large-scale iOS application. What are the key components and their responsibilities?",
      "back": "A scalable network layer abstracts away the underlying networking mechanism (like URLSession) and separates concerns into distinct, testable components.\n\n**Core Concept Explanation:**\nThe goal is to create a layer that is decoupled from business logic (ViewModels, Interactors) and the UI. This is typically achieved with a protocol-oriented approach.\n\n1.  **Endpoint/Router:** This component (often a protocol and an enum) defines everything needed for a single API call: path, HTTP method, headers, and parameters. It centralizes all API contracts, making them easy to find and manage. It's responsible for constructing a `URLRequest`.\n\n2.  **Network Service:** A generic service class/struct that takes an `Endpoint`, executes the request, handles response validation (e.g., checking status codes), and decodes the data into a generic `Decodable` model. It depends on a protocol, not a concrete networking library, allowing for easy mocking.\n\n3.  **Model Layer:** Simple `Codable` structs that map directly to the JSON responses from the API.\n\n4.  **Error Handling:** A custom error enum to represent various failure scenarios like invalid URL, server errors (4xx, 5xx), decoding failures, or underlying network issues.\n\n**Practical Code Example:**\n```swift\n// 1. Endpoint Protocol and a concrete implementation\nprotocol Endpoint {\n    var path: String { get }\n    var method: String { get }\n    func asURLRequest() throws -> URLRequest\n}\n\nenum UserEndpoint: Endpoint {\n    case fetchUser(id: String)\n\n    var path: String { // ... build path ... }\n    var method: String { // ... return \"GET\" ... }\n\n    func asURLRequest() throws -> URLRequest { /* ... create request ... */ return URLRequest(url: URL(string: \"example.com\")!) }\n}\n\n// 2. Generic Network Service\nprotocol NetworkService {\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T\n}\n\nclass URLSessionNetworkService: NetworkService {\n    private let session: URLSession\n    private let decoder: JSONDecoder\n\n    init(session: URLSession = .shared, decoder: JSONDecoder = JSONDecoder()) {\n        self.session = session\n        self.decoder = decoder\n    }\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        let request = try endpoint.asURLRequest()\n        let (data, response) = try await session.data(for: request)\n        // ... add status code validation ...\n        return try decoder.decode(T.self, from: data)\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Tight Coupling:** Directly using `URLSession` or a library like Alamofire within ViewModels or Interactors. This makes unit testing difficult as you can't easily mock network calls.\n- **Stringly-Typed APIs:** Constructing URLs via string concatenation inside business logic. The Endpoint pattern prevents this by centralizing API definitions.\n- **Poor Error Handling:** Not distinguishing between network errors (no internet), server errors (500), and decoding errors. A proper error layer is crucial for providing useful feedback to the user.\n- **Ignoring Concurrency:** Not correctly managing threading, leading to UI updates on background threads or race conditions. Modern `async/await` and `@MainActor` greatly simplify this.\n\n**When to use vs Alternatives:**\nThis layered architecture is ideal for any app beyond a simple prototype. The upfront investment pays dividends in maintainability, testability, and scalability. For a very simple project, direct `URLSession` calls might suffice, but this approach isolates dependencies. Even when using a third-party library like Alamofire, it should be wrapped within this architecture, making the library an implementation detail that can be swapped out later.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "design patterns",
        "async-await",
        "testing"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "You must download a large file that continues even if the app is terminated. Detail the architecture using URLSession, including session setup, delegate responsibilities, and how the app handles completion after being relaunched by the system.",
      "back": "To handle transfers that persist after app termination, you must use a `URLSession` configured for background processing. This hands off the networking to a system daemon (`nsurlsessiond`), which manages the transfer independently of your app's lifecycle.\n\n**Core Concept:**\n1.  **Configuration:** Create a `URLSessionConfiguration.background(withIdentifier:)`. The identifier is crucial; it's used to reconnect to the same session if the app is relaunched.\n2.  **Delegate-only:** Background sessions *do not* support completion handlers or modern async/await methods like `data(for:)`. You must provide a delegate object that conforms to `URLSessionTaskDelegate` and `URLSessionDownloadDelegate`.\n3.  **App Relaunch:** When a task finishes or requires authentication while the app is terminated, the system relaunches the app in the background. \n4.  **Reconnection:** The `application(_:handleEventsForBackgroundURLSession:completionHandler:)` method in your `AppDelegate` is called. Here, you must recreate the `URLSession` with the *exact same identifier* to reconnect and receive delegate callbacks.\n\n**Code Example:**\n```swift\n// 1. Session creation (typically in a dedicated networking class)\nprivate lazy var backgroundSession: URLSession = {\n    // The identifier must be unique to your app.\n    let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundDownloader\")\n    config.isDiscretionary = true // Allows system to optimize for performance, e.g., wait for Wi-Fi\n    config.sessionSendsLaunchEvents = true\n    return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n}()\n\nfunc startBackgroundDownload() {\n    let url = URL(string: \"https://example.com/largefile.zip\")!\n    let downloadTask = backgroundSession.downloadTask(with: url)\n    downloadTask.resume()\n}\n\n// 2. AppDelegate handling\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the completion handler to be called when all events are delivered.\n    backgroundCompletionHandler = completionHandler\n    // Re-establish connection to the session (if your networking class is a singleton).\n    MyNetworkManager.shared.backgroundSession \n}\n\n// 3. Delegate implementation\nextension MyNetworkManager: URLSessionDownloadDelegate {\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // The file at `location` is temporary. You MUST move it before this method returns.\n        let destinationURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(\"largefile.zip\")\n        try? FileManager.default.moveItem(at: location, to: destinationURL)\n        // Handle successful download (e.g., post a notification)\n    }\n}\n\nfunc urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    // This is called after all events for a session have been delivered.\n    DispatchQueue.main.async {\n        // Call the stored completion handler.\n        AppDelegate.shared.backgroundCompletionHandler?()\n        AppDelegate.shared.backgroundCompletionHandler = nil\n    }\n}\n```\n\n**Common Pitfalls:**\n-   **Not moving the temporary file:** The file at the `location` URL in `didFinishDownloadingTo` is deleted immediately after the delegate method returns. Failure to move or copy it results in data loss.\n-   **Identifier Mismatch:** Using a different identifier on app relaunch prevents reconnection to the in-progress session.\n-   **Forgetting the Completion Handler:** The system keeps your app alive in the background until you call the completion handler from `handleEventsForBackgroundURLSession`. Forgetting to call it drains the battery and may cause your app to be penalized by the system.\n\n**When to Use vs. Alternatives:**\n-   **Use Background Session:** For large, non-urgent transfers that must survive app suspension or termination (e.g., downloading video content, uploading backups).\n-   **Use Standard Session + `beginBackgroundTask`:** For important, short-lived tasks (<30s) that need to complete after the user backgrounds the app, but don't need to survive termination. This is simpler as it doesn't require the full delegate/relaunch dance.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "background-tasks",
        "concurrency",
        "appdelegate"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Describe the evolution from HTTP/1.1 to HTTP/2 and HTTP/3. How does `URLSession` leverage these newer protocols, and what are the practical implications for a senior developer when architecting an app's networking layer?",
      "back": "The evolution of HTTP addresses performance bottlenecks inherent in previous versions.\n\n**Core Concept Explanation:**\n\n*   **HTTP/1.1:** Suffers from Head-of-Line (HOL) blocking. It can only handle one request/response at a time per TCP connection. Browsers and clients mitigated this by opening multiple (usually 6) parallel connections to a single host, which is inefficient.\n\n*   **HTTP/2:** The primary goal was to improve performance by addressing HOL blocking. It introduces:\n    *   **Multiplexing:** A single TCP connection can handle multiple, concurrent request/response streams. This is the most significant change, eliminating the need for multiple connections.\n    *   **Binary Framing:** A more efficient and less error-prone protocol to parse compared to text-based HTTP/1.1.\n    *   **Header Compression (HPACK):** Reduces redundant data by compressing headers sent in multiple requests.\n\n*   **HTTP/3:** Further refines performance by changing the underlying transport protocol from TCP to QUIC (which runs over UDP).\n    *   **Eliminates TCP HOL Blocking:** In HTTP/2, if a single TCP packet is lost, the entire connection stalls until it's retransmitted, blocking all multiplexed streams. Because QUIC streams are independent at the transport layer, packet loss in one stream doesn't affect others.\n    *   **Faster Connection Setup:** QUIC integrates the TCP and TLS handshakes, reducing round-trips needed to establish a secure connection (often achieving 0-RTT).\n\n`URLSession` handles protocol negotiation automatically. If the server supports HTTP/3, it will be used. If not, it falls back to HTTP/2, and then to HTTP/1.1. As a developer, you get these benefits without changing your code.\n\n**Practical Code Example:**\n```swift\n// URLSession transparently handles protocol negotiation.\n// There is no special code required to \"enable\" HTTP/2 or HTTP/3.\n// If the server supports it, URLSession will use the best available protocol.\nguard let url = URL(string: \"https://api.apple.com\") else { return }\n\nlet task = URLSession.shared.dataTask(with: url) { data, response, error in\n    // The underlying transport details are abstracted away. We focus on the result.\n    // The performance gains are the primary indicator of a modern protocol being used.\n    guard let httpResponse = response as? HTTPURLResponse,\n          (200...299).contains(httpResponse.statusCode) else {\n        print(\"Network request failed: \\(error?.localizedDescription ?? \"Unknown error\")\")\n        return\n    }\n    // Process successful response data...\n    print(\"Successfully fetched data with status code: \\(httpResponse.statusCode)\")\n}\ntask.resume()\n```\n\n**Common Pitfalls & Architectural Implications:**\n\n*   **Anti-Patterns:** Techniques like \"domain sharding\" (e.g., `assets1.server.com`, `assets2.server.com`), used to bypass HTTP/1.1's connection limit, are harmful to HTTP/2 and HTTP/3 performance. They prevent connection reuse and header compression benefits. Consolidate resources to a single domain where possible.\n*   **Server-Side Dependency:** Your app can't use these protocols if the server doesn't support them. Performance issues might be server-side, not client-side.\n*   **Network Intermediaries:** Firewalls or proxies can sometimes block UDP traffic, preventing HTTP/3 from working and forcing a fallback to TCP-based HTTP/2, which can add latency to the initial connection.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "urlsession",
        "performance",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Architect a robust WebSocket client using `URLSessionWebSocketTask`. Detail its lifecycle management, message handling, and strategies for handling network interruptions and app backgrounding.",
      "back": "A robust WebSocket client architecture centers on `URLSessionWebSocketTask`, introduced in iOS 13, for handling the persistent, bidirectional connection. The core of the design is a state machine to manage the connection's lifecycle: `connecting`, `connected`, `disconnecting`, and `disconnected`.\n\n**Core Concept:** The implementation involves creating a `URLSessionWebSocketTask` from a `URLRequest`. Communication is handled via `task.send()` and a recurring `task.receive()` call. The `URLSessionDelegate` provides crucial callbacks like `urlSession(_:webSocketTask:didOpenWithProtocol:)` and `urlSession(_:webSocketTask:didCloseWith:reason:)` to transition the client's state.\n\n**Practical Code Example:**\n```swift\nclass WebSocketManager: NSObject, URLSessionWebSocketDelegate {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private var session: URLSession!\n\n    override init() {\n        super.init()\n        // Use a delegate queue to handle callbacks off the main thread\n        session = URLSession(configuration: .default, delegate: self, delegateQueue: OperationQueue())\n    }\n\n    func connect(url: URL) {\n        webSocketTask = session.webSocketTask(with: url)\n        listen() // Start listening for messages\n        webSocketTask?.resume() // Open the connection\n    }\n\n    private func listen() {\n        webSocketTask?.receive { [weak self] result in\n            switch result {\n            case .failure(let error):\n                print(\"WebSocket receive error: \\(error)\")\n                // Handle error and potential reconnection logic\n            case .success(let message):\n                // Handle incoming message (string or data)\n                print(\"Received message: \\(message)\")\n                self?.listen() // Re-register to listen for the next message\n            }\n        }\n    }\n\n    func send(message: String) {\n        webSocketTask?.send(.string(message)) { error in\n            if let error = error {\n                print(\"WebSocket send error: \\(error)\")\n            }\n        }\n    }\n\n    // MARK: - URLSessionWebSocketDelegate\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?) {\n        print(\"WebSocket connection opened.\")\n        // Connection is open, can now send periodic pings to keep it alive\n    }\n\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?) {\n        print(\"WebSocket connection closed: \\(closeCode)\")\n        // Connection is closed, trigger reconnection logic if needed\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Network Interruptions:** Don't attempt to reconnect immediately in a tight loop. Implement an exponential backoff with jitter strategy to avoid overwhelming the server and draining the battery.\n2.  **App Backgrounding:** `URLSessionWebSocketTask` does not support background execution. The system will tear down the connection when the app is backgrounded. You must listen for `UIApplication.willEnterForegroundNotification` to re-establish the connection.\n3.  **Silent Disconnects:** A TCP connection can drop without an immediate notification. Implement a heartbeat mechanism using `task.sendPing(pongReceiveHandler:)` every 30-60 seconds to detect a dead connection and trigger a reconnect.\n4.  **Message Listening:** The `receive` completion handler is called only once. You must call `receive` again inside the handler to create a persistent listener loop.\n\n**When to Use vs. Alternatives:**\n-   **Use WebSockets:** For true real-time, low-latency, bidirectional communication like chat apps, collaborative editing tools, or live multiplayer games.\n-   **Alternatives:**\n    -   **HTTP Long Polling:** Inefficient, higher latency, and more overhead. A fallback for environments where WebSockets are blocked.\n    -   **Server-Sent Events (SSE):** Simpler, but only for unidirectional server-to-client communication (e.g., live news feeds, stock tickers).\n    -   **APNs (Push Notifications):** For infrequent, low-priority updates or to wake the app. Not suitable for high-frequency, real-time data streams.",
      "code_example": null,
      "tags": [
        "networking",
        "websocket",
        "urlsession",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Discuss implementing certificate pinning in an iOS app. Cover your strategy for handling certificate rotation and the trade-offs between pinning a leaf certificate, an intermediate certificate, or a public key.",
      "back": "Certificate pinning is a security technique that hardcodes the server's X.509 certificate or, more commonly, its public key, into the client application. During the TLS handshake, the app compares the server's presented identity against this embedded 'pin'. If they don't match, the connection is terminated. This mitigates Man-in-the-Middle (MITM) attacks, even if a trusted Certificate Authority (CA) is compromised.\n\n**Implementation Strategy (`URLSessionDelegate`):**\nThe standard approach is to use the `urlSession(_:didReceive:completionHandler:)` delegate method. We extract the public key from the server's certificate, hash it (e.g., SHA-256), and compare it to a stored set of trusted key hashes.\n\n```swift\n// Assume self conforms to URLSessionDelegate\nlet pinnedKeyHashes: Set<String> = [\n    \"hpfSoE05vD8S/IdN3DOV2s2p2Lnk2zsoDvo0a33T/E0=\", // Primary key hash (base64)\n    \"k3d2+eI3p4V+vtef4pI5hlI0tQ2kT+2TBAZdcCAQCwE=\"  // Backup key hash\n]\n\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n    guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n          let serverTrust = challenge.protectionSpace.serverTrust,\n          SecTrustGetCertificateCount(serverTrust) > 0 else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n\n    // Get the leaf certificate's public key\n    guard let certificate = SecTrustGetCertificateAtIndex(serverTrust, 0),\n          let publicKey = SecCertificateCopyKey(certificate),\n          let publicKeyData = SecKeyCopyExternalRepresentation(publicKey, nil) as Data? else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n\n    // Hash the public key (SPKI) and Base64 encode it\n    let keyHash = sha256(data: publicKeyData).base64EncodedString()\n\n    // Check if the hash matches one of our pins\n    if pinnedKeyHashes.contains(keyHash) {\n        completionHandler(.useCredential, URLCredential(trust: serverTrust))\n    } else {\n        // Pin validation failed!\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n}\n\n// Helper to calculate SHA256 hash\nfunc sha256(data: Data) -> Data { ... }\n```\n\n**Trade-offs & Rotation:**\n*   **Leaf Certificate vs. Public Key:** Pinning the entire leaf certificate is brittle. When it expires (often annually), the app breaks. Pinning the public key is far more robust, as a new certificate can be issued using the same key pair, avoiding the need for an immediate app update.\n*   **Intermediate Certificate:** Pinning an intermediate CA is a middle ground. It's more flexible but less secure. If that CA is compromised or issues a certificate for your domain to an attacker, your pin is bypassed. It's generally not recommended for high-security applications.\n*   **Rotation Strategy:** This is the most critical part. A failed rotation strategy can 'brick' your app. The best practice is to pin the current key AND at least one backup key. When you need to rotate the server certificate, you use the backup key and ship a new app update that replaces the used key with a new backup. This provides an overlap period, ensuring users on the older app version continue to function.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "URLSession",
        "TLS"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Contrast REST and GraphQL from an iOS client's perspective. Discuss the architectural trade-offs regarding data fetching, state management, and caching you'd consider for a new project.",
      "back": "REST (REpresentational State Transfer) is an architectural style that uses standard HTTP methods and multiple endpoints to represent resources (e.g., `/users/123`). GraphQL is a query language for APIs that uses a single endpoint, allowing the client to specify the exact structure and data it needs in a single request.\n\n**Core Concept:**\nThe fundamental difference for an iOS client is the data fetching model. With REST, fetching a user and their posts might require two separate network calls, one to `/users/{id}` and another to `/users/{id}/posts`. This can lead to over-fetching (getting unused fields) or under-fetching (the N+1 problem, requiring more calls). GraphQL solves this by allowing the client to define its data needs in one query to a single endpoint, receiving a JSON response that mirrors the query's shape. This shifts the power of data shaping from the server to the client.\n\n**Practical Code Example:**\nFetching a user and their 10 most recent posts:\n\n```swift\n// --- REST Approach (Multiple Requests) ---\nfunc fetchUserAndPostsREST(userId: String) {\n    // 1. Fetch user\n    let userURL = URL(string: \"https://api.example.com/users/\\(userId)\")!\n    URLSession.shared.dataTask(with: userURL) { userData, _, _ in\n        // ... decode user ...\n        \n        // 2. Fetch user's posts\n        let postsURL = URL(string: \"https://api.example.com/users/\\(userId)/posts?limit=10\")!\n        URLSession.shared.dataTask(with: postsURL) { postsData, _, _ in\n            // ... decode posts and combine with user ...\n        }.resume()\n    }.resume()\n}\n\n// --- GraphQL Approach (Single Request) ---\nfunc fetchUserAndPostsGraphQL(userId: String) {\n    let endpoint = URL(string: \"https://api.example.com/graphql\")!\n    var request = URLRequest(url: endpoint)\n    request.httpMethod = \"POST\"\n    request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    \n    let query = \"\"\"\n    query GetUserAndPosts($id: ID!) {\n      user(id: $id) {\n        name\n        email\n        posts(first: 10) {\n          title\n          createdAt\n        }\n      }\n    }\n    \"\"\"\n    // In a real app, use a library like Apollo to handle this\n    let body: [String: Any] = [\"query\": query, \"variables\": [\"id\": userId]]\n    request.httpBody = try? JSONSerialization.data(withJSONObject: body)\n    \n    URLSession.shared.dataTask(with: request) { data, _, _ in\n        // ... decode the single, nested JSON response ...\n    }.resume()\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **REST:** Prone to versioning chaos (e.g., `/v1/`, `/v2/`). Tightly couples the client to the server's data models, making UI changes that require new data dependent on backend deployments.\n*   **GraphQL:** Caching is more complex. Standard URL-based HTTP caching doesn't work effectively with a single endpoint. Client-side normalized caching (e.g., via Apollo iOS) is often necessary. Unrestricted, deeply nested queries from a client can create performance bottlenecks on the server.\n\n**When to Use:**\n*   **Use REST for:** Simple, resource-oriented APIs; public APIs where HTTP standards and caching are paramount; microservice architectures where each service has a clear, bounded context.\n*   **Use GraphQL for:** Apps with complex, interconnected data models (e.g., social networks); applications with diverse clients (iOS, Web, Android) that have varying data needs; situations where minimizing network round-trips and payload size is critical for performance.",
      "code_example": null,
      "tags": [
        "networking",
        "api",
        "rest",
        "graphql",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    }
  ]
}