{
  "topic": "networking",
  "generated_at": "2026-01-12T04:20:49.156896+00:00",
  "cards": [
    {
      "id": "networking_6431b3cd68e4",
      "front": "Explain how to implement certificate pinning in Swift. Discuss the tradeoffs of pinning a leaf certificate vs. its public key, and describe a strategy for handling certificate rotation.",
      "back": "Certificate pinning is a security technique used to prevent man-in-the-middle (MitM) attacks. Standard TLS validation trusts any certificate signed by a trusted root Certificate Authority (CA). Pinning adds a layer by asserting that the certificate presented by the server must match a certificate (or public key) known in advance and bundled within the app.\n\n**Core Concept & Implementation:**\nThe standard implementation uses the `URLSessionDelegate` method `urlSession(_:didReceive:completionHandler:)`. During the TLS handshake, this delegate method is called with a `URLAuthenticationChallenge`. You inspect the challenge's `protectionSpace.serverTrust`, extract the certificate chain, and compare the server's certificate or public key against your pinned, bundled value.\n\n**Practical Code Example:**\n```swift\nclass NetworkService: NSObject, URLSessionDelegate {\n    // Load your pinned certificate from the app bundle\n    private lazy var pinnedCertificate: Data? = {\n        let certURL = Bundle.main.url(forResource: \"server\", withExtension: \"cer\")!\n        return try? Data(contentsOf: certURL)\n    }()\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Ensure it's a server trust challenge\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust,\n              let pinnedCertData = pinnedCertificate else {\n            completionHandler(.performDefaultHandling, nil)\n            return\n        }\n\n        // Get the server's leaf certificate from the trust chain\n        if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0) {\n            let serverCertData = SecCertificateCopyData(serverCertificate) as Data\n\n            // Compare the server's certificate with the one bundled in the app\n            if serverCertData == pinnedCertData {\n                // Success: The certificate matches our pin\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                return\n            }\n        }\n        \n        // Failure: Pin validation failed, reject the connection\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n}\n```\n\n**Pitfalls & Tradeoffs:**\n- **Pinning Leaf Certificate:** This is brittle. When the certificate expires and is renewed, its signature and metadata change, breaking the pin even if the underlying key is the same. Your app will lose connectivity until an update is released.\n- **Pinning Public Key:** This is the recommended approach. It's more flexible because a new certificate can be issued using the same key pair. The app pins the public key, which doesn't change upon certificate renewal, thus avoiding service disruption.\n\n**Handling Certificate Rotation:**\nA robust rotation strategy is critical. Hardcoding a single pin is a recipe for disaster. Instead:\n1.  **Pin Multiple Keys:** Bundle the public key for the current certificate *and* a backup key for the next one. The app should accept a connection if the server presents a certificate matching *either* key.\n2.  **Dynamic Pin Updates:** Implement a secure mechanism (e.g., a separate, trusted endpoint or a signed payload in an API response) to deliver new public keys to the app before the old ones expire. This requires careful design to avoid creating a new attack vector.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "URLSession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Describe the key components and design principles of a robust, scalable, and testable network layer in an iOS app. How would you handle concerns like routing, request building, and response parsing?",
      "back": "A modern, scalable network layer is built on the principle of Separation of Concerns, making it testable, reusable, and easy to maintain. It moves beyond scattering `URLSession` calls throughout the app and abstracts the networking logic into distinct, replaceable components.\n\n**Core Concepts & Components:**\n\n1.  **Endpoint/Router:** This component's sole responsibility is to define *what* an API call is. It encapsulates all the information needed to build a request, such as the base URL, path, HTTP method, headers, and parameters. Using an enum that conforms to an `Endpoint` protocol is a common and effective pattern. This makes adding new endpoints clean and type-safe.\n\n2.  **Network Service (or Client):** This is the engine that knows *how* to perform a network request. It takes an `Endpoint`, uses its properties to construct a `URLRequest`, executes it using `URLSession`, and handles the response. A well-designed service is generic, capable of decoding any `Decodable` type, and uses modern concurrency like `async/await`.\n\n3.  **Parser/Decoder:** This is responsible for transforming raw `Data` from a response into concrete Swift models. `JSONDecoder` is the standard tool for this, working seamlessly with `Codable` models.\n\n**Practical Code Example:**\n```swift\n// 1. Endpoint Protocol and a concrete Router enum\nprotocol Endpoint {\n    var baseURL: String { get }\n    var path: String { get }\n    var method: String { get }\n    var headers: [String: String]? { get }\n}\n\nenum UserEndpoint: Endpoint {\n    case fetchUsers\n    case fetchUser(id: Int)\n\n    var baseURL: String { \"https://api.example.com\" }\n    var path: String {\n        switch self {\n        case .fetchUsers: return \"/users\"\n        case .fetchUser(let id): return \"/users/\\(id)\"\n        }\n    }\n    var method: String { \"GET\" }\n    var headers: [String : String]? { [\"Content-Type\": \"application/json\"] }\n}\n\n// 2. Generic Network Service\nactor NetworkService {\n    private let session: URLSession\n    \n    init(session: URLSession = .shared) {\n        self.session = session\n    }\n\n    func request<T: Decodable>(endpoint: Endpoint) async throws -> T {\n        guard let url = URL(string: endpoint.baseURL + endpoint.path) else {\n            throw URLError(.badURL)\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method\n        endpoint.headers?.forEach { request.setValue($1, forHTTPHeaderField: $0) }\n\n        // Execute request and handle response\n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {\n            throw URLError(.badServerResponse) // More specific error handling is needed here\n        }\n        \n        // 3. Decode the response\n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n\n*   **Error Handling:** The example is basic. A production-ready layer needs robust error handling to distinguish between network errors (no connection), server errors (5xx), client errors (4xx), and parsing errors. This is often done with a custom `Error` enum.\n*   **Singleton Abuse:** Avoid a hard-coded `NetworkManager.shared` singleton. Instead, create an instance of the `NetworkService` and inject it as a dependency. This is crucial for testability, allowing you to inject a mock service.\n*   **Ignoring Cancellation:** `async/await` tasks are cancellable. The `NetworkService` should check for `Task.isCancelled` to avoid unnecessary work if the calling task is cancelled.\n*   **Environment Management:** Base URLs and API keys should not be hardcoded. Use build configurations (e.g., Xcode's `.xcconfig` files) to manage different environments (Dev, Staging, Prod).\n\n**When to Use vs. Alternatives:**\n\n*   **Use This Approach:** For any app beyond a simple prototype. The upfront effort pays off immensely in scalability and testability.\n*   **Alternatives (e.g., Alamofire):** Third-party libraries like Alamofire can be useful for complex needs like multipart form-data uploads, advanced request/response validation, or certificate pinning. However, for most standard JSON APIs, `URLSession` combined with this architecture provides sufficient power and avoids an external dependency.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "async-await",
        "testing",
        "design-patterns"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Design a robust, reusable WebSocket service for an iOS app. Discuss its lifecycle management, error handling, and strategies for maintaining a persistent connection, especially when the app backgrounds.",
      "back": "A robust WebSocket service acts as a centralized manager for real-time communication, abstracting the complexities of the connection from the rest of the app.\n\n### Core Concept\nThe foundation is `URLSessionWebSocketTask`, introduced in iOS 13. It provides a native, high-level API for WebSocket communication. A durable service must manage the entire connection lifecycle: initiating the connection, listening for messages, handling disconnections (both intentional and unexpected), and attempting to reconnect. It should also handle application state changes, such as entering the background, where network connections are typically suspended.\n\n### Practical Code Example\nHere's a simplified manager demonstrating key concepts:\n```swift\nclass WebSocketManager: NSObject, URLSessionWebSocketDelegate {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private var session: URLSession!\n\n    override init() {\n        super.init()\n        session = URLSession(configuration: .default, delegate: self, delegateQueue: OperationQueue())\n    }\n\n    func connect() {\n        let url = URL(string: \"wss://your.server.com/socket\")!\n        webSocketTask = session.webSocketTask(with: url)\n        webSocketTask?.resume()\n        listen()\n        schedulePing()\n    }\n\n    private func listen() {\n        webSocketTask?.receive { [weak self] result in\n            switch result {\n            case .success(let message):\n                // Handle received message (e.g., String or Data)\n                print(\"Received message: \\(message)\")\n                self?.listen() // Continue listening for the next message\n            case .failure(let error):\n                print(\"WebSocket error: \\(error)\")\n                // Handle error and potentially trigger reconnection logic\n            }\n        }\n    }\n\n    func send(message: String) {\n        webSocketTask?.send(.string(message)) { error in\n            if let error = error {\n                print(\"Error sending message: \\(error)\")\n            }\n        }\n    }\n\n    // Send a ping every 30 seconds to keep the connection alive\n    private func schedulePing() {\n        DispatchQueue.main.asyncAfter(deadline: .now() + 30) { [weak self] in\n            guard let self = self, self.webSocketTask?.state == .running else { return }\n            self.webSocketTask?.sendPing { error in\n                if let error = error {\n                    print(\"Ping failed: \\(error)\")\n                }\n            }\n            self.schedulePing() // Reschedule the next ping\n        }\n    }\n}\n```\n\n### Common Pitfalls & Edge Cases\n1.  **Reconnection Storms:** On connection failure, avoid immediate, repeated reconnection attempts. Implement an exponential backoff strategy (e.g., wait 1s, 2s, 4s, 8s) to avoid overwhelming the server and draining the battery.\n2.  **App Lifecycle:** Standard `URLSession` tasks are suspended when the app backgrounds. The service must observe `UIApplication.didEnterBackgroundNotification` and `willEnterForegroundNotification` to disconnect gracefully and reconnect when the app becomes active again.\n3.  **Idle Connections:** Network routers or proxies can drop idle connections. The `sendPing(pongReceiveHandler:)` method is crucial for sending control frames to keep the connection alive and verify the peer is responsive.\n4.  **Message Handling:** The `receive` call is a one-shot operation. You must call it again in its own completion handler to create a continuous listening loop.\n\n### When to Use vs. Alternatives\n-   **WebSockets:** Ideal for low-latency, bidirectional communication like chat, real-time gaming, or live data feeds.\n-   **HTTP Long Polling:** A fallback for older infrastructure. Higher overhead due to repeated HTTP handshakes. Use when true WebSockets are not an option.\n-   **Server-Sent Events (SSE):** Use for unidirectional (server-to-client) data streams, like news tickers or notifications. Simpler than WebSockets but lacks client-to-server communication over the same channel.\n-   **Push Notifications (APNs):** Best for delivering infrequent, high-priority data, especially when the app is in the background or closed. Not suitable for continuous real-time data.",
      "code_example": null,
      "tags": [
        "networking",
        "websocket",
        "URLSession",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "How would you design a robust networking layer that supports background downloads, custom authentication, and request prioritization using URLSession?",
      "back": "For a robust networking layer, avoid `URLSession.shared`. Instead, create a dedicated `URLSession` instance with a custom `URLSessionConfiguration` and a delegate.\n\n**Core Concept:**\nThe key is to separate concerns. The `URLSessionConfiguration` defines the behavior for a group of tasks (caching policy, timeouts, network service type, background support). The `URLSessionDelegate` (and its sub-protocols) provides fine-grained control over events like authentication, redirection, and task completion.\n\n- **Background Downloads:** Use `URLSessionConfiguration.background(withIdentifier:)`. This identifier allows the system to reconnect your app to the session if it was terminated while tasks were running. You must also implement `application(_:handleEventsForBackgroundURLSession:completionHandler:)` in your `AppDelegate`.\n- **Custom Authentication:** Implement the `urlSession(_:didReceive:completionHandler:)` delegate method to handle server trust evaluation, client certificates, or credential-based challenges.\n- **Prioritization:** Set the `priority` property on `URLSessionTask` (a float from 0.0 to 1.0). While this is a hint to the system, it helps prioritize critical requests over less important ones, like pre-fetching.\n\n**Practical Code Example:**\n```swift\n// In your AppDelegate or SceneDelegate\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Reconnect the session and store the completion handler to call later\n    NetworkManager.shared.backgroundCompletionHandler = completionHandler\n}\n\n// NetworkManager.swift\nclass NetworkManager: NSObject, URLSessionDownloadDelegate {\n    static let shared = NetworkManager()\n    var backgroundCompletionHandler: (() -> Void)?\n\n    private lazy var backgroundSession: URLSession = {\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundDownloader\")\n        config.isDiscretionary = true // Let the system optimize for performance/power\n        config.sessionSendsLaunchEvents = true\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil) // `delegateQueue: nil` creates a serial queue\n    }()\n\n    func startBackgroundDownload() {\n        let url = URL(string: \"https://example.com/largefile.zip\")!\n        let downloadTask = backgroundSession.downloadTask(with: url)\n        downloadTask.priority = URLSessionTask.highPriority\n        downloadTask.resume()\n    }\n\n    // MARK: - URLSessionDownloadDelegate\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move the file from the temporary location to a permanent one\n        print(\"Download finished, file at: \\(location)\")\n    }\n\n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        // Called when all tasks for the background session have finished\n        DispatchQueue.main.async {\n            self.backgroundCompletionHandler?()\n            self.backgroundCompletionHandler = nil\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Retain Cycles:** `URLSession` holds a strong reference to its delegate. If the delegate also holds a strong reference back to the session, you create a retain cycle. You must explicitly invalidate the session with `finishTasksAndInvalidate()` or `invalidateAndCancel()` to break the cycle when it's no longer needed.\n- **Background Session Handling:** Forgetting to implement `application(_:handleEventsForBackgroundURLSession:completionHandler:)` or failing to call the stored completion handler will cause your app to be penalized by the system for misusing background resources.\n- **Delegate Queue:** Specifying a delegate queue is crucial. Using `nil` creates a serial queue, which can become a bottleneck. Using `OperationQueue.main` will block your UI. A custom background queue is often best, but remember to dispatch any UI updates back to the main thread.\n\n**When to use vs. Alternatives:**\n- **Delegate vs. Async/Await:** For foreground requests, Swift's async/await provides a much cleaner, modern syntax (`URLSession.shared.data(for:)`). However, for background sessions and fine-grained control over events like authentication challenges or progress updates, the delegate pattern remains essential and is the only way to handle background session events.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "concurrency",
        "background"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Your team is building a feature with complex, nested data and multiple client platforms. How would you evaluate using REST vs. GraphQL for the API design?",
      "back": "The choice between REST and GraphQL is a significant architectural decision that hinges on data complexity, client diversity, and performance goals.\n\n### Core Concept\n**REST (Representational State Transfer)** is an architectural style based on resources. Each resource has a unique URI (e.g., `/users/123`), and you interact with it using standard HTTP verbs (GET, POST, PUT, DELETE). The server dictates the structure of the response, which is often a fixed JSON object. This can lead to over-fetching (getting more data than needed) or under-fetching (needing multiple API calls to gather all necessary data).\n\n**GraphQL** is a query language for APIs. It uses a single endpoint (e.g., `/graphql`) and a strongly-typed schema. The client sends a query specifying the exact data fields it needs, including nested relationships. The server responds with a JSON object that mirrors the query structure, eliminating over/under-fetching.\n\n### Practical Code Example\nScenario: Fetch a user's name and the titles of their posts.\n\n**REST Approach (Under-fetching):**\n```swift\n// 1. First, fetch the user\n// GET /api/users/123 -> { \"id\": 123, \"name\": \"Jane Doe\", \"email\": \"...\" }\n\n// 2. Then, fetch their posts in a separate request\n// GET /api/users/123/posts -> [ { \"id\": 1, \"title\": \"First Post\", \"content\": \"...\" } ]\n\n// This requires two round trips to the server.\n```\n\n**GraphQL Approach (Single Request):**\n```swift\n// POST /graphql\n// Body is a query string, not separate URL paths.\nlet query = \"\"\"\nquery GetUserAndPosts {\n  user(id: \"123\") {\n    name\n    posts {\n      title\n    }\n  }\n}\n\"\"\"\n// The single response contains exactly what was requested:\n// { \"data\": { \"user\": { \"name\": \"Jane Doe\", \"posts\": [ { \"title\": \"First Post\" } ] } } }\n```\n\n### Common Pitfalls & Edge Cases\n*   **REST:** The primary pitfall is the N+1 problem caused by under-fetching, leading to multiple, slow network requests. Versioning (`/v1`, `/v2`) can become complex to manage as the API evolves.\n*   **GraphQL:** Server-side complexity is a major concern. A deeply nested or poorly designed query can overload the database. Implementing robust caching is harder than REST's standard HTTP caching. Rate limiting and query depth analysis are essential to prevent abuse.\n\n### When to Use vs. Alternatives\n*   **Use REST** for simpler, resource-centric APIs where data models are stable. It's great for standard CRUD operations and when you can leverage HTTP caching effectively. It has a lower learning curve for teams already familiar with HTTP.\n*   **Use GraphQL** when you have multiple diverse clients (e.g., iOS, Web, Android) with varying data requirements. It excels in applications with complex, interconnected data models (like a social network feed) and helps reduce network payloads and round trips, which is critical for mobile performance.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "rest",
        "graphql",
        "api"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Describe the lifecycle and constraints of a `URLSession` background task. How does it differ from a standard task, and what are the key delegate methods you must implement?",
      "back": "A `URLSession` configured for background transfers hands off networking to a separate system daemon (`nsurlsessiond`). This out-of-process approach is the key difference from standard sessions, which run within your app's process. It allows transfers to continue even if the app is suspended, terminated by the user, or crashes. The OS then relaunches the app in the background upon completion or for authentication challenges, making it ideal for large, non-urgent files like videos or backups.\n\n**Practical Code Example:**\n```swift\n// 1. Session Configuration (e.g., in a NetworkService class)\nprivate lazy var backgroundSession: URLSession = {\n    // The identifier is crucial for the system to reconnect to your app.\n    let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundtransfer\")\n    // Allows the OS to schedule the transfer optimally (e.g., on Wi-Fi, when plugged in).\n    config.isDiscretionary = true\n    config.sessionSendsLaunchEvents = true\n    // A delegate is REQUIRED for background sessions.\n    return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n}()\n\n// 2. AppDelegate Hook to receive the completion handler\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the handler to be called when all events are processed.\n    NetworkService.shared.backgroundCompletionHandler = completionHandler\n}\n\n// 3. URLSessionDownloadDelegate Implementation\nfunc urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n    // The 'location' is a temporary file path. You MUST move the file before this method returns.\n    guard let destinationURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first?.appendingPathComponent(location.lastPathComponent) else { return }\n    try? FileManager.default.moveItem(at: location, to: destinationURL)\n}\n\nfunc urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    // Call the stored completion handler on the main thread.\n    DispatchQueue.main.async {\n        self.backgroundCompletionHandler?()\n        self.backgroundCompletionHandler = nil\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Using Completion Handlers:** Background sessions do not support completion block-based APIs on tasks (`downloadTask(with:completionHandler:)`). You *must* use the delegate pattern.\n- **Not Moving the File:** The file at the temporary `location` is deleted after `didFinishDownloadingTo` returns. Failure to move it results in data loss.\n- **Not Calling the Completion Handler:** Forgetting to call the `completionHandler` provided in the `AppDelegate` signals to the OS that your app is misbehaving, which negatively impacts its background time and battery usage.\n\n**When to Use vs. Alternatives:**\n- **Use for:** Large file transfers that are not time-sensitive and must survive app termination.\n- **Alternatives:** \n  - **Standard `URLSessionTask`:** For all foreground, user-initiated requests that complete while the app is active.\n  - **`UIApplication.beginBackgroundTask`:** For short-lived tasks (< 3 mins) that need to finish after the app is backgrounded. It does not survive termination and is not suitable for large, unpredictable transfers.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "background-execution",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Beyond faster speeds, how do HTTP/2 and HTTP/3 change the way we should architect networking in iOS apps, and how does `URLSession` support them?",
      "back": "HTTP/2 and HTTP/3 fundamentally change network efficiency, allowing for architectural patterns that were previously unviable. `URLSession` handles protocol negotiation transparently, so the main change is in how we design our app's network interactions.\n\n**Core Concept:**\n- **HTTP/1.1 Problem:** Suffered from head-of-line (HOL) blocking. Only one request could be active on a connection at a time. Browsers and OSs opened multiple TCP connections (typically 6-8 per host) to parallelize, but this was inefficient and led to workarounds like asset bundling and domain sharding.\n- **HTTP/2 Solution:** Introduces multiplexing over a single TCP connection per host. It uses binary frames to interleave multiple request/response streams simultaneously, eliminating HOL blocking at the application layer. It also adds header compression (HPACK) to reduce overhead.\n- **HTTP/3 Evolution:** Solves the *TCP-level* HOL blocking that still exists in HTTP/2. If one TCP packet is lost, the entire connection pauses for retransmission, blocking all multiplexed streams. HTTP/3 uses QUIC, a transport protocol over UDP. QUIC implements streams independently, so packet loss in one stream doesn't block others. It also features a faster 0-RTT or 1-RTT connection handshake.\n\n**Practical Code Example:**\n`URLSession` automatically negotiates and uses HTTP/2 or HTTP/3 if the server supports it. No special code is needed to 'opt-in'.\n\n```swift\n// URLSession transparently handles protocol negotiation.\n// Your code remains the same, but its performance characteristics improve.\nlet url = URL(string: \"https://api.example.com/v2/user/profile\")!\n\n// Standard shared session is sufficient\nlet task = URLSession.shared.dataTask(with: url) { data, response, error in\n    guard let httpResponse = response as? HTTPURLResponse, error == nil else {\n        // Handle error\n        return\n    }\n\n    // In a debugger, `po httpResponse` will reveal the protocol used (e.g., HTTP/2.0).\n    // This confirms your app is leveraging modern protocols without code changes.\n    print(\"Status Code: \\(httpResponse.statusCode)\")\n}\ntask.resume()\n```\n\n**Common Pitfalls:**\n- **Outdated Patterns:** Continuing to use HTTP/1.1 workarounds like domain sharding (`media1.host.com`, `media2.host.com`) is now an anti-pattern. It prevents HTTP/2's connection reuse, increasing TCP/TLS handshake overhead.\n- **Request Bundling:** Over-bundling API requests into a single large call can be less flexible than making multiple, granular requests, which HTTP/2 handles efficiently.\n- **Environment Issues:** HTTP/3's use of UDP can be blocked by restrictive corporate firewalls or older network hardware, forcing a fallback. `URLSession` handles this gracefully, but the performance benefits are lost.\n\n**When to Use vs. Alternatives:**\nThis is less about choosing a protocol in code (as `URLSession` handles it) and more about architectural choice.\n- **Use Modern Patterns:** Design APIs to be granular and resource-oriented. A screen displaying a user's profile, friends, and photos can make three separate, concurrent requests. With HTTP/2, these run in parallel over one connection without blocking each other.\n- **Alternative (Fallback):** If a server or proxy doesn't support HTTP/2 or HTTP/3, `URLSession` will automatically fall back to HTTP/1.1. Your app will still function, but with the performance limitations of the older protocol. The key is to architect for the best-case scenario that modern infrastructure provides.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "http2",
        "http3",
        "performance"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    }
  ]
}