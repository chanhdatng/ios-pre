{
  "topic": "networking",
  "generated_at": "2026-01-09T07:04:34.069286+00:00",
  "cards": [
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "When implementing a client-side WebSocket using `URLSessionWebSocketTask`, how do you manage its lifecycle, handle unsolicited messages, and ensure connection robustness (e.g., heartbeats, reconnection)?",
      "back": "Implementing a robust WebSocket client with `URLSessionWebSocketTask` requires manually managing its state and behavior, as the API is powerful but low-level.\n\n**Core Concept:**\nThe process involves three key areas:\n1.  **Lifecycle Management:** You initiate the connection by creating a `URLSessionWebSocketTask` and calling `resume()`. To close it, you call `cancel(with:reason:)`. The task's state isn't exposed via a simple `isConnected` property; you must infer it from successful pings, message receipts, or errors.\n2.  **Message Handling:** The `receive(completionHandler:)` method (or its `async` counterpart) is a one-shot operation. To continuously listen for server-pushed messages, you must call `receive()` again from within the completion handler of the previous call, creating a recursive loop.\n3.  **Robustness:** To keep the connection alive through proxies and NATs, and to detect silent drops, you must implement a heartbeat mechanism. This is done by periodically calling `sendPing(pongReceiveHandler:)` on a timer. If the pong is not received within a timeout, you assume the connection is dead and initiate a reconnection sequence, ideally with an exponential backoff strategy to avoid overwhelming the server.\n\n**Practical Code Example (using async/await):**\n```swift\nactor WebSocketManager {\n    private var webSocketTask: URLSessionWebSocketTask?\n    private let session = URLSession(configuration: .default)\n    private var pingTimer: Timer?\n\n    func connect(url: URL) {\n        disconnect()\n        webSocketTask = session.webSocketTask(with: url)\n        webSocketTask?.resume()\n        listenForMessages()\n        schedulePing()\n    }\n\n    func disconnect() {\n        pingTimer?.invalidate()\n        webSocketTask?.cancel(with: .goingAway, reason: nil)\n        webSocketTask = nil\n    }\n\n    private func listenForMessages() {\n        Task {\n            do {\n                let message = try await webSocketTask?.receive()\n                // Handle message (e.g., switch on .string or .data)\n                print(\"Received message: \\(String(describing: message))\")\n                listenForMessages() // The crucial recursive call\n            } catch {\n                print(\"Error receiving message: \\(error). Reconnecting...\")\n                // Handle disconnection and implement reconnection logic here\n                self.disconnect()\n            }\n        }\n    }\n\n    private func schedulePing() {\n        pingTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { [weak self] _ in\n            self?.sendPing()\n        }\n    }\n\n    private func sendPing() {\n        webSocketTask?.sendPing { error in\n            if let error = error {\n                print(\"Ping failed: \\(error). Connection might be lost.\")\n                // Trigger reconnection logic\n            }\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Forgetting the Receive Loop:** Calling `receive()` only once is a common mistake, resulting in only the first message being processed.\n*   **No Reconnection Strategy:** Not handling the error from `receive()` or a failed ping to trigger a reconnection attempt (with exponential backoff) leads to a fragile implementation.\n*   **Backgrounding:** iOS will terminate the connection when the app is backgrounded. You must handle this by reconnecting when the app returns to the foreground.\n\n**When to use vs. Alternatives:**\n*   **`URLSessionWebSocketTask`:** Use when you want a first-party, dependency-free solution and need fine-grained control. It's ideal for integrating with modern Swift concurrency (async/await) and Combine.\n*   **Third-party Libraries (e.g., Starscream):** Opt for a library if you need features like automatic reconnection, advanced state management, or support for older iOS versions (pre-iOS 13) out of the box. This trades control for convenience and an extra dependency.",
      "code_example": null,
      "tags": [
        "networking",
        "websockets",
        "URLSession",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_af7f793e90df",
      "front": "URLSession advanced usage",
      "back": "",
      "code_example": null,
      "tags": [
        "URLSession advanced usage"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "How would you implement a robust, large file download that continues after the app is backgrounded or terminated? Describe the `URLSession` configuration, delegate methods, and the process for reconnecting to the session when the app relaunches.",
      "back": "To handle large background transfers, you must use a `URLSession` configured for background activity. This hands off the transfer management to a separate system daemon (`nsurlsessiond`), allowing downloads/uploads to continue even if your app is suspended or terminated by the system.\n\n**Core Concept:**\nThe process involves three main parts:\n1.  **Configuration:** Create a `URLSessionConfiguration.background(withIdentifier:)` with a unique identifier. This identifier is crucial for reconnecting to the session later.\n2.  **Delegation:** Background sessions *require* a delegate; they do not support completion handlers or async/await syntax. You must implement `URLSessionDownloadDelegate` (for downloads) and `URLSessionDelegate` methods to handle completion, errors, and progress.\n3.  **Reconnection:** When tasks finish, the system relaunches your app in the background. The `AppDelegate`'s `application(_:handleEventsForBackgroundURLSession:completionHandler:)` is called. Here, you must use the provided identifier to re-instantiate your `URLSession` with the *exact same configuration* to receive the pending delegate callbacks.\n\n**Practical Code Example:**\n```swift\n// In your network service or a dedicated manager\nclass DownloadManager: NSObject, URLSessionDownloadDelegate {\n    lazy var backgroundSession: URLSession = {\n        // The identifier must be unique to your app.\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.backgroundDownloader\")\n        config.isDiscretionary = true // Let the system optimize for performance/battery\n        config.sessionSendsLaunchEvents = true\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    func startDownload(url: URL) {\n        let task = backgroundSession.downloadTask(with: url)\n        task.resume()\n    }\n\n    // 1. Called when the download successfully finishes\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // You MUST move the file from the temporary location before this method returns.\n        // Otherwise, the system will delete it.\n        let destinationURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(location.lastPathComponent)\n        try? FileManager.default.moveItem(at: location, to: destinationURL)\n        // Update your model, perhaps schedule a local notification.\n    }\n\n    // 2. Called when all events for the session have been delivered\n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        // Retrieve and call the completion handler stored by the AppDelegate\n        DispatchQueue.main.async {\n            guard let appDelegate = UIApplication.shared.delegate as? AppDelegate,\n                  let handler = appDelegate.backgroundCompletionHandler else { return }\n            appDelegate.backgroundCompletionHandler = nil\n            handler()\n        }\n    }\n}\n\n// In your AppDelegate.swift\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    var backgroundCompletionHandler: (() -> Void)?\n\n    func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n        // Store the handler to be called when all transfers are complete.\n        self.backgroundCompletionHandler = completionHandler\n        // You might also re-instantiate your download manager here to ensure the session is ready.\n    }\n}\n```\n\n**Common Pitfalls:**\n-   **Forgetting to Move the File:** The file at the temporary `location` is deleted immediately after `didFinishDownloadingTo` returns. It must be moved or copied.\n-   **Not Calling the Completion Handler:** Failing to call the `completionHandler` in `urlSessionDidFinishEvents` tells the OS your app is done, but you haven't confirmed it. This can lead to your app being penalized for background activity and prevents the OS from taking a new UI snapshot.\n-   **UI Updates:** Never perform direct, extensive UI updates from background delegate methods. Update your data model and let your UI reflect those changes when the app is next foregrounded, or use a `UNNotification` to alert the user.\n\n**When to use vs. Alternatives:**\n-   **Background Session:** For large or long-running transfers that must survive app termination. Ideal for video, audio, or data sync.\n-   **Standard `URLSession`:** For all typical network requests made while the app is active. These are cancelled if the app is terminated.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "background",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Explain the mechanism of SSL certificate pinning in an iOS app. How does it mitigate Man-in-the-Middle (MITM) attacks, and what are the operational risks and best practices for implementing it?",
      "back": "### Core Concept\nStandard TLS validation relies on the device's trust store of Certificate Authorities (CAs). This is vulnerable if a CA is compromised or a malicious root certificate is installed, enabling a Man-in-the-Middle (MITM) attack. Certificate pinning defends against this by bypassing the CA chain of trust. The app is \"pinned\" to a specific server certificate or, more flexibly, its public key. During the TLS handshake, the app compares the server's presented certificate/key against a copy bundled within the app. If they don't match, the connection is terminated, even if the OS would otherwise trust the certificate. This ensures the app communicates exclusively with the intended server.\n\n### Practical Code Example\nPinning the server's public key hash (SPKI) is the best practice. It allows the server certificate to be renewed without requiring an app update, as long as the underlying key pair is unchanged.\n\n```swift\nimport Security\nimport CommonCrypto // Required for SHA256 hashing\n\nclass PinningDelegate: NSObject, URLSessionDelegate {\n    // Base64 encoded SHA-256 hash of the server's Subject Public Key Info (SPKI)\n    let pinnedPublicKeyHash = \"YOUR_SERVER_PUBLIC_KEY_HASH_BASE64==\"\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        \n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        if let serverCert = SecTrustGetCertificateAtIndex(serverTrust, 0),\n           let serverPublicKey = SecCertificateCopyKey(serverCert),\n           let serverPublicKeyData = SecKeyCopyExternalRepresentation(serverPublicKey, nil) as Data? {\n\n            let remoteKeyHash = sha256(data: serverPublicKeyData).base64EncodedString()\n\n            if remoteKeyHash == pinnedPublicKeyHash {\n                // Success: Key matches our pin.\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n            } else {\n                // Failure: Mismatch. Potential MITM attack.\n                completionHandler(.cancelAuthenticationChallenge, nil)\n            }\n        } else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n    \n    private func sha256(data: Data) -> Data {\n        var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n        data.withUnsafeBytes { _ = CC_SHA256($0.baseAddress, CC_LONG(data.count), &hash) }\n        return Data(hash)\n    }\n}\n```\n\n### Common Pitfalls & Best Practices\n*   **Bricking the App:** If the server's pinned key is rotated without a corresponding app update, all users will be locked out. **Best Practice:** Always include a backup pin and consider a remote configuration mechanism to update pins before they expire.\n*   **Pinning the Wrong Thing:** Pinning a leaf certificate is brittle due to expiration. Pinning a root CA is too broad. **Best Practice:** Pin the public key hash of the leaf or an intermediate certificate you control.\n*   **Domain Coverage:** Ensure you pin keys for all critical domains your app communicates with (APIs, CDNs, etc.).\n\n### When to Use vs. Alternatives\nUse pinning for apps handling highly sensitive data (e.g., banking, health records) where the risk and consequence of a targeted MITM attack are high. For most other apps, the standard Public Key Infrastructure (PKI) is sufficient. A complementary technology is Certificate Transparency (CT), which helps detect maliciously issued certificates but doesn't prevent the initial connection like pinning does.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "urlsession",
        "mitm"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Your team is building a new, feature-rich iOS app with complex, interconnected data. Argue for choosing GraphQL over a traditional REST architecture, considering client-side complexity, performance, and long-term maintainability.",
      "back": "Choosing GraphQL over REST is a strategic decision that shifts control from the server to the client, which is highly advantageous for mobile applications with evolving requirements.\n\n### Core Concept\nREST (Representational State Transfer) is an architectural style where you interact with resources via distinct URLs and standard HTTP verbs (GET, POST, etc.). To fetch related data, like a user and their posts, you might need multiple network requests (e.g., `/users/1` then `/users/1/posts`). This often leads to over-fetching (getting more data than needed) or under-fetching (requiring multiple calls).\n\nGraphQL is a query language for your API. It uses a single endpoint and allows the client to specify the exact shape and content of the data it needs in a single request. This is defined by a strongly-typed schema on the server, which acts as a contract between the client and server.\n\n### Practical Code Example\nImagine fetching a user and the titles of their last 3 posts.\n\n**REST Approach (Multiple Requests):**\n```swift\n// 1. Fetch user\nlet userURL = URL(string: \"https://api.example.com/v1/users/123\")!\nlet (userData, _) = try await URLSession.shared.data(from: userURL)\n\n// 2. Fetch user's posts (potentially over-fetches full post objects)\nlet postsURL = URL(string: \"https://api.example.com/v1/users/123/posts?limit=3\")!\nlet (postsData, _) = try await URLSession.shared.data(from: postsURL)\n// Client-side work needed to combine and parse both responses.\n```\n\n**GraphQL Approach (Single Request):**\n```swift\nlet endpoint = URL(string: \"https://api.example.com/graphql\")!\nvar request = URLRequest(url: endpoint)\nrequest.httpMethod = \"POST\"\nrequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n\n// The client defines exactly what it needs in the query.\nlet query = \"\"\"\nquery GetUserWithPosts($userId: ID!) {\n  user(id: $userId) {\n    name\n    email\n    posts(last: 3) {\n      title\n    }\n  }\n}\n\"\"\"\nlet body: [String: Any] = [\"query\": query, \"variables\": [\"userId\": \"123\"]]\nrequest.httpBody = try JSONSerialization.data(withJSONObject: body)\n\nlet (data, _) = try await URLSession.shared.data(for: request)\n// A single response contains all the requested data in the specified shape.\n```\n\n### Common Pitfalls & Edge Cases\n*   **GraphQL Caching:** REST benefits from standard HTTP caching based on URLs. With GraphQL's single endpoint, this is non-trivial. Client-side solutions like the Apollo iOS client implement sophisticated normalized caching, but it adds complexity.\n*   **Error Handling:** A GraphQL request can partially succeed. You might get a 200 OK status, but the JSON response body could contain an `errors` array alongside the `data` object. The client must be architected to handle these partial failures gracefully.\n*   **N+1 Problem:** This is a server-side concern, but senior client developers should be aware of its performance impact. A naive GraphQL resolver can trigger a separate database query for each field, leading to performance degradation. This is solved on the backend with techniques like data loaders.\n\n### When to Use vs. Alternatives\n*   **Use GraphQL for:**\n    *   Applications with complex and nested data relationships (e.g., social feeds).\n    *   Projects with multiple clients (iOS, Web, Android) that have different data requirements.\n    *   Mobile-first applications where minimizing bandwidth and network round trips is critical.\n*   **Stick with REST for:**\n    *   Simpler, resource-based APIs where endpointsmap cleanly to data models.\n    *   When the overhead of setting up a GraphQL server and client is not justified.\n    *   When leveraging standard HTTP caching is a primary performance strategy.",
      "code_example": null,
      "tags": [
        "networking",
        "graphql",
        "rest",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}