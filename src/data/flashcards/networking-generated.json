{
  "topic": "networking",
  "generated_at": "2026-01-15T04:04:42.375050+00:00",
  "cards": [
    {
      "id": "networking_af7f793e90df",
      "front": "You need to download a multi-gigabyte file, provide real-time progress updates, and handle custom server auth. Why is the basic `dataTask` with a completion handler insufficient, and what `URLSession` architecture would you use?",
      "back": "The standard `dataTask(with:completionHandler:)` or `async/await`'s `data(for:)` are insufficient because they load the entire response into a single `Data` object in memory. A multi-gigabyte file would cause an immediate crash due to excessive memory allocation.\n\n**Core Concept: Delegate-Based URLSession**\n\nThe solution is to use the delegate-based approach, which provides granular control over the networking lifecycle. For this specific scenario, a `URLSessionDownloadTask` configured with a delegate is ideal. This writes the data directly to a temporary file on disk, using minimal memory.\n\nThe key delegates are:\n- `URLSessionDelegate`: The base protocol.\n- `URLSessionTaskDelegate`: Handles task-level events like authentication challenges via `urlSession(_:task:didReceive:completionHandler:)`.\n- `URLSessionDownloadDelegate`: Provides progress updates via `urlSession(_:downloadTask:didWriteData:...)` and the final file location upon completion.\n\n**Practical Code Example:**\n```swift\nclass LargeFileDownloader: NSObject, URLSessionDownloadDelegate, URLSessionTaskDelegate {\n    private lazy var session: URLSession = {\n        // Use a background configuration for large downloads\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.largefiledownloader\")\n        // Create a dedicated serial queue for delegate callbacks to avoid blocking the main thread.\n        let queue = OperationQueue()\n        queue.maxConcurrentOperationCount = 1\n        return URLSession(configuration: config, delegate: self, delegateQueue: queue)\n    }()\n\n    func startDownload(url: URL) {\n        let downloadTask = session.downloadTask(with: url)\n        downloadTask.resume()\n    }\n\n    // 1. Progress Reporting\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {\n        let progress = Float(totalBytesWritten) / Float(totalBytesExpectedToWrite)\n        DispatchQueue.main.async {\n            print(\"Download Progress: \\(progress)\")\n            // Update UI here\n        }\n    }\n\n    // 2. Handling Completion\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Move the temporary file to a permanent location\n        // The file at `location` will be deleted after this delegate method returns.\n    }\n\n    // 3. Handling Authentication\n    func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Handle server trust, client certificates, or other auth challenges\n        // For example, trust a specific server\n        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {\n            if let serverTrust = challenge.protectionSpace.serverTrust {\n                 completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                 return\n            }\n        }\n        completionHandler(.performDefaultHandling, nil)\n    }\n    \n    deinit {\n        // Invalidate the session to release the delegate and prevent memory leaks.\n        session.finishTasksAndInvalidate()\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Memory Leaks:** `URLSession` holds a strong reference to its delegate. If the delegate also holds a strong reference to the session, a retain cycle occurs. You must explicitly call `invalidateAndCancel()` or `finishTasksAndInvalidate()` to break this cycle, typically in `deinit`.\n- **Blocking Main Thread:** Not providing a `delegateQueue` means delegate methods will be called on a serial queue managed by the session. If you use `OperationQueue.main`, any long-running delegate code will freeze your UI.\n- **File Handling:** Forgetting to move the file from the temporary location in `didFinishDownloadingTo` will result in data loss.\n\n**When to use vs Alternatives:**\n- **Completion Handlers / `async/await`:** Use for simple, small requests (e.g., fetching JSON) where the entire response fits in memory and no custom handling is needed.\n- **`URLSessionDataDelegate`:** Use for streaming data that you need to process in-memory chunk-by-chunk, without writing to a file (e.g., parsing a massive XML or JSON stream).\n- **`URLSessionDownloadDelegate`:** The best choice for downloading large files to disk, as demonstrated above.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "concurrency",
        "architecture",
        "memory management"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Explain how to implement certificate pinning using `URLSession`. Discuss the trade-offs of pinning the certificate vs. its public key, and strategies for handling certificate rotation without breaking the app.",
      "back": "Certificate pinning is a security technique that hardcodes the server's X.509 certificate or its public key into the client application. During a TLS handshake, the app compares the server's certificate/key with its embedded copy. If they don't match, the connection is terminated. This prevents man-in-the-middle (MITM) attacks where an attacker uses a fraudulent certificate, even if it's signed by a compromised but trusted Certificate Authority (CA).\n\n**Core Implementation (Public Key Pinning):**\nThe standard approach uses the `URLSessionDelegate` authentication challenge.\n\n```swift\nclass NetworkService: NSObject, URLSessionDelegate {\n    // Pinned public key hashes (SHA256, Base64 encoded)\n    private let pinnedHashes: Set<String> = [\n        \"hpfZplg3YRKhvADg024A2b34H8ag/xso3ZlSQs2oG2E=\", // Primary key\n        \"k3d2+eJd2qgE2/kSj9sJd8sS/kLq9eJd8sS/kLq9eJd=\"  // Backup key\n    ]\n\n    lazy var session: URLSession = {\n        return URLSession(configuration: .default, delegate: self, delegateQueue: nil)\n    }()\n\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        // Ensure we're dealing with a server trust challenge\n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n\n        // Extract the public key from the server's certificate\n        if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0),\n           let serverPublicKey = SecCertificateCopyKey(serverCertificate),\n           let serverPublicKeyData = SecKeyCopyExternalRepresentation(serverPublicKey, nil) as Data? {\n            \n            // Hash the public key (SPKI)\n            let keyHash = sha256(data: serverPublicKeyData)\n            let base64Hash = keyHash.base64EncodedString()\n\n            // Check if the hash matches one of our pinned hashes\n            if pinnedHashes.contains(base64Hash) {\n                // Success! Trust this server.\n                completionHandler(.useCredential, URLCredential(trust: serverTrust))\n                return\n            }\n        }\n        \n        // Pinning failed. Reject the connection.\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n\n    // Helper to compute SHA256 hash\n    private func sha256(data: Data) -> Data {\n        var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n        data.withUnsafeBytes { _ = CC_SHA256($0.baseAddress, CC_LONG(data.count), &hash) }\n        return Data(hash)\n    }\n}\n```\n\n**Trade-offs: Certificate vs. Public Key Pinning**\n- **Certificate Pinning:** Pins the entire certificate. It's very brittle; when the certificate expires and is renewed (even with the same key pair), the app will break because the new certificate's signature and validity dates are different. This requires an app update for every renewal.\n- **Public Key Pinning:** Pins only the Subject Public Key Info (SPKI). This is the recommended approach. You can renew a certificate with the same key pair, and the public key hash will remain the same. This provides robust security with much greater operational flexibility.\n\n**Handling Certificate Rotation:**\nThis is the biggest pitfall of pinning. If not handled, a certificate change can render your app unusable.\n1.  **Backup Pin:** The best practice is to include at least two pins: the hash for the current public key and a hash for a backup key. When the primary certificate is nearing expiration, the server can be updated to use a new certificate generated from the backup key. The app will continue to function, giving you time to ship an update with a new backup pin.\n2.  **Avoid Pinning Leaf Certificates:** Pinning the leaf certificate is most specific but most brittle. Pinning an intermediate CA's public key is an alternative, trusting any certificate issued by them. This is less secure but more flexible. The choice depends on your security requirements and control over the infrastructure.",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "Your team is starting a new project. Argue for choosing GraphQL over REST, considering the impact on client-side architecture, performance, and long-term maintenance.",
      "back": "Choosing GraphQL over REST is a significant architectural decision. I'd advocate for GraphQL when our application's data is highly interconnected and our UI requires fetching nested or partial objects, which is common in modern, component-based UIs.\n\n**Core Concept Explanation**\nREST is an architectural style centered around resources, accessed via distinct endpoints (e.g., `/users/1`, `/users/1/posts`). The server dictates the response structure. This can lead to over-fetching (getting more data than needed) or under-fetching (requiring multiple API calls to assemble a complete view).\n\nGraphQL is a query language for your API. It uses a single endpoint where the client sends a query specifying exactly the data it needs. This shifts control to the client, eliminating over/under-fetching and reducing network round trips, which is crucial for mobile performance.\n\n**Practical Code Example**\nImagine fetching a user and their post titles.\n\n*REST Approach (Multiple Requests):*\n```swift\n// Needs two separate network calls\nstruct User: Decodable { let id: String, name: String }\nstruct Post: Decodable { let title: String }\n\nfunc fetchUserAndPosts() async throws -> (User, [Post]) {\n    // 1. Fetch user\n    let userURL = URL(string: \"/api/users/1\")!\n    let (userData, _) = try await URLSession.shared.data(from: userURL)\n    let user = try JSONDecoder().decode(User.self, from: userData)\n\n    // 2. Fetch posts\n    let postsURL = URL(string: \"/api/users/1/posts\")!\n    let (postsData, _) = try await URLSession.shared.data(from: postsURL)\n    let posts = try JSONDecoder().decode([Post].self, from: postsData)\n    return (user, posts)\n}\n```\n\n*GraphQL Approach (Single Request with Apollo Client):*\n```swift\n// Client defines the exact data shape in one query\n/*\nquery GetUserAndPosts($userId: ID!) {\n  user(id: $userId) {\n    name\n    posts {\n      title\n    }\n  }\n}\n*/\n\n// Generated Swift code from the query\nfunc fetchUserAndPosts() async throws -> GetUserAndPostsQuery.Data.User {\n    let query = GetUserAndPostsQuery(userId: \"1\")\n    return try await apolloClient.fetch(query: query).data.user\n}\n```\n\n**Common Pitfalls & Edge Cases**\n- **Caching:** REST leverages standard HTTP caching. GraphQL's single endpoint makes HTTP caching difficult. This necessitates a sophisticated client-side normalized cache (like Apollo's) to avoid re-fetching data, which adds complexity.\n- **Error Handling:** REST uses HTTP status codes (404, 500) for errors. GraphQL typically returns a 200 OK with an `errors` array in the JSON payload, requiring a different client-side error handling paradigm.\n- **Tooling Overhead:** GraphQL requires more initial setup: a client library (e.g., Apollo), a schema, and code generation tools. This can slow down initial development compared to using `URLSession` and `Codable` with REST.\n\n**When to Use vs. Alternatives**\n- **Use GraphQL:** For applications with complex UIs, a graph-like data model, or multiple clients (iOS, Web, Android) with varying data needs. It improves performance by minimizing network payloads and round trips. It excels in long-term maintenance as the API can evolve without versioning or adding new endpoints.\n- **Stick with REST:** For simpler, resource-oriented APIs, microservices with clear boundaries, or when leveraging HTTP caching is a primary requirement. The lower initial complexity and wider familiarity can be advantageous for smaller projects or teams new to these concepts.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "graphql",
        "rest"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Design a scalable and testable network layer for a large-scale iOS application. Describe the key components, their responsibilities, and how they interact.",
      "back": "A modern, scalable network layer abstracts URLSession and promotes separation of concerns, testability, and reusability. It typically consists of three main components:\n\n1.  **Endpoint/Router**: This component (often an enum or protocol) defines all the necessary information for a single API request: path, HTTP method, headers, and parameters/body. It's responsible for constructing a `URLRequest`. This centralizes API definitions, making them type-safe and easy to manage.\n\n2.  **Network Client**: A generic service responsible for executing requests. It takes an `Endpoint`, uses it to create a `URLRequest`, performs the request using `URLSession`, and handles the response. It is agnostic to the specific API call and focuses on the mechanics of networking, including centralized error handling (e.g., mapping URL, HTTP, and decoding errors to a custom error type).\n\n3.  **Model & Parser**: Standard `Codable` models represent the API response structures. The Network Client uses a `JSONDecoder` instance to parse the raw `Data` from a successful response into these typed models.\n\nThis architecture ensures that view models or interactors only need to know which endpoint to call, without being burdened by the implementation details of URL construction, serialization, or error handling.\n\n```swift\n// 1. Endpoint Protocol\nprotocol Endpoint {\n    var path: String { get }\n    var method: String { get }\n    func asURLRequest() throws -> URLRequest\n}\n\nenum UserEndpoint: Endpoint {\n    case fetchUser(id: String)\n\n    var path: String { \n        switch self { \n        case .fetchUser(let id): return \"/users/\\(id)\"\n        }\n    }\n    var method: String { \"GET\" }\n\n    func asURLRequest() throws -> URLRequest { /* Builds request from path, method, etc. */ \n        let url = URL(string: \"https://api.example.com\" + path)!\n        return URLRequest(url: url)\n    }\n}\n\n// 2. Generic Network Client\nactor NetworkClient {\n    private let session = URLSession.shared\n\n    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {\n        let request = try endpoint.asURLRequest()\n        let (data, response) = try await session.data(for: request)\n        // Centralized response & error validation here...\n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Fat API Manager**: Creating a single `APIManager` class with a separate method for every API call. This becomes bloated and violates the Single Responsibility Principle.\n*   **Scattered Logic**: Building `URLRequest`s and parsing JSON directly within ViewModels or ViewControllers, leading to code duplication and making testing nearly impossible.\n*   **Inadequate Error Handling**: Not distinguishing between network errors (`URLError`), server-side HTTP errors (4xx, 5xx), and client-side decoding errors.\n\n**When to Use vs. Alternatives:**\n*   **Use**: For any app with more than a few API calls. The protocol-oriented approach makes it trivial to inject a mock client for unit testing.\n*   **Alternatives**: For very simple apps, a direct `URLSession` call might suffice. Libraries like Alamofire can handle the execution part, but it's still best practice to wrap them in this Endpoint/Client architecture to isolate the dependency and maintain a clean API contract within your app.",
      "code_example": null,
      "tags": [
        "networking",
        "architecture",
        "design patterns",
        "api",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Explain the lifecycle of a background `URLSession` task when the app is terminated by the system. How does the app reconnect to the session and handle completion events?",
      "back": "A background `URLSession` delegates network transfers to a separate system daemon (`nsurlsessiond`). This allows downloads or uploads to continue even if the app is suspended, crashes, or is terminated by the user or system.\n\n**Lifecycle & Reconnection Process:**\n1.  **Initiation:** You create a `URLSessionConfiguration.background(withIdentifier:)` with a unique identifier and a `URLSession` with a delegate. You cannot use completion handler-based APIs.\n2.  **Suspension/Termination:** Once a task is started, the system daemon manages it. If the app is terminated, the transfer continues in the background.\n3.  **Relaunch:** When all tasks for a given session identifier are complete (or if authentication is required), the system relaunches the app in the background.\n4.  **Re-association:** The `application(_:handleEventsForBackgroundURLSession:completionHandler:)` method in your `AppDelegate` is called. You must store the provided `completionHandler`.\n5.  **Session Recreation:** Inside this method, you must re-create the `URLSession` using the *exact same identifier*. This re-associates your app with the daemon's completed tasks, allowing your session delegate methods to be called.\n6.  **Delegate Callbacks:** The system then calls your delegate methods, like `urlSession(_:downloadTask:didFinishDownloadingTo:)` to process the downloaded file.\n7.  **Completion Signal:** Finally, `urlSessionDidFinishEvents(forBackgroundURLSession:)` is called on your session delegate. This is your signal to call the saved `completionHandler`, telling the OS you're done. The OS can then update the UI (e.g., app switcher snapshot) and safely suspend your app.\n\n```swift\n// In your AppDelegate or SceneDelegate\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {\n    // Store the completion handler to be called when all events are processed.\n    BackgroundSessionManager.shared.savedCompletionHandler = completionHandler\n}\n\n// A singleton to manage the background session\nclass BackgroundSessionManager: NSObject, URLSessionDelegate, URLSessionDownloadDelegate {\n    static let shared = BackgroundSessionManager()\n    var savedCompletionHandler: (() -> Void)?\n\n    private lazy var backgroundSession: URLSession = {\n        // The identifier MUST be the same across app launches.\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.myapp.background.session\")\n        config.isDiscretionary = true // Let the system optimize for performance, etc.\n        config.sessionSendsLaunchEvents = true\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n\n    func startDownload(url: URL) {\n        let task = backgroundSession.downloadTask(with: url)\n        task.resume()\n    }\n\n    // URLSessionDownloadDelegate method\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Handle the downloaded file at `location`\n        print(\"Download finished: \\(location.path)\")\n    }\n\n    // URLSessionDelegate method\n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        DispatchQueue.main.async {\n            // Call the saved completion handler\n            self.savedCompletionHandler?()\n            self.savedCompletionHandler = nil\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Forgetting the Completion Handler:** Failing to call the `completionHandler` from `urlSessionDidFinishEvents` tells the OS your app is still busy. This drains the battery and can cause the OS to throttle or terminate your app.\n*   **Using a Non-Unique Identifier:** The session identifier must be unique. Reusing identifiers improperly can lead to unpredictable behavior.\n*   **Using Completion Blocks:** Background sessions *require* a delegate. Using APIs like `dataTask(with:completionHandler:)` will result in an error.\n*   **Not Handling Re-instantiation:** Your code must be able to lazily re-create the `URLSession` with the correct identifier when the app is launched into the background.\n\n**When to Use vs. Alternatives:**\n*   **Use For:** Large file transfers (> 100MB) or critical uploads/downloads that must complete regardless of the app's state (e.g., video exports, podcast downloads).\n*   **Alternatives:** Use standard `URLSession` tasks for foreground operations. For short-lived tasks that need to complete after the app is backgrounded (a few seconds), use `UIApplication.beginBackgroundTask(withName:expirationHandler:)`.",
      "code_example": null,
      "tags": [
        "networking",
        "urlsession",
        "background",
        "concurrency",
        "appdelegate"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "Describe how you would architect a robust, reusable WebSocket client in a modern Swift app. Cover connection lifecycle management, message handling, and error recovery strategies.",
      "back": "A robust WebSocket client architecture abstracts the underlying `URLSessionWebSocketTask` into a dedicated manager class responsible for the entire connection lifecycle.\n\n**Core Concept:** The manager should encapsulate all logic for connecting, disconnecting, sending, and receiving messages. It must maintain and publish its connection state (e.g., `connecting`, `connected`, `disconnected`), allowing other parts of the app to react accordingly. Error handling is critical, especially for network interruptions, which should trigger a controlled reconnection strategy like exponential backoff to avoid overwhelming the server.\n\n**Code Example:**\n```swift\nclass WebSocketManager: NSObject, URLSessionWebSocketDelegate {\n    // Published state for UI observation\n    @Published var connectionState: String = \"Disconnected\"\n    private var webSocketTask: URLSessionWebSocketTask?\n    private var session: URLSession!\n\n    override init() {\n        super.init()\n        // Use a delegate queue to handle responses off the main thread\n        session = URLSession(configuration: .default, delegate: self, delegateQueue: OperationQueue())\n    }\n\n    func connect(url: URL) {\n        webSocketTask = session.webSocketTask(with: url)\n        webSocketTask?.resume()\n        connectionState = \"Connecting\"\n        listenForMessages()\n    }\n\n    func send(message: String) {\n        webSocketTask?.send(.string(message)) { error in\n            if let error = error {\n                print(\"WebSocket send error: \\(error.localizedDescription)\")\n            }\n        }\n    }\n\n    private func listenForMessages() {\n        webSocketTask?.receive { [weak self] result in\n            switch result {\n            case .success(let message):\n                // Handle message (e.g., decode JSON)\n                // ...\n                self?.listenForMessages() // Crucial: Listen for the next message\n            case .failure(let error):\n                print(\"WebSocket receive error: \\(error.localizedDescription)\")\n                self?.disconnect()\n            }\n        }\n    }\n\n    func disconnect() {\n        webSocketTask?.cancel(with: .goingAway, reason: nil)\n        connectionState = \"Disconnected\"\n    }\n\n    // MARK: - URLSessionWebSocketDelegate\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?) {\n        connectionState = \"Connected\"\n        // You can also schedule pings here to keep the connection alive\n    }\n\n    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?) {\n        connectionState = \"Disconnected\"\n        // Implement reconnection logic here\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting to re-call `receive()`:** The `receive` completion handler is only for a single message. You must call it again to listen for the next one.\n- **No Reconnection Strategy:** A simple `connect()` on failure can lead to a 'reconnection storm'. Use exponential backoff with jitter.\n- **Ignoring Keep-Alives:** Long-lived connections can be terminated by network intermediaries. `URLSessionWebSocketTask` sends pings automatically, but be aware of server-side timeout configurations.\n- **Blocking the Main Thread:** All `URLSession` delegate methods and completion handlers should run on a background queue. Dispatch any UI updates back to `DispatchQueue.main`.\n\n**When to Use vs. Alternatives:**\n- **Use WebSockets for:** True, low-latency, bidirectional communication (chat, live feeds, multiplayer games).\n- **Alternatives:**\n  - **Server-Sent Events (SSE):** For server-to-client-only streams (e.g., stock tickers, notifications).\n  - **HTTP Long-Polling:** A less efficient fallback for real-time updates when WebSockets are not supported.\n  - **Standard REST:** For client-initiated, state-less requests where real-time is not a requirement.",
      "code_example": null,
      "tags": [
        "networking",
        "websockets",
        "URLSession",
        "architecture",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Beyond performance gains, how do HTTP/2 and HTTP/3 fundamentally change network request strategies in iOS apps, and what `URLSession` considerations are required to leverage them?",
      "back": "HTTP/2 and HTTP/3 primarily change networking strategy by moving from managing multiple connections to leveraging a single, highly efficient one.\n\n### Core Concept\n**HTTP/1.1** suffered from head-of-line (HOL) blocking, where a slow request would block subsequent requests on the same TCP connection. The workaround was to open multiple connections (typically 6 per host), incurring significant TCP handshake and TLS negotiation overhead.\n\n**HTTP/2** introduced multiplexing, allowing multiple requests and responses to be interleaved over a single TCP connection. This eliminates HTTP-level HOL blocking and reduces connection overhead. For iOS apps, this means the old strategy of \"domain sharding\" (distributing assets across `img1.host.com`, `img2.host.com`, etc.) is now an anti-pattern that negates the benefits of H2's single connection.\n\n**HTTP/3** evolves this by replacing TCP with QUIC, a transport protocol built on UDP. This solves TCP-level HOL blocking. In HTTP/2, if a single TCP packet is lost, the entire connection (and all multiplexed streams) must wait for retransmission. With QUIC, packet loss only affects the specific stream it belongs to, which is a massive advantage on unreliable mobile networks.\n\n### Practical Code Example\nFor HTTP/2, `URLSession` requires no special configuration; it's enabled by default and will be used automatically if the server supports it.\n\n```swift\n// No special configuration is needed for HTTP/2. \n// URLSession negotiates it automatically via ALPN during the TLS handshake.\nlet url = URL(string: \"https://your-http2-enabled-server.com/api/data\")!\n\nURLSession.shared.dataTask(with: url) { data, response, error in\n    // The HTTPURLResponse object doesn't directly expose the protocol version,\n    // but network diagnostic tools can confirm H2 is being used.\n    guard let data = data else { return }\n    print(\"Received \\(data.count) bytes\")\n}.resume()\n\n// Note on HTTP/3: As of iOS 17, general-purpose URLSession support for H3 is not\n// yet available. To use it, you must integrate a third-party library like\n// Google's Cronet or a SwiftNIO-based implementation.\n```\n\n### Common Pitfalls\n*   **Domain Sharding:** Continuing to use domain sharding with an HTTP/2-enabled server is counter-productive. It forces multiple new connections, re-introducing the handshake overhead that H2 was designed to eliminate.\n*   **Ignoring Server Configuration:** An app cannot force the use of H2/H3. Its adoption is entirely dependent on the server's capabilities. Always verify server support.\n*   **Misunderstanding HOL Blocking:** Confusing HTTP-level HOL blocking (solved by H2) with TCP-level HOL blocking (solved by H3). This is a key distinction for diagnosing network performance issues.\n\n### When to Use vs. Alternatives\n*   **HTTP/2:** Use is the default and strongly recommended. Your `URLSession` code already supports it. The focus should be on ensuring your backend infrastructure supports it.\n*   **HTTP/3:** Pursue an H3 implementation for apps where low latency is critical, especially over lossy networks (e.g., real-time communication, video streaming, competitive gaming). For typical REST API consumption, the benefits may not outweigh the complexity of adding a third-party networking stack until it's natively and transparently supported by `URLSession`.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "urlsession",
        "performance"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}