{
  "topic": "networking",
  "generated_at": "2026-01-08T05:23:57.290846+00:00",
  "cards": [
    {
      "id": "networking_af7f793e90df",
      "front": "Describe advanced `URLSession` usage beyond basic data tasks. How do you handle background downloads/uploads, progress tracking, and cancellation? What are potential pitfalls?",
      "back": "`URLSession` offers much more than simple data retrieval. For background tasks, use `URLSessionConfiguration.background(withIdentifier:)`, which allows downloads/uploads to continue even when the app is suspended or terminated.  The system relaunches the app in the background to handle completion. `URLSessionDelegate` methods like `urlSession(_:downloadTask:didFinishDownloadingTo:)` are crucial here.\n\nProgress tracking is achieved through `URLSessionTaskDelegate`'s `urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)` for uploads and similar methods for downloads. Calculate the percentage complete from these values and update the UI accordingly.\n\nCancellation involves calling `task.cancel()`. For resumable downloads, `task.cancel(byProducingResumeData:)` is preferred. Store the resume data and use it to create a new download task later.\n\nHere's an example of a background download:\n\n```swift\nfunc startBackgroundDownload(url: URL) {\n    let config = URLSessionConfiguration.background(withIdentifier: \"bgDownload\")\n    let session = URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    let task = session.downloadTask(with: url)\n    task.resume()\n}\n\n//URLSessionDownloadDelegate\nfunc urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n    // Handle downloaded file\n}\n\nfunc urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n    if let error = error {\n        //Handle error\n    }\n}\n```\n\nCommon pitfalls:\n*   Forgetting to handle the delegate methods, especially `urlSession(_:task:didCompleteWithError:)`. Background sessions *require* a delegate.\n*   Not properly handling errors or resume data during cancellation.\n*   Incorrectly calculating progress, leading to inaccurate UI updates.\n*   Not understanding background execution limits. The system may terminate background tasks if they take too long.\n*   Not handling the app relaunch after background completion, resulting in data loss or unexpected behavior.\n\nAlternatives: While `URLSession` is the standard, libraries like Alamofire provide higher-level abstractions, simplifying common networking tasks and offering features like automatic retries and request validation. However, for advanced background tasks or fine-grained control, `URLSession` directly is often necessary. Using `Operation` queues with `URLSession` can also help manage concurrency and dependencies for complex networking workflows.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "background",
        "download",
        "upload",
        "delegate",
        "concurrency"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/optionals-in-swift-explained/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_88601ef8bf23",
      "front": "Explain HTTP/2 and HTTP/3.  What are the key improvements in each, and why are they important for modern iOS app development?",
      "back": "HTTP/2 improves performance over HTTP/1.1 by introducing: binary protocol (easier parsing), header compression (HPACK), multiplexing (multiple requests over single TCP), and server push (proactively sending resources).  This reduces latency and improves resource utilization.  HTTP/3 builds on this by using QUIC, a UDP-based transport protocol. QUIC solves head-of-line blocking at the TCP layer (where a lost packet blocks all subsequent packets on the same connection) by providing streams with independent loss recovery. It also provides built-in encryption and connection migration (seamlessly switching networks without re-establishing the connection).  For iOS apps, this means faster load times, better responsiveness, and improved user experience, especially on unreliable networks.  Multiplexing example: Imagine loading 10 images.  HTTP/1.1 would typically load them sequentially or with limited parallel connections, causing delays. HTTP/2 loads them concurrently over one connection.  Pitfalls:  Server support is required for both.  HTTP/3 adoption is still growing.  Incorrect server configuration can negate the benefits.  Prioritization misconfiguration can starve resources.  Example: `URLSession` automatically uses the best available protocol.  No code changes are usually required for HTTP/2.  For HTTP/3, ensure your server supports it and `URLSession` will negotiate it. While `URLSession` handles the protocol negotiation, understanding the underlying mechanisms allows for better debugging and optimization. Consider using tools like Wireshark to analyze network traffic and verify protocol usage.  Choosing between them depends on server support.  HTTP/3 is generally preferred when available due to its superior performance and resilience, but HTTP/2 is a significant improvement over HTTP/1.1 and widely supported.",
      "code_example": null,
      "tags": [
        "networking",
        "http",
        "performance",
        "urlsession",
        "quic"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_dcafb044d110",
      "front": "REST vs GraphQL",
      "back": "",
      "code_example": null,
      "tags": [
        "REST vs GraphQL"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "networking_3f3e4ac61fbf",
      "front": "How would you implement WebSocket communication in an iOS app, focusing on architecture, error handling, and testing?",
      "back": "WebSocket implementation involves several considerations.  First, the core concept: WebSockets provide full-duplex communication channels over a single TCP connection.  This contrasts with HTTP's request-response model, making WebSockets ideal for real-time applications.  For architecture, a dedicated `WebSocketManager` class (often a singleton) encapsulates WebSocket logic. This promotes reusability and separation of concerns.  Error handling is crucial. Implement delegate methods to handle connection opening/closing, message reception, and errors.  Use heartbeats (ping/pong frames) to detect broken connections.  Implement automatic reconnection with exponential backoff. Consider using a library like Starscream or SocketRocket for robust WebSocket handling; they abstract away much of the low-level complexity.  For testing, avoid direct network calls in unit tests.  Instead, create a `MockWebSocket` class that conforms to the WebSocket protocol.  Use dependency injection to inject this mock into your `WebSocketManager` during testing.  This allows you to simulate various scenarios (successful connection, connection failure, message reception, errors) without relying on a real WebSocket server.  A potential pitfall is neglecting proper thread management.  WebSocket delegate methods are often called on background threads.  Ensure UI updates are dispatched to the main thread.  Also, be mindful of memory leaks, especially when dealing with long-lived WebSocket connections.  Alternatives include Server-Sent Events (SSE), which are simpler but unidirectional.  For example:\n\n```swift\nimport Foundation\nimport Starscream\n\nclass WebSocketManager: WebSocketDelegate {\n    static let shared = WebSocketManager()\n    private var socket: WebSocket!\n    private var url: String = \"ws://example.com/socket\"\n\n    private init() {}\n\n    func connect() {\n        var request = URLRequest(url: URL(string: url)!) \n        request.timeoutInterval = 5 // Timeout\n        socket = WebSocket(request: request)\n        socket.delegate = self\n        socket.connect()\n    }\n\n    func disconnect() {\n        socket.disconnect()\n    }\n\n    func send(message: String) {\n        socket.write(string: message)\n    }\n\n    // MARK: - WebSocketDelegate\n\n    func didReceive(event: WebSocketEvent, client: WebSocket) {\n        switch event {\n        case .connected(let headers):\n            print(\"websocket is connected: \\(headers)\")\n        case .disconnected(let reason, let code):\n            print(\"websocket is disconnected: \\(reason) with code: \\(code)\")\n        case .text(let string):\n            print(\"Received text: \\(string)\")\n            // Handle received message\n        case .binary(let data):\n            print(\"Received data: \\(data.count)\")\n        case .ping(_):\n            break\n        case .pong(_):\n            break\n        case .viabilityChanged(_):\n            break\n        case .reconnectSuggested(_):\n            break\n        case .cancelled:\n            print(\"websocket is cancelled\")\n        case .error(let error):\n            print(\"websocket error: \\(String(describing: error))\")\n            // Handle error, potentially reconnect\n            reconnect()\n        case .peerClosed(let message):\n            print(\"Peer closed connection: \\(String(describing: message))\")\n        }\n    }\n\n    private func reconnect() {\n        // Implement exponential backoff\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {\n            self.connect()\n        }\n    }\n}\n```\n\nCommon mistakes include not handling disconnections gracefully and failing to implement proper error handling.  Also ensure your mock implementation covers various edge cases, such as slow connections or malformed messages.  When choosing between WebSockets and alternatives, consider the real-time requirements of your application. If only unidirectional data flow is needed, SSE might be a simpler option.  If compatibility with older browsers is a concern, consider using a fallback mechanism like long polling in addition to WebSockets.",
      "code_example": null,
      "tags": [
        "networking",
        "websockets",
        "architecture",
        "error handling",
        "testing",
        "realtime"
      ],
      "sources": [
        "https://www.objc.io/issues/2-concurrency/common-background-practices/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_6431b3cd68e4",
      "front": "Explain certificate pinning. Why and when would you use it in an iOS app for network security?",
      "back": "Certificate pinning is a security technique where an app, instead of blindly trusting any certificate signed by a trusted root CA, only trusts a specific set of certificates for a given domain. This prevents man-in-the-middle (MITM) attacks where an attacker presents a fraudulent certificate signed by a compromised or rogue CA.\n\nWhy use it?  The CA system is complex and vulnerable. A compromised CA can issue certificates for any domain. Pinning limits the trust to only your known, valid certificates.\n\nWhen to use it?  For apps handling sensitive data (banking, healthcare, etc.) where security is paramount. It adds a layer of defense against sophisticated attacks.\n\nExample:\n```swift\nimport Foundation\n\nclass CertificatePinning {\n    static func validate(challenge: URLAuthenticationChallenge, trust: SecTrust) -> Bool {\n        guard let serverCert = SecTrustGetCertificateAtIndex(trust, 0) else { return false }\n        \n        // Get certificate data as Data\n        let serverCertData = SecCertificateCopyData(serverCert) as Data\n        \n        // Hashes of your trusted certificates (SHA256 recommended)\n        let trustedCertificateHashes: [Data] = [\n            Data(base64Encoded: \"YOUR_CERTIFICATE_HASH_1\")!,\n            Data(base64Encoded: \"YOUR_CERTIFICATE_HASH_2\")!\n        ]\n\n        let serverCertHash = SHA256.hash(data: serverCertData)\n        \n        return trustedCertificateHashes.contains(serverCertHash)\n    }\n}\n\n// In your URLSession delegate:\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n    guard let trust = challenge.protectionSpace.serverTrust else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n\n    if CertificatePinning.validate(challenge: challenge, trust: trust) {\n        completionHandler(.useCredential, URLCredential(trust: trust))\n    } else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n}\n```\n\nCommon Pitfalls:\n*   **Certificate Rotation:**  Certificates expire. Implement a mechanism to update pinned certificates without requiring an app update.  Store multiple valid certs (current, next) to allow seamless rotation. Consider using a fallback mechanism (e.g., allowing the system trust store temporarily) if all pins fail, but log this occurrence.\n*   **Hash vs. Certificate:**  Pinning the entire certificate is easier to implement, but pinning the public key hash is more robust against certificate changes.  The example above uses certificate hash for simplicity.\n*   **Implementation Errors:** Incorrectly implementing pinning can lead to app failures or, worse, a false sense of security. Thorough testing is crucial.\n*   **Bypassing Pinning:** Attackers may try to bypass pinning by reverse engineering the app. Obfuscation and runtime integrity checks can help.\n\nAlternatives:\n*   **TrustKit:** An open-source framework that simplifies certificate pinning and provides automatic updates. It handles much of the complexity.\n*   **Default System Trust Store:** Relying solely on the system trust store is the default, but it's vulnerable to CA compromises.\n\nWhen *not* to use:  If the app doesn't handle sensitive data and the risk of MITM attacks is low, the added complexity of certificate pinning might not be justified.  However, it's generally a good practice for any app communicating over HTTPS.\nSwift Version: 5.5+",
      "code_example": null,
      "tags": [
        "networking",
        "security",
        "certificate pinning",
        "https",
        "URLSession"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "networking_431f69c77375",
      "front": "Explain background URLSession configurations and their use cases. What are the benefits and drawbacks compared to standard configurations? Show a basic setup.",
      "back": "Background URLSession configurations allow your app to perform networking tasks even when suspended or terminated.  The OS handles transfers in a separate process, waking your app (or relaunching it) when complete or requiring authentication.  This is crucial for tasks like uploading large files or downloading content for offline use. \n\n**Benefits:**\n*   Resilience: Transfers continue even if the app is suspended/terminated.\n*   Improved User Experience:  Long-running tasks don't block the main thread and can complete without the app needing to stay in the foreground.\n\n**Drawbacks:**\n*   More Complex Setup: Requires careful handling of delegate methods and state restoration.\n*   Limited Control:  You have less direct control over the transfer process once initiated.\n*   Data Serialization:  Data passed between your app and the background process must be serializable.\n\n**Use Cases:**\n*   Uploading photos/videos\n*   Downloading large assets (e.g., offline maps, podcasts)\n*   Syncing data with a server\n\n**Basic Setup (Swift):**\n\n```swift\n// 1. Create a background configuration\nlet identifier = \"com.example.backgroundTransfer\"\nlet config = URLSessionConfiguration.background(withIdentifier: identifier)\n\n// Optional configurations (adjust to your needs)\nconfig.sessionSendsLaunchEvents = true // App launched on completion\nconfig.isDiscretionary = true // Defer transfers for better performance\n\n// 2. Create a URLSession with the background configuration\nlet session = URLSession(configuration: config, delegate: self, delegateQueue: nil) // Delegate must be self\n\n// 3. Create a URL and request\nlet url = URL(string: \"https://example.com/largefile.zip\")!\nlet request = URLRequest(url: url)\n\n// 4. Create a download task\nlet task = session.downloadTask(with: request)\ntask.resume()\n```\n\n**Important Notes:**\n*   The `identifier` is used to re-associate with the session after the app is relaunched.\n*   The `delegate` is crucial for handling completion, errors, and authentication challenges. Implement the required `URLSessionDelegate`, `URLSessionTaskDelegate`, and `URLSessionDownloadDelegate` (or `URLSessionUploadDelegate`) methods.\n*   `sessionSendsLaunchEvents` determines if the system will launch your app in the background when tasks complete.\n*   The system may throttle background transfers to conserve power.  `isDiscretionary` allows the system to optimize transfer scheduling.\n\n**Common Pitfalls:**\n*   Forgetting to handle delegate methods properly, leading to lost data or unhandled errors.\n*   Not re-associating with the background session after app relaunch, causing tasks to be orphaned.\n*   Using non-serializable data in the session configuration or delegate methods.\n*   Assuming background transfers are immediate.  They are subject to system scheduling.\n\n**Alternatives:**\n*   Standard `URLSession` configurations are suitable for short-lived, interactive networking tasks that should be cancelled when the app is suspended.\n*   `NSBackgroundActivityScheduler` is for general background tasks, but it's less reliable for guaranteed transfers compared to background URLSession configurations.",
      "code_example": null,
      "tags": [
        "networking",
        "URLSession",
        "background",
        "concurrency"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/2-concurrency/common-background-practices/"
      ]
    },
    {
      "id": "networking_a38f04f89b89",
      "front": "Network layer architecture",
      "back": "",
      "code_example": null,
      "tags": [
        "Network layer architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    }
  ]
}