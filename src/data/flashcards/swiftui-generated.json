{
  "topic": "swiftui",
  "generated_at": "2026-01-13T04:04:10.582292+00:00",
  "cards": [
    {
      "id": "swiftui_4bd31d70cc62",
      "front": "Explain how SwiftUI translates a state change within a `withAnimation` block into a smooth visual transition. Detail the roles of `Transaction`, the `Animatable` protocol, and the view update cycle in this process.",
      "back": "SwiftUI's animation system is declarative and state-driven. When a state change occurs within a `withAnimation` block, SwiftUI doesn't animate the code; it creates a `Transaction` object. This transaction is a context that holds the animation's properties (e.g., duration, curve, delay) and is implicitly propagated down the view hierarchy during the subsequent re-render.\n\nHere's the process:\n1.  **Transaction Creation**: `withAnimation` creates a `Transaction` and associates it with any state changes happening inside its closure.\n2.  **View Update**: The state change invalidates the current view hierarchy, triggering a new `body` computation.\n3.  **Interpolation**: As SwiftUI renders the new view state, it compares the old and new values of view properties. If a property belongs to a type conforming to the `Animatable` protocol, SwiftUI uses the animation details from the ambient `Transaction` to interpolate between the start and end values of its `animatableData` property.\n4.  **Rendering**: The render server receives these interpolated values for each frame, re-rendering the view repeatedly to create a smooth visual transition.\n\nThe `Animatable` protocol is the key. It requires a computed property `animatableData` of a type that conforms to `VectorArithmetic` (like `CGFloat` or `AnimatablePair`). This is the data SwiftUI actually interpolates.\n\n```swift\n// A custom view modifier that animates a skew transformation.\nstruct SkewEffect: GeometryEffect {\n    var skew: CGFloat\n\n    // SwiftUI interpolates this value from its old to new state.\n    var animatableData: CGFloat {\n        get { skew }\n        set { skew = newValue }\n    }\n\n    func effectValue(size: CGSize) -> ProjectionTransform {\n        return ProjectionTransform(CGAffineTransform(a: 1, b: 0, c: animatableData, d: 1, tx: 0, ty: 0))\n    }\n}\n\nstruct ContentView: View {\n    @State private var isSkewed = false\n\n    var body: some View {\n        Text(\"Animate Me\")\n            .padding(50)\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .clipShape(RoundedRectangle(cornerRadius: 10))\n            .modifier(SkewEffect(skew: isSkewed ? 0.8 : 0))\n            .onTapGesture {\n                // This creates a Transaction that drives the SkewEffect's animatableData.\n                withAnimation(.easeInOut(duration: 1.0)) {\n                    isSkewed.toggle()\n                }\n            }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Animating non-animatable types**: Trying to animate a `Bool` to change a color will result in an instant change. The correct approach is to use an animatable proxy (e.g., a `CGFloat` from 0 to 1) and derive the color from it.\n*   **Misplacing the `.animation()` modifier**: Its position in the modifier chain is critical. An animation modifier only affects the modifiers placed *before* it.\n\n**When to Use vs. Alternatives:**\n*   **`withAnimation` (Explicit)**: Use when a single user action needs to orchestrate animations across multiple, potentially disconnected views. It provides precise control over the transaction.\n*   **`.animation(_:value:)` (Implicit)**: The preferred modern approach for simple animations. It ties an animation to a specific piece of state (`value`), preventing it from running due to unrelated state changes, which is a common bug with the older `.animation()` modifier.",
      "code_example": null,
      "tags": [
        "swiftui",
        "animation",
        "architecture",
        "internals"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_fce609cc67b5",
      "front": "How does SwiftUI's `Layout` protocol enable custom layout containers, and what are the performance implications and trade-offs compared to using built-in stacks like `HStack` or `Grid`?",
      "back": "The `Layout` protocol, introduced in iOS 16, provides the fundamental building blocks for creating custom, reusable layout containers beyond the standard `HStack`, `VStack`, and `Grid`.\n\n**Core Concept:**\nTo create a custom layout, you conform to the `Layout` protocol and implement two essential methods:\n1.  `sizeThatFits(proposal:subviews:cache:)`: You calculate and return the total size your container needs, given a `ProposedViewSize` and access to its subviews. This is where you measure your children to determine your own geometry.\n2.  `placeSubviews(in:proposal:subviews:cache:)`: After the system determines the final size for your container, this method is called. You iterate through the subviews and assign each one an explicit position within the container's bounds using `view.place(at:anchor:proposal:)`.\nThe `cache` parameter in both methods is crucial for performance, allowing you to store and retrieve intermediate calculations to avoid redundant work during a single layout update.\n\n**Practical Code Example (Simple Flow Layout):**\n```swift\nstruct FlowLayout: Layout {\n    var spacing: CGFloat = 8\n\n    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {\n        // A production implementation would calculate the required height based on wrapping.\n        // For brevity, we use the proposed size.\n        return proposal.replacingUnspecifiedDimensions()\n    }\n\n    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {\n        var currentX = bounds.minX\n        var currentY = bounds.minY\n        var lineHeight: CGFloat = 0\n\n        for view in subviews {\n            let viewSize = view.sizeThatFits(.unspecified)\n            // If view overflows, wrap to the next line\n            if currentX + viewSize.width > bounds.maxX {\n                currentX = bounds.minX\n                currentY += lineHeight + spacing\n                lineHeight = 0\n            }\n            // Place the view at its calculated position\n            view.place(at: CGPoint(x: currentX, y: currentY), anchor: .topLeading, proposal: .unspecified)\n\n            // Advance the coordinates for the next view\n            currentX += viewSize.width + spacing\n            lineHeight = max(lineHeight, viewSize.height)\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n-   **Performance:** The layout methods can be called frequently. Avoid any expensive computations. Heavy logic or failure to use the `cache` for things like pre-calculated subview sizes can severely degrade UI performance.\n-   **Ignoring Proposals:** Not respecting the `ProposedViewSize` can lead to your layout being clipped or improperly sized within the parent view.\n-   **Laziness:** `Layout` is not inherently lazy. It measures and places all its subviews at once, making it unsuitable for very large, dynamic data sets where a `LazyVStack` would be more appropriate.\n\n**When to Use vs. Alternatives:**\n-   **Use `Layout` for:** Truly custom arrangements that are impossible with standard containers, such as radial/circular layouts, masonry grids, or layouts based on mathematical functions.\n-   **Use `HStack`/`VStack` for:** Standard, one-dimensional layouts. They are highly optimized and much simpler to implement.\n-   **Use `Grid` for:** Two-dimensional layouts where items align in both rows and columns. `Grid` is powerful but more constrained than a custom `Layout`.",
      "code_example": null,
      "tags": [
        "swiftui",
        "layout",
        "custom-layout",
        "performance",
        "architecture"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_5db790af102a",
      "front": "When creating a reusable style in SwiftUI, when should you implement a custom `ViewModifier` vs. simply extending `View` with a helper function? Discuss the implications for state, composition, and reusability.",
      "back": "A `ViewModifier` is a protocol that transforms a view, acting as a blueprint for a specific, reusable modification. It's the foundation for SwiftUI's declarative syntax; built-in modifiers like `.padding()` and `.font()` are implemented using this pattern.\n\n**Core Concept:**\nThe `ViewModifier` protocol requires a `body(content: Content) -> some View` function, where `content` is the view being modified. This encapsulates styling and behavior into a distinct, reusable type. In contrast, a simple `View` extension is just a convenience function that chains together existing modifiers.\n\n**Practical Example:**\n\n```swift\n// 1. The custom ViewModifier struct encapsulates the logic.\nstruct TitleStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.largeTitle.bold())\n            .foregroundStyle(.primary)\n            .padding(.bottom, 4)\n    }\n}\n\n// 2. A convenience extension provides a clean, ergonomic call-site.\nextension View {\n    func titleStyle() -> some View {\n        self.modifier(TitleStyle())\n    }\n}\n\n// Usage:\nstruct MyView: View {\n    var body: some View {\n        Text(\"Hello, Senior Dev!\")\n            .titleStyle() // Clean and declarative\n    }\n}\n```\n\n**When to use `ViewModifier`:**\n- **Statefulness:** A `ViewModifier` is a `struct` and can have its own `@State`, `@GestureState`, or other property wrappers. This is impossible in a `View` extension's function. Use it for modifiers that need to manage their own internal state (e.g., a custom hover effect).\n- **Animatable Properties:** By conforming to `AnimatableModifier`, you can interpolate custom values over time, enabling complex animations that a simple extension cannot achieve.\n- **Complex Logic:** When the modification involves significant logic or a large number of combined modifiers, encapsulating it in a `ViewModifier` improves organization and reusability.\n\n**When to use a `View` extension:**\n- **Simplicity & Convenience:** For a simple, stateless combination of 2-3 modifiers, a direct extension is less boilerplate and more straightforward.\n- **Example:** `extension View { func asCard() -> some View { self.padding().background(Color.secondarySystemBackground).cornerRadius(10) } }`\n\n**Common Pitfalls:**\n- **Over-engineering:** Creating a `ViewModifier` for a trivial style (e.g., just setting a font and color) is often overkill.\n- **Forgetting the Extension:** Applying modifiers with `.modifier(MyModifier())` is verbose. Always provide a clean extension for better ergonomics.",
      "code_example": null,
      "tags": [
        "swiftui",
        "viewmodifier",
        "architecture",
        "composition"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_cddc3f3f2aa5",
      "front": "Explain your decision-making process for choosing among `@State`, `@StateObject`, `@ObservedObject`, and `@EnvironmentObject` in SwiftUI, focusing on data ownership, scope, and the source of truth.",
      "back": "My decision hinges on two questions: 1) What is the data's scope? and 2) Which view owns the data's lifecycle?\n\n**Core Concept:**\nState management in SwiftUI is about establishing a single source of truth and propagating changes. The choice of property wrapper defines the relationship between a view and its data.\n\n- **`@State`**: For simple, transient value types (Structs, Enums, simple values) that are owned and managed by a single view. This is for local UI state, like a toggle's `isOn` status or a text field's content. The view owns the data's storage.\n\n- **`@StateObject`**: For reference types (`ObservableObject`) that are owned and created by a view. SwiftUI ensures the object's lifecycle is tied to the view's identity, persisting across redraws. This is the primary source of truth for a complex data model or view model.\n\n- **`@ObservedObject`**: For observing a reference type that a view receives but does not own. The object is created elsewhere (e.g., by a parent view with `@StateObject`) and passed in. The view is a subscriber, not an owner.\n\n- **`@EnvironmentObject`**: A form of dependency injection for sharing an `ObservableObject` with a deep hierarchy of views without manual prop-drilling. An ancestor view owns the object (often with `@StateObject`) and places it in the environment.\n\n**Practical Code Example:**\n```swift\n// 1. Shared data model (Source of Truth)\nclass UserSettings: ObservableObject {\n    @Published var fontSize: Double = 14.0\n}\n\n// 2. Root view owns the settings object with @StateObject\nstruct RootView: View {\n    @StateObject private var settings = UserSettings()\n\n    var body: some View {\n        ContentView()\n            .environmentObject(settings) // Inject into the environment\n    }\n}\n\n// 3. A view that consumes the shared settings\nstruct ContentView: View {\n    @EnvironmentObject var settings: UserSettings\n    @State private var isShowingSheet = false // Local, view-specific state\n\n    var body: some View {\n        VStack {\n            Text(\"Hello, World!\").font(.system(size: settings.fontSize))\n            Button(\"Show Settings\") { isShowingSheet = true }\n        }\n        .sheet(isPresented: $isShowingSheet) {\n            // Pass the observed object to a child that doesn't need the environment\n            SettingsSheet(settings: settings)\n        }\n    }\n}\n\n// 4. A child view that observes a passed-in object\nstruct SettingsSheet: View {\n    @ObservedObject var settings: UserSettings // Receives an existing object\n\n    var body: some View {\n        Slider(value: $settings.fontSize, in: 12...24)\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Incorrectly using `@ObservedObject` for creation**: Never initialize an object inside a view and assign it to `@ObservedObject` (e.g., `@ObservedObject var model = MyModel()`). The view's redraws will re-create the object, losing its state. Use `@StateObject` for creation and ownership.\n- **Overusing `@EnvironmentObject`**: While powerful, it creates implicit dependencies that can make views harder to test and reason about. Reserve it for truly global, environmental state like authentication status, themes, or app settings.\n\n**When to use vs. Alternatives:**\n- Use this hierarchy for most SwiftUI apps. For highly complex state interactions, especially in large teams, consider a more structured pattern like The Composable Architecture (TCA). TCA enforces unidirectional data flow and makes dependencies explicit, improving testability at the cost of more boilerplate.",
      "code_example": null,
      "tags": [
        "swiftui",
        "state management",
        "architecture",
        "observableobject",
        "source of truth"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_52087b03c6db",
      "front": "Describe how SwiftUI determines whether to destroy/recreate a view versus updating it. What role does the `.id()` modifier play, and when is its explicit use crucial for correctness and performance?",
      "back": "SwiftUI's view lifecycle is fundamentally tied to the concept of **view identity**. A `View` in SwiftUI is a lightweight struct describing a piece of UI. When state changes, SwiftUI re-evaluates the `body` property, creating a new view description tree. It then diffs this new tree against the previous one to determine the minimal set of changes needed for the UI.\n\n**Core Concept: Identity**\nSwiftUI uses two types of identity to track views across these updates:\n1.  **Structural Identity**: Based on the view's type and its position within the view hierarchy. For example, in an `if/else` block, the view in the `if` branch has a different structural identity from the view in the `else` branch. When the condition changes, SwiftUI destroys the old view (and its state) and creates the new one.\n2.  **Explicit Identity**: Manually assigned by the developer. This is most common in `ForEach` loops (via the `id:` parameter on `Identifiable` data) or by using the `.id()` modifier on any view. Explicit identity overrides structural identity.\n\nIf a view's identity remains the same between two rendering passes, SwiftUI considers it to be the same view. It will update its properties but preserve its underlying state (e.g., variables marked with `@State` or `@StateObject`). If the identity changes, the old view is considered gone, its state is destroyed, and a new view with new state is created.\n\n**Code Example: Using `.id()` to Reset State**\nThe `.id()` modifier is a powerful tool for controlling this lifecycle. A common use case is to force a view to be completely recreated, thereby resetting its state.\n\n```swift\nstruct ResettableTextField: View {\n    // This ID controls the identity of the VStack below.\n    @State private var viewId = UUID()\n    \n    // State *inside* the view whose identity we control.\n    @State private var text: String = \"\"\n\n    var body: some View {\n        VStack(spacing: 20) {\n            // When viewId changes, this entire VStack is destroyed and recreated.\n            // This is because its explicit identity has changed.\n            VStack {\n                Text(\"Enter your name:\")\n                TextField(\"Name\", text: $text)\n                    .textFieldStyle(.roundedBorder)\n            }\n            .id(viewId) // Assigning an explicit identity.\n\n            Button(\"Reset\") {\n                // Creating a new UUID changes the identity, forcing a redraw.\n                viewId = UUID()\n            }\n        }\n        .padding()\n    }\n}\n```\n\n**Common Pitfalls**\n*   **Misusing `ForEach` IDs**: Using an array index `ForEach(0..<items.count, id: \\.self)` for data that can be reordered or have items deleted. This causes SwiftUI to map the wrong data to views, leading to visual bugs and crashes. Always use a stable identifier from your data model (e.g., `ForEach(items, id: \\.stableID)`).\n*   **Unintentional State Destruction**: Placing stateful views inside `if/else` or `switch` statements can inadvertently destroy and recreate them, losing user input or scroll position. Sometimes, using modifiers like `.opacity()` or `.disabled()` to change a view's appearance without altering its identity is a better approach.\n\n**When to Use `.id()` vs. Alternatives**\n*   **Use `.id()`**: When you need to programmatically force a view and all its associated state (`@State`, `@StateObject`) to be reset to their initial values. It's also crucial for ensuring correct animations and transitions when replacing one piece of data with another in the same view structure (e.g., navigating between user profiles in a detail view).\n*   **Alternatives (Manual Reset)**: You could create a `reset()` function in a view model that manually clears all properties. This is more verbose but can be clearer for complex state logic. Using `.id()` is a more declarative, \"SwiftUI-native\" approach for resetting view-specific state.",
      "code_example": null,
      "tags": [
        "swiftui",
        "lifecycle",
        "performance",
        "state-management",
        "identity"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_0c71a581d980",
      "front": "A child view needs to communicate its dynamic size to a distant ancestor for layout adjustments. How can you achieve this in a declarative, SwiftUI-native way without using `GeometryReader` in the ancestor or passing down complex binding closures?",
      "back": "SwiftUI's data flow is primarily top-down. `PreferenceKey` is a powerful mechanism to communicate values from a descendant view back up to an ancestor, enabling bottom-up data flow, which is ideal for layout-dependent information.\n\n### Core Concept\nA `PreferenceKey` is a protocol with two requirements:\n1.  `defaultValue`: A static property that provides a starting value.\n2.  `reduce(value: &inout Value, nextValue: () -> Value)`: A static function that combines values from multiple sibling views. This is crucial because multiple children might set the same preference. You decide how to combine them (e.g., choose the max, sum them, or append to an array).\n\nThe child view uses `.preference(key:value:)` to set a value. This value travels up the hierarchy. An ancestor view can then read this value using `.onPreferenceChange(_:perform:)` to react to changes or `.background()`/`.overlay()` to use the value in its layout.\n\n### Practical Code Example\nHere, a child `TitleView` reports its height to the parent `ContentView`, which displays it.\n\n```swift\n// 1. Define the PreferenceKey\nstruct TitleHeightPreferenceKey: PreferenceKey {\n    // The type of value to propagate\n    typealias Value = CGFloat\n    // Default if no view sets a value\n    static var defaultValue: CGFloat = 0\n    \n    // Combine values from multiple children. Here, we only care about one title,\n    // but using max() is a robust way to handle potential duplicates.\n    static func reduce(value: &CGFloat, nextValue: () -> CGFloat) {\n        value = max(value, nextValue())\n    }\n}\n\n// 2. The child view that sets the preference\nstruct TitleView: View {\n    var body: some View {\n        Text(\"Dynamically Sized Title\")\n            .font(.largeTitle)\n            .padding()\n            // Use a GeometryReader *inside an overlay/background* on the child\n            // to avoid altering the parent's layout.\n            .background(GeometryReader { geometry in\n                Color.clear.preference(\n                    key: TitleHeightPreferenceKey.self,\n                    value: geometry.size.height\n                )\n            })\n    }\n}\n\n// 3. The ancestor view that reads the preference\nstruct ContentView: View {\n    @State private var titleHeight: CGFloat = 0\n\n    var body: some View {\n        VStack {\n            Text(\"Title Height: \\(titleHeight, specifier: \"%.2f\")\")\n                .padding()\n                .background(Color.yellow)\n            \n            TitleView()\n            \n            Spacer()\n        }\n        // Read the preference value and update state\n        .onPreferenceChange(TitleHeightPreferenceKey.self) { height in\n            self.titleHeight = height\n        }\n    }\n}\n```\n\n### Common Pitfalls\n*   **Incorrect `reduce` Logic:** A common mistake is simply assigning `value = nextValue()`. This can discard values from other siblings. The logic must correctly combine all values as needed for your specific use case (e.g., `+`, `max`, `min`).\n*   **Misplacing `GeometryReader`:** Wrapping the *parent* view in a `GeometryReader` to measure a child can alter the layout proposals and cause unexpected behavior. The correct pattern is for the child to measure itself using a background or overlay.\n*   **Timing:** Preference values are updated as part of the SwiftUI view update cycle. Relying on them synchronously can be problematic. Use `.onPreferenceChange` for a clean, asynchronous update.\n\n### When to Use vs. Alternatives\n*   **Use `PreferenceKey`:** For communicating layout-related data (size, anchor points, position) up the view hierarchy in a decoupled way. It's the most idiomatic SwiftUI solution for this problem.\n*   **Alternatives:**\n    *   **Callback Closures/Bindings:** Passing a closure or `Binding` down to the child works but creates tighter coupling. The parent and child are now explicitly aware of each other. `PreferenceKey` is more of a broadcast that any ancestor can listen to.\n    *   **`@EnvironmentObject`:** Overkill for simple value propagation and introduces a dependency on a shared object throughout a large part of the view hierarchy.",
      "code_example": null,
      "tags": [
        "swiftui",
        "data flow",
        "layout",
        "view hierarchy"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "swiftui_57b904137e80",
      "front": "How does the @Observable macro change SwiftUI's observation mechanism compared to ObservableObject, and what are the key benefits and trade-offs?",
      "back": "The `@Observable` macro, introduced in iOS 17, fundamentally modernizes SwiftUI's state management by shifting from a coarse-grained to a fine-grained observation model.\n\n**Core Concept Explanation:**\n\n`ObservableObject` is a protocol from the Combine framework. When a property marked with `@Published` changes, the object's `objectWillChange` publisher fires. Any view observing this object (e.g., via `@StateObject` or `@ObservedObject`) is notified that *something* changed, causing its entire `body` to be re-evaluated. This is inefficient if a view only depends on a subset of the object's properties, as it leads to unnecessary UI updates.\n\n`@Observable` is a Swift macro that automatically synthesizes observation capabilities. It doesn't use `@Published`. Instead, it tracks which specific properties are accessed within a view's `body` at render time. When a property's value is mutated, SwiftUI knows precisely which views depend on that specific property and re-renders only them. This property-level dependency tracking drastically improves performance by minimizing view invalidations.\n\n**Practical Code Example:**\n```swift\n// New: iOS 17+ with @Observable\n@Observable\nclass UserProfile {\n    var name = \"Alex\"\n    var score = 0\n}\n\n// Old: Pre-iOS 17 with ObservableObject\nclass LegacyUserProfile: ObservableObject {\n    @Published var name = \"Alex\"\n    @Published var score = 0\n}\n\nstruct ProfileView: View {\n    @State private var profile = UserProfile()\n\n    var body: some View {\n        VStack {\n            // This view only depends on `name`\n            NameView(name: profile.name)\n\n            // This view only depends on `score`\n            ScoreView(score: profile.score)\n\n            Button(\"Increment Score\") {\n                profile.score += 1 // With @Observable, only ScoreView re-renders.\n                                   // With ObservableObject, both would re-render.\n            }\n        }\n    }\n}\n\nstruct NameView: View {\n    let name: String\n    var body: some View {\n        let _ = print(\"NameView updated\")\n        Text(\"Name: \\(name)\")\n    }\n}\n\nstruct ScoreView: View {\n    let score: Int\n    var body: some View {\n        let _ = print(\"ScoreView updated\")\n        Text(\"Score: \\(score)\")\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Backwards Compatibility:** `@Observable` requires iOS 17 / macOS 14 / watchOS 10 or newer. For projects supporting older OS versions, you must continue using `ObservableObject`.\n2.  **Migration:** Migrating involves replacing `class C: ObservableObject` with `@Observable class C` and removing all `@Published` wrappers. Forgetting to remove `@Published` can lead to unexpected behavior as it will not trigger UI updates in an `@Observable` class.\n3.  **Concurrency:** `@Observable` classes are not inherently thread-safe. If properties are mutated from a background thread, you must still ensure UI updates are dispatched to the main actor, for example by marking the class with `@MainActor`.\n\n**When to Use vs. Alternatives:**\n*   **`@Observable`**: The default choice for all new reference-type state models in apps targeting iOS 17+. It's more performant, requires less boilerplate, and is the future-proof direction for SwiftUI.\n*   **`ObservableObject`**: Use only when you need to support OS versions prior to iOS 17 or when integrating with existing Combine-heavy codebases that rely on the `objectWillChange` publisher explicitly.",
      "code_example": null,
      "tags": [
        "swiftui",
        "state management",
        "performance",
        "macros",
        "ios17"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    }
  ]
}