{
  "topic": "memory-management",
  "title": "Memory Management & Runtime Behavior",
  "description": "Deep understanding of ARC, retain cycles, and memory debugging",
  "cards": [
    {
      "id": "memory_001",
      "front": "Your payment app crashes with out-of-memory after 3-4 transaction attempts. Walk through your exact debugging process using Instruments.",
      "back": "**Memory Debugging Workflow:**\n\n**Step 1: Reproduce with Instruments**\n```bash\n# Profile with Allocations instrument\nProduct → Profile → Allocations\n```\n\n**Step 2: Identify Growth Pattern**\n- Enable \"Record Reference Counts\"\n- Mark generations after each transaction\n- Look for objects that grow but never shrink\n\n**Step 3: Analyze Allocations**\n```\nAllocations → Statistics → Sort by \"Persistent Bytes\"\n\nLook for:\n- UIImage instances accumulating\n- Data objects not released\n- View controllers not deallocated\n- Closures holding strong references\n```\n\n**Step 4: Memory Graph Debugger**\n```\nDebug → Debug Memory Graph (while app running)\n\nLook for:\n- Purple \"!\" warnings (retain cycles)\n- Objects with unexpected retain count\n- Click object → see all references\n```\n\n**Common Payment App Issues:**\n\n**1. Closure Retain Cycle:**\n```swift\n// BAD\nclass PaymentProcessor {\n    var onComplete: (() -> Void)?\n    \n    func process() {\n        PaymentAPI.charge { result in\n            self.handleResult(result) // Strong capture!\n            self.onComplete?()\n        }\n    }\n}\n\n// GOOD\nfunc process() {\n    PaymentAPI.charge { [weak self] result in\n        self?.handleResult(result)\n        self?.onComplete?()\n    }\n}\n```\n\n**2. Delegate Retain Cycle:**\n```swift\n// BAD\nprotocol PaymentDelegate: AnyObject { }\nclass PaymentSheet {\n    var delegate: PaymentDelegate? // Should be weak!\n}\n\n// GOOD\nweak var delegate: PaymentDelegate?\n```\n\n**3. Timer Not Invalidated:**\n```swift\n// BAD\nclass TransactionMonitor {\n    var timer: Timer?\n    \n    func start() {\n        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n            self.checkStatus() // Retains self!\n        }\n    }\n}\n\n// GOOD\nfunc start() {\n    timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in\n        self?.checkStatus()\n    }\n}\n\ndeinit {\n    timer?.invalidate()\n}\n```\n\n**Step 5: Verify Fix**\n- Run Memory Graph again\n- Confirm objects deallocate\n- Run Leaks instrument\n- Test 10+ transactions",
      "tags": ["memory", "instruments", "debugging", "retain-cycles", "allocations"],
      "sources": ["https://developer.apple.com/documentation/xcode/gathering-information-about-memory-use"],
      "summary": "Use Allocations to track growth, Memory Graph for retain cycles. Common causes: closure strong self, non-weak delegates, timers not invalidated."
    },
    {
      "id": "memory_002",
      "front": "Explain when to use weak vs unowned. You have a ViewController with a retained closure that captures self—which should you use?",
      "back": "**weak vs unowned:**\n\n**weak:**\n- Reference becomes `nil` when object deallocates\n- Always optional (`weak var x: T?`)\n- Safe - no crashes\n- Small performance overhead (zeroing)\n\n**unowned:**\n- Reference becomes dangling when object deallocates\n- Non-optional (`unowned var x: T`)\n- **Crashes if accessed after dealloc**\n- Slightly faster (no zeroing)\n\n**Decision Framework:**\n\n```swift\n// Use WEAK when:\n// - The captured object might be deallocated before closure runs\n// - Async operations (network, timers, animations)\n// - You're not 100% sure about lifetimes\n\nclass ViewController: UIViewController {\n    func loadData() {\n        // WEAK: Network call might complete after VC dismissed\n        APIClient.fetch { [weak self] data in\n            self?.updateUI(data) // Safe if self is nil\n        }\n    }\n}\n```\n\n```swift\n// Use UNOWNED when:\n// - You're 100% certain the object outlives the closure\n// - The closure is synchronous or owned by self\n// - Parent-child relationships where child can't exist without parent\n\nclass NetworkRequest {\n    let url: URL\n    \n    lazy var urlRequest: URLRequest = { [unowned self] in\n        // UNOWNED OK: lazy var can't be accessed after self deallocs\n        var request = URLRequest(url: self.url)\n        return request\n    }()\n}\n```\n\n**ViewController + Closure Answer:**\n\n```swift\n// ALWAYS use WEAK for ViewControllers!\nclass PaymentViewController: UIViewController {\n    var processor: PaymentProcessor?\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // User might dismiss VC before payment completes\n        processor?.onComplete = { [weak self] result in\n            guard let self else { return }\n            self.showResult(result)\n        }\n    }\n}\n```\n\n**Why weak for VCs:**\n1. User can dismiss anytime (navigation, swipe)\n2. Parent VC might be deallocated\n3. Async operations common\n4. Safety > tiny performance gain\n\n**When unowned is safe:**\n```swift\nclass Parent {\n    lazy var child: Child = Child(parent: self)\n}\n\nclass Child {\n    unowned let parent: Parent // Child can't exist without parent\n}\n```",
      "tags": ["weak", "unowned", "retain-cycles", "closures", "arc"],
      "sources": ["https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/"],
      "summary": "Use weak for async/uncertain lifetimes (always for VCs). Use unowned only when 100% certain object outlives closure. When in doubt, use weak."
    },
    {
      "id": "memory_003",
      "front": "What's the difference between stack and heap allocation? How does this affect performance and memory usage?",
      "back": "**Stack vs Heap Allocation:**\n\n**Stack:**\n```swift\nfunc processData() {\n    let x = 42           // Stack: Int is value type\n    let point = CGPoint(x: 1, y: 2)  // Stack: struct\n    let array = [1, 2, 3] // Stack pointer, heap buffer\n}\n// All stack memory freed instantly when function returns\n```\n\n- **Allocation:** Instant (just move stack pointer)\n- **Deallocation:** Instant (just move pointer back)\n- **Location:** Contiguous, cache-friendly\n- **Thread safety:** Each thread has own stack\n- **Size:** Limited (~1MB on iOS)\n\n**Heap:**\n```swift\nclass User {\n    var name: String\n    init(name: String) { self.name = name }\n}\n\nlet user = User(name: \"John\") // Heap: class instance\n// Reference counting, dealloc when count reaches 0\n```\n\n- **Allocation:** Slower (find free memory, bookkeeping)\n- **Deallocation:** Slower (reference counting, fragmentation)\n- **Location:** Scattered, less cache-friendly\n- **Thread safety:** Shared, needs synchronization\n- **Size:** Large (limited by device RAM)\n\n**Performance Comparison:**\n\n| Operation | Stack | Heap |\n|-----------|-------|------|\n| Allocate | ~1 instruction | 100s of instructions |\n| Access | Cache-friendly | Cache misses likely |\n| Thread safety | Free | Needs locks/atomic ops |\n| Copy | Bit-by-bit (fast for small) | Reference copy (fast) |\n\n**Swift Type Allocation:**\n\n```swift\n// VALUE TYPES (usually stack)\nstruct Point { var x, y: Double }  // Stack\nlet numbers = [1, 2, 3]  // Stack pointer + heap buffer\nenum State { case loading, loaded }  // Stack\n\n// REFERENCE TYPES (always heap)\nclass ViewModel { }  // Heap\nlet closure = { print(\"hi\") }  // Heap (closures are reference types)\n```\n\n**Why Value Types Are Safer in Concurrency:**\n```swift\n// Value type: each task gets independent copy\nstruct Counter {\n    var count = 0\n}\n\nvar counter = Counter()\n\n// No race condition - each task has its own copy\nTask { var local = counter; local.count += 1 }\nTask { var local = counter; local.count += 1 }\n```\n\n```swift\n// Reference type: shared mutable state = danger\nclass Counter {\n    var count = 0  // RACE CONDITION!\n}\n```\n\n**Optimization Tips:**\n1. Prefer structs for small data models\n2. Use `final class` to avoid vtable overhead\n3. Avoid unnecessary heap allocations in tight loops\n4. Use `ContiguousArray` for performance-critical arrays",
      "tags": ["stack", "heap", "value-types", "reference-types", "performance"],
      "sources": ["https://developer.apple.com/swift/blog/?id=10"],
      "summary": "Stack: fast, automatic, thread-local, limited size. Heap: slower, reference counted, shared. Value types often stack, classes always heap."
    },
    {
      "id": "memory_004",
      "front": "A user's feed becomes sluggish after 5 minutes of scrolling, memory climbs from 150MB to 500MB. What patterns would you investigate?",
      "back": "**Diagnosing Scroll Performance + Memory Growth:**\n\n**Suspect 1: Cell Reuse Issues**\n```swift\n// BAD: Creating new views in cellForRowAt\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = PostCell() // NEW cell every time! Never reused\n    return cell\n}\n\n// GOOD: Dequeue reusable cells\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"PostCell\", for: indexPath) as! PostCell\n    cell.configure(with: posts[indexPath.row])\n    return cell\n}\n\n// Check: prepareForReuse clears state\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    imageView.image = nil  // Clear previous image!\n    imageView.cancelImageLoad() // Cancel pending request\n}\n```\n\n**Suspect 2: Image Caching Problems**\n```swift\n// BAD: Images cached indefinitely\nclass ImageCache {\n    static var cache: [URL: UIImage] = [:]  // Never cleared!\n}\n\n// GOOD: Use NSCache (auto-evicts on memory pressure)\nclass ImageCache {\n    static let shared = NSCache<NSURL, UIImage>()\n    \n    init() {\n        shared.countLimit = 100\n        shared.totalCostLimit = 50 * 1024 * 1024 // 50MB\n    }\n}\n\n// BETTER: Use SDWebImage/Kingfisher with memory limits\nimageView.sd_setImage(with: url, placeholderImage: placeholder)\n```\n\n**Suspect 3: Observers Not Removed**\n```swift\n// BAD: Observer never removed\nclass PostCell: UITableViewCell {\n    func configure(with post: Post) {\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(handleUpdate),\n            name: .postUpdated,\n            object: nil\n        ) // Adds observer EVERY configure call!\n    }\n}\n\n// GOOD: Remove in prepareForReuse\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    NotificationCenter.default.removeObserver(self)\n}\n```\n\n**Suspect 4: Retain Cycles in Cells**\n```swift\n// BAD: Strong reference in closure\nclass PostCell: UITableViewCell {\n    var onLike: (() -> Void)?\n    \n    func configure(with post: Post, viewModel: FeedViewModel) {\n        onLike = {\n            viewModel.like(post)  // Strong capture!\n        }\n    }\n}\n\n// GOOD: Capture list\nonLike = { [weak viewModel] in\n    viewModel?.like(post)\n}\n```\n\n**Debugging Steps:**\n\n1. **Instruments → Allocations:**\n   - Filter by \"PostCell\", \"UIImage\"\n   - Check if count keeps increasing\n\n2. **Memory Graph:**\n   - Look for multiple instances of same cell type\n   - Check retain cycles (purple warnings)\n\n3. **Add logging:**\n```swift\nclass PostCell: UITableViewCell {\n    static var instanceCount = 0\n    \n    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        Self.instanceCount += 1\n        print(\"PostCell instances: \\(Self.instanceCount)\")\n    }\n    \n    deinit {\n        Self.instanceCount -= 1\n        print(\"PostCell instances: \\(Self.instanceCount)\")\n    }\n}\n```",
      "tags": ["uitableview", "cell-reuse", "image-caching", "memory-leak", "scrolling"],
      "sources": ["https://developer.apple.com/documentation/uikit/uitableview/1614891-dequeuereusablecell"],
      "summary": "Check: cell reuse (dequeue), prepareForReuse clearing state, NSCache for images, observers removed, no retain cycles in closures."
    },
    {
      "id": "memory_005",
      "front": "Explain autorelease pools in Swift. When would you need to manually create one?",
      "back": "**Autorelease Pools in Swift:**\n\n**What is it?**\nAutorelease pools defer object deallocation until the pool is drained. In Objective-C/Swift interop, objects are often autoreleased instead of immediately deallocated.\n\n**Default Behavior:**\n```swift\n// Main run loop has implicit autorelease pool\n// Each run loop iteration drains the pool\nfunc applicationDidFinishLaunching() {\n    // Autoreleased objects collected at end of run loop\n}\n```\n\n**When to Use Manual Pool:**\n\n**1. Loops Creating Many Temporary Objects:**\n```swift\n// BAD: Memory spikes during loop\nfunc processImages() {\n    for i in 0..<10000 {\n        let image = UIImage(named: \"photo_\\(i)\") // Autoreleased\n        let data = image?.pngData() // More autoreleased objects\n        saveToFile(data, index: i)\n    }\n    // All 10000 images stay in memory until function returns!\n}\n\n// GOOD: Drain pool periodically\nfunc processImages() {\n    for i in 0..<10000 {\n        autoreleasepool {\n            let image = UIImage(named: \"photo_\\(i)\")\n            let data = image?.pngData()\n            saveToFile(data, index: i)\n        } // Memory freed here!\n    }\n}\n```\n\n**2. Background Threads Without Run Loop:**\n```swift\n// Background threads don't have automatic pools\nDispatchQueue.global().async {\n    autoreleasepool {\n        // Any Objective-C bridging here needs a pool\n        let data = NSData(contentsOf: url)\n        process(data)\n    }\n}\n```\n\n**3. Command-Line Tools:**\n```swift\n// No UIKit run loop, need manual pool\n@main\nstruct MyTool {\n    static func main() {\n        autoreleasepool {\n            // Tool code here\n        }\n    }\n}\n```\n\n**Measuring Impact:**\n```swift\nfunc benchmark() {\n    let start = CFAbsoluteTimeGetCurrent()\n    var peakMemory: UInt64 = 0\n    \n    // Without autoreleasepool\n    for i in 0..<10000 {\n        let _ = UIImage(named: \"test\")\n        peakMemory = max(peakMemory, currentMemoryUsage())\n    }\n    print(\"Without pool - Peak: \\(peakMemory / 1024 / 1024)MB\")\n    \n    // With autoreleasepool\n    peakMemory = 0\n    for i in 0..<10000 {\n        autoreleasepool {\n            let _ = UIImage(named: \"test\")\n            peakMemory = max(peakMemory, currentMemoryUsage())\n        }\n    }\n    print(\"With pool - Peak: \\(peakMemory / 1024 / 1024)MB\")\n}\n```\n\n**When NOT Needed:**\n- Pure Swift code (no Obj-C bridging)\n- Modern Swift APIs that don't use autorelease\n- Short-lived operations on main thread\n\n**Rule of Thumb:**\nUse `autoreleasepool` in loops that:\n1. Create many UIKit/Foundation objects\n2. Process images or large data\n3. Run on background threads",
      "tags": ["autoreleasepool", "memory", "loops", "objc-interop"],
      "sources": ["https://developer.apple.com/documentation/swift/autoreleasepool(_:)"],
      "summary": "Use autoreleasepool in loops creating many objects (images, data), on background threads, or command-line tools. Drains memory immediately instead of waiting for run loop."
    }
  ]
}
