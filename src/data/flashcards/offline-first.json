{
  "topic": "offline-first",
  "title": "Offline-First Architecture & Data Sync",
  "description": "Critical for fintech and consumer apps - handle connectivity gracefully",
  "cards": [
    {
      "id": "offline_001",
      "front": "Design an offline-first news app where users can read articles offline and sync reading progress when back online. How do you handle conflicting edits?",
      "back": "**Offline-First News App Architecture:**\n\n**Data Layer:**\n```swift\n// Local-first with sync metadata\nstruct Article: Codable {\n    let id: UUID\n    var title: String\n    var content: String\n    var isRead: Bool\n    var readProgress: Double\n    var localModifiedAt: Date  // For conflict detection\n    var serverModifiedAt: Date?\n    var syncStatus: SyncStatus\n}\n\nenum SyncStatus: String, Codable {\n    case synced, pendingUpload, conflict\n}\n```\n\n**Sync Strategy (Last-Write-Wins with Merge):**\n```swift\nclass SyncManager {\n    func sync() async throws {\n        // 1. Push local changes\n        let pending = try await localDB.fetchPendingChanges()\n        for item in pending {\n            do {\n                let serverItem = try await api.push(item)\n                if serverItem.serverModifiedAt > item.localModifiedAt {\n                    // Conflict! Server was modified after our local change\n                    try await resolveConflict(local: item, server: serverItem)\n                } else {\n                    try await localDB.markSynced(item.id)\n                }\n            } catch {\n                // Keep as pending, retry later\n            }\n        }\n        \n        // 2. Pull server changes\n        let lastSync = UserDefaults.lastSyncTimestamp\n        let serverChanges = try await api.fetchChanges(since: lastSync)\n        try await localDB.merge(serverChanges)\n    }\n    \n    func resolveConflict(local: Article, server: Article) async throws {\n        // For reading progress: take the maximum (user read further)\n        let merged = Article(\n            id: local.id,\n            title: server.title,  // Server wins for content\n            content: server.content,\n            isRead: local.isRead || server.isRead,  // OR merge\n            readProgress: max(local.readProgress, server.readProgress),\n            localModifiedAt: Date(),\n            serverModifiedAt: server.serverModifiedAt,\n            syncStatus: .pendingUpload\n        )\n        try await localDB.save(merged)\n    }\n}\n```\n\n**Key Patterns:**\n1. **Local-first reads** - Always read from local DB\n2. **Background sync** - Sync when connectivity available\n3. **Optimistic UI** - Update UI immediately, sync later\n4. **Conflict resolution** - Domain-specific merge strategies",
      "tags": ["offline-first", "sync", "conflict-resolution", "architecture"],
      "sources": ["https://developer.apple.com/documentation/coredata/mirroring_a_core_data_store_with_cloudkit"],
      "summary": "Local-first reads, background sync, optimistic UI. Conflict resolution: last-write-wins or domain-specific merge (max progress, OR for booleans)."
    },
    {
      "id": "offline_002",
      "front": "Your payment app needs to support offline transactions that sync when connectivity returns. What are the security and consistency implications?",
      "back": "**Offline Payment Architecture:**\n\n**Security Concerns:**\n1. **Double-spend prevention** - Can't verify balance offline\n2. **Transaction tampering** - Local data could be modified\n3. **Replay attacks** - Same transaction submitted multiple times\n\n**Solution: Cryptographically Signed Pending Transactions**\n```swift\nstruct OfflineTransaction {\n    let id: UUID\n    let amount: Decimal\n    let merchantId: String\n    let timestamp: Date\n    let deviceId: String\n    let signature: Data  // Signed with device key\n    let nonce: String    // Prevent replay\n    \n    // Limit offline transactions\n    static let maxOfflineAmount: Decimal = 100\n    static let maxOfflineCount = 5\n}\n\nclass OfflinePaymentManager {\n    private let keychain: KeychainService\n    private let localDB: LocalDatabase\n    \n    func createOfflineTransaction(amount: Decimal, merchant: String) throws -> OfflineTransaction {\n        // 1. Check offline limits\n        let pendingTotal = try localDB.pendingTransactionsTotal()\n        guard pendingTotal + amount <= Self.maxOfflineAmount else {\n            throw PaymentError.offlineLimitExceeded\n        }\n        \n        // 2. Create and sign transaction\n        let txn = OfflineTransaction(\n            id: UUID(),\n            amount: amount,\n            merchantId: merchant,\n            timestamp: Date(),\n            deviceId: UIDevice.current.identifierForVendor!.uuidString,\n            signature: Data(), // Placeholder\n            nonce: UUID().uuidString\n        )\n        \n        let signature = try keychain.sign(txn.dataToSign)\n        var signedTxn = txn\n        signedTxn.signature = signature\n        \n        // 3. Store locally\n        try localDB.saveTransaction(signedTxn)\n        return signedTxn\n    }\n    \n    func syncTransactions() async throws {\n        let pending = try localDB.fetchPendingTransactions()\n        \n        for txn in pending {\n            let result = try await api.submitTransaction(txn)\n            switch result {\n            case .success:\n                try localDB.markCompleted(txn.id)\n            case .duplicateNonce:\n                // Already processed, mark as complete\n                try localDB.markCompleted(txn.id)\n            case .insufficientFunds:\n                // Transaction failed, notify user\n                try localDB.markFailed(txn.id, reason: .insufficientFunds)\n            case .invalidSignature:\n                // Security issue!\n                try localDB.markFailed(txn.id, reason: .securityError)\n            }\n        }\n    }\n}\n```\n\n**Consistency Guarantees:**\n- **Idempotency** via nonce - Same transaction can't be submitted twice\n- **Offline limits** - Cap risk exposure\n- **Server validation** - Final authority on balance\n- **Eventual consistency** - UI shows pending state until confirmed",
      "tags": ["offline", "payments", "security", "fintech", "idempotency"],
      "sources": ["https://stripe.com/docs/payments/payment-intents"],
      "summary": "Signed transactions with nonce for idempotency. Offline limits cap risk. Server is final authority. Show pending state in UI until confirmed."
    },
    {
      "id": "offline_003",
      "front": "What's the difference between optimistic updates and pessimistic updates in offline-first architecture? When would you use each?",
      "back": "**Optimistic vs Pessimistic Updates:**\n\n**Optimistic Updates:**\n```swift\n// Update UI immediately, sync in background\nfunc likePost(_ post: Post) {\n    // 1. Update UI immediately\n    post.isLiked = true\n    post.likeCount += 1\n    updateUI()\n    \n    // 2. Sync in background\n    Task {\n        do {\n            try await api.likePost(post.id)\n        } catch {\n            // 3. Rollback on failure\n            post.isLiked = false\n            post.likeCount -= 1\n            updateUI()\n            showError(\"Failed to like post\")\n        }\n    }\n}\n```\n\n**Pessimistic Updates:**\n```swift\n// Wait for server confirmation before updating UI\nfunc transferMoney(amount: Decimal, to account: String) async {\n    // 1. Show loading state\n    showLoading()\n    \n    do {\n        // 2. Wait for server confirmation\n        let result = try await api.transfer(amount: amount, to: account)\n        \n        // 3. Update UI only after success\n        updateBalance(result.newBalance)\n        showSuccess(\"Transfer complete\")\n    } catch {\n        showError(\"Transfer failed\")\n    }\n}\n```\n\n**Comparison:**\n\n| Aspect | Optimistic | Pessimistic |\n|--------|------------|-------------|\n| **UX** | Instant, responsive | Slower, shows loading |\n| **Complexity** | Higher (rollback logic) | Lower |\n| **Data integrity** | Risk of inconsistency | Always consistent |\n| **Offline support** | Excellent | Poor |\n| **Conflict handling** | Required | Not needed |\n\n**When to Use Each:**\n\n**Optimistic:**\n- Social actions (likes, follows, comments)\n- Non-critical data (reading progress, preferences)\n- Frequently used actions where speed matters\n- Actions that rarely fail\n\n**Pessimistic:**\n- Financial transactions\n- Irreversible actions (delete account)\n- Critical data modifications\n- Actions requiring server-side validation\n- Multi-step workflows\n\n**Hybrid Approach:**\n```swift\n// Optimistic for display, pessimistic for persistence\nfunc addToCart(_ item: Item) {\n    // Optimistic UI\n    cart.items.append(item)\n    updateCartBadge()\n    \n    // Pessimistic persistence\n    Task {\n        let confirmed = try await api.addToCart(item.id)\n        if !confirmed {\n            cart.items.removeLast()\n            showError(\"Item unavailable\")\n        }\n    }\n}\n```",
      "tags": ["optimistic-updates", "pessimistic-updates", "offline-first", "ux"],
      "sources": ["https://tanstack.com/query/latest/docs/react/guides/optimistic-updates"],
      "summary": "Optimistic: instant UI, rollback on failure - use for social/non-critical. Pessimistic: wait for server - use for financial/irreversible."
    },
    {
      "id": "offline_004",
      "front": "Design the data persistence layer for an offline-first app. Would you use Core Data, Realm, or SQLite? Justify your choice.",
      "back": "**Database Comparison for Offline-First:**\n\n**Core Data:**\n```swift\n// Pros: Native, CloudKit sync, NSFetchedResultsController\n@objc(Article)\nclass Article: NSManagedObject {\n    @NSManaged var id: UUID\n    @NSManaged var title: String\n    @NSManaged var syncStatus: String\n}\n\n// CloudKit sync built-in\nlet container = NSPersistentCloudKitContainer(name: \"Model\")\n```\n- **Pros:** Native Apple, free CloudKit sync, memory efficient, mature\n- **Cons:** Steep learning curve, verbose, main thread issues\n- **Best for:** Apps with iCloud sync, complex relationships\n\n**Realm:**\n```swift\n// Pros: Simple API, reactive, cross-platform\nclass Article: Object {\n    @Persisted(primaryKey: true) var id: UUID\n    @Persisted var title: String\n    @Persisted var syncStatus: SyncStatus\n}\n\n// Reactive queries\nlet articles = realm.objects(Article.self)\nlet token = articles.observe { changes in\n    // Auto-updates!\n}\n```\n- **Pros:** Simple API, reactive, fast, cross-platform\n- **Cons:** Large binary size (~10MB), vendor lock-in\n- **Best for:** Real-time apps, cross-platform (KMM)\n\n**SQLite (GRDB/SQLite.swift):**\n```swift\n// Pros: Full SQL control, lightweight\nstruct Article: Codable, FetchableRecord, PersistableRecord {\n    var id: UUID\n    var title: String\n    var syncStatus: String\n}\n\ntry dbQueue.write { db in\n    try Article(id: UUID(), title: \"Test\", syncStatus: \"pending\")\n        .insert(db)\n}\n```\n- **Pros:** Full SQL control, tiny footprint, portable\n- **Cons:** More boilerplate, no built-in sync\n- **Best for:** Apps needing SQL, small footprint, migrations\n\n**Recommendation by Use Case:**\n\n| Use Case | Recommendation |\n|----------|----------------|\n| iCloud sync needed | Core Data + CloudKit |\n| Cross-platform (Android) | Realm or SQLite |\n| Complex queries | SQLite (GRDB) |\n| Real-time UI updates | Realm |\n| Minimal dependencies | SQLite |\n| Enterprise/Banking | Core Data or SQLite |\n\n**My Pick for Offline-First:** **GRDB (SQLite)** - Full control over sync logic, lightweight, excellent migration support, no vendor lock-in.",
      "tags": ["core-data", "realm", "sqlite", "persistence", "offline-first"],
      "sources": ["https://github.com/groue/GRDB.swift", "https://realm.io/"],
      "summary": "Core Data for iCloud sync. Realm for simplicity/cross-platform. SQLite/GRDB for full control and lightweight. Pick based on sync needs."
    },
    {
      "id": "offline_005",
      "front": "Describe how you'd implement a conflict resolution strategy for a collaborative note-taking app where users can edit offline and later encounter conflicting changes.",
      "back": "**Conflict Resolution for Collaborative Notes:**\n\n**Strategy Options:**\n\n**1. Last-Write-Wins (Simple but lossy)**\n```swift\nfunc resolve(local: Note, server: Note) -> Note {\n    return local.modifiedAt > server.modifiedAt ? local : server\n}\n// Problem: Loses one version entirely\n```\n\n**2. Three-Way Merge (Git-style)**\n```swift\nstruct NoteVersion {\n    let content: String\n    let modifiedAt: Date\n    let baseVersion: String  // Common ancestor\n}\n\nfunc threeWayMerge(base: String, local: String, server: String) -> MergeResult {\n    let localDiff = diff(base, local)\n    let serverDiff = diff(base, server)\n    \n    if localDiff.conflicts(with: serverDiff) {\n        return .conflict(local: local, server: server)\n    }\n    return .merged(apply(localDiff + serverDiff, to: base))\n}\n```\n\n**3. Operational Transformation (Real-time)**\n```swift\n// Used by Google Docs\nenum Operation {\n    case insert(position: Int, text: String)\n    case delete(position: Int, length: Int)\n}\n\nfunc transform(_ op1: Operation, _ op2: Operation) -> Operation {\n    // Adjust positions based on concurrent operations\n}\n```\n\n**4. CRDTs (Conflict-Free Replicated Data Types)**\n```swift\n// Best for offline-first\nstruct TextCRDT {\n    var characters: [CRDTChar]\n    \n    struct CRDTChar: Comparable {\n        let id: LamportTimestamp\n        let char: Character\n        let isDeleted: Bool\n    }\n    \n    mutating func insert(_ char: Character, after: LamportTimestamp) {\n        // Insertion is deterministic regardless of order\n    }\n    \n    mutating func merge(with other: TextCRDT) {\n        // Merge is commutative and idempotent\n        characters = (characters + other.characters)\n            .sorted()\n            .uniqued(by: \\.id)\n    }\n}\n```\n\n**Practical Implementation:**\n```swift\nclass NoteConflictResolver {\n    func resolve(_ conflict: NoteConflict) -> ResolvedNote {\n        switch conflict.type {\n        case .titleOnly:\n            // Last-write-wins for title\n            return conflict.newer\n            \n        case .contentOnly:\n            // Try auto-merge\n            if let merged = tryAutoMerge(conflict) {\n                return merged\n            }\n            // Fall back to user choice\n            return .needsUserInput(conflict)\n            \n        case .both:\n            // Show conflict UI\n            return .needsUserInput(conflict)\n        }\n    }\n    \n    func tryAutoMerge(_ conflict: NoteConflict) -> ResolvedNote? {\n        // If changes are in different paragraphs, auto-merge\n        let localChanges = detectChangedParagraphs(conflict.base, conflict.local)\n        let serverChanges = detectChangedParagraphs(conflict.base, conflict.server)\n        \n        if localChanges.isDisjoint(with: serverChanges) {\n            return mergeNonOverlapping(conflict)\n        }\n        return nil\n    }\n}\n```\n\n**Best Practice:** Use CRDTs for text (Yjs, Automerge libraries), show conflict UI for complex cases, prefer auto-merge when possible.",
      "tags": ["crdt", "conflict-resolution", "collaboration", "sync", "offline"],
      "sources": ["https://crdt.tech/", "https://www.yjs.dev/"],
      "summary": "LWW is simple but lossy. Three-way merge for Git-style. CRDTs for automatic conflict-free sync. Show UI for unresolvable conflicts."
    }
  ]
}
