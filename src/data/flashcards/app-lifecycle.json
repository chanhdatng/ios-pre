{
  "topic": "app-lifecycle",
  "title": "Application Lifecycle & System Integration",
  "description": "Understanding iOS app states, scene lifecycle, and system callbacks",
  "cards": [
    {
      "id": "lifecycle_001",
      "front": "Explain all lifecycle states for a scene-based iOS app. What tasks can you safely perform in each state?",
      "back": "**iOS Scene Lifecycle States:**\n\n```\n                    ┌─────────────┐\n                    │ Unattached  │\n                    └──────┬──────┘\n                           │ scene(_:willConnectTo:)\n                    ┌──────▼──────┐\n                    │ Foreground  │\n                    │  Inactive   │\n                    └──────┬──────┘\n                           │ sceneDidBecomeActive\n                    ┌──────▼──────┐\n              ┌─────│ Foreground  │─────┐\n              │     │   Active    │     │\n              │     └─────────────┘     │\n              │                         │\n    sceneWillResignActive    sceneDidEnterBackground\n              │                         │\n    ┌─────────▼─────────┐    ┌─────────▼─────────┐\n    │    Foreground     │    │    Background     │\n    │     Inactive      │    │                   │\n    └───────────────────┘    └─────────┬─────────┘\n                                       │\n                              ┌────────▼────────┐\n                              │   Suspended     │\n                              └─────────────────┘\n```\n\n**Safe Tasks by State:**\n\n| State | Safe Tasks | Avoid |\n|-------|------------|-------|\n| **Active** | All UI updates, user interaction, animations, network calls | N/A |\n| **Inactive** | Pause ongoing tasks, save state | Start new tasks, heavy processing |\n| **Background** | Finish critical tasks (5s), save data, schedule background tasks | UI updates, new network calls |\n| **Suspended** | Nothing - app is frozen | N/A |\n\n**Code Example:**\n```swift\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    func sceneDidBecomeActive(_ scene: UIScene) {\n        // Resume tasks, refresh data\n        refreshContent()\n        resumeAnimations()\n    }\n    \n    func sceneWillResignActive(_ scene: UIScene) {\n        // Pause tasks, save state\n        pauseGame()\n        saveUserProgress()\n    }\n    \n    func sceneDidEnterBackground(_ scene: UIScene) {\n        // Save data, release shared resources\n        // You have ~5 seconds!\n        saveToCoreData()\n        releaseMemory()\n        \n        // Request more time if needed\n        var backgroundTask: UIBackgroundTaskIdentifier = .invalid\n        backgroundTask = UIApplication.shared.beginBackgroundTask {\n            UIApplication.shared.endBackgroundTask(backgroundTask)\n        }\n    }\n    \n    func sceneWillEnterForeground(_ scene: UIScene) {\n        // Undo background changes\n        checkForUpdates()\n    }\n}\n```\n\n**Key Points:**\n- Inactive state happens during alerts, control center, app switcher\n- Background gives ~5 seconds for critical work\n- Use `beginBackgroundTask` for extended background time\n- UI updates in background will be ignored/crash",
      "tags": ["lifecycle", "scene-delegate", "background", "foreground"],
      "sources": ["https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle"],
      "summary": "Active: full access. Inactive: pause tasks. Background: 5s for critical work. Suspended: frozen. Use beginBackgroundTask for extended time."
    },
    {
      "id": "lifecycle_002",
      "front": "Your app uses Face ID for authentication. When a user switches to another app and returns, the biometric prompt disappears. Debug this issue.",
      "back": "**Face ID Disappearing on App Switch - Root Cause:**\n\nWhen app enters background, the system **cancels** pending Local Authentication prompts for security.\n\n**The Problem:**\n```swift\n// This gets cancelled when app backgrounds\nfunc authenticate() {\n    let context = LAContext()\n    context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics,\n                          localizedReason: \"Unlock app\") { success, error in\n        // Never called if user switches apps!\n    }\n}\n```\n\n**Debugging Steps:**\n\n1. **Check error code:**\n```swift\ncontext.evaluatePolicy(...) { success, error in\n    if let laError = error as? LAError {\n        switch laError.code {\n        case .systemCancel:\n            print(\"System cancelled - app went to background\")\n        case .userCancel:\n            print(\"User cancelled\")\n        case .appCancel:\n            print(\"App called invalidate()\")\n        default:\n            print(\"Other error: \\(laError)\")\n        }\n    }\n}\n```\n\n2. **Check lifecycle:**\n```swift\nfunc sceneWillResignActive(_ scene: UIScene) {\n    // LA prompt will be cancelled here!\n}\n```\n\n**Solution: Re-prompt on Return**\n```swift\nclass AuthManager {\n    private var pendingAuth = false\n    private let context = LAContext()\n    \n    func authenticate() {\n        pendingAuth = true\n        performAuth()\n    }\n    \n    private func performAuth() {\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics,\n                              localizedReason: \"Unlock app\") { [weak self] success, error in\n            DispatchQueue.main.async {\n                self?.pendingAuth = false\n                if success {\n                    self?.onAuthSuccess()\n                } else if let error = error as? LAError,\n                          error.code == .systemCancel {\n                    // Will retry when app returns to foreground\n                } else {\n                    self?.onAuthFailure(error)\n                }\n            }\n        }\n    }\n    \n    func handleAppDidBecomeActive() {\n        if pendingAuth {\n            // Re-trigger authentication\n            performAuth()\n        }\n    }\n}\n\n// In SceneDelegate\nfunc sceneDidBecomeActive(_ scene: UIScene) {\n    AuthManager.shared.handleAppDidBecomeActive()\n}\n```\n\n**Best Practice:**\n- Track authentication state\n- Listen for `sceneDidBecomeActive`\n- Re-prompt if auth was interrupted\n- Consider a brief delay before re-prompting",
      "tags": ["face-id", "local-authentication", "lifecycle", "debugging"],
      "sources": ["https://developer.apple.com/documentation/localauthentication/laerror"],
      "summary": "System cancels Face ID when app backgrounds (LAError.systemCancel). Track pending state, re-trigger auth in sceneDidBecomeActive."
    },
    {
      "id": "lifecycle_003",
      "front": "Handle this scenario: app is terminated by the system during a critical operation (payment processing, file upload). How would you recover gracefully on next launch?",
      "back": "**Recovering from Unexpected Termination:**\n\n**Strategy: Transaction Log + Resume Token**\n\n```swift\n// 1. Persist operation state BEFORE starting\nstruct PendingOperation: Codable {\n    let id: UUID\n    let type: OperationType\n    let payload: Data\n    let startedAt: Date\n    let resumeToken: String?  // Server-provided\n    var status: OperationStatus\n}\n\nenum OperationStatus: String, Codable {\n    case started, inProgress, awaitingConfirmation, completed, failed\n}\n\nclass OperationRecoveryManager {\n    private let storage = UserDefaults.standard\n    private let storageKey = \"pending_operations\"\n    \n    // Called BEFORE starting critical operation\n    func registerOperation(_ op: PendingOperation) throws {\n        var pending = loadPendingOperations()\n        pending.append(op)\n        try savePendingOperations(pending)\n    }\n    \n    // Called on app launch\n    func recoverPendingOperations() async {\n        let pending = loadPendingOperations()\n        \n        for operation in pending {\n            switch operation.type {\n            case .payment:\n                await recoverPayment(operation)\n            case .fileUpload:\n                await recoverUpload(operation)\n            }\n        }\n    }\n    \n    private func recoverPayment(_ op: PendingOperation) async {\n        // 1. Check server status first\n        let serverStatus = await api.checkPaymentStatus(op.id)\n        \n        switch serverStatus {\n        case .completed:\n            // Payment went through! Update local state\n            markCompleted(op.id)\n            notifyUser(\"Payment successful\")\n            \n        case .failed:\n            markFailed(op.id)\n            notifyUser(\"Payment failed - please retry\")\n            \n        case .notFound:\n            // Never reached server - safe to retry\n            if let resumeToken = op.resumeToken {\n                await retryWithToken(op, token: resumeToken)\n            } else {\n                await retryFromStart(op)\n            }\n            \n        case .pending:\n            // Still processing - wait and check again\n            scheduleRecheck(op)\n        }\n    }\n}\n\n// 2. App Delegate setup\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(_ application: UIApplication,\n                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        Task {\n            await OperationRecoveryManager.shared.recoverPendingOperations()\n        }\n        return true\n    }\n}\n```\n\n**For File Uploads - Use Background URL Session:**\n```swift\nclass UploadManager {\n    lazy var backgroundSession: URLSession = {\n        let config = URLSessionConfiguration.background(withIdentifier: \"com.app.upload\")\n        config.isDiscretionary = false\n        config.sessionSendsLaunchEvents = true  // Wake app on completion\n        return URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }()\n    \n    func upload(file: URL) {\n        let task = backgroundSession.uploadTask(with: request, fromFile: file)\n        task.resume()\n        // This continues even if app is terminated!\n    }\n}\n\n// In AppDelegate\nfunc application(_ application: UIApplication,\n                 handleEventsForBackgroundURLSession identifier: String,\n                 completionHandler: @escaping () -> Void) {\n    // System wakes app to handle completed upload\n    UploadManager.shared.backgroundCompletionHandler = completionHandler\n}\n```\n\n**Key Principles:**\n1. **Persist before starting** - Write operation to disk first\n2. **Idempotency** - Server operations must be safe to retry\n3. **Server as source of truth** - Always check server status on recovery\n4. **Background sessions** - For uploads/downloads that survive termination",
      "tags": ["recovery", "persistence", "background-tasks", "reliability"],
      "sources": ["https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background"],
      "summary": "Persist operation state before starting. On launch, check server status. Use background URL sessions for uploads. Ensure server operations are idempotent."
    },
    {
      "id": "lifecycle_004",
      "front": "Design how your app should respond to a low memory warning. What specific objects would you deallocate?",
      "back": "**Handling Low Memory Warnings:**\n\n**Detection Methods:**\n```swift\n// 1. UIApplicationDelegate\nfunc applicationDidReceiveMemoryWarning(_ application: UIApplication) {\n    handleMemoryWarning()\n}\n\n// 2. NotificationCenter\nNotificationCenter.default.addObserver(\n    self,\n    selector: #selector(handleMemoryWarning),\n    name: UIApplication.didReceiveMemoryWarningNotification,\n    object: nil\n)\n\n// 3. UIViewController\noverride func didReceiveMemoryWarning() {\n    super.didReceiveMemoryWarning()\n    // Clear view-specific caches\n}\n```\n\n**What to Deallocate (Priority Order):**\n\n```swift\nclass MemoryManager {\n    @objc func handleMemoryWarning() {\n        // 1. IMAGE CACHES (Highest impact)\n        ImageCache.shared.removeAll()\n        SDImageCache.shared.clearMemory()\n        URLCache.shared.removeAllCachedResponses()\n        \n        // 2. REUSABLE DATA STRUCTURES\n        precomputedLayouts.removeAll()\n        cellHeightCache.removeAll()\n        \n        // 3. OFF-SCREEN VIEW CONTROLLERS\n        // Release views of non-visible VCs\n        for vc in navigationController?.viewControllers ?? [] {\n            if vc.view.window == nil {\n                vc.view = nil  // Force view to be recreated later\n            }\n        }\n        \n        // 4. UNDO HISTORY\n        undoManager?.removeAllActions()\n        \n        // 5. LARGE DATA BUFFERS\n        videoBuffer = nil\n        audioBuffer = nil\n        \n        // 6. PRELOADED CONTENT\n        preloadedArticles.removeAll()\n        prefetchedImages.removeAll()\n        \n        // Log for debugging\n        print(\"Memory warning handled. Freed caches.\")\n    }\n}\n```\n\n**Smart Image Cache:**\n```swift\nclass ImageCache {\n    private let cache = NSCache<NSString, UIImage>()\n    \n    init() {\n        // Auto-respond to memory pressure\n        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB\n        \n        NotificationCenter.default.addObserver(\n            forName: UIApplication.didReceiveMemoryWarningNotification,\n            object: nil,\n            queue: .main\n        ) { [weak self] _ in\n            self?.cache.removeAllObjects()\n        }\n    }\n}\n```\n\n**What NOT to Deallocate:**\n- User's unsaved data\n- Authentication tokens\n- Critical state (current document)\n- Small caches that are expensive to rebuild\n\n**Testing:**\n```swift\n// Simulate memory warning in tests\nUIApplication.shared.perform(\n    Selector((\"_performMemoryWarning\"))\n)\n\n// Or use Instruments → Simulate Memory Warning\n```\n\n**Best Practice:** Use NSCache (auto-evicts on memory pressure) instead of Dictionary for caches.",
      "tags": ["memory-warning", "memory-management", "nscache", "optimization"],
      "sources": ["https://developer.apple.com/documentation/foundation/nscache"],
      "summary": "Deallocate: image caches, URL caches, off-screen views, undo history, preloaded content. Keep: unsaved data, auth, critical state. Use NSCache."
    },
    {
      "id": "lifecycle_005",
      "front": "Your app provides offline reading. After a system-initiated background refresh, sometimes content is incomplete. What specific background task limitations would you consider?",
      "back": "**Background Refresh Limitations:**\n\n**Time Limits:**\n| Task Type | Time Limit | Notes |\n|-----------|------------|-------|\n| Background App Refresh | ~30 seconds | System-initiated |\n| Background Task (beginBackgroundTask) | ~30 seconds | After app backgrounds |\n| Background Processing | Minutes | Requires BGProcessingTaskRequest |\n| Background URL Session | Unlimited | For downloads/uploads only |\n\n**Common Causes of Incomplete Content:**\n\n**1. Time Limit Exceeded:**\n```swift\n// Bad: Synchronous fetch that might timeout\nfunc application(_ application: UIApplication,\n                 performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n    // This MUST complete in ~30 seconds!\n    fetchAllContent() // If this takes 45 seconds, you're killed\n    completionHandler(.newData)\n}\n\n// Good: Prioritize critical content\nfunc application(_ application: UIApplication,\n                 performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n    \n    let startTime = Date()\n    let maxDuration: TimeInterval = 25 // Leave buffer\n    \n    Task {\n        // Fetch only most important content\n        let articles = await fetchTopArticles(limit: 10)\n        \n        // Check if we have time for more\n        if Date().timeIntervalSince(startTime) < maxDuration {\n            await fetchImages(for: articles.prefix(5))\n        }\n        \n        completionHandler(articles.isEmpty ? .noData : .newData)\n    }\n}\n```\n\n**2. Network Constraints:**\n```swift\n// Background refresh may have limited bandwidth\nclass BackgroundFetcher {\n    func fetchForBackground() async throws -> [Article] {\n        var request = URLRequest(url: articlesURL)\n        \n        // Request smaller payload for background\n        request.addValue(\"background\", forHTTPHeaderField: \"X-Fetch-Mode\")\n        \n        // Don't download images inline - just URLs\n        request.addValue(\"minimal\", forHTTPHeaderField: \"X-Response-Size\")\n        \n        return try await URLSession.shared.decode(request)\n    }\n}\n```\n\n**3. System Throttling:**\n```swift\n// System learns usage patterns and may not wake your app\n// If user rarely opens app, background refresh is deprioritized\n\n// Check if background refresh is available\nif UIApplication.shared.backgroundRefreshStatus == .available {\n    // Good to go\n} else {\n    // User disabled or system restricted\n    showOfflineMessage()\n}\n```\n\n**4. Memory Pressure:**\n```swift\n// Background tasks run with stricter memory limits\nfunc backgroundFetch() async {\n    // Don't load everything into memory\n    for article in articles {\n        await downloadAndSaveToDisk(article) // Stream to disk\n        // NOT: allContent.append(article) // Accumulates in memory\n    }\n}\n```\n\n**Solution: Use BGTaskScheduler for Longer Tasks:**\n```swift\n// Register in AppDelegate\nBGTaskScheduler.shared.register(\n    forTaskWithIdentifier: \"com.app.refresh\",\n    using: nil\n) { task in\n    self.handleBackgroundRefresh(task: task as! BGAppRefreshTask)\n}\n\n// Schedule\nfunc scheduleBackgroundRefresh() {\n    let request = BGAppRefreshTaskRequest(identifier: \"com.app.refresh\")\n    request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)\n    try? BGTaskScheduler.shared.submit(request)\n}\n\n// For longer processing\nlet processingRequest = BGProcessingTaskRequest(identifier: \"com.app.sync\")\nprocessingRequest.requiresNetworkConnectivity = true\nprocessingRequest.requiresExternalPower = false\n```",
      "tags": ["background-refresh", "bgtaskscheduler", "background-fetch", "limitations"],
      "sources": ["https://developer.apple.com/documentation/backgroundtasks"],
      "summary": "30s limit for background refresh. Prioritize critical content. Use BGProcessingTask for longer work. System throttles based on usage patterns."
    }
  ]
}
