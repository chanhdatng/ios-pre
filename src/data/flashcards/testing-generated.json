{
  "topic": "testing",
  "generated_at": "2026-01-08T03:55:15.486181+00:00",
  "cards": [
    {
      "id": "testing_394cb39087e3",
      "front": "What are your go-to unit testing best practices in iOS? How do you ensure tests are maintainable and effective?",
      "back": "Focus on testing behavior, not implementation. Use Arrange-Act-Assert (Given-When-Then) for clarity. Mock dependencies to isolate units. Avoid over-mocking. Test state changes and boundary conditions.  Keep tests small, fast, and independent. Name tests descriptively. Use a test base class for common setup/teardown. Consider protocol conformance in tests instead of complex mocking. Regularly review & refactor tests.",
      "code_example": null,
      "tags": [
        "testing",
        "unit testing",
        "best practices",
        "mocking",
        "XCTest"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "testing_99d655367931",
      "front": "Describe different strategies for UI testing in iOS. When would you choose one over another?",
      "back": "Strategies include record/replay, programmatic UI interaction, and visual testing. Record/replay is quick for basic flows but brittle. Programmatic is more robust, using `XCTest` and `XCUITest` APIs to find & interact with UI elements, enabling data-driven & complex scenarios. Visual testing uses snapshot comparisons, good for detecting visual regressions after UI changes. Choose programmatic for complex logic or data-driven tests; record/replay for rapid prototyping; visual testing for UI stability.",
      "code_example": null,
      "tags": [
        "testing",
        "ui testing",
        "xcuitest",
        "xctest"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "testing_76bda1e74f8b",
      "front": "Explain the benefits and drawbacks of snapshot testing in iOS. When would you choose snapshot testing over other testing methods?",
      "back": "Snapshot testing captures a UI's rendered output and compares it against a previously recorded \"golden image\".\n\nBenefits:\n*   Detect UI regressions quickly.\n*   Tests complex UIs without intricate assertions.\n*   Good for UI components with visual subtleties.\n\nDrawbacks:\n*   Can be brittle if UI is constantly changing.\n*   Requires careful management of \"golden images\".\n*   Doesn't test logic, only visual output.\n*   Can be slow, especially with large or complex views.\n\nChoose when:\n*   Testing UI appearance and layout is critical.\n*   Regression testing of visual changes is important.\n*   Testing complex, data-driven UI elements.\n\nAlternatives include UI and unit tests.",
      "code_example": null,
      "tags": [
        "testing",
        "snapshot testing",
        "UI testing"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "testing_cb7a1cf32d96",
      "front": "Explain different test double patterns (mocks, stubs, fakes, spies) and when you would use each.",
      "back": "Test doubles replace real dependencies for isolated testing. **Mocks** verify interactions (method calls, arguments). **Stubs** provide canned responses to calls. **Fakes** are working implementations, but simplified (e.g., in-memory data store). **Spies** are stubs that also record interactions for later verification. Use mocks to verify behavior, stubs for predictable state, fakes for functional replacement, and spies when both state and behavior are important.",
      "code_example": null,
      "tags": [
        "testing",
        "test doubles",
        "mocks",
        "stubs",
        "fakes",
        "spies"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "testing_01f7c12dabda",
      "front": "How do you ensure proper isolation when testing asynchronous code in iOS, preventing interference between tests?",
      "back": "I use `dispatch_group_t` to track asynchronous operations.  Inject the group into classes using `dispatch_queue`. For Core Data, I'd add a `performGroupedBlock` to `NSManagedObjectContext` using `dispatch_group_enter` and `dispatch_group_leave`.  In `tearDown`, I wait for the group to complete using `dispatch_group_notify` and a timeout to prevent indefinite hangs. This ensures all async tasks from a test finish before the next one starts.",
      "code_example": null,
      "tags": [
        "testing",
        "async",
        "dispatchgroup",
        "isolation",
        "coredata"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}