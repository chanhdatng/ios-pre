{
  "topic": "data_persistence",
  "generated_at": "2026-01-08T05:23:57.290850+00:00",
  "cards": [
    {
      "id": "data_persistence_0658a152705c",
      "front": "Explain the Core Data stack and the role of managed object contexts. How do different context types affect concurrency and data visibility?",
      "back": "The Core Data stack comprises: persistent store coordinator (PSC), managed object model (MOM), persistent store, and managed object context (MOC). The MOC is a central object responsible for object lifecycle management (creation, deletion, fetching). It tracks changes to managed objects. Saving a context persists these changes to the persistent store via the PSC.\n\nDifferent context types impact concurrency:\n\n1.  **Main Queue Context (`NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)`)**: Bound to the main thread. UI updates should happen here. Safe for single-threaded access.\n\n2.  **Private Queue Context (`NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)`)**: Has its own serial dispatch queue. Ideal for background tasks. Use `perform(_:)` or `performAndWait(_:)` for thread safety.\n\n3.  **`NSManagedObjectContext.mergeChanges(fromRemoteContextData: [AnyHashable : Any])`**:  If you have multiple contexts and one saves, you need to merge those changes into the other contexts. This is often done via `NotificationCenter` observing `NSManagedObjectContext.didSaveNotification`.\n\nExample:\n\n```swift\nimport CoreData\n\n// Assume you have a persistent container named 'MyPersistentContainer'\n\n// Main queue context\nlet mainContext = MyPersistentContainer.shared.viewContext\n\n// Private queue context\nlet backgroundContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)\nbackgroundContext.parent = mainContext // or persistentStoreCoordinator directly\n\nbackgroundContext.perform { // Perform work on the private queue\n    // Create a new object in the background context\n    let newItem = Item(context: backgroundContext)\n    newItem.name = \"Background Item\"\n\n    do {\n        try backgroundContext.save()\n        // Save the background context. This will push changes to the parent context\n        mainContext.perform { // Perform work on the main queue\n            do {\n                try mainContext.save()\n                print(\"Saved to main context\")\n            } catch {\n                print(\"Error saving main context: \\(error)\")\n            }\n        }\n\n    } catch {\n        print(\"Error saving background context: \\(error)\")\n    }\n}\n```\n\nCommon Pitfalls:\n*   **Incorrect Threading:** Accessing a context from the wrong thread can lead to crashes or data corruption.  Always use `perform(_:)` or `performAndWait(_:)` for private queue contexts.\n*   **Forgetting to Save:** Changes in a context are not persisted until the context is saved.\n*   **Context hierarchy complexity**:  Deeply nested context hierarchies can become difficult to manage.  Consider using a flat structure or simpler alternatives if possible.\n*   **Merging changes properly**:  Failing to merge changes between contexts can lead to data inconsistencies.\n\nAlternatives: Realm, SQLite directly, or cloud-based solutions like CloudKit or Firebase. Core Data shines when you need robust object graph management, undo/redo support, and relationships between data, especially within a single app.  Realm is simpler to set up and faster for some operations. SQLite provides more control but requires more boilerplate. CloudKit and Firebase are suited for multi-device synchronization.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Data Persistence",
        "iOS",
        "Contexts"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "Explain the Core Data stack, its components (Managed Object Context, Persistent Store Coordinator, Persistent Store), and how they interact during object creation, saving, and retrieval. Include common pitfalls.",
      "back": "The Core Data stack is the foundation for managing persistent data in iOS apps. It comprises the Managed Object Context (MOC), Persistent Store Coordinator (PSC), and Persistent Store.\n\nThe MOC is an in-memory scratchpad for objects. You create, modify, and delete objects within a context. It tracks changes but doesn't persist them directly. Each object knows its context, and each context knows the objects it manages.  Changes are tracked within the context.\n\nThe PSC acts as a bridge between the MOC and the Persistent Store. It translates requests from the MOC into instructions for the store. It coordinates interaction between the store and one or more contexts.\n\nThe Persistent Store handles reading and writing data to the underlying storage (e.g., SQLite). It interacts with the file system.\n\n**Object Creation:** To create an object, you insert it into the MOC.  `NSEntityDescription.insertNewObject(forEntityName:into:)` creates a new instance of the managed object. You can add convenience methods to your model class to do this.\n\n```swift\nclass Item: NSManagedObject {\n    @NSManaged public var title: String?\n\n    class func entityName() -> String {\n        return \"Item\"\n    }\n\n    class func insertNewObject(into context: NSManagedObjectContext) -> Item {\n        return NSEntityDescription.insertNewObject(forEntityName: entityName(), into: context) as! Item\n    }\n}\n\nlet newItem = Item.insertNewObject(into: managedObjectContext)\nnewItem.title = \"New Item\"\n```\n\n**Saving:**  Calling `managedObjectContext.save()` triggers the persistence process. The MOC identifies changes, passes them to the PSC, which then instructs the store to update the database.  \n\n```swift\ndo {\n    try managedObjectContext.save()\n} catch {\n    print(\"Error saving context: \\(error)\")\n}\n```\n\n**Retrieval:** To fetch objects, you create an `NSFetchRequest`, set its entity name and optionally a predicate for filtering, then execute the request.  The MOC returns managed objects that match the criteria.\n\n```swift\nlet fetchRequest: NSFetchRequest<Item> = Item.fetchRequest()\nfetchRequest.predicate = NSPredicate(format: \"title == %@\", \"Existing Item\")\n\ndo {\n    let results = try managedObjectContext.fetch(fetchRequest)\n    for item in results {\n        print(\"Found item: \\(item.title ?? \"\")\")\n    }\n} catch {\n    print(\"Error fetching: \\(error)\")\n}\n```\n\n**Common Pitfalls:**\n*   **Forgetting to Save:** Changes only persist after calling `save()`.  \n*   **Contexts and Threads:** MOCs are not thread-safe. Use separate contexts for different threads, merging changes to a main thread context.\n*   **Save Conflicts:** Concurrent modifications can lead to save failures. Implement conflict resolution strategies.\n*   **Validation Errors:** Core Data supports validation rules. Failure to adhere to these rules will cause a save to fail.\n*   **Memory Management:** Managed objects can consume significant memory. Use fetch limits and batch sizes to manage memory usage.\n*   **Zombie Objects:**  Accessing a managed object after its context has been deallocated results in a crash. Ensure objects remain valid within their context's lifecycle.\n\n**Alternatives:**\n*   **SwiftData**: Apple's new persistence framework, designed to be simpler and more integrated with Swift.\n*   **Realm:** A mobile database that offers performance and ease of use.\n*   **SQLite.swift:** A Swift wrapper for the SQLite C API.\n*   **UserDefaults:** For simple key-value storage, not suitable for complex data models.\n*   **FileManager**: For saving data as files (JSON, Plist, etc.). Requires manual object serialization/deserialization.\n\nCore Data's power lies in its ability to manage object graphs and relationships, but its complexity requires careful attention to detail.",
      "code_example": null,
      "tags": [
        "core data",
        "persistence",
        "ios",
        "data persistence",
        "managed object context",
        "persistent store coordinator",
        "persistent store"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Compare and contrast Core Data and SwiftData for data persistence in iOS. When would you choose one over the other? Discuss their architectures and key differences.",
      "back": "Core Data is a mature, object graph management and persistence framework. It's not just a database wrapper but a system for managing in-memory object state, relationships, and persistence. It uses a schema, managed object context, persistent store coordinator, and persistent stores (SQLite, binary, in-memory).  SwiftData, introduced in iOS 17, is a modern persistence framework built on Core Data principles but with a more Swift-native and declarative syntax. It leverages Swift's features like `@Model` macro for defining entities. \n\nKey Differences:\n*   **Syntax:** Core Data uses `NSManagedObject` subclasses and manual fetching. SwiftData uses Swift structs/classes marked with `@Model` and Swift's query API.\n*   **Learning Curve:** SwiftData is generally easier to learn due to its Swift-native approach.\n*   **Boilerplate:** SwiftData reduces boilerplate code compared to Core Data.\n*   **Relationships:** Both handle relationships, but SwiftData's declarative approach simplifies defining them.\n*   **Migrations:** Both support migrations, but SwiftData aims for simpler, automatic migrations.\n*   **Performance:** Core Data is highly optimized and can handle complex data models. SwiftData's performance is still evolving, but it's generally suitable for most apps.\n*   **Compatibility:** Core Data is available on older iOS versions. SwiftData requires iOS 17+.\n\nWhen to Choose:\n*   **Core Data:** Complex data models, advanced features (e.g., versioning, external storage), compatibility with older iOS versions, existing Core Data codebases.\n*   **SwiftData:** New projects targeting iOS 17+, simpler data models, Swift-native development, rapid prototyping, reduced boilerplate.\n\nExample (SwiftData):\n```swift\nimport SwiftData\n\n@Model\nclass Item {\n    var name: String\n    var timestamp: Date\n\n    init(name: String, timestamp: Date = Date()) {\n        self.name = name\n        self.timestamp = timestamp\n    }\n}\n\n// Usage\nstruct ContentView: View {\n    @Environment(\\EnvironmentValues.modelContext) private var modelContext\n    @Query private var items: [Item]\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.name)\n            }\n        }\n        .onAppear {\n            let newItem = Item(name: \"New Item\")\n            modelContext.insert(newItem)\n        }\n    }\n}\n```\n\nCommon Pitfalls:\n*   **Core Data:**  Incorrectly managing managed object contexts, forgetting to save, complex fetch requests.\n*   **SwiftData:**  Understanding the `@Model` macro, dealing with schema changes in migrations, early adoption issues.\n\nAlternatives: Realm, SQLite.swift, other ORMs.",
      "code_example": null,
      "tags": [
        "data persistence",
        "core data",
        "swiftdata",
        "ios",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Discuss Core Data migration strategies. What are the different types, and when would you choose one over another? Explain the process and potential pitfalls.",
      "back": "Core Data migrations evolve your data model. There are lightweight, manual, and custom migrations.\n\n**Lightweight Migration:** Simplest option, automatically handles basic schema changes like adding/removing optional attributes or renaming entities. Enabled by setting `NSMigratePersistentStoresAutomaticallyOption` and `NSInferMappingModelAutomaticallyOption` to `true` in the persistent store description.\n\n```swift\nlet description = NSPersistentStoreDescription(url: storeURL)\ndescription.shouldMigrateStoreAutomatically = true\ndescription.shouldInferMappingModelAutomatically = true\ncontainer.persistentStoreDescriptions = [description]\n```\n\n*Pitfalls:* Doesn't handle complex changes like splitting/merging entities, changing attribute types, or complex relationship transformations.\n\n**Manual Migration:** Required when lightweight migration fails. Involves creating a mapping model (`.xcmappingmodel`) that defines how data transforms from the source to the destination model. Can use value transformers for more complex conversions.\n\n*Process:* \n1.  Create new data model version.\n2.  Create a mapping model.\n3.  Implement `NSMigrationManager` to perform the migration.\n\n```swift\nclass MigrationManager {\n    let persistentStoreCoordinator: NSPersistentStoreCoordinator\n    let sourceModel: NSManagedObjectModel\n    let destinationModel: NSManagedObjectModel\n    let mappingModel: NSMappingModel\n\n    init(...) { ... }\n\n    func migrateStore(from url: URL, type: String, to newURL: URL) throws {\n        let migrationManager = NSMigrationManager(sourceModel: sourceModel, destinationModel: destinationModel)\n        try migrationManager.migrateStore(from: url, sourceType: type, options: nil, with: mappingModel, toDestinationURL: newURL, destinationType: type, destinationOptions: nil)\n    }\n}\n```\n\n*Pitfalls:*  Mapping models can become complex, especially with numerous changes.  Testing is critical.\n\n**Custom Migration:**  Provides the most control. Implemented entirely in code. Useful for complex data transformations or when external data sources are involved.\n\n*Process:* Load data from the old store, transform it, and save it to the new store programmatically.\n\n```swift\nfunc performCustomMigration(from sourceURL: URL, to destinationURL: URL) throws {\n    // 1. Load data from source store\n    let sourceContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)\n    sourceContext.persistentStoreCoordinator = // set up PSC with source model\n\n    // 2. Create destination context\n    let destinationContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)\n    destinationContext.persistentStoreCoordinator = // set up PSC with destination model\n\n    // 3. Iterate over source entities, transform, and insert into destination\n    // Example:\n    let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: \"OldEntity\")\n    let oldEntities = try sourceContext.fetch(fetchRequest)\n\n    for oldEntity in oldEntities {\n        let newEntity = NSEntityDescription.insertNewObject(forEntityName: \"NewEntity\", into: destinationContext) as! NewEntity\n        newEntity.attribute1 = oldEntity.value(forKey: \"oldAttribute1\") as? String\n        // ... more transformations\n    }\n\n    // 4. Save destination context\n    try destinationContext.save()\n}\n```\n\n*Pitfalls:* Requires significantly more code.  Error-prone if transformations are not handled correctly. Performance can be an issue with large datasets.\n\n**Choosing a Strategy:**\n*   Lightweight: For simple, additive changes.\n*   Manual: For moderately complex changes that can be described in a mapping model.\n*   Custom: For very complex changes, external data integration, or when precise control over the migration process is needed.\n\n**Common Pitfalls:**\n*   Forgetting to test migrations on large datasets.\n*   Incorrectly configuring mapping models.\n*   Not handling errors during migration.\n*   Failing to update the store's metadata after migration.\n*   Data loss due to incorrect transformations.\n*   Performance issues with custom migrations.\n*   Failing to handle optional properties correctly during migration.\n\n**Alternatives:**\n*   Deleting the store and starting fresh (acceptable for some apps that don't need to preserve data).\n*   Using a different persistence framework that handles migrations more easily (e.g., Realm, SQLite directly).",
      "code_example": null,
      "tags": [
        "Core Data",
        "Migration",
        "Data Persistence"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "How do you handle concurrency with Core Data to prevent data corruption or inconsistencies, especially in a multi-threaded environment?",
      "back": "Core Data isn't inherently thread-safe.  Multiple threads shouldn't directly access the *same* `NSManagedObjectContext`.  Concurrency issues arise when different threads try to modify the same data simultaneously. The key is to use different contexts on different threads, and then merge changes.\n\nHere's how to manage it:\n\n1. **Private Queue Contexts:** Create a `NSManagedObjectContext` with a `NSPrivateQueueConcurrencyType` for each thread that needs to work with Core Data.  This serializes operations on that context.\n\n2. **Main Queue Context:**  Have a `NSManagedObjectContext` with `NSMainQueueConcurrencyType` for UI updates.\n\n3. **Parent-Child Contexts:**  Set up a hierarchy of contexts. Typically, the private queue context(s) has the main queue context as its parent, or vice-versa (private queue context is child of main queue context). Or, both private queue contexts can have one parent context.\n\n4. **Merging Changes:**  After a background context saves, merge the changes into the main queue context (or parent context) using `perform(_:)` or `performAndWait(_:)` on the main queue context. This ensures UI reflects the updated data.  Alternatively, observe `NSManagedObjectContextDidSave` notifications and use `mergeChanges(fromContextDidSave notification:)` on the main context.\n\n```swift\n// Example:\n\n// Create a main queue context (for UI)\nlazy var mainContext: NSManagedObjectContext = {\n    let context = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n    context.persistentStoreCoordinator = persistentStoreCoordinator\n    return context\n}()\n\n// Function to perform a background task\nfunc performBackgroundTask(task: @escaping (NSManagedObjectContext) -> Void) {\n    // Create a private queue context\n    let backgroundContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)\n    backgroundContext.parent = mainContext // or set persistentStoreCoordinator directly\n\n    backgroundContext.perform {\n        task(backgroundContext)\n        do {\n            try backgroundContext.save()\n\n            // Save the main context to persist changes to disk\n            mainContext.perform { // Ensure on main thread\n                do {\n                    try mainContext.save()\n                } catch {\n                    print(\"Error saving main context: \\(error)\")\n                }\n            }\n\n        } catch {\n            print(\"Error saving background context: \\(error)\")\n        }\n    }\n}\n\n// Example usage:\nperformBackgroundTask {\n    (context) in\n    // Perform Core Data operations here using the backgroundContext\n    let newItem = Item(context: context)\n    newItem.title = \"New Item from background\"\n    // ...\n}\n\n// Alternative using NSManagedObjectContextDidSave notification\nNotificationCenter.default.addObserver(forName: .NSManagedObjectContextDidSave, object: nil, queue: .main) { notification in\n    mainContext.mergeChanges(fromContextDidSave: notification)\n}\n```\n\n**Common Pitfalls:**\n*   **Directly sharing contexts between threads:**  This leads to crashes and data corruption.\n*   **Forgetting to save the main context after merging:** Changes won't be persisted to disk.\n*   **Not handling errors during saves:**  Saves can fail due to validation errors, conflicts, or disk space issues.\n*   **Deadlocks:** Using `performAndWait` in nested contexts can cause deadlocks.  Avoid this by using `perform` and asynchronous operations.\n*   **Ignoring `NSMergePolicy`:** Set an appropriate merge policy on your context (e.g., `.errorMergePolicy`, `.rollbackMergePolicy`, `.overwriteMergePolicy`) to handle conflicts during merging.\n\n**Alternatives:**\n*   **Using Operation Queues:**  You can use `OperationQueue` to manage background tasks and Core Data operations. Create a private queue context within the operation.\n*   **Reactive frameworks (RxSwift, Combine):**  These can help manage asynchronous operations and data flow, making concurrency easier to handle.  Integrate Core Data operations within reactive streams.\n\nUsing parent-child contexts with private queues is the recommended approach for most Core Data concurrency scenarios. It ensures data consistency and prevents UI freezes.",
      "code_example": null,
      "tags": [
        "coredata",
        "concurrency",
        "multithreading",
        "ios",
        "data persistence"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Explain common caching strategies used in iOS development, focusing on their benefits, drawbacks, and when to use them. Include both memory and disk-based caching.",
      "back": "Caching is essential for optimizing iOS app performance, minimizing network requests, and providing a smooth user experience.  Several strategies exist, each with trade-offs.\n\n**1. Memory Caching (NSCache):**\n   - *Concept:* Stores data in RAM for quick access. `NSCache` automatically evicts objects when memory pressure is high, unlike a simple `Dictionary`.  It's thread-safe and uses weak references by default for keys, preventing retain cycles.\n   - *Usage:* Ideal for frequently accessed data like images or parsed JSON.\n   - *Example:* \n```swift\nlet imageCache = NSCache<NSString, UIImage>()\n\nfunc setImage(image: UIImage, forKey key: String) {\n imageCache.setObject(image, forKey: key as NSString)\n}\n\nfunc getImage(forKey key: String) -> UIImage? {\n return imageCache.object(forKey: key as NSString)\n}\n```\n   - *Pitfalls:* Data is lost when the app terminates or is purged by the OS.  `NSCache` eviction is non-deterministic.\n   - *Alternatives:* `Dictionary` (but requires manual memory management and thread safety). Use `URLCache` for caching responses from `URLSession`.\n\n**2. Disk Caching:**\n   - *Concept:* Persists data on disk for use across app launches. Useful for larger datasets or content that doesn't change frequently.\n   - *Strategies:*\n      *   **File System:** Store data as individual files. Simple but requires manual management of directory structure and file naming.\n      *   **SQLite Database:** Store structured data in a database. Offers querying and indexing capabilities.\n      *   **Core Data:** Apple's object graph management framework with built-in persistence. Suitable for complex data models and relationships.  It supports caching at the `NSManagedObjectContext` and `NSPersistentStoreCoordinator` levels.\n      *   **UserDefaults:**  For small amounts of user preferences or configuration data. Not suitable for large or complex data.\n   - *Example (File System):*\n```swift\nfunc saveImageToDisk(image: UIImage, filename: String) {\n let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n let fileURL = documentsDirectory.appendingPathComponent(filename)\n if let data = image.jpegData(compressionQuality: 0.8) {\n try? data.write(to: fileURL)\n }\n}\n\nfunc loadImageFromDisk(filename: String) -> UIImage? {\n let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n let fileURL = documentsDirectory.appendingPathComponent(filename)\n return UIImage(contentsOfFile: fileURL.path)\n}\n```\n   - *Pitfalls:* Disk access is slower than memory.  Requires careful consideration of storage limits and data expiration policies.  Managing concurrency and data consistency is crucial.\n   - *Alternatives:* CloudKit caching for syncing data across devices.\n\n**3. Hybrid Caching:**\n   - *Concept:* Combines memory and disk caching.  Frequently accessed data is stored in memory, while less frequently accessed data is stored on disk.\n   - *Benefits:* Provides the best of both worlds: fast access and persistence.\n   - *Implementation:*  Check memory cache first; if not found, load from disk and store in memory cache.\n\n**4. URLCache:**\n - *Concept:* A built-in caching mechanism for `URLSession`. It caches responses based on request policies (e.g., cache control headers).\n - *Usage:* Automatically caches network responses, reducing the need for manual caching.\n - *Pitfalls:* Limited control over caching behavior. Only caches responses from `URLSession`.\n\n**Choosing a Strategy:**\n   - *Frequency of Access:*  Memory cache for frequently used data, disk cache for less frequent.\n   - *Data Size:*  Memory cache for small objects, disk cache for large objects.\n   - *Data Persistence:* Disk cache for data that needs to persist across app launches.\n   - *Complexity:* `URLCache` for simple network response caching, Core Data for complex object graphs.\n\n**Important Considerations:**\n   - *Cache Invalidation:* Implement a strategy to invalidate cached data when it becomes stale (e.g., using expiration dates or version numbers).\n   - *Concurrency:* Ensure thread safety when accessing caches from multiple threads.\n   - *Storage Limits:*  Be mindful of device storage limits and implement a mechanism to clear the cache when necessary.\n   - *Security:*  Protect sensitive data stored in the cache (e.g., encrypt the data).\n   - *Core Data Caching:* Core Data automatically caches objects. `objectRegisteredForID:` checks if an object with a specific ID is already in the context.  `existingObjectWithID:error:` retrieves the object if it exists; otherwise, it returns nil or faults the object. Batch fetching with `NSFetchRequest` improves performance. Saving in batches is also important for performance.\n\nBy carefully selecting and implementing caching strategies, you can significantly improve the performance and responsiveness of your iOS applications.",
      "code_example": null,
      "tags": [
        "caching",
        "performance",
        "memory management",
        "disk persistence",
        "core data",
        "urlsession"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "How do you securely store sensitive data like API keys or user credentials in an iOS app using Keychain, and what are some best practices to follow?",
      "back": "Keychain is a secure storage container in iOS for small amounts of sensitive data. It encrypts data at rest, making it more secure than storing it in UserDefaults or a file.\n\n**Core Concept:** Keychain Services provides a secure way to store key-value pairs.  The system handles encryption and access control.\n\n**Code Example:**\n```swift\nimport Security\n\nfunc savePassword(password: String, account: String) {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: password.data(using: .utf8)!,\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly // Restrict access\n    ]\n\n    SecItemDelete(query as CFDictionary)\n\n    let status = SecItemAdd(query as CFDictionary, nil)\n    guard status == errSecSuccess else { print(\"Error saving to Keychain: \\(status)\"); return }\n}\n\nfunc loadPassword(account: String) -> String? {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecReturnData as String: true,\n        kSecMatchLimit as String: kSecMatchLimitOne\n    ]\n\n    var result: AnyObject?\n    let status = SecItemCopyMatching(query as CFDictionary, &result)\n\n    guard status == errSecSuccess, let data = result as? Data, let password = String(data: data, encoding: .utf8) else {\n        return nil\n    }\n    return password\n}\n\n// Usage\nsavePassword(password: \"mySecretAPIKey\", account: \"api.example.com\")\nif let apiKey = loadPassword(account: \"api.example.com\") {\n    print(\"API Key: \\(apiKey)\")\n}\n```\n**Explanation:**\n*   `SecItemAdd` saves data to Keychain. We first delete any existing item to avoid errors.\n*   `SecItemCopyMatching` retrieves data.\n*   `kSecAttrAccessible` specifies when the data is accessible.  `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` is a secure default.\n*   Error handling is crucial.\n\n**Common Pitfalls:**\n*   **Not handling errors:** Always check the `SecItemAdd` and `SecItemCopyMatching` return status.\n*   **Incorrectly setting `kSecAttrAccessible`:**  Choose the appropriate accessibility level based on your app's security needs. Avoid `kSecAttrAccessibleAlways` unless absolutely necessary.\n*   **Hardcoding Keychain item names:** Use constants or a configuration file to manage Keychain item names.\n*   **Storing large amounts of data:** Keychain is designed for small amounts of sensitive data.  For larger data, consider encrypting it and storing it in the file system, with the encryption key in Keychain.\n*   **Forgetting to delete old items before adding new ones with the same account:** Can lead to errors and unexpected behavior.\n\n**Alternatives:**\n*   **UserDefaults:** Not secure for sensitive data. Stores data in plain text.\n*   **Storing in Files:** Requires manual encryption/decryption, which can be complex and error-prone.\n*   **Cloud Key Management Services (KMS):** For enterprise applications, consider using cloud-based KMS for managing encryption keys.  This adds complexity but improves security and key rotation.\n\n**When to Use:**\n*   Storing user passwords.\n*   Storing API keys.\n*   Storing encryption keys.\n*   Any other small, sensitive data that needs to be protected.\n\n**Best Practices:**\n*   Use appropriate `kSecAttrAccessible` values.\n*   Implement robust error handling.\n*   Use constants for Keychain item names.\n*   Consider using a Keychain wrapper library for easier management (e.g., SwiftKeychainWrapper).\n*   Be aware of iCloud Keychain synchronization implications.\n*   Regularly audit your Keychain usage and security practices.",
      "code_example": null,
      "tags": [
        "data persistence",
        "security",
        "keychain",
        "encryption"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}