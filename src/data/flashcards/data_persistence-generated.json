{
  "topic": "data_persistence",
  "generated_at": "2026-01-15T04:04:42.375055+00:00",
  "cards": [
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "Explain the roles of `@Model`, `ModelContainer`, and `ModelContext` in SwiftData. How do these components abstract and improve upon Core Data's `NSManagedObject`, `NSPersistentContainer`, and `NSManagedObjectContext`?",
      "back": "SwiftData modernizes data persistence on Apple platforms by providing a Swift-native API built directly on top of Core Data's proven storage engine. Its key components\u2014`@Model`, `ModelContainer`, and `ModelContext`\u2014directly map to and simplify Core Data's core concepts.\n\n**Core Concepts:**\n*   **`@Model` vs. `NSManagedObject`**: The `@Model` macro transforms a standard Swift class into a persistable model. It automatically infers the schema and relationships from class properties. This replaces the cumbersome process of defining an entity in the `.xcdatamodeld` visual editor and generating a separate `NSManagedObject` subclass, which could lead to sync issues. `@Model` provides compile-time safety; a typo in a property name is a compile error, not a runtime crash.\n\n*   **`ModelContainer` vs. `NSPersistentContainer`**: The `ModelContainer` is responsible for setting up the entire persistence stack. You provide it with a list of `@Model` types, and it configures the underlying persistent store (e.g., SQLite), coordinator, and model contexts. This is analogous to `NSPersistentContainer` but with a much simpler, declarative setup, often requiring just a single line in your SwiftUI `App` or `Scene`.\n\n*   **`ModelContext` vs. `NSManagedObjectContext`**: The `ModelContext` is the live version of your object graph used for fetching, inserting, and deleting objects. It tracks all changes. Crucially, the default context provided via the SwiftUI environment is bound to the `@MainActor`. This eliminates a huge source of complexity from Core Data: manual context management for UI updates and merging changes from background contexts.\n\n**Practical Code Example:**\n```swift\n// 1. Define the model with the @Model macro\n@Model\nfinal class Trip {\n    var name: String\n    var destination: String\n\n    init(name: String, destination: String) {\n        self.name = name\n        self.destination = destination\n    }\n}\n\n// 2. Set up the container in the App's body\n@main\nstruct TravelApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        // The container is configured once for the entire app\n        .modelContainer(for: Trip.self)\n    }\n}\n\n// 3. Use the context in a SwiftUI view\nstruct ContentView: View {\n    // Access the main-actor-bound context from the environment\n    @Environment(\\.modelContext) private var modelContext\n    @Query private var trips: [Trip]\n\n    func addTrip() {\n        // Inserts are tracked by the context automatically\n        let newTrip = Trip(name: \"Honeymoon\", destination: \"Kyoto\")\n        modelContext.insert(newTrip)\n        // No explicit save is needed by default due to autosave\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Concurrency**: While the main context simplifies UI, background tasks require a separate context. You must fetch an object's `PersistentIdentifier` on the main actor, pass that ID to a background actor, and then use a new context (created from the `ModelContainer`) to fetch and modify the object. `@Model` objects are not `Sendable`.\n*   **Autosave**: The default context autosaves on UI lifecycle events. This can be unpredictable. For critical transactions, disable it (`modelContext.autosaveEnabled = false`) and call `try modelContext.save()` explicitly.\n\n**When to Use vs. Alternatives:**\n*   **SwiftData**: The default choice for new SwiftUI projects targeting iOS 17+. Its deep integration and simplicity are major advantages.\n*   **Core Data**: Use for existing projects, supporting older iOS versions, or when you require advanced features not yet in SwiftData (e.g., `NSFetchedResultsController` for UIKit, complex validation rules).",
      "code_example": null,
      "tags": [
        "data_persistence",
        "swiftdata",
        "core_data",
        "concurrency",
        "swiftui"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_0658a152705c",
      "front": "Describe the 'scratchpad' nature of a `NSManagedObjectContext` and its role within the Core Data stack. How does this design enable thread confinement and support operations like background data processing?",
      "back": "The Core Data stack's architecture is designed for robust object graph management, not just persistence. The `NSManagedObjectContext` (MOC) is the centerpiece of this design, acting as an intelligent in-memory 'scratchpad' or transactional workspace.\n\n**Core Concept Explanation:**\n\nThe stack consists of three main components:\n1.  **`NSManagedObjectContext` (MOC):** Your primary interface. It manages a collection of `NSManagedObject` instances. All edits (creations, updates, deletions) are tracked within a specific context, isolated from the persistent store and other contexts. This isolation is key to its power, enabling features like undo/redo and atomic saves.\n2.  **`NSPersistentStoreCoordinator` (PSC):** The 'central scrutinizer' or traffic cop. It connects the MOC(s) to the underlying persistent store(s). A context never writes to a file directly; it communicates its changes to the PSC, which then coordinates writing to the store. This prevents direct store corruption and manages a unified view of the data model.\n3.  **`NSPersistentStore`:** Represents the actual storage file (e.g., SQLite database). It handles the low-level work of serializing object graph changes into the chosen storage format.\n\nThis separation allows for thread confinement. Each context is bound to a specific dispatch queue. By creating separate contexts for the main thread (UI) and background threads, you can perform long-running data operations without blocking the UI. Changes are made in isolation on the background context's scratchpad and then saved. The PSC ensures this save is handled safely, and mechanisms exist to merge these changes back to the main context to update the UI.\n\n**Practical Code Example:**\nUsing `NSPersistentContainer` simplifies this pattern. The `viewContext` is for the main queue, and we can create background contexts for other work.\n\n```swift\n// Assume 'container' is your NSPersistentContainer instance\n\n// 1. Ensure the main UI context automatically observes and merges changes\n//    saved on background contexts.\ncontainer.viewContext.automaticallyMergesChangesFromParent = true\n\nfunc processAndSaveDataInBackground() {\n    // 2. performBackgroundTask provides a private queue context for safe background work.\n    container.performBackgroundTask { backgroundContext in\n        // 3. Fetch or create an object within this specific background context.\n        let request: NSFetchRequest<Item> = Item.fetchRequest()\n        request.predicate = NSPredicate(format: \"id == %@\", someId)\n\n        do {\n            let item = try backgroundContext.fetch(request).first ?? Item(context: backgroundContext)\n            item.lastUpdated = Date()\n            \n            // 4. Save the background context. This pushes changes to the PSC/store.\n            //    It does NOT directly update the viewContext.\n            if backgroundContext.hasChanges {\n                try backgroundContext.save()\n            }\n        } catch {\n            // Handle the error appropriately\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Cross-Thread Contamination:** Accessing a MOC or its managed objects from a different queue than the one it's bound to. This is the most common cause of Core Data crashes and data corruption. Always use `perform()` or `performAndWait()`.\n*   **Passing Managed Objects:** Never pass an `NSManagedObject` from one context to another. Instead, pass its thread-safe `NSManagedObjectID` and re-fetch the object in the destination context.\n\n**When to Use vs. Alternatives:**\n*   **Use Core Data:** For complex object graphs, large datasets requiring lazy loading (faulting), and applications needing robust undo/redo and transactional integrity.\n*   **Alternatives:** For simpler needs, consider **Realm** (a fast, mobile-first database), **GRDB.swift** (for direct SQL control), or simple `Codable` to a file for non-relational data.",
      "code_example": null,
      "tags": [
        "core-data",
        "persistence",
        "concurrency",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Explain Core Data's multi-layered caching and the concept of faulting. How would you diagnose and resolve a 'faulting storm' (N+1 query problem) in a performance-critical screen?",
      "back": "Core Data employs a sophisticated multi-layered caching system to optimize performance and manage memory. Understanding it is key to avoiding common performance bottlenecks.\n\n**Core Concept Explanation:**\n\n1.  **`NSManagedObjectContext` (MOC) Cache:** This is the primary, in-memory 'scratchpad'. When you fetch an object, it's registered with the MOC. The MOC guarantees *object uniquing*\u2014only one managed object instance exists for any given data record within that context. Subsequent requests for the same object return the existing instance from this cache, which is extremely fast (a pointer lookup).\n\n2.  **`NSPersistentStoreCoordinator` (PSC) Row Cache:** The PSC sits between the MOC and the physical store (e.g., SQLite). It maintains its own cache of raw row data. If a MOC needs an object not in its own cache, it asks the PSC. If the PSC has the row data cached, it can create the object without hitting the disk, which is significantly faster than a full database query.\n\n3.  **Faulting:** This is Core Data's lazy-loading mechanism. When you fetch an object, its relationships are not immediately loaded. Instead, they are represented by placeholder objects called 'faults'. When you access a property on a faulted relationship for the first time, Core Data 'fires the fault,' automatically executing a fetch to retrieve the required data from the store. This is efficient for memory but can cause a 'faulting storm' or N+1 query problem if done in a loop, where 1 query fetches the parent objects and N subsequent queries fetch the children one-by-one.\n\n**Practical Code Example:**\n\nDiagnosing a faulting storm can be done by enabling the launch argument `-com.apple.CoreData.SQLDebug 1` to see the generated SQL queries.\n\n```swift\n// BAD: Causes a faulting storm (N+1 queries)\n// One query for authors, then one query for each author's books\nlet fetchRequest: NSFetchRequest<Author> = Author.fetchRequest()\nlet authors = try context.fetch(fetchRequest)\n\nfor author in authors {\n    // Accessing .books fires a fault for EACH author, hitting the DB every time.\n    let bookCount = author.books?.count ?? 0\n    print(\"\\(author.name) has \\(bookCount) books.\")\n}\n\n// GOOD: Resolves the storm with prefetching\n// Fetches all authors AND their books in a single, optimized database trip.\nlet optimizedRequest: NSFetchRequest<Author> = Author.fetchRequest()\n\n// Tell Core Data to fetch the 'books' relationship along with the authors.\noptimizedRequest.relationshipKeyPathsForPrefetching = [\"books\"]\n\nlet optimizedAuthors = try context.fetch(optimizedRequest)\n\nfor author in optimizedAuthors {\n    // Accessing .books is now fast, as the data is already in memory.\n    let bookCount = author.books?.count ?? 0\n    print(\"\\(author.name) has \\(bookCount) books.\")\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n\n*   **Over-Prefetching:** Prefetching is a trade-off. Eagerly loading too many deep or large relationships can consume significant memory, negating the benefits of lazy loading.\n*   **Stale Data:** The MOC's cache can become stale if the underlying store is changed by another context or process (e.g., a background sync or app extension). You must implement a strategy to observe and merge these changes, like using `NSPersistentCloudKitContainer` or manually observing `NSManagedObjectContext.didSaveObjectsNotification`.\n\n**When to Use vs. Alternatives:**\n\n*   **Default (Faulting):** Use for detail views where you are loading a single object and its relationships. The on-demand nature is perfect here.\n*   **Prefetching:** Essential for list views (`UITableView`, `UICollectionView`) where you will display data from a relationship for every visible item. This prevents UI stutter while scrolling.\n*   **Batch Faulting:** Use `NSFetchRequest` with `returnsObjectsAsFaults = false` for processing large datasets where you need all the data but want to avoid loading everything into memory at once. It can be combined with `fetchBatchSize` for further optimization.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Caching",
        "Performance",
        "Data Persistence",
        "Faulting"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Discuss Core Data migration strategies. When is automatic lightweight migration insufficient, and how would you implement a heavyweight migration with a custom NSEntityMigrationPolicy?",
      "back": "Core Data migration is the process of updating a persistent store from an older version of your data model to the current version. The two primary strategies are lightweight and heavyweight migration.\n\n**Lightweight Migration** is the default, automatic process. You enable it by setting two flags when loading your persistent store. It can handle simple changes like adding/removing attributes, renaming entities/attributes (using the 'Renaming ID' in the Xcode Data Model Inspector), and adding relationships. It works by inferring the mapping between the old and new models.\n\n```swift\n// Enable lightweight migration on your NSPersistentContainer\nlet container = NSPersistentContainer(name: \"MyApp\")\n\nguard let description = container.persistentStoreDescriptions.first else {\n    fatalError(\"Failed to retrieve a persistent store description.\")\n}\n\n// These flags enable automatic, lightweight migration\ndescription.shouldMigrateStoreAutomatically = true\ndescription.shouldInferMappingModelAutomatically = true\n\ncontainer.loadPersistentStores { ... }\n```\n\n**Heavyweight Migration** is required for complex schema changes that Core Data cannot infer. This includes splitting an entity into two, merging entities, changing an attribute's type in a non-trivial way (e.g., `String` to a custom `Transformable` type), or performing data validation/transformation during the move. It involves creating a Mapping Model (`.xcmappingmodel`) in Xcode, which defines the source-to-destination entity and attribute mappings. For custom logic, you subclass `NSEntityMigrationPolicy`.\n\n```swift\n// Custom policy to merge 'firstName' and 'lastName' into 'fullName'\nclass UserV2MigrationPolicy: NSEntityMigrationPolicy {\n    override func createDestinationInstances(forSource sInstance: NSManagedObject, in mapping: NSEntityMapping, manager: NSMigrationManager) throws {\n        // Let the default implementation create the destination object\n        try super.createDestinationInstances(forSource: sInstance, in: mapping, manager: manager)\n\n        // Get the newly created destination instance\n        guard let destInstance = manager.destinationInstances(forEntityMappingName: mapping.name, sourceInstances: [sInstance]).first else { return }\n\n        let firstName = sInstance.value(forKey: \"firstName\") as? String ?? \"\"\n        let lastName = sInstance.value(forKey: \"lastName\") as? String ?? \"\"\n        destInstance.setValue(\"\\(firstName) \\(lastName)\", forKey: \"fullName\")\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Blocking UI:** Large migrations can take time and block the main thread if not performed asynchronously.\n- **Data Loss:** A faulty migration policy can lead to data loss. Always test migrations thoroughly with realistic data.\n- **Forgetting Flags:** Not setting `shouldMigrateStoreAutomatically` will cause the app to crash on launch if the model has changed.\n\n**When to Use:**\n- **Lightweight:** Always the first choice. Use for 90% of model changes.\n- **Heavyweight:** Only when lightweight fails. Essential for maintaining data integrity during complex refactors.\n- **Alternative:** For extremely large or complex migrations, consider a manual export/import process to a new store to provide better user feedback and avoid a long, blocking operation.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "migration"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Despite SwiftData's modern API, describe a scenario where you'd advocate for using Core Data in a new iOS 17+ project. What specific features or limitations would justify this decision?",
      "back": "While SwiftData is the clear future for on-device persistence in the Apple ecosystem, its initial release (iOS 17) is a v1.0 product. I would advocate for Core Data in a new project that requires the maturity and deep configurability that SwiftData currently abstracts away.\n\n**Core Concept Explanation:**\nThe primary reason to choose Core Data is for fine-grained control over the persistence stack. SwiftData's `@Model` macros and `ModelContainer` provide a simple, elegant API but hide the underlying `NSPersistentStoreCoordinator`. This coordinator is Core Data's powerhouse, allowing for complex setups.\n\nA key scenario is an application requiring multiple persistent stores attached to a single object model. For example, an app that stores sensitive, user-generated data in an encrypted SQLite store on disk, while simultaneously managing ephemeral, non-sensitive data (like a cache) in a separate in-memory store. This allows for efficient data segregation and performance tuning. SwiftData's `ModelConfiguration` currently lacks the explicit API to manage multiple stores of different types against a single coordinator in this manner.\n\nOther justifications include:\n- **Value Transformers:** For legacy or complex data types that are not easily `Codable`, Core Data's support for custom `ValueTransformer` subclasses is robust and proven.\n- **Advanced Data Model Features:** The Core Data Visual Editor provides access to configurations, fetched properties, and complex validation rules that are not yet fully surfaced in SwiftData.\n\n**Practical Code Example:**\nHere's how to configure a Core Data container with both a SQLite and an in-memory store, a feature not directly available in SwiftData.\n\n```swift\n// In your Core Data stack setup\nlet container = NSPersistentContainer(name: \"MyDataModel\")\n\n// 1. Describe the main, on-disk SQLite store\nlet dbURL = NSPersistentContainer.defaultDirectoryURL().appendingPathComponent(\"main.sqlite\")\nlet primaryStoreDescription = NSPersistentStoreDescription(url: dbURL)\nprimaryStoreDescription.configuration = \"Default\" // Use the default configuration\n\n// 2. Describe the secondary, in-memory store for cached data\nlet cacheStoreDescription = NSPersistentStoreDescription()\ncacheStoreDescription.type = NSInMemoryStoreType\ncacheStoreDescription.configuration = \"Cache\" // A separate configuration in the .xcdatamodeld\n\n// 3. Assign both store descriptions to the container\ncontainer.persistentStoreDescriptions = [primaryStoreDescription, cacheStoreDescription]\n\ncontainer.loadPersistentStores { storeDescription, error in\n    if let error = error as NSError? {\n        fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Premature Complexity:** Choosing Core Data for a simple CRUD app \"just in case\" is a common mistake. This introduces significant boilerplate and concurrency challenges that SwiftData solves elegantly. Always default to SwiftData unless a specific, known limitation forces your hand.\n- **Ignoring SwiftData's Evolution:** A feature missing today (e.g., store configurations) may be added in the next iOS release. Choosing Core Data locks you into an older paradigm, so the trade-off must be worth it for the project's lifespan.\n\n**When to Use vs Alternatives:**\n- **Use Core Data when:** The project has non-negotiable requirements for multiple store types, complex data model configurations, fetched properties, or must support OS versions prior to iOS 17.\n- **Use SwiftData when:** Starting any typical new project on iOS 17+. Its simplicity, type safety, and integration with Swift Concurrency make it the superior choice for the vast majority of use cases.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "architecture",
        "ios17"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "How would you design a robust, concurrent Core Data stack for an app that performs background data sync while the user interacts with the UI? Explain your context strategy, data flow, and conflict resolution.",
      "back": "A robust concurrent Core Data strategy centers on isolating work and safely merging changes. The modern approach uses `NSPersistentContainer`.\n\n**Core Concept:**\n`NSManagedObjectContext` is not thread-safe. You must only access a context on the queue it was created for. The standard pattern involves:\n1.  **Main Queue Context (`viewContext`):** Provided by the container, this context is for all UI-related work (fetching data for tables, saving user edits). It operates on the main thread.\n2.  **Private Queue Contexts:** For any long-running or background tasks (e.g., network sync, data import/export). `NSPersistentContainer.performBackgroundTask` provides a temporary private context that shares the same `NSPersistentStoreCoordinator` as the `viewContext`.\n\n**Data Flow:**\nThe background context fetches and modifies data, then saves it directly to the Persistent Store. To make the UI aware of these changes, the `viewContext` must be updated. The most robust way is to set `viewContext.automaticallyMergesChangesFromParent = true`. This makes the `viewContext` listen for `NSManagedObjectContext.didSaveObjectsNotification` from other contexts attached to the same coordinator and automatically merge those changes, updating its object graph.\n\n**Code Example:**\n```swift\n// 1. In your Core Data stack setup (e.g., AppDelegate or a singleton)\nlazy var persistentContainer: NSPersistentContainer = {\n    let container = NSPersistentContainer(name: \"MyAppModel\")\n    container.loadPersistentStores { (storeDescription, error) in\n        // Error handling...\n    }\n    // CRITICAL: Enable automatic merging of changes from background contexts\n    container.viewContext.automaticallyMergesChangesFromParent = true\n    // Set a merge policy to handle conflicts gracefully\n    container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n    return container\n}()\n\n// 2. Performing a background data sync\nfunc syncDataInBackground() {\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // This closure executes on a private background queue\n        // Perform fetch, network calls, and data updates here\n        let newPost = Post(context: backgroundContext)\n        newPost.id = UUID()\n        newPost.title = \"New Post from Background\"\n        newPost.syncedAt = Date()\n        \n        do {\n            // Save changes to the persistent store\n            try backgroundContext.save()\n            // The viewContext will now automatically merge this change\n        } catch {\n            print(\"Background save failed: \\(error)\")\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Passing Managed Objects Across Threads:** Never pass an `NSManagedObject` from one context to another. Instead, pass its `NSManagedObjectID` and refetch the object in the destination context: `let safeObject = destinationContext.object(with: objectID)`.\n*   **Merge Conflicts:** The default merge policy (`NSErrorMergePolicy`) will crash your app on conflict. You must set a deterministic policy. `NSMergeByPropertyObjectTrumpMergePolicy` (in-memory changes win) is common for user-facing data, while `NSMergeByPropertyStoreTrumpMergePolicy` (persistent store's version wins) is better if the backend is the source of truth.\n*   **Forgetting `automaticallyMergesChangesFromParent`:** Without this, your UI (e.g., an `NSFetchedResultsController`) will not update after a background save, leading to stale data and a poor user experience.\n\n**Alternatives:**\n*   **Parent/Child Contexts:** A private context can be a child of the `viewContext`. Saving the child pushes changes to the parent (in memory), which then must be saved to disk. This is useful for isolated, discardable changes (like an edit screen), but less ideal for background sync as it can block the parent context during the merge.",
      "code_example": null,
      "tags": [
        "core-data",
        "concurrency",
        "persistence",
        "threading"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "How would you store a sensitive credential in the Keychain to ensure it's only accessible when the device is unlocked and requires biometric authentication for each retrieval? Detail the key `kSecAttr` attributes and `SecAccessControl` flags involved.",
      "back": "The Keychain is a secure, encrypted database managed by the OS for storing small secrets like passwords and tokens. To achieve this level of security, we must configure two key aspects: accessibility and access control.\n\n1.  **Accessibility (`kSecAttrAccessible`):** This attribute defines *when* your app can access the Keychain item, based on the device's lock state. For sensitive data that should not be in backups and only available while the device is unlocked, `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` is the ideal choice. It provides a strong balance of security and usability.\n\n2.  **Access Control (`SecAccessControl`):** This object defines *how* an item can be accessed, often requiring user interaction. By creating a `SecAccessControl` instance with the `.userPresence` flag, we tell the system that the user must prove their presence via biometrics (Face ID/Touch ID) or the device passcode before the data can be retrieved. This prevents other processes from accessing the secret without explicit user consent.\n\n**Code Example:**\n```swift\nimport Security\n\nfunc save(token: Data, for account: String) -> OSStatus {\n    // 1. Define SecAccessControl: Require user presence (biometrics/passcode)\n    var error: Unmanaged<CFError>?\n    guard let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly, // Accessibility\n        .userPresence, // Require Face ID/Touch ID for each access\n        &error\n    ) else {\n        return errSecInternal\n    }\n\n    // 2. Build the query dictionary for adding the item\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"com.yourapp.api.v1\", // A unique service name\n        kSecAttrAccount as String: account, // e.g., user's identifier\n        kSecValueData as String: token, // The secret data\n        kSecAttrAccessControl as String: accessControl // Link the access control object\n    ]\n\n    // 3. Atomically add/update: delete any existing item first\n    SecItemDelete(query as CFDictionary)\n\n    // 4. Add the new item to the Keychain\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls:**\n*   **Update vs. Add:** `SecItemAdd` fails if an item already exists (`errSecDuplicateItem`). A robust, simple pattern is to first call `SecItemDelete` and then `SecItemAdd`, ensuring an atomic update.\n*   **Simulator Limitations:** Biometric-protected items behave differently or fail on the simulator. Always test Keychain security features on a physical device.\n*   **Biometric Changes:** If a user adds/removes a fingerprint or face, keys protected by `.userPresence` can be invalidated. Your app must gracefully handle retrieval failures (`errSecAuthFailed`) and prompt the user to re-authenticate.\n\n**When to Use vs. Alternatives:**\n*   **Use Keychain for:** Small, highly sensitive data like OAuth tokens, API keys, and user passwords.\n*   **`UserDefaults`:** For non-sensitive user preferences (e.g., \"dark mode enabled\"). Data is unencrypted.\n*   **Encrypted Core Data/Realm:** For storing and querying large sets of structured, sensitive data. This encrypts an entire database file, offering protection for large amounts of data at rest.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}