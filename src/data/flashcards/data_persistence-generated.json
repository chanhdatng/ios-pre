{
  "topic": "data_persistence",
  "generated_at": "2026-01-13T04:04:10.582321+00:00",
  "cards": [
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "You're tasked with importing a large dataset into Core Data without blocking the UI. Describe your concurrency strategy, including context setup, data processing, and merging changes back to the main view.",
      "back": "The core principle of Core Data concurrency is that a `NSManagedObjectContext` is bound to a specific queue and is not thread-safe. For a large import, we must offload work from the main queue to prevent UI stuttering.\n\n**Core Concept: The Modern Stack**\n1.  **Isolate Work**: The `NSPersistentContainer` provides the main queue-bound `viewContext` for UI-related work. For background tasks, we use a separate context on a private queue.\n2.  **Background Context**: The `performBackgroundTask(_:)` method is ideal. It vends a temporary, private `NSManagedObjectContext` that operates on its own queue, saving us from manual context and queue management.\n3.  **Saving & Merging**: When the background context is saved, its changes are committed to the `NSPersistentStore`. To reflect these changes in the UI, the `viewContext` must be updated. By setting `viewContext.automaticallyMergesChangesFromParent = true` during stack setup, the `viewContext` will automatically consume save notifications from its persistent coordinator and merge the changes, triggering UI updates via mechanisms like `NSFetchedResultsController`.\n\n**Practical Code Example:**\n```swift\n// 1. In your Core Data stack setup (e.g., AppDelegate or a manager class)\nfunc setupCoreDataStack() {\n    // This is crucial for automatic UI updates from background saves.\n    persistentContainer.viewContext.automaticallyMergesChangesFromParent = true\n}\n\n// 2. The import function\nfunc importLargeDataset(from data: [MyJSONModel]) {\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // This closure executes on a private background queue.\n        // Set a merge policy to handle potential conflicts.\n        backgroundContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n\n        for (index, model) in data.enumerated() {\n            let entity = MyEntity(context: backgroundContext)\n            entity.id = model.id\n            entity.name = model.name\n            \n            // Batch saving prevents building a massive transaction in memory,\n            // which can cause performance issues and high memory usage.\n            if (index + 1) % 100 == 0 {\n                try? backgroundContext.save()\n            }\n        }\n\n        // Save any remaining items\n        if backgroundContext.hasChanges {\n            do {\n                try backgroundContext.save()\n            } catch {\n                print(\"Final import save failed: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Passing `NSManagedObject`s**: Never pass managed objects between contexts. They are not thread-safe. If you need to reference an object across a thread boundary, pass its `NSManagedObjectID` and fetch it in the new context using `context.object(with: objectID)`.\n*   **Forgetting to Save**: Changes in the `backgroundContext` are purely in-memory until `save()` is called. Forgetting to save means the work is lost.\n*   **Merge Conflicts**: If data can be edited in the UI while an import is running, conflicts can occur. Setting a `mergePolicy` (like `NSMergeByPropertyObjectTrumpMergePolicy`) on the context is essential to define how to resolve these conflicts automatically.\n\n**When to Use vs. Alternatives:**\n*   **`performBackgroundTask`**: Best for discrete, self-contained background operations like an import. The context is managed for you.\n*   **`newBackgroundContext()`**: Use when you need a longer-lived background context that you manage yourself, perhaps for a complex sync engine that persists across multiple operations.\n*   **Parent/Child Contexts**: An older pattern where a background context is a child of the `viewContext`. Saves are pushed to the parent in memory (fast), not the store. This is useful for UI-driven tasks like a complex editing screen that can be canceled, but `performBackgroundTask` is generally simpler and more robust for data processing.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Persistence",
        "iOS",
        "Swift"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_0658a152705c",
      "front": "Describe the roles of the key components in a Core Data stack. How do you design a robust, multi-threaded data layer using Managed Object Contexts?",
      "back": "The Core Data stack consists of four key components working together:\n\n1.  **NSManagedObjectModel (`.xcdatamodeld`):** The schema or blueprint of your data. It defines entities, their attributes, and relationships. It's compiled and immutable at runtime.\n2.  **NSPersistentStoreCoordinator (PSC):** The central hub. It connects the object model to the persistent stores and is responsible for realizing objects from the store. A single coordinator can manage multiple stores.\n3.  **NSPersistentStore:** The actual backend storage (e.g., SQLite, Binary, In-Memory). The PSC abstracts the store type, so your application logic doesn't need to know the underlying format.\n4.  **NSManagedObjectContext (MOC):** Your gateway to the stack. It's an in-memory 'scratchpad' where you create, fetch, and modify managed objects. Contexts are not thread-safe and must be used on the queue they are associated with.\n\nA robust multi-threaded design, facilitated by `NSPersistentContainer`, uses separate contexts for UI and background work.\n\n- **Main Queue Context (`viewContext`):** Tied to the main queue. Use this for all UI-related data operations (e.g., populating a table view).\n- **Private Queue Contexts:** Created for background tasks like network syncs or large data imports. These contexts have their own private serial queue.\n\n```swift\n// Using NSPersistentContainer for a modern, robust setup\nlet container = NSPersistentContainer(name: \"MyDataModel\")\ncontainer.loadPersistentStores { description, error in /* ... */ }\n\n// 1. Main context for UI updates\nlet viewContext = container.viewContext\n\n// 2. Perform a background task using a temporary private context\ncontainer.performBackgroundTask { backgroundContext in\n    // This block is executed on a private background queue.\n    // backgroundContext is a new MOC for this task.\n\n    let request: NSFetchRequest<Item> = Item.fetchRequest()\n    request.predicate = NSPredicate(format: \"id == %@\", someId)\n\n    do {\n        if let itemToUpdate = try backgroundContext.fetch(request).first {\n            itemToUpdate.lastUpdated = Date()\n        }\n        \n        // Save changes from the background context to the persistent store.\n        if backgroundContext.hasChanges {\n            try backgroundContext.save()\n        }\n    } catch {\n        // Handle error\n        print(\"Failed to save background context: \\(error)\")\n    }\n}\n// After the background context saves, NSPersistentContainer automatically\n// merges these changes back into the viewContext on the main thread.\n```\n\n**Common Pitfalls:**\n*   **Threading Violations:** The most common crasher. Never access a managed object or its context from a different queue. Always use `perform` or `performAndWait` to ensure you're on the correct queue.\n*   **Passing Managed Objects Between Contexts:** You cannot directly pass a managed object from one context to another. Instead, pass its `NSManagedObjectID` and re-fetch the object in the destination context.\n\n**Alternatives:** The older parent/child context pattern allows for changes to be pushed up to a parent context without saving to the store. This is useful for 'draft' or 'undo' features but is generally less performant for concurrent background saves than the modern sibling context approach that `NSPersistentContainer` encourages.",
      "code_example": null,
      "tags": [
        "core_data",
        "persistence",
        "concurrency",
        "ios",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "How would you manage a non-trivial Core Data model schema change in a production app? Discuss the differences between lightweight and heavyweight migration, and the steps involved in a custom migration.",
      "back": "Core Data migration updates a user's local data store to match a new app version's data model.\n\n**Core Concept Explanation:**\nThere are two main strategies:\n\n1.  **Lightweight Migration**: This is the preferred, automatic approach. You enable it, and Core Data infers the migration map. It works for simple changes like:\n    *   Adding/removing an attribute or entity.\n    *   Making an attribute non-optional with a default value, or making it optional.\n    *   Renaming an entity or attribute (by setting the `renamingIdentifier` in the model inspector).\n\n2.  **Heavyweight (Manual) Migration**: This is required for complex changes that Core Data cannot infer, such as:\n    *   Splitting an entity into two.\n    *   Merging two entities into one.\n    *   Transforming an attribute's data (e.g., `String` to a binary `Data` representation).\n    *   Changing relationship types (e.g., to-one to to-many).\n    It requires creating an `NSMappingModel` in Xcode, which defines source-to-destination mappings. For custom logic, you create an `NSEntityMigrationPolicy` subclass and associate it with an entity mapping.\n\n**Practical Code Example:**\n\n```swift\n// 1. Enabling Lightweight Migration (common setup)\nlet container = NSPersistentContainer(name: \"MyModel\")\n\n// Get the store description\nguard let description = container.persistentStoreDescriptions.first else {\n    fatalError(\"Failed to retrieve a persistent store description.\")\n}\n\n// Enable automatic migration options\ndescription.shouldMigrateStoreAutomatically = true\ndescription.shouldInferMappingModelAutomatically = true\n\ncontainer.loadPersistentStores { ... }\n\n// 2. Stub for a Heavyweight Migration Policy\nclass TransformUsernamePolicy: NSEntityMigrationPolicy {\n    // Used for complex logic, e.g., combining firstName and lastName into a new fullName attribute.\n    override func createDestinationInstances(forSource sInstance: NSManagedObject, in mapping: NSEntityMapping, manager: NSMigrationManager) throws {\n        // Call super to handle basic attribute-to-attribute mapping\n        try super.createDestinationInstances(forSource: sInstance, in: mapping, manager: manager)\n\n        // Get the destination instance(s)\n        guard let destination = manager.destinationInstances(forEntityMappingName: mapping.name, sourceInstances: [sInstance]).first else { return }\n        \n        // Apply custom transformation logic\n        let firstName = sInstance.value(forKey: \"firstName\") as? String ?? \"\"\n        let lastName = sInstance.value(forKey: \"lastName\") as? String ?? \"\"\n        destination.setValue(\"\\(firstName) \\(lastName)\", forKey: \"fullName\")\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n*   **Forgetting to Version**: You must never modify a shipped data model. Always select the `.xcdatamodeld` file, go to Editor -> Add Model Version, and make changes on the new version.\n*   **Performance**: Heavyweight migrations on large datasets can be very slow and block app launch. The migration should be performed on a background thread while showing progress to the user.\n*   **Progressive Migration**: If a user skips several app versions, Core Data must perform a multi-step migration (e.g., v1->v2, then v2->v3). This works automatically if a chain of mapping models exists, but it's a critical testing scenario.\n\n**When to use vs Alternatives:**\n*   **Lightweight**: Default for all compatible changes. It's simple and reliable.\n*   **Heavyweight**: Use only when lightweight is insufficient. It adds significant development and testing overhead.\n*   **Manual Export/Import**: For extremely complex schema changes, it can be safer to write a custom routine that exports user data to JSON, creates a fresh store with the new schema, and re-imports the data. This bypasses the Core Data migration framework entirely.",
      "code_example": null,
      "tags": [
        "core-data",
        "data-persistence",
        "migration",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Beyond syntax, contrast the architectural philosophies of Core Data and SwiftData. How do their approaches to concurrency, data modeling, and stack management influence your choice for a complex, long-term project?",
      "back": "SwiftData isn't a replacement for Core Data but a modern, Swift-native abstraction built directly on top of it. It fundamentally shifts the developer experience from an imperative, object-graph management framework to a declarative, code-first persistence solution.\n\n**Architectural Differences:**\n*   **Modeling:** Core Data uses a visual `.xcdatamodeld` editor, generating `NSManagedObject` subclasses. This separates model definition from code. SwiftData employs a code-first approach with the `@Model` macro on plain Swift classes, which is more version-control friendly and keeps the schema definition with the code.\n*   **Stack Management:** Core Data requires manual setup of `NSPersistentContainer` and explicit management of `NSManagedObjectContext`. SwiftData automates this via the `.modelContainer()` view modifier and `@Environment(\\.modelContext)`, drastically reducing boilerplate.\n*   **Concurrency:** This is a key differentiator. Core Data relies on thread-confined contexts and `perform`/`performAndWait` blocks, a common source of bugs. SwiftData's `ModelContext` is built on Swift Concurrency (actors), making thread-safe operations natural with `async/await`.\n\n**Code Example:**\n```swift\n// --- Core Data ---\n// Model is defined in .xcdatamodeld and an NSManagedObject subclass\nclass CDTask: NSManagedObject {\n    @NSManaged public var title: String\n    @NSManaged public var isDone: Bool\n}\n// Fetching requires string-based predicates\nlet request = NSFetchRequest<CDTask>(entityName: \"CDTask\")\nrequest.predicate = NSPredicate(format: \"isDone == NO\")\n\n// --- SwiftData (iOS 17+) ---\n// Model is a simple class with a macro\n@Model\nfinal class SDTask {\n    var title: String\n    var isDone: Bool\n    init(title: String, isDone: Bool = false) { self.title = title; self.isDone = isDone }\n}\n// Fetching uses a type-safe, compile-time checked predicate\nlet predicate = #Predicate<SDTask> { $0.isDone == false }\nlet descriptor = FetchDescriptor(predicate: predicate)\n```\n\n**Pitfalls & Considerations:**\n*   **Maturity:** SwiftData is new (iOS 17+) and lacks some of Core Data's advanced features like complex store configurations, fetched properties, and granular validation rules.\n*   **Control vs. Simplicity:** Core Data offers deep, fine-grained control, which is powerful but complex. SwiftData prioritizes ease of use and safety, abstracting away this control.\n*   **Migration:** Core Data has a robust, battle-tested migration system. SwiftData's migration is simpler for basic changes but less proven for complex schema evolutions.\n\n**When to Choose:**\n*   **Use SwiftData for:** New SwiftUI projects targeting iOS 17+, where a modern, type-safe API and seamless Swift Concurrency integration are priorities.\n*   **Stick with Core Data for:** Projects supporting older OS versions, those with complex existing data models, or when requiring advanced features and granular control over the persistence stack.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "architecture",
        "concurrency"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Explain Core Data's multi-layered caching and faulting mechanism. How would you diagnose and optimize a UI that's slow due to excessive database fetches?",
      "back": "Core Data employs a sophisticated multi-layered caching strategy to minimize expensive disk I/O. Understanding this is key to performance optimization.\n\n**Core Concept Explanation:**\nData access performance exists on a spectrum:\n1.  **Fastest (L1 Cache):** The `NSManagedObjectContext` (MOC) acts as a scratchpad and an in-memory object graph. If an object is already registered in the context, accessing it is nearly free. Core Data guarantees 'uniquing' here, meaning only one object instance exists per record within a single MOC.\n2.  **Moderate (L2 Cache):** The `NSPersistentStoreCoordinator` (PSC) maintains its own internal row cache. If an object isn't in the MOC but its raw data is in the PSC's cache from a recent fetch, it can be brought into the MOC without hitting the disk.\n3.  **Slowest (Disk):** If the data is in neither cache, a round trip to the persistent store (e.g., SQLite) is required. This is the most expensive operation.\n\n**Faulting** is Core Data's lazy-loading mechanism. When you fetch objects, you initially get back 'faults'\u2014placeholder objects with only their ID. Accessing any property on a fault triggers it to 'fire,' causing Core Data to perform a fetch to populate its data. While efficient for single objects, this can lead to the 'N+1 query problem' when iterating over a list and accessing a to-many relationship, causing one fetch for each item.\n\n**Code Example (Diagnosing & Optimizing):**\n```swift\n// Problem: A table view displaying authors and their book counts is slow.\n// This loop can trigger a separate DB fetch for each author's 'books' relationship.\nfunc configureCell(author: Author) {\n    // BAD: Accessing '.books' fires a fault for each author, causing N+1 fetches.\n    let bookCount = author.books?.count ?? 0\n    cell.textLabel.text = \"\\(author.name) (\\(bookCount) books)\"\n}\n\n// Optimization: Use prefetching in the initial fetch request.\nfunc fetchAuthors() -> [Author] {\n    let request: NSFetchRequest<Author> = Author.fetchRequest()\n    // GOOD: Tell Core Data to fetch all related 'books' in a single, optimized query.\n    request.relationshipKeyPathsForPrefetching = [\"books\"]\n\n    do {\n        return try viewContext.fetch(request)\n    } catch {\n        // Handle error\n        return []\n    }\n}\n```\nTo diagnose this, use the launch argument `-com.apple.CoreData.SQLDebug 1` to see the exact SQL queries Core Data executes in the console. You would observe many individual queries in the 'bad' case and a single, more complex query (often using a `JOIN` or `IN` clause) in the 'good' case.\n\n**Common Pitfalls:**\n- **Accidental Firing:** Unintentionally accessing a faulted property in logging, debugging, or background processing.\n- **Over-Prefetching:** Prefetching large or numerous relationships that aren't actually used, leading to high memory consumption and slow initial fetches.\n- **Stale Cache:** The MOC's cache can become out of sync if the underlying store is modified by another process (e.g., an App Extension). Use `NSPersistentHistoryTracking` to merge changes and invalidate the cache when necessary.\n\n**When to Use vs. Alternatives:**\n- **Default (Faulting):** Best for master-detail interfaces where you only need related data after a user interaction.\n- **Prefetching:** Use when you know you will immediately access the relationships for every object in a collection, like displaying a list with aggregated data.\n- **`returnsObjectsAsFaults = false`:** Use to fetch all attributes of the primary objects at once, but it doesn't pre-fetch relationships. Less common now that `relationshipKeyPathsForPrefetching` is available.",
      "code_example": null,
      "tags": [
        "core-data",
        "data-persistence",
        "caching",
        "performance",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "Explain the role of `kSecAttrAccessible` when saving items to the Keychain. How would you select an appropriate protection class for an API token versus a key for biometric authentication?",
      "back": "The `kSecAttrAccessible` attribute is a fundamental security control in Keychain Services. It assigns a Data Protection Class to a Keychain item, defining the conditions under which the item can be decrypted and accessed. This is enforced at the OS level, often with hardware backing from the Secure Enclave.\n\nFor an **API token**, which is often needed while the app is in use or during background fetches, the choice depends on the specific requirement:\n- `kSecAttrAccessibleWhenUnlocked`: A strong default. The item is only accessible when the device is unlocked. Ideal for data used in the foreground.\n- `kSecAttrAccessibleAfterFirstUnlock`: Use if a background task needs the token while the device is locked. It's less secure, as the item remains decrypted in memory after the first unlock post-boot, but necessary for background network requests.\n\nFor a **key backing biometric authentication** (e.g., a private key used to sign a challenge), security is paramount and the key should never leave the device:\n- `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`: This is the most secure option. It requires a device passcode to be set, the item is only accessible when the device is unlocked, and critically, it will not be migrated to a new device via iCloud Keychain or an encrypted backup. This ensures the key is intrinsically tied to the physical hardware.\n\n```swift\nimport Foundation\nimport Security\n\n// Saves a piece of data to the Keychain with a specific accessibility level.\nfunc saveSecret(data: Data, service: String, account: String, accessibility: CFString) -> OSStatus {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: service,           // Uniquely identifies the service\n        kSecAttrAccount as String: account,           // User's account identifier\n        kSecValueData as String: data,                // The secret data\n        kSecAttrAccessible as String: accessibility   // CRITICAL: Sets the protection class\n    ]\n\n    // Delete any old item to handle updates cleanly\n    SecItemDelete(query as CFDictionary)\n\n    // Add the new item to the Keychain\n    return SecItemAdd(query as CFDictionary, nil)\n}\n\n// Example: Save an API token needed for foreground use\nlet apiToken = \"secret-auth-token\".data(using: .utf8)!\nsaveSecret(data: apiToken, service: \"com.myapp.api\", account: \"user1\", accessibility: kSecAttrAccessibleWhenUnlocked)\n```\n\n**Common Pitfalls:**\n- **Background Access Failure:** Using `kSecAttrAccessibleWhenUnlocked` for data needed by a background task will cause Keychain access to fail when the device is locked.\n- **Inadvertent Migration:** Not using a `...ThisDeviceOnly` attribute for device-specific secrets can lead to them being restored on a new device, potentially breaking application logic or creating a security vulnerability.\n- **Ignoring `OSStatus`:** Keychain functions return an `OSStatus` code. Failing to check for errors like `errSecDuplicateItem` or `errSecItemNotFound` can lead to silent data loss or corruption.\n\n**Alternatives:**\n- **UserDefaults:** For non-sensitive data only. It's unencrypted and easily readable.\n- **Encrypted Database (Core Data/Realm):** For large sets of structured sensitive data. The database encryption key itself should be stored in the Keychain for maximum security.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "SwiftData is often described as a modern wrapper for Core Data. Describe the key architectural components of SwiftData and explain how its design fundamentally simplifies the persistence stack compared to its predecessor.",
      "back": "SwiftData is built upon Core Data but provides a modern, Swift-native API that dramatically simplifies the persistence stack by abstracting away its complexities.\n\n**Core Concept Explanation:**\nThe traditional Core Data stack consists of several interconnected components: `NSManagedObjectModel` (the schema), `NSPersistentStoreCoordinator` (manages stores), and `NSManagedObjectContext` (the transaction scratchpad). Setting this up required significant boilerplate code.\n\nSwiftData replaces this with a much simpler architecture:\n1.  **`@Model` Macro:** Instead of a `.xcdatamodeld` file and `NSManagedObject` subclasses, you define your schema directly in Swift code using the `@Model` macro. This macro synthesizes conformance to `PersistentModel`, handles property observation, and generates the underlying schema, eliminating the disconnect between code and a separate model editor.\n2.  **`ModelContainer`:** This is the new central piece, analogous to the entire Core Data stack setup. It takes your model types and configures the backing store (e.g., SQLite), schema, and migration strategy. It's typically configured once at the app's root.\n3.  **`ModelContext`:** This is the equivalent of `NSManagedObjectContext`. It's the environment for fetching, creating, modifying, and deleting model objects. It tracks all changes and is designed for the main actor, integrating seamlessly with SwiftUI's environment.\n\nThis design shift moves from a manually configured, multi-part stack to a declarative, code-centric approach that is more type-safe and requires far less setup.\n\n**Practical Code Example:**\n```swift\n// 1. Define the model directly in Swift code\n@Model\nfinal class Trip {\n    var name: String\n    var destination: String\n    init(name: String, destination: String) {\n        self.name = name\n        self.destination = destination\n    }\n}\n\n// 2. Set up the container once in the app's entry point\n@main\nstruct TravelApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        // This single modifier sets up the entire persistence stack\n        .modelContainer(for: Trip.self)\n    }\n}\n\n// 3. Use the context and @Query in a SwiftUI view\nstruct ContentView: View {\n    // Access the main context via the environment\n    @Environment(\\.modelContext) private var modelContext\n    // Declaratively fetch and observe data\n    @Query private var trips: [Trip]\n\n    func addTrip() {\n        let newTrip = Trip(name: \"Alpine Hike\", destination: \"Switzerland\")\n        modelContext.insert(newTrip)\n        // No explicit save needed for UI-driven changes; SwiftData autosaves.\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n*   **Threading:** The default `ModelContext` is main-actor-bound. For background data processing, you must create a new context from the `ModelContainer` to avoid blocking the UI.\n*   **Autosave:** Relying solely on autosave can be risky. For critical operations or background tasks, you must explicitly call `modelContext.save()` to ensure data is persisted immediately.\n*   **Migrations:** While simpler, complex schema changes still require a `SchemaMigrationPlan` and are not fully automatic.\n\n**When to Use vs. Alternatives:**\n*   **SwiftData:** The go-to for new apps targeting iOS 17+. Its deep integration with SwiftUI and modern Swift concurrency makes it the most efficient choice.\n*   **Core Data:** Use for projects that must support older iOS versions or require advanced features not yet exposed in SwiftData (e.g., fetched properties, custom store coordinators).",
      "code_example": null,
      "tags": [
        "swiftdata",
        "coredata",
        "persistence",
        "swiftui",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}