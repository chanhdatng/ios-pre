{
  "topic": "data_persistence",
  "generated_at": "2026-01-19T04:22:05.538135+00:00",
  "cards": [
    {
      "id": "data_persistence_0658a152705c",
      "front": "Describe a robust, multi-context Core Data setup for performing background data syncs. Explain the roles of the main and background contexts, their relationship, and how changes are propagated to the UI.",
      "back": "A robust multi-context setup in Core Data, especially with `NSPersistentContainer`, involves a main context for the UI and one or more background contexts for tasks like network syncs. This pattern prevents UI blocking and ensures thread safety.\n\n**Core Concept:**\nThe `NSPersistentContainer` provides a `viewContext` which is configured with `.mainQueueConcurrencyType`. This context should be the single source of truth for the UI. For background work, you create a separate context using `container.newBackgroundContext()`. This context has a `.privateQueueConcurrencyType` and operates on its own queue. Both contexts are connected to the same `NSPersistentStoreCoordinator`, making them siblings. When the background context saves, it writes changes to the persistent store. The `viewContext` can then be notified and merge these changes to reflect them in the UI. Setting `viewContext.automaticallyMergesChangesFromParent` to `true` handles this automatically.\n\n**Code Example:**\n```swift\n// In your Core Data stack setup\nclass PersistenceController {\n    static let shared = PersistenceController()\n    let container: NSPersistentContainer\n\n    init() {\n        container = NSPersistentContainer(name: \"MyAppModel\")\n        container.loadPersistentStores { description, error in\n            // ... error handling ...\n        }\n        // Key for automatic UI updates\n        container.viewContext.automaticallyMergesChangesFromParent = true\n    }\n\n    // Function to perform a background sync\n    func syncNetworkData() {\n        // performBackgroundTask provides a private queue context\n        container.performBackgroundTask { backgroundContext in\n            // 1. Fetch data from network (e.g., [DecodableItem])\n            let newItems = NetworkService.fetchItems()\n\n            // 2. Process and save data using the background context\n            for itemData in newItems {\n                let newItem = Item(context: backgroundContext)\n                newItem.id = itemData.id\n                newItem.name = itemData.name\n            }\n\n            // 3. Save changes to the persistent store\n            do {\n                try backgroundContext.save()\n            } catch {\n                // Handle save error\n                print(\"Failed to save background context: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n1.  **Threading Violations:** Never access a managed object or its context from a different queue without using `perform` or `performAndWait`. This is the most common cause of Core Data crashes.\n2.  **Passing Managed Objects:** Do not pass `NSManagedObject` instances between contexts. Instead, pass their `NSManagedObjectID` and refetch the object in the destination context.\n3.  **Forgetting to Save:** Changes made in a background context are isolated until `save()` is called. Without saving, the changes are never persisted or merged.\n\n**When to Use vs. Alternatives:**\n*   **Sibling Contexts (as shown):** Ideal for independent, long-running tasks like network syncs. The main thread is fully isolated. This is the most common and recommended pattern with `NSPersistentContainer`.\n*   **Parent/Child Contexts:** A child context is a temporary scratchpad. Saving a child pushes changes to its parent *in memory only*. The parent must then be saved to persist. This is useful for modal UI where a user can cancel their changes (e.g., an edit screen), as you can simply discard the child context without affecting the parent.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Persistence",
        "iOS"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "An app screen displays 'Projects' and their 'Task' counts. Iterating each Project's `tasks` relationship to get the count is slow. Explain the underlying Core Data performance issue and propose two distinct optimization strategies.",
      "back": "The performance issue stems from Core Data's lazy loading mechanism, known as faulting. When you fetch the 'Projects', their relationships like 'tasks' are initially faults\u2014placeholders that aren't populated with data. Accessing `project.tasks.count` for each project individually forces Core Data to resolve or 'fire' that fault. This results in a separate database fetch for each project's tasks, leading to the classic 'N+1' query problem: one query for the projects, and N subsequent queries for their tasks.\n\nThis is inefficient because each trip to the persistent store (SQLite) has overhead. The Managed Object Context (MOC) can't satisfy these requests from its in-memory cache, nor can the Persistent Store Coordinator's (PSC) row cache, forcing repeated, expensive I/O operations.\n\n**Strategy 1: Prefetching**\nThis approach tells Core Data to fetch the related 'Task' objects in a single, optimized, follow-up query. When you later access the `tasks` relationship, the objects are already in the MOC, and firing the fault is nearly instantaneous.\n\n```swift\n// Fetches Projects and their related Tasks efficiently\nlet request: NSFetchRequest<Project> = Project.fetchRequest()\n// Prefetching tells Core Data to grab all tasks for the fetched projects\nrequest.relationshipKeyPathsForPrefetching = [\"tasks\"]\n\ndo {\n    let projects = try viewContext.fetch(request)\n    // Now, accessing project.tasks.count is fast as data is in memory\n    for project in projects {\n        print(\"\\(project.name): \\(project.tasks.count) tasks\")\n    }\n} catch {\n    // Handle error\n}\n```\n\n**Strategy 2: NSExpressionDescription (Database-level count)**\nThis is often the most performant method if you *only* need the count and not the `Task` objects themselves. It pushes the counting logic down to the SQLite database, which is highly optimized for such aggregate operations. It avoids pulling potentially thousands of `Task` objects into memory.\n\n```swift\nlet request: NSFetchRequest<NSDictionary> = NSFetchRequest(entityName: \"Project\")\nrequest.resultType = .dictionaryResultType\n\n// Create an expression for the count of the 'tasks' relationship\nlet countExpression = NSExpression(forKeyPath: \"@count.tasks\")\nlet countDescription = NSExpressionDescription()\ncountDescription.name = \"taskCount\"\ncountDescription.expression = countExpression\ncountDescription.expressionResultType = .integer64AttributeType\n\n// We need the project's name as well\nrequest.propertiesToFetch = [\"name\", countDescription]\n\ndo {\n    let results = try viewContext.fetch(request)\n    // Results are dictionaries: [\"name\": \"Project A\", \"taskCount\": 15]\n    for result in results {\n        print(\"\\(result[\"name\"] as! String): \\(result[\"taskCount\"] as! Int) tasks\")\n    }\n} catch {\n    // Handle error\n}\n```\n\n**Pitfalls & Considerations:**\n*   **Over-prefetching:** Be cautious with `relationshipKeyPathsForPrefetching`. Fetching deep or wide relationship graphs can consume significant memory if you don't actually need all the data.\n*   **When to Use:** Use prefetching when you need the related objects for display (e.g., showing the first 3 task names). Use `NSExpressionDescription` when you only need an aggregate value (count, sum, average) for optimal performance.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "performance",
        "caching",
        "faulting",
        "prefetching"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "How would you securely store a `Codable` user session object in the Keychain? Detail the necessary query attributes, focusing on the `kSecAttrAccessible` options and their implications for data protection.",
      "back": "The Keychain is a secure, encrypted database managed by iOS for storing small, sensitive pieces of data like passwords, keys, and authentication tokens. It provides hardware-backed security, making it superior to other persistence methods for secrets.\n\nTo store a `Codable` object, you first serialize it into `Data`, typically using `JSONEncoder`. You then interact with the low-level Security framework C-APIs by constructing a query dictionary (`[String: Any]`) that describes the item and the operation.\n\n**Code Example:**\n```swift\n// A sample Codable object to store\nstruct UserSession: Codable {\n    let authToken: String\n    let userId: String\n}\n\n// Saves the session object to the Keychain\nfunc save(session: UserSession, for account: String) -> OSStatus {\n    guard let data = try? JSONEncoder().encode(session) else { return errSecParam }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword, // The type of data\n        kSecAttrAccount as String: account,           // A unique identifier for the item\n        kSecValueData as String: data,                // The actual data to store\n        // Crucial security attribute defining when the data is accessible\n        kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly\n    ]\n    \n    // Delete any existing item for this account to avoid conflicts\n    SecItemDelete(query as CFDictionary)\n    \n    // Add the new item to the keychain\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls & `kSecAttrAccessible`:**\nThe most critical attribute is `kSecAttrAccessible`. Choosing the wrong one can compromise security.\n- `kSecAttrAccessibleWhenUnlocked`: Accessible only when the device is unlocked. The default.\n- `kSecAttrAccessibleAfterFirstUnlock`: Accessible after the first unlock post-boot. Useful for background tasks that need credentials.\n- `kSecAttrAccessible...ThisDeviceOnly`: A highly recommended suffix. It prevents the item from being migrated to a new device via iCloud Keychain backup, tying the secret to the physical device.\n\nA common pitfall is mishandling updates. Calling `SecItemAdd` for an existing item returns `errSecDuplicateItem`. A robust solution involves either deleting before adding (as shown) or attempting an update with `SecItemUpdate` and adding only if it fails with `errSecItemNotFound`.\n\n**When to Use vs. Alternatives:**\n- **Keychain:** Only for small (<4KB), highly sensitive data (tokens, passwords).\n- **UserDefaults:** For non-sensitive user preferences (e.g., theme settings). It's an unencrypted plist.\n- **Core Data/SQLite/Realm:** For large sets of structured, non-sensitive application data. While they support encryption, Keychain is the standard for secrets.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain",
        "codable"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Your app and its Share Extension share a Core Data store via an App Group. Describe the challenges of keeping their `NSManagedObjectContext`s in sync and compare the modern Persistent History Tracking approach with older notification-based methods.",
      "back": "The core challenge with a shared Core Data store is that a change made by one process (e.g., the Share Extension) doesn't automatically update the in-memory `NSManagedObjectContext` of another running process (the main app), leading to stale data.\n\n**Legacy Approach: Notification & Refresh**\nBefore iOS 13, the common solution was using `DarwinNotificationCenter` to broadcast a notification when one process saved the context. The other process would listen for this and trigger a refresh. This was often inefficient, requiring a call to `viewContext.refreshAllObjects()`. A major pitfall was the `stalenessInterval` property, which defaults to -1 (cache never invalidates), forcing developers to temporarily set it to 0 to ensure the refresh actually fetched from the store, then reset it.\n\n**Modern Approach: Persistent History Tracking**\nIntroduced in iOS 11 and enhanced in iOS 13, this is the superior method. By enabling it, Core Data maintains a transaction log within the database itself. Instead of a blunt refresh, your app can query for changes that have occurred since its last known state and merge only those specific deltas.\n\n**Code Example (Persistent History Tracking):**\n\n```swift\n// 1. Enable history tracking on your store description\nlet description = NSPersistentStoreDescription(url: storeURL)\ndescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)\ncontainer.persistentStoreDescriptions = [description]\n\n// 2. Observe remote changes and process them\nNotificationCenter.default.addObserver(\n    self, selector: #selector(processRemoteChanges),\n    name: .NSPersistentStoreRemoteChange, object: container.persistentStoreCoordinator\n)\n\n@objc func processRemoteChanges(_ notification: Notification) {\n    // Fetch and merge history on the context's queue\n    viewContext.perform {\n        self.mergeChanges()\n    }\n}\n\nprivate func mergeChanges() {\n    let fetchRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: lastToken)\n    guard let historyResult = try? viewContext.execute(fetchRequest) as? NSPersistentHistoryResult,\n          let history = historyResult.result as? [NSPersistentHistoryTransaction] else { return }\n\n    for transaction in history {\n        viewContext.mergeChanges(fromContextDidSave: transaction.objectIDNotification)\n        // Update the last processed token\n        lastToken = transaction.token\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting the Token:** You must persist the `lastToken` (e.g., in App Group `UserDefaults`) to avoid re-processing old changes.\n- **History Bloat:** The transaction history grows indefinitely. Periodically, you must prune it using `NSPersistentHistoryChangeRequest.deleteHistory(before: someTokenOrDate)`.\n- **Concurrency:** Always perform the history fetch and merge on the target context's queue using `perform` or `performAndWait`.\n\n**When to Use:**\n- **Persistent History Tracking:** The standard for iOS 13+. Use it for syncing between app/extensions or between a background context and the UI context.\n- **Notification-based Refresh:** A legacy fallback for older iOS versions or simpler use cases where the performance hit of a full refresh is acceptable.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Data Persistence",
        "Concurrency",
        "App Extension"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "Design a strategy for performing a large, background data import using Core Data without blocking the UI. Detail the context setup, how changes are propagated to the UI, and how you would handle potential data conflicts.",
      "back": "The modern and recommended strategy for Core Data concurrency leverages `NSPersistentContainer` and its built-in features to simplify background tasks.\n\n### Core Concept: `NSPersistentContainer` Concurrency\n\nThe strategy revolves around two key components:\n1.  **`viewContext`**: This `NSManagedObjectContext` is associated with the main queue (`.main`) and is used for all UI-related data operations. It should be considered the single source of truth for the UI.\n2.  **Background Contexts**: For any long-running task like a data import, we use a temporary, private queue context. `NSPersistentContainer` provides a convenient API, `performBackgroundTask(_:)`, which creates such a context for you.\n\nWhen you save the background context, `NSPersistentContainer` automatically handles merging these changes into the `viewContext`, provided `viewContext.automaticallyMergesChangesFromParent` is set to `true` (which is the default in many templates). This keeps the UI in sync with background changes without manual observation and merging code.\n\n### Practical Code Example\n\n```swift\n// Assuming 'persistentContainer' is your NSPersistentContainer instance\n\nfunc importLargeDataset(from data: Data) {\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // This closure is executed on a private background queue.\n        // The 'backgroundContext' is a new, temporary context for this task.\n\n        // Set a merge policy to handle potential conflicts.\n        // 'mergeByPropertyObjectTrump' means in-memory changes win over the store's state.\n        backgroundContext.mergePolicy = NSMergeByPropertyObjectTrump\n\n        do {\n            let items = try JSONDecoder().decode([ImportedItem].self, from: data)\n            for itemData in items {\n                // Create or update managed objects using the backgroundContext\n                let newItem = MyEntity(context: backgroundContext)\n                newItem.id = itemData.id\n                newItem.name = itemData.name\n                // ... set other properties\n            }\n\n            // Save the background context. This is the crucial step.\n            // This save pushes changes to the Persistent Store Coordinator.\n            if backgroundContext.hasChanges {\n                try backgroundContext.save()\n            }\n        } catch {\n            // Handle import or save errors appropriately.\n            print(\"Failed to import data: \\(error)\")\n        }\n        // After this block, Core Data automatically merges the saved changes\n        // into the viewContext on the main thread, updating the UI via NSFetchedResultsController, etc.\n    }\n}\n```\n\n### Common Pitfalls & Edge Cases\n\n1.  **Passing `NSManagedObject`s Between Contexts**: Never pass a managed object fetched from one context to another. They are not thread-safe. Instead, pass its `NSManagedObjectID` and re-fetch the object on the new context: `let safeObject = newContext.object(with: objectID)`.\n2.  **Conflict Resolution**: The default merge policy is `NSErrorMergePolicy`, which will cause a save to fail if there's a conflict. For background sync, it's common to set a policy like `NSMergeByPropertyObjectTrump` (the new data overwrites old) or `NSMergeByPropertyStoreTrump` (the existing data is preserved). This must be set on the context performing the save.\n3.  **Blocking `viewContext`**: Ensure you don't accidentally access the `viewContext` from within the `performBackgroundTask` block. All Core Data work inside the block must use the provided background context.\n\n### When to Use vs. Alternatives\n\n-   **Use This Pattern**: For 95% of background tasks, including network fetches, data synchronization, and large imports. It's simple, safe, and leverages modern Core Data features.\n-   **Alternative (Parent/Child Contexts)**: A legacy pattern where you'd create a private context as a child of the `viewContext`. Saving the child context would push changes only to the parent (in memory), requiring an additional save on the parent to persist them. This is more complex and largely superseded by the automatic merging of `NSPersistentContainer`.",
      "code_example": null,
      "tags": [
        "core-data",
        "concurrency",
        "persistence",
        "ios",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "SwiftData fundamentals",
      "back": "",
      "code_example": null,
      "tags": [
        "SwiftData fundamentals"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Explain how SwiftData simplifies Core Data's object graph management and concurrency model. What trade-offs does this simplification introduce?",
      "back": "SwiftData fundamentally modernizes Core Data's approach by deeply integrating with the Swift language and its concurrency system.\n\n**Core Concept Explanation:**\nCore Data's power comes from its object graph management, centered on the `NSManagedObjectContext` (MOC) as a 'scratchpad'. However, this introduced significant complexity, especially with concurrency. Developers had to manually manage MOCs on specific threads or queues using `perform(_:)` or `performAndWait(_:)` to prevent data corruption and crashes. This required careful handling of parent/child contexts or passing `NSManagedObjectID`s between threads.\n\nSwiftData abstracts this entire stack away. It uses the `@Model` macro to transform a plain Swift class into a persistent object, eliminating the need for `.xcdatamodeld` files and `NSManagedObject` subclasses. The `ModelContext` replaces the MOC, but it's designed to be thread-safe. It's bound to an Actor, meaning changes are serialized, and you can safely use it within Swift's modern `async/await` syntax without manual locking or queue hopping.\n\n**Practical Code Example (Background Update):**\n```swift\n// --- Core Data --- \n// Requires manual background context and perform block\nlet container = persistentContainer\nlet taskID = // some NSManagedObjectID\ncontainer.performBackgroundTask { backgroundContext in\n    if let task = backgroundContext.object(with: taskID) as? TaskItem {\n        task.isCompleted = true\n    }\n    try? backgroundContext.save()\n}\n\n// --- SwiftData ---\n// Uses Swift Concurrency and an actor-isolated context\n@MainActor\nfunc updateTask(task: TaskItem, container: ModelContainer) {\n    let taskID = task.persistentModelID // Safely capture the ID\n    Task.detached {\n        // A new context is implicitly created for this background actor\n        let backgroundContext = ModelContext(container)\n        // Fetch the specific object on the background context\n        if let taskToUpdate = backgroundContext.model(for: taskID) as? TaskItem {\n             taskToUpdate.isCompleted = true\n             try? backgroundContext.save()\n        }\n    }\n}\n```\n\n**Common Pitfalls & Trade-offs:**\n\nThe primary trade-off is a loss of fine-grained control for the sake of simplicity. \n- **Abstraction:** While SwiftData is built on Core Data, the underlying mechanics are hidden. Debugging complex performance issues can be more difficult.\n- **Immaturity:** SwiftData is new and lacks some of Core Data's advanced features like custom fetch request subclasses, derived attributes, and complex migration policies. \n- **Concurrency:** While safer, it's not magic. You must not pass managed model objects across actor boundaries; you should pass their `PersistentIdentifier` instead and re-fetch them on the new actor's context, as shown in the example.\n\n**When to Use:**\n- **SwiftData:** The default choice for new apps, especially those built with SwiftUI. Its simplicity and integration with Swift Concurrency dramatically reduce boilerplate and common errors.\n- **Core Data:** Still necessary for existing large-scale projects where migration is infeasible, or for apps needing advanced features not yet present in SwiftData.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}