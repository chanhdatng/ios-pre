{
  "topic": "data_persistence",
  "generated_at": "2026-01-18T04:17:57.524036+00:00",
  "cards": [
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "You're storing a user's OAuth token. Why is Keychain the appropriate storage, and which `kSecAttr...` attributes are critical to configure for a secure, user-friendly implementation? Discuss the trade-offs.",
      "back": "Keychain is the correct choice for storing sensitive data like OAuth tokens because it's a secure, encrypted database managed by the OS, separate from the app's sandbox. Data stored in the Keychain persists even if the app is deleted, and it's protected by hardware-level encryption.\n\n**Core Concept:**\nThe Keychain Services API allows you to securely store small chunks of data. You interact with it by building a query dictionary that specifies what you want to do (add, update, read, delete) and the attributes of the item. The most critical attribute is `kSecAttrAccessible`, which defines when the data can be read.\n\nFor an OAuth token, a strong choice is `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`. This means:\n- The data can only be read when the device is unlocked.\n- The data is not migrated to a new device or included in backups.\n\nThis provides a great security balance: the token is protected when the device is locked, and a compromised backup won't expose the token. The trade-off is that the user must log in again on a new device.\n\n**Code Example:**\n```swift\n// Helper to manage a generic password item in Keychain\nfunc saveToken(token: String, account: String, service: String) -> OSStatus {\n    guard let data = token.data(using: .utf8) else { return errSecParam }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword, // We are storing a generic password\n        kSecAttrService as String: service,             // A unique service identifier (e.g., your app's bundle ID)\n        kSecAttrAccount as String: account,             // A unique account identifier (e.g., user ID)\n        kSecValueData as String: data,                  // The actual token data\n        // CRITICAL: Defines accessibility. Only available when device is unlocked.\n        // Not synced via iCloud Keychain or backed up.\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n\n    // Delete any existing item before saving a new one to prevent errSecDuplicateItem\n    SecItemDelete(query as CFDictionary)\n\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls:**\n- **Using `kSecAttrAccessibleAlways`:** This is a major security risk. It allows the data to be read even when the device is locked, defeating a primary security feature.\n- **Ignoring `OSStatus` return codes:** Always check the status returned from Keychain functions. A common mistake is not handling `errSecItemNotFound`, causing a crash or unexpected behavior when trying to read a non-existent item.\n- **Storing large data:** Keychain is optimized for small secrets. Storing large objects like images or JSON blobs will lead to poor performance.\n- **Forgetting data persists after uninstall:** If you don't explicitly clear Keychain data on logout, it will remain on the device after the app is deleted, which could be a surprise to the user upon reinstallation.\n\n**When to Use vs. Alternatives:**\n- **vs. UserDefaults:** Use `UserDefaults` for non-sensitive, user-facing preferences (e.g., dark mode setting). It's stored in an unencrypted plist file.\n- **vs. Encrypted Core Data/Realm:** Use these for large sets of structured, sensitive application data. The encryption key for the database itself is an excellent candidate for storage in the Keychain.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_0658a152705c",
      "front": "Describe the Core Data stack components and their roles in a concurrent environment. How would you safely perform a background data import and merge the changes to the main UI context?",
      "back": "The Core Data stack orchestrates object graph management and persistence. In a modern setup, `NSPersistentContainer` abstracts the boilerplate.\n\n**Core Concepts:**\n1.  **NSManagedObjectModel (MOM):** The schema. It describes your entities, attributes, and relationships, compiled from your `.xcdatamodeld` file. It's the blueprint for your data.\n2.  **NSPersistentStoreCoordinator (PSC):** The central coordinator. It connects the MOM to the persistent store(s) (e.g., a SQLite database). All contexts communicate with the store through a single coordinator, which ensures data integrity and manages access to the underlying file.\n3.  **NSManagedObjectContext (MOC):** An in-memory \"scratchpad\" for your managed objects. All fetching, creating, updating, and deleting happens within a context. **Crucially, contexts are not thread-safe.** The `NSPersistentContainer.viewContext` is configured for the main queue. For any background work, you must use a separate context on a private queue.\n\n**Practical Code Example:**\nThe modern approach uses `NSPersistentContainer` to manage concurrency by creating temporary, private queue contexts that share the same PSC as the main `viewContext`.\n\n```swift\n// Assume 'container' is your initialized NSPersistentContainer\n\n// 1. Configure the main context to observe and merge changes from other contexts\n// that save to the same persistent store coordinator.\ncontainer.viewContext.automaticallyMergesChangesFromParent = true\n\nfunc importLargeJSON() {\n    // 2. performBackgroundTask provides a new, temporary MOC on a private queue.\n    container.performBackgroundTask { privateContext in\n        // This block is executed on a background thread.\n        // It is safe to perform long-running parsing and object creation here.\n        let newItem = Item(context: privateContext)\n        newItem.name = \"New data from background\"\n        newItem.timestamp = Date()\n\n        do {\n            // 3. Save the private context. This saves changes directly to the PSC,\n            // which writes them to the store. This is efficient and doesn't block the main thread.\n            try privateContext.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n            // Implement robust error handling\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Passing `NSManagedObject`s between threads:** This is the most common cause of crashes. An `NSManagedObject` is tied to its context. Instead, pass its `NSManagedObjectID`, which is thread-safe, and fetch the object again in the new context.\n*   **Modifying `viewContext` from a background thread:** Never do this. It will lead to data corruption and crashes. Always use `viewContext.perform` or `viewContext.performAndWait` to ensure work is done on the main queue.\n*   **Misunderstanding Context Merging:** Forgetting to set `automaticallyMergesChangesFromParent = true` means your UI (e.g., an `NSFetchedResultsController`) won't update automatically after a background save.\n\n**When to Use vs. Alternatives:**\n*   **Sibling Contexts (via `performBackgroundTask`):** Ideal for independent, asynchronous tasks like network syncs or data imports. They save directly to the PSC, minimizing impact on the main thread.\n*   **Parent/Child Contexts:** An older pattern useful for discrete UI changes (e.g., an edit screen). The child context is a temporary scratchpad. Saving the child pushes changes to the parent (e.g., `viewContext`), but doesn't persist them until the parent is saved. This can be less efficient for heavy background tasks as saving the parent can block the UI.",
      "code_example": null,
      "tags": [
        "core-data",
        "concurrency",
        "persistence",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Describe Core Data's multi-layer caching mechanism. How do the `NSManagedObjectContext` and `NSPersistentStoreCoordinator` caches interact, and what strategies, like prefetching, can you use to mitigate performance issues like N+1 queries?",
      "back": "Core Data's performance relies on a sophisticated, multi-layer caching system to minimize expensive I/O operations with the persistent store (e.g., SQLite).\n\n**Core Concept Explanation:**\nThere are two primary caching layers:\n\n1.  **`NSManagedObjectContext` (MOC):** This is the first-level cache, often called the \"scratchpad.\" It holds the in-memory object graph you're working with. It guarantees *uniquing*, meaning for any given data record, only one `NSManagedObject` instance will exist within that context. Accessing objects already registered in the MOC is extremely fast as it's a direct memory access.\n\n2.  **`NSPersistentStoreCoordinator` (PSC):** This is the second-level cache. It sits between one or more MOCs and the persistent store(s). The PSC caches the raw row data fetched from the database. When a MOC faults an object that isn't in its own graph, it asks the PSC. If the PSC has the data cached, it can fulfill the request without hitting the disk, which is significantly faster than a full database query.\n\nThe most expensive operation is when neither cache has the data, forcing the PSC to execute a fetch against the store. This process of on-demand data loading is called *faulting*. While efficient for single objects, it can lead to the \"N+1 query\" problem when accessing relationships in a loop, causing one fetch for the initial objects and N subsequent fetches for their related objects.\n\n**Practical Code Example:**\nLet's say we have `Post` and `Comment` entities with a to-many relationship. A naive fetch can cause N+1 queries.\n\n```swift\n// Assume 'context' is your NSManagedObjectContext\n\n// --- PITFALL: The N+1 Query Problem ---\nlet postsFetch = NSFetchRequest<Post>(entityName: \"Post\")\nlet posts = try context.fetch(postsFetch)\n\n// This loop triggers a separate DB hit for EACH post to fetch its comments.\nfor post in posts {\n    // Accessing .comments fires a fault for each post individually.\n    print(\"\\(post.title) has \\(post.comments.count) comments.\")\n}\n\n// --- SOLUTION: Prefetching ---\nlet optimizedFetch = NSFetchRequest<Post>(entityName: \"Post\")\n// Tell Core Data to fetch all related 'comments' in an efficient, single follow-up query.\noptimizedFetch.relationshipKeyPathsForPrefetching = [\"comments\"]\n\nlet optimizedPosts = try context.fetch(optimizedFetch)\n\n// Now, iterating is fast. No new DB hits occur inside the loop.\nfor post in optimizedPosts {\n    // .comments are already in memory, no fault is triggered.\n    print(\"\\(post.title) has \\(post.comments.count) comments.\")\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n*   **Unintentional Faulting:** Accessing a relationship property on a managed object inside a loop is the most common cause of the N+1 problem.\n*   **Over-Prefetching:** Be selective. Prefetching large, complex object graphs or unused relationships can consume significant memory and slow down the initial fetch.\n*   **Ignoring the MOC Cache:** Before executing a fetch, consider if the object might already be in the context. Use `context.object(with: objectID)` or `context.existingObject(with: objectID)` to retrieve a known object without hitting the store.\n\n**When to Use vs. Alternatives:**\n*   **Lazy Loading (Default Faulting):** Ideal when you only need to access a few objects from a large dataset or when related data is accessed infrequently. It optimizes for memory usage.\n*   **Prefetching:** Use when you know you will access the related objects for a collection you've fetched (e.g., displaying posts and their authors in a list). It optimizes for speed by trading a higher initial fetch cost for faster subsequent access.\n*   **Fetch Request `batchSize`:** This is different. It faults objects from a large result set in batches as you iterate, which is useful for managing memory with large lists, but it does not solve the N+1 relationship problem. It's for the primary fetch, not the related objects.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Persistence",
        "Caching",
        "Performance",
        "NSFetchRequest"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Beyond syntax, contrast the architectural philosophies of Core Data and SwiftData. When would you advocate for using Core Data in a new, modern Swift project?",
      "back": "SwiftData is not merely a syntactic wrapper around Core Data; it's a fundamental re-imagining of the persistence layer for the modern Swift ecosystem. While it leverages Core Data's proven storage engine, its architectural philosophy is entirely different.\n\n**Core Concept Explanation:**\n\n*   **Core Data:** Is an *object graph management framework* first and a persistence solution second. Its architecture is explicit and imperative. You manually manage a stack: `NSPersistentContainer`, `NSManagedObjectContext`, `NSPersistentStoreCoordinator`. Concurrency is handled through distinct, manually managed contexts and `perform` blocks, enforcing strict thread confinement. This gives developers immense power and control but at the cost of significant boilerplate and a steep learning curve.\n\n*   **SwiftData:** Is a *declarative, Swift-native persistence framework*. It deeply integrates with modern Swift features like macros, value types, and structured concurrency. The complex stack is abstracted away behind a `ModelContainer` and `ModelContext`. The `ModelContext` is actor-bound, making concurrency management far more intuitive and less error-prone. It's designed to work seamlessly with SwiftUI via property wrappers like `@Query`.\n\n**Practical Code Example:**\n\n```swift\n// --- Core Data ---\n// In a .xcdatamodeld file, you define an 'Item' entity.\n// Then, you generate an NSManagedObject subclass.\nclass Item: NSManagedObject {\n    @NSManaged public var name: String\n    @NSManaged public var timestamp: Date\n}\n// Usage:\nlet context = persistentContainer.viewContext\nlet newItem = Item(context: context)\nnewItem.name = \"My Core Data Item\"\nnewItem.timestamp = Date()\ntry? context.save()\n\n\n// --- SwiftData ---\n// Model definition is simple and in code.\n@Model\nfinal class Item {\n    var name: String\n    var timestamp: Date\n\n    init(name: String, timestamp: Date) {\n        self.name = name\n        self.timestamp = timestamp\n    }\n}\n// Usage (often in a SwiftUI view with a modelContext):\nlet newItem = Item(name: \"My SwiftData Item\", timestamp: Date())\nmodelContext.insert(newItem)\n// Saving is often automatic or can be triggered via modelContext.save()\n```\n\n**When to Advocate for Core Data:**\n\nA common pitfall is assuming SwiftData replaces all Core Data use cases. Its simplicity can be a limitation.\n\n1.  **Complex Data Models & Migrations:** You need fine-grained control over complex migration paths (e.g., using mapping models), derived attributes, or complex validation rules. SwiftData's migration is simpler but less powerful.\n2.  **Custom Stores:** The app requires a non-SQLite store, like an in-memory store for unit tests, a binary store, or a custom atomic store for document-based apps. SwiftData currently only supports SQLite.\n3.  **Objective-C Interoperability:** The project is a mixed-language codebase or needs to expose its data model to Objective-C. SwiftData's macro-based models are pure Swift.\n4.  **Fine-Grained Control:** You need direct access to the `NSPersistentStoreCoordinator` to manage multiple stores or implement custom context merging policies. SwiftData abstracts this control away.\n5.  **Maturity & Stability:** For mission-critical apps where the stability of a framework battle-tested for over a decade outweighs the benefits of a modern API that is still evolving.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "architecture",
        "concurrency"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "SwiftData simplifies Core Data's architecture. Describe the roles of `ModelContainer`, `ModelContext`, and the `@Model` macro, and explain how they replace the traditional Core Data stack (PSC, MOC, NSManagedObject).",
      "back": "SwiftData fundamentally streamlines Core Data's verbose stack by leveraging modern Swift features. It replaces the complex setup of a Persistent Store Coordinator (PSC), Managed Object Context (MOC), and NSManagedObject subclasses with a more integrated, declarative API.\n\n**Core Concept Explanation:**\n\n1.  **`@Model` Macro:** This is the replacement for `NSManagedObject` subclasses and the `.xcdatamodeld` visual editor. By annotating a plain Swift class with `@Model`, the compiler automatically synthesizes the necessary code for persistence, including schema generation, property-level change tracking (replacing KVO), and relationship management. It makes the model a simple, type-safe Swift type.\n\n2.  **`ModelContext`:** This is the modern equivalent of `NSManagedObjectContext`. It's the primary actor for all data operations: inserting, fetching, updating, and deleting model objects. It tracks all changes and serves as the 'in-memory scratchpad'. Unlike the MOC, it's deeply integrated with SwiftUI, and changes automatically trigger view updates. By default, it also features an autosave mechanism.\n\n3.  **`ModelContainer`:** This component replaces the `NSPersistentContainer` and the manual configuration of the `NSPersistentStoreCoordinator`. It's the top-level object responsible for setting up the entire persistence stack, including the underlying storage (e.g., SQLite), loading the data model schema, and vending `ModelContext` instances.\n\n**Practical Code Example:**\n\n```swift\n// 1. Define the model using the @Model macro\n@Model\nfinal class Trip {\n    var name: String\n    var destination: String\n    var startDate: Date\n\n    init(name: String, destination: String, startDate: Date) {\n        self.name = name\n        self.destination = destination\n        self.startDate = startDate\n    }\n}\n\n// 2. Set up the container in the App's entry point\n@main\nstruct TravelApp: App {\n    var sharedModelContainer: ModelContainer = {\n        let schema = Schema([\n            Trip.self,\n        ])\n        let modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: false)\n\n        do {\n            return try ModelContainer(for: schema, configurations: [modelConfiguration])\n        } catch {\n            fatalError(\"Could not create ModelContainer: \\(error)\")\n        }\n    }()\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        // 3. Inject the context into the SwiftUI environment\n        .modelContainer(sharedModelContainer)\n    }\n}\n\n// 4. Use the context in a view\nstruct ContentView: View {\n    @Environment(\\.modelContext) private var modelContext\n    @Query private var trips: [Trip]\n\n    func addTrip() {\n        let newTrip = Trip(name: \"Alpine Hike\", destination: \"Switzerland\", startDate: .now)\n        // The context tracks this new object\n        modelContext.insert(newTrip)\n        // Saving is often automatic, or can be done explicitly:\n        // try? modelContext.save()\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n\n*   **Threading:** `ModelContext` is **not** thread-safe and is bound to the actor it was created on (typically `@MainActor`). For background work, you must create a new context from the `ModelContainer` on a background actor.\n*   **Autosave:** The default autosave behavior is convenient but can be problematic for complex transactions. You can disable it in the `ModelConfiguration` and call `modelContext.save()` manually for more precise control.\n*   **Relationships & Deletes:** Understanding cascade rules (`@Relationship(deleteRule: .cascade)`) is critical to avoid orphaned data or accidental deletions.\n\n**When to Use vs. Alternatives:**\n\n*   **SwiftData:** The default choice for new apps targeting iOS 17+. Its tight integration with SwiftUI and simplified API drastically speeds up development.\n*   **Core Data:** Necessary for projects that must support older iOS versions, require advanced features like complex validation rules, custom fetch request templates (NSFetchRequest), or have a mature, complex migration strategy that SwiftData cannot yet handle.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "swiftdata",
        "core_data",
        "architecture"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Your app's Core Data model requires a complex schema change. Compare lightweight and heavyweight migration, and describe a scenario where a custom NSEntityMigrationPolicy is necessary.",
      "back": "Core Data migration updates the database schema to match a new version of the data model. There are two primary strategies:\n\n**1. Lightweight Migration:**\nThis is the default and preferred approach. Core Data infers the changes between the old and new models and performs the migration automatically. It's enabled by setting two flags on the store description. It supports common changes like adding/removing entities or attributes, renaming properties (with renaming identifiers), and changing relationship cardinality.\n\n**2. Heavyweight (Custom) Migration:**\nThis is required for complex changes that Core Data cannot infer. Examples include splitting an entity into two, merging entities, or transforming an attribute's data type (e.g., String to a binary representation). It involves creating a Mapping Model (`.xcmappingmodel`) in Xcode, which explicitly defines how to map data from the source model version to the destination. For highly complex logic, you subclass `NSEntityMigrationPolicy` and implement custom transformation code, which you then associate with an entity mapping in the mapping model.\n\n**Code Example (Enabling Lightweight Migration):**\n```swift\n// In your Core Data stack setup\nlet container = NSPersistentContainer(name: \"MyModel\")\n\n// Get the default store description\nguard let description = container.persistentStoreDescriptions.first else {\n    fatalError(\"Failed to retrieve a persistent store description.\")\n}\n\n// Enable automatic lightweight migration\ndescription.shouldMigrateStoreAutomatically = true\ndescription.shouldInferMappingModelAutomatically = true\n\ncontainer.loadPersistentStores { /* ... */ }\n```\n\n**Common Pitfalls:**\n- **Forgetting to Version:** You must select the `.xcdatamodeld` file, go to Editor > Add Model Version, and set the new version as the current one. Failure to do so will cause a crash on launch as the model in code won't match the store's schema.\n- **Blocking UI:** Migrations run synchronously on `loadPersistentStores`. For large datasets, this can freeze the app for an extended period, risking termination by the system watchdog. This is a critical senior-level concern.\n- **Underestimating Complexity:** Assuming a change is simple enough for lightweight migration when it isn't. This can lead to crashes or data loss.\n\n**When to Use:**\n- **Lightweight:** Use for over 90% of schema changes. It's robust and requires no extra work beyond enabling the flags and versioning the model.\n- **Heavyweight with `NSEntityMigrationPolicy`:** Use when data transformation requires business logic. For example, migrating a single `fullName` (String) attribute into separate `firstName` and `lastName` attributes requires a custom policy to parse the string and populate the two new fields correctly.",
      "code_example": null,
      "tags": [
        "core-data",
        "data-persistence",
        "migration"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "You're architecting a feature that requires large, background data processing with Core Data. What concurrency strategy would you implement and why? Detail the lifecycle from context creation to merging changes for the UI.",
      "back": "For large background tasks, the modern and recommended strategy is to use `NSPersistentContainer` and its concurrency-focused APIs. The core principle is to isolate long-running work from the main thread to prevent UI freezes.\n\n**Core Concept: The `NSPersistentContainer` Model**\n\nThe fundamental rule of Core Data concurrency is that a `NSManagedObjectContext` and its managed objects must only be accessed from the queue they were created on. `NSPersistentContainer` simplifies this by providing:\n1.  **`viewContext`**: A context configured for the main queue (`.mainQueueConcurrencyType`). This is for all UI-related data operations.\n2.  **Background Contexts**: Temporary, private queue contexts (`.privateQueueConcurrencyType`) for background work. These are created via `performBackgroundTask` or `newBackgroundContext()`.\n\nWhen a background context saves, it writes directly to the `NSPersistentStoreCoordinator`. If the `viewContext` has its `automaticallyMergesChangesFromParent` property set to `true` (the default in SwiftUI projects, but must be set manually in UIKit), the container will observe the save notification and automatically merge the changes into the `viewContext` on the main thread, triggering UI updates via mechanisms like `NSFetchedResultsController`.\n\n**Lifecycle & Code Example:**\n```swift\n// Assume 'container' is your NSPersistentContainer instance\n// Ensure this is set, typically during stack setup.\ncontainer.viewContext.automaticallyMergesChangesFromParent = true\n\nfunc importLargeDataSet(from data: [DataType]) {\n    // 1. Request a background context from the container.\n    // This block is executed on a private background queue.\n    container.performBackgroundTask { backgroundContext in\n        // The context is configured for you.\n        backgroundContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        // 2. Perform heavy work inside the block.\n        // Fetch, create, or update objects using ONLY this backgroundContext.\n        data.forEach { itemData in\n            let newItem = Item(context: backgroundContext)\n            newItem.id = itemData.id\n            newItem.title = itemData.title\n        }\n        \n        // 3. Save the background context.\n        // This is an I/O operation and happens in the background.\n        do {\n            if backgroundContext.hasChanges {\n                try backgroundContext.save()\n            }\n        } catch {\n            // Handle the save error (e.g., logging).\n            print(\"Failed to save background context: \\(error)\")\n        }\n        // 4. On successful save, the container automatically merges\n        // these changes into viewContext on the main thread.\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Passing `NSManagedObject`s between threads**: This is the most critical error. An object fetched on one context is invalid on another. Instead, pass its `NSManagedObjectID`, which is thread-safe, and use it to fetch a new instance of the object on the destination context.\n*   **Merge Conflicts**: If both the `viewContext` and a background context modify the same object, a save can fail. Setting a `mergePolicy` (like `NSMergeByPropertyObjectTrumpMergePolicy`) on the background context tells Core Data how to resolve these conflicts automatically.\n*   **Stale UI**: Forgetting to set `viewContext.automaticallyMergesChangesFromParent = true` will result in background changes never appearing in the UI until the next app launch.\n\n**Alternatives:**\n*   **Parent/Child Contexts**: An older pattern where a background context is a child of the main context. The child save only pushes changes to the parent in memory. The parent must then be saved to persist. This is more complex and can block the main context during the parent's save operation, making it less ideal for large data imports compared to the modern approach where background contexts work directly with the store coordinator.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Persistence",
        "iOS",
        "Multithreading"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}