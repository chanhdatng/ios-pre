{
  "topic": "data_persistence",
  "generated_at": "2026-01-14T04:19:33.242017+00:00",
  "cards": [
    {
      "id": "data_persistence_0658a152705c",
      "front": "Describe the modern Core Data stack, focusing on the roles of the main vs. background `NSManagedObjectContext`. How do you ensure thread safety and propagate changes from a background context to the UI-bound main context?",
      "back": "The modern Core Data stack, simplified by `NSPersistentContainer`, consists of the `NSManagedObjectModel` (schema), `NSPersistentStoreCoordinator` (PSC), and `NSManagedObjectContext` (MOC).\n\nThe PSC is the central hub, connecting the in-memory object graphs (MOCs) to the persistent store (e.g., SQLite). MOCs act as intelligent, in-memory scratchpads where you manage your `NSManagedObject` instances.\n\n**Contexts and Concurrency:**\n- **`viewContext`**: A main-queue context provided by the container, intended for all UI-related work. Accessing it from any other thread will lead to crashes or data corruption.\n- **Background Contexts**: Created via `container.newBackgroundContext()`. These operate on a private background queue. They are ideal for long-running tasks like data imports, complex calculations, or network syncs, preventing UI freezes.\n\n**Thread Safety and Data Propagation:**\nSince MOCs are not thread-safe, you must never pass `NSManagedObject` instances between threads. Instead, pass its thread-safe `NSManagedObjectID` and re-fetch the object in the destination context. All work on a context must be wrapped in its `perform` or `performAndWait` block.\n\nTo update the UI with background changes, the `viewContext` should be configured with `automaticallyMergesChangesFromParent = true`. When a background context saves, its changes are written to the PSC. The PSC then notifies other contexts, and the `viewContext` automatically merges these changes, triggering UI updates via mechanisms like `NSFetchedResultsController`.\n\n```swift\n// Assumes 'container' is your NSPersistentContainer instance\n// In setup: container.viewContext.automaticallyMergesChangesFromParent = true\n\nfunc updateUserBio(for userID: NSManagedObjectID, newBio: String) {\n    // 1. Get a background context for the heavy lifting.\n    let backgroundContext = container.newBackgroundContext()\n\n    // 2. Use perform to ensure work happens on the context's private queue.\n    backgroundContext.perform {\n        // 3. Safely fetch the object in this context using its ID.\n        guard let userToUpdate = backgroundContext.object(with: userID) as? User else {\n            print(\"User not found in background context\")\n            return\n        }\n\n        userToUpdate.bio = newBio // Perform modifications\n\n        do {\n            // 4. Save the background context. This writes changes to the persistent store.\n            try backgroundContext.save()\n        } catch {\n            // Production code should handle this error robustly.\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Cross-thread MOC access**: Directly accessing `viewContext` from a background queue.\n- **Passing Managed Objects**: Passing a managed object instance across queues instead of its `NSManagedObjectID`.\n- **Forgetting to Save**: Performing work in a background context but forgetting to call `save()`. The changes will be lost when the context is deallocated.\n\n**Alternatives:**\nThe older parent/child context pattern involved saving a child context, which only pushed changes to the parent's memory. This could block the parent (often the `viewContext` on the main thread) during its final save to the PSC. The modern sibling-context approach with automatic merging is generally more efficient and non-blocking.",
      "code_example": null,
      "tags": [
        "core-data",
        "concurrency",
        "persistence",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "You're debugging a slow UI backed by Core Data that displays a list of objects and their related data. What are the layers of caching you would investigate, and what specific strategies would you use to optimize performance and minimize database hits?",
      "back": "Core Data employs a sophisticated multi-level caching strategy to balance memory usage and performance. When optimizing, I'd investigate these three layers:\n\n1.  **NSManagedObjectContext (MOC):** The highest-level cache, or 'scratchpad.' It holds fully materialized managed objects. Access is extremely fast as it's just pointer traversal in memory. Core Data guarantees 'uniquing' here, meaning only one object instance exists per record within a given context.\n\n2.  **NSPersistentStoreCoordinator (PSC):** An intermediate cache that holds raw row data (snapshots) fetched from the persistent store. If an object isn't in the MOC but its data is in the PSC cache, Core Data can create the managed object without a disk I/O operation, which is significantly faster than a full database fetch.\n\n3.  **NSPersistentStore (SQLite):** The lowest level, representing the database on disk. Accessing this layer is the most expensive operation as it involves file I/O and SQL query execution.\n\nMy primary strategy would be to prevent 'faulting storms' (the N+1 query problem), where accessing a relationship on each object in a loop triggers a separate database hit for each one. This is solved with prefetching.\n\n**Code Example (Prefetching):**\n```swift\n// Assume a 'Department' entity with a to-many relationship 'employees' to 'Employee'\nlet fetchRequest: NSFetchRequest<Department> = Department.fetchRequest()\n\n// Without prefetching, accessing 'department.employees' for each department in a loop\n// would trigger a separate fetch for each department's employees.\n\n// WITH prefetching: Tell Core Data to fetch all related 'employees' in a single, optimized query.\nfetchRequest.relationshipKeyPathsForPrefetching = [\"employees\"]\n\n// This single fetch now pulls all Departments AND their related Employees efficiently.\ndo {\n    let departments = try viewContext.fetch(fetchRequest)\n    for dept in departments {\n        // Accessing .employees is now fast, as the objects are already in the MOC.\n        print(\"\\(dept.name ?? \\\"N/A\\\") has \\(dept.employees?.count ?? 0) employees.\")\n    }\n} catch {\n    print(\"Failed to fetch departments: \\(error)\")\n}\n```\n\n**Common Pitfalls:**\n- **Lazy Loading Abuse:** Relying on faulting for everything. While great for memory, it's a performance killer in loops or for list UIs.\n- **Ignoring Existing Objects:** Unnecessarily re-fetching data that might already exist in the MOC. Before fetching, one could check with `context.objectRegisteredForID(:)`.\n- **Large In-Memory Graphs:** Loading too much data via prefetching can lead to high memory consumption. Use `fetchLimit` and `fetchOffset` for pagination.\n\n**When to Use vs. Alternatives:**\n- **Prefetching:** Best for table/collection views where you know you'll need related data for visible cells.\n- **Batch Faulting (`returnsObjectsAsFaults = false`):** Fetches all property values at once, avoiding individual property faults. Useful if you know you'll access most properties of the fetched objects.\n- **`NSBatchUpdateRequest`/`DeleteRequest`:** For bulk data changes without loading objects into memory at all. This bypasses the MOC cache and operates directly on the PSC, offering the best performance for large-scale updates/deletes.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "caching",
        "performance",
        "ios"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Describe Core Data migration strategies. When would you choose a lightweight migration over a heavyweight one, and what are the key steps and pitfalls of implementing a custom migration policy?",
      "back": "Core Data migration is essential for evolving an app's data model without losing user data. There are two main strategies:\n\n1.  **Lightweight Migration**: This is the default, automatic approach. By setting `shouldMigrateStoreAutomatically` and `shouldInferMappingModelAutomatically` to `true` on your `NSPersistentStoreDescription`, Core Data can infer the mapping for simple changes like adding/removing attributes or entities, renaming properties (using the `renamingIdentifier`), and changing optionality.\n\n2.  **Heavyweight (Manual) Migration**: This is required for complex changes that Core Data cannot infer. This includes splitting an attribute into multiple attributes, merging entities, or changing an attribute's data type in a non-trivial way. It involves creating a Mapping Model (`.xcmappingmodel`) in Xcode that explicitly defines the transformation from the source to the destination model. For custom logic, you create a subclass of `NSEntityMigrationPolicy` and associate it with an entity mapping in the Mapping Model.\n\n**Example: Custom Migration Policy (Splitting `fullName` to `firstName`, `lastName`)**\n```swift\n// In a custom NSEntityMigrationPolicy subclass\nclass PersonMigrationPolicy: NSEntityMigrationPolicy {\n    override func createDestinationInstances(for sInstance: NSManagedObject,\n                                           in mapping: NSEntityMapping,\n                                           manager: NSMigrationManager) throws {\n        // 1. Get source data\n        guard let fullName = sInstance.value(forKey: \"fullName\") as? String else {\n            try super.createDestinationInstances(for: sInstance, in: mapping, manager: manager)\n            return\n        }\n\n        // 2. Create destination instance\n        let destInstance = NSEntityDescription.insertNewObject(\n            forEntityName: mapping.destinationEntityName!,\n            into: manager.destinationContext\n        )\n\n        // 3. Transform and populate data\n        let components = fullName.components(separatedBy: \" \")\n        destInstance.setValue(components.first ?? \"\", forKey: \"firstName\")\n        destInstance.setValue(components.last ?? \"\", forKey: \"lastName\")\n\n        // 4. Associate source and destination\n        manager.associate(sourceInstance: sInstance, withDestinationInstance: destInstance, for: mapping)\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Forgetting to Version**: Failing to create a new version of the `.xcdatamodeld` file before making changes. This is the most common mistake and prevents migration from being triggered.\n*   **Performance**: Migration runs synchronously on app launch. With large datasets, this can cause a significant delay or even a watchdog termination. For very large migrations, consider a multi-stage or background approach.\n*   **Data Loss**: Flawed logic in a custom policy can lead to incorrect data transformation or data loss. Thorough testing is critical.\n\n**When to Use vs. Alternatives:**\n*   **Lightweight**: Always prefer this for its simplicity and reliability. Use for any supported schema change.\n*   **Heavyweight**: Use only when lightweight migration is insufficient, such as for complex data transformations that require custom code.\n*   **Alternative**: For massive schema changes or to provide a better UX (e.g., a progress bar), you could perform a manual export/import. This involves creating a new store with the new model, exporting data from the old store into an intermediate format, and then importing it into the new store. This is significantly more complex.",
      "code_example": null,
      "tags": [
        "core-data",
        "data-persistence",
        "migration",
        "ios"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Beyond its modern Swift syntax, how do Core Data and SwiftData fundamentally differ in their approach to object graph management, persistence, and concurrency? What are the practical implications for a senior developer?",
      "back": "The fundamental difference lies in their design philosophy and level of abstraction.\n\n**Core Concept Explanation:**\nCore Data is an imperative, object-graph management framework with its roots in Objective-C. You interact with a \"stack\" of objects, with `NSManagedObjectContext` being the central \"scratchpad\" for all in-memory model objects. You explicitly fetch, modify, and save changes to a context. This gives you granular control over the object lifecycle and persistence but requires significant boilerplate and manual management, especially for concurrency (e.g., using `performBackgroundTask` or parent/child contexts).\n\nSwiftData is a declarative, Swift-native wrapper built on top of the same Core Data engine. It abstracts away the complex stack. Instead of managing contexts directly, you work with a `ModelContext`, which is an actor, providing thread-safety out of the box. The schema is defined using modern Swift macros (`@Model`), making model classes cleaner and eliminating the `.xcdatamodeld` file. SwiftData is designed for seamless integration with SwiftUI and Swift Concurrency, prioritizing developer experience and safety.\n\n**Practical Code Example:**\n```swift\n// --- Core Data ---\n// Model is an NSManagedObject subclass from a .xcdatamodeld file.\nclass CDItem: NSManagedObject { /* ... properties with @NSManaged ... */ }\n\n// Fetching and updating requires explicit context management.\nlet context = persistentContainer.viewContext\nlet request = NSFetchRequest<CDItem>(entityName: \"CDItem\")\n\nfunc updateItem(id: UUID) {\n    context.perform { // Ensure work is on the correct queue\n        request.predicate = NSPredicate(format: \"id == %@\", id as CVarArg)\n        if let item = try? context.fetch(request).first {\n            item.setValue(\"New Name\", forKey: \"name\")\n            // Saving is an explicit, potentially throwing operation.\n            try? context.save()\n        }\n    }\n}\n\n// --- SwiftData ---\n// Model is a plain Swift class with the @Model macro.\n@Model\nfinal class SDItem {\n    @Attribute(.unique) var id: UUID\n    var name: String\n    init(id: UUID, name: String) { self.id = id; self.name = name }\n}\n\n// ModelContext is an actor, simplifying concurrency.\nfunc updateItem(id: UUID, context: ModelContext) async {\n    let descriptor = FetchDescriptor<SDItem>(predicate: #Predicate { $0.id == id })\n    if let item = try? context.fetch(descriptor).first {\n        item.name = \"New Name\"\n        // Saving can be automatic, or explicit if needed.\n        // try? context.save()\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n- **Core Data:** The biggest pitfall is concurrency. Passing `NSManagedObject` instances between threads/queues is a common source of crashes. Developers must carefully manage contexts to avoid data corruption. Understanding object faulting and complex merge policies is also crucial.\n- **SwiftData:** Its \"magic\" can be a pitfall. The automatic saving mechanism might be unsuitable for all use cases, and understanding when and how to perform explicit saves is important. As it's a higher-level abstraction, debugging underlying persistence issues can be more challenging. Some advanced Core Data features (e.g., derived attributes, fetched properties) lack a direct, first-party equivalent.\n\n**When to Use vs. Alternatives:**\n- **Use Core Data** for projects targeting < iOS 17, those with complex pre-existing models, or when you need fine-grained control over the persistence stack (e.g., custom stores, intricate fetch configurations). It remains the robust choice for mature UIKit-heavy applications.\n- **Use SwiftData** for new projects targeting iOS 17+, especially those built with SwiftUI. Its simplicity, type safety, and built-in concurrency support lead to faster development and fewer bugs, making it the default choice for modern apps.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "How do you safely perform a large background data import using Core Data without blocking the UI? Describe the context setup, the process of saving, and how changes are propagated to the main view context.",
      "back": "The core principle of Core Data concurrency is that a `NSManagedObjectContext` is not thread-safe and should only be accessed from the queue it was created on. To perform background work, you use a separate context on a private queue.\n\n**Core Concept: Sibling Contexts**\nThe modern approach with `NSPersistentContainer` creates a main queue context (`viewContext`) for the UI and allows for creating separate background contexts that share the same `NSPersistentStoreCoordinator`. When a background context saves, its changes are written to the persistent store. The persistent store coordinator then notifies other contexts, like the `viewContext`, about these changes.\n\nTo ensure the UI updates automatically, you must set `viewContext.automaticallyMergesChangesFromParent = true` during your Core Data stack setup. Despite its name, this property enables the context to observe `NSManagedObjectContext.didSaveObjectsNotification` from other contexts sharing its coordinator and merge those changes automatically.\n\n**Practical Code Example:**\n```swift\n// In your Core Data stack setup (e.g., AppDelegate or a singleton)\nlazy var persistentContainer: NSPersistentContainer = {\n    let container = NSPersistentContainer(name: \"MyApp\")\n    container.loadPersistentStores { ... }\n    // Key step: Enable automatic merging for the UI context\n    container.viewContext.automaticallyMergesChangesFromParent = true\n    return container\n}()\n\n// Function to perform the background import\nfunc importLargeDataset() {\n    // Use performBackgroundTask to get a temporary, private queue context\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // The code inside this closure runs on a background thread.\n        \n        // 1. Fetch or create data within this backgroundContext\n        for itemData in largeDataset {\n            let newItem = Item(context: backgroundContext)\n            newItem.id = itemData.id\n            newItem.name = itemData.name\n        }\n\n        // 2. Save the changes on the background context.\n        // This is transactional and writes directly to the store.\n        do {\n            try backgroundContext.save()\n        } catch {\n            // Handle the save error (e.g., validation, conflicts)\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n    // After this block, the backgroundContext is disposed of.\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Passing `NSManagedObject`s between threads:** Never pass a managed object fetched from one context to another. They are bound to their context's queue. Instead, pass its thread-safe `NSManagedObjectID` and use `context.object(with:)` to retrieve a new instance of the object on the target context.\n2.  **Forgetting to Save:** Changes made in the `performBackgroundTask` block are only in memory. If you don't call `save()`, the work is discarded and nothing is persisted or merged.\n3.  **Merge Conflicts:** If the main context and a background context modify the same object, a conflict can occur. You can configure a merge policy on your context (e.g., `NSMergeByPropertyObjectTrumpMergePolicy`) to define how conflicts are resolved. The default policy is `NSErrorMergePolicy`, which fails the save.\n\n**When to Use vs. Alternatives:**\nThis sibling context pattern is ideal for most background tasks like network syncs or data processing. An older alternative is parent-child contexts, where a background context is a child of the main context. Saving the child pushes changes to the parent in-memory, not to the store. This is better for isolated, discardable changes (like an edit form) but less efficient for large background imports as it can still block the main context during the parent's final save.",
      "code_example": null,
      "tags": [
        "core-data",
        "concurrency",
        "persistence",
        "ios",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "How do SwiftData's `ModelContainer` & `ModelContext` refactor Core Data's stack (PSC, MOC), and what are the implications for concurrency and data modeling?",
      "back": "SwiftData fundamentally modernizes Apple's persistence framework by replacing Core Data's verbose stack with a streamlined, Swift-native architecture.\n\n**Core Concept Explanation:**\n\nIn Core Data, you manage a complex stack: an `NSPersistentContainer` that holds the `NSPersistentStoreCoordinator` (manages stores), and one or more `NSManagedObjectContext`s (MOCs) which act as in-memory scratchpads for your data. Concurrency is a major challenge, requiring manual creation of private queue contexts, passing `NSManagedObjectID`s, and merging changes, which is notoriously error-prone.\n\nSwiftData replaces this entire hierarchy with two main components:\n1.  **`ModelContainer`**: This is the new top-level object. It configures the entire persistence stack, including the schema (defined by your `@Model` classes), the store (e.g., SQLite), and migration policies. It's typically set up once for the entire app.\n2.  **`ModelContext`**: This is the equivalent of a MOC. It's the object you use to fetch, insert, update, and delete model objects. Crucially, a `ModelContext` is actor-isolated. The main context, provided via SwiftUI's environment, is bound to the `@MainActor`, ensuring that any data access for UI purposes is thread-safe by default. For background work, you can create a new context that runs on a background actor, safely interacting with data off the main thread.\n\nThis architecture shift also moves from a visual `.xcdatamodeld` file to a **code-first approach**. You define your schema directly in Swift using the `@Model` macro, which synthesizes all the necessary persistence logic.\n\n**Practical Code Example:**\n```swift\n// 1. Define a model with the @Model macro (code-first approach)\n@Model\nfinal class Item {\n    var name: String\n    var timestamp: Date\n    \n    init(name: String, timestamp: Date) {\n        self.name = name\n        self.timestamp = timestamp\n    }\n}\n\n// 2. Set up the container in your App struct\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        // The container is configured once for all scenes\n        .modelContainer(for: Item.self)\n    }\n}\n\n// 3. Use @Query and ModelContext in a SwiftUI View\nstruct ContentView: View {\n    // Injects the main, actor-isolated model context\n    @Environment(\\.modelContext) private var modelContext\n    \n    // @Query automatically fetches data and updates the view on changes\n    @Query(sort: \\.timestamp, order: .reverse) private var items: [Item]\n\n    func addItem() {\n        // This operation is safely performed on the main actor\n        let newItem = Item(name: \"New Item\", timestamp: .now)\n        modelContext.insert(newItem)\n        // Autosave is enabled by default, but explicit save is better for critical paths\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Concurrency Misuse**: Accessing the main `ModelContext` from a background task (`Task.detached`) will cause a runtime crash due to actor isolation. You must create a new context from the `ModelContainer` for background work.\n- **Over-relying on Autosave**: While convenient, autosave can obscure errors. For critical data writes, use an explicit `do-try-catch` block around `modelContext.save()` to handle potential validation or I/O failures.\n- **Large Datasets**: The `@Query` property wrapper is simple but can be inefficient for very large datasets. For better performance, create a custom `FetchDescriptor` with specific predicates, sort orders, and fetch limits.\n\n**When to Use vs. Alternatives:**\n- **SwiftData**: The default choice for new SwiftUI projects targeting iOS 17+. Its deep integration with SwiftUI and Swift Concurrency simplifies development significantly.\n- **Core Data**: Necessary for projects that must support older OS versions, are heavily based in UIKit, or require fine-grained control over complex data validation, migration, and store coordination that SwiftData currently abstracts away.\n- **GRDB/Realm**: Consider third-party solutions like GRDB for type-safe SQL power and performance, or Realm for its cross-platform capabilities and mature reactive object database.",
      "code_example": null,
      "tags": [
        "swiftdata",
        "coredata",
        "persistence",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "How do you securely share credentials between a main app and its extensions (e.g., Widget) using the Keychain? Discuss the roles of Access Groups and `kSecAttrSynchronizable`.",
      "back": "The Keychain is sandboxed by default, meaning items are only accessible to the app that created them. To share secrets like API tokens between a main app and its extensions, you must use a Keychain Access Group.\n\n**Core Concept:**\nAn Access Group is an entitlement that creates a shared Keychain space for a suite of apps from the same developer team. By adding this entitlement to your main app and all extensions (e.g., `group.com.yourcompany.yourapp`), they can all read and write to the same Keychain items if the `kSecAttrAccessGroup` attribute is set during the operation.\n\nSeparately, the `kSecAttrSynchronizable` attribute, when set to `kCFBooleanTrue`, tells the system to sync the item across all of a user's devices via their iCloud Keychain. This is powerful but introduces potential data latency.\n\n**Code Example (Save/Update Token):**\n```swift\nfunc saveToken(_ token: String, for account: String) -> OSStatus {\n    guard let tokenData = token.data(using: .utf8) else { return errSecInvalidData }\n    let accessGroup = \"YOUR_TEAM_ID.com.yourcompany.shared\"\n\n    // Base query for save/update operations\n    var query: [String: Any] = [\n        kSecClass: kSecClassGenericPassword,\n        kSecAttrAccount: account,\n        kSecAttrAccessGroup: accessGroup\n    ]\n\n    // Attributes for the item to be added or updated\n    let attributes: [String: Any] = [\n        kSecValueData: tokenData,\n        // Syncs item across user's devices via iCloud Keychain\n        kSecAttrSynchronizable: kCFBooleanTrue \n    ]\n\n    // First, try to update an existing item\n    var status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)\n\n    // If the item doesn't exist, add it\n    if status == errSecItemNotFound {\n        query.merge(attributes) { (_, new) in new }\n        status = SecItemAdd(query as CFDictionary, nil)\n    }\n    return status\n}\n```\n**Common Pitfalls:**\n1.  **Configuration Errors:** The Access Group entitlement must be enabled and identical in the 'Signing & Capabilities' tab for the main app and *every* extension target. Mismatches are a common cause of `errSecItemNotFound`.\n2.  **Synchronization Lag:** iCloud Keychain sync is not instantaneous. Your app/extensions must handle cases where a secret saved on one device is not yet available on another.\n3.  **Forgetting the Access Group in Queries:** When fetching or deleting an item, you *must* include the `kSecAttrAccessGroup` key in your query dictionary, otherwise the search will be confined to the app's default sandbox.\n\n**When to Use vs. Alternatives:**\n-   **Use Keychain:** For small, highly sensitive secrets like auth tokens, passwords, and cryptographic keys. It provides hardware-backed security.\n-   **Alternatives:**\n    -   `UserDefaults(suiteName:)`: For non-sensitive shared data like user settings or flags. It's unencrypted and easily readable.\n    -   **Shared File Container:** For larger, structured, sensitive data. You can store a file (e.g., an encrypted database like SQLCipher or a file encrypted with CryptoKit) in a shared App Group container. This requires you to manage encryption, serialization, and file access coordination yourself.",
      "code_example": null,
      "tags": [
        "security",
        "data_persistence",
        "keychain",
        "app_extensions"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}