{
  "topic": "data_persistence",
  "generated_at": "2026-01-08T04:59:58.553499+00:00",
  "cards": [
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "Explain SwiftData's fundamental architecture and how it differs from Core Data. Focus on the roles of the Model Container, Model Context, and persistent storage.",
      "back": "SwiftData simplifies data persistence compared to Core Data. \n\n**Core Concepts:**\n\n*   **Model Container:** This is the entry point. It manages the schema (your data model) and the persistent storage.  Think of it as the database file and the schema definition combined. Unlike Core Data's managed object model, persistent store coordinator, and managed object context setup, SwiftData bundles these. Initialization involves providing your model classes.  It handles the underlying SQLite database setup.\n\n*   **Model Context:**  This is your scratchpad. You create, read, update, and delete objects within a model context.  Changes are tracked here.  It's analogous to Core Data's `NSManagedObjectContext`.  Saving the context persists the changes to the underlying storage.\n\n*   **Persistent Storage:**  SwiftData uses SQLite by default. The Model Container handles the interaction.  You rarely need to interact with SQLite directly. \n\n**Differences from Core Data:**\n\n*   **Simplified Setup:** Core Data requires setting up a managed object model, persistent store coordinator, and managed object context. SwiftData streamlines this with the Model Container.\n*   **Type Safety:**  SwiftData leverages Swift's type system more effectively, reducing the need for string-based entity names and key paths.\n*   **Integration with SwiftUI:** SwiftData is designed to work seamlessly with SwiftUI, offering property wrappers like `@Query` for easy data fetching.\n*   **Less Boilerplate:**  SwiftData aims to reduce boilerplate code associated with Core Data.\n\n**Code Example:**\n\n```swift\nimport SwiftData\n\n// 1. Define your Model\n@Model\nclass Item {\n    var title: String\n    var timestamp: Date\n\n    init(title: String, timestamp: Date = Date()) {\n        self.title = title\n        self.timestamp = timestamp\n    }\n}\n\n// In your SwiftUI view:\nstruct ContentView: View {\n    @Environment(\\ModelContext) private var modelContext\n    @Query private var items: [Item]\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.title)\n            }\n        }\n        .toolbar {\n            Button(\"Add Item\") {\n                let newItem = Item(title: \"New Item\")\n                modelContext.insert(newItem)\n                //No need to save context explicitly, done automatically unless disabled\n            }\n        }\n    }\n}\n\n//In your app:\n@main\nstruct SwiftDataApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .modelContainer(for: Item.self)\n    }\n}\n```\n\n**Common Pitfalls:**\n\n*   **Forgetting `@Model`:**  SwiftData won't recognize your class as a model without the `@Model` macro.\n*   **Context Management:**  Ensure you're using the correct `ModelContext`. In SwiftUI, use `@Environment(\\ModelContext)`.  For background tasks, create a new context.\n*   **Schema Migrations:**  SwiftData handles basic schema changes, but complex migrations might require manual intervention (not fully fleshed out as of the current release).\n*   **Relationship management:** SwiftData simplifies relationships, but you still need to understand inverse relationships to avoid data inconsistencies. Using `@Relationship` macro.\n\n**Alternatives:**\n\n*   **Core Data:**  Still a powerful option for complex data models and advanced features, but requires more setup.\n*   **Realm:**  Another mobile database solution with a different architecture.\n*   **SQLite (Directly):**  Provides the most control but requires writing SQL queries and managing the database yourself.\n*   **UserDefaults:**  Suitable for simple key-value storage, not for complex data models.",
      "code_example": null,
      "tags": [
        "SwiftData",
        "Data Persistence",
        "Core Data",
        "Model Container",
        "Model Context"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Compare and contrast Core Data and SwiftData. When would you choose one over the other?",
      "back": "Core Data is a mature, powerful framework for managing an app's data model. It's not just persistence; it's an object graph management system. You define entities, attributes, and relationships in a schema. Core Data handles persistence (often SQLite), change tracking, validation, and even undo/redo. \n\nSwiftData, introduced in iOS 17, is Apple's modern data persistence framework built on top of Core Data. It simplifies the process, leveraging Swift's features like `@Model` macro for declarative data modeling. It integrates seamlessly with SwiftUI.  \n\n**Core Data:**\n*   **Pros:** Mature, flexible, handles complex data models & relationships, supports migrations, background processing.\n*   **Cons:** Steeper learning curve, more boilerplate code, manual management of the Core Data stack (managed object context, persistent store coordinator).\n\n**SwiftData:**\n*   **Pros:** Simpler API, declarative data modeling, SwiftUI integration, automatic schema migration.\n*   **Cons:** Relatively new, fewer features than Core Data, limited customization, may not be suitable for highly complex scenarios.\n\n**Example (Core Data):**\n```swift\nimport CoreData\n\nclass Task: NSManagedObject {\n @NSManaged public var title: String?\n @NSManaged public var isCompleted: Bool\n}\n\n// Creating a new task\nlet task = Task(context: managedObjectContext)\ntask.title = \"Buy groceries\"\ntask.isCompleted = false\n\n// Saving the context\ndo {\n try managedObjectContext.save()\n} catch {\n print(\"Error saving context: \\(error)\")\n}\n```\n\n**Example (SwiftData):**\n```swift\nimport SwiftData\n\n@Model\nclass Task {\n var title: String\n var isCompleted: Bool = false\n\n init(title: String) {\n self.title = title\n }\n}\n\n// Creating a new task\nlet task = Task(title: \"Buy groceries\")\nmodelContext.insert(task)\n\n// Saving is automatic\n```\n\n**When to use which:**\n*   **Core Data:** Use when you need advanced features like versioning, complex relationships, or fine-grained control over persistence. If you have an existing Core Data project, sticking with it might be the best option.\n*   **SwiftData:** Use when you want a simpler, more SwiftUI-friendly approach, especially for new projects.  If you need rapid development and your data model is relatively straightforward, SwiftData is a great choice.\n\n**Pitfalls:**\n*   **Core Data:**  Forgetting to save the context, incorrect thread management, complex migrations.\n*   **SwiftData:** Limited customization, potential issues with very large datasets, lack of some advanced Core Data features.",
      "code_example": null,
      "tags": [
        "data persistence",
        "Core Data",
        "SwiftData",
        "iOS 17"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Migration strategies",
      "back": "",
      "code_example": null,
      "tags": [
        "Migration strategies"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "Concurrency with Core Data",
      "back": "",
      "code_example": null,
      "tags": [
        "Concurrency with Core Data"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Caching strategies",
      "back": "",
      "code_example": null,
      "tags": [
        "Caching strategies"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "Keychain usage",
      "back": "",
      "code_example": null,
      "tags": [
        "Keychain usage"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}