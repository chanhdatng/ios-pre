{
  "topic": "data_persistence",
  "generated_at": "2026-01-17T03:55:34.001175+00:00",
  "cards": [
    {
      "id": "data_persistence_0658a152705c",
      "front": "Describe the roles of the key components in a Core Data stack and explain how `NSManagedObjectContext` acts as a transactional 'scratchpad' for managing the object graph.",
      "back": "The Core Data stack is a collection of objects that manage an app's model layer. While modern development uses `NSPersistentContainer` to encapsulate this, understanding the underlying components is crucial.\n\n1.  **`NSManagedObjectModel`**: The schema or blueprint of your data. It's created from your `.xcdatamodeld` file and defines entities, attributes, and relationships.\n2.  **`NSPersistentStoreCoordinator` (PSC)**: The \"brain\" of the stack. It connects the object model to the persistent store(s) and knows how to map data from `NSManagedObject` instances to records in the database.\n3.  **`NSPersistentStore`**: The actual backend storage, typically a SQLite database. The PSC can manage multiple stores of different types (e.g., SQLite, in-memory).\n4.  **`NSManagedObjectContext` (MOC)**: Your primary interface. It's an in-memory \"scratchpad\" or transactional workspace. All operations (create, fetch, update, delete) are performed within a context. The context tracks every change. When you call `save()`, it pushes these changes through the PSC to the persistent store, making operations atomic and enabling features like undo/redo.\n\n### Practical Code Example\nThis example uses `NSPersistentContainer` to perform a background save, the standard modern approach.\n\n```swift\n// Setup in a data controller or AppDelegate\nlet container = NSPersistentContainer(name: \"MyAppModel\")\ncontainer.loadPersistentStores { description, error in\n    // Automatically merges changes from background contexts to the viewContext\n    container.viewContext.automaticallyMergesChangesFromParent = true\n}\n\n// Function to add an item in the background\nfunc addItemInBackground(name: String) {\n    // performBackgroundTask provides a temporary, private queue context\n    container.performBackgroundTask { backgroundContext in\n        let newItem = Item(context: backgroundContext)\n        newItem.name = name\n        \n        do {\n            // Saving the background context commits changes to the persistent store.\n            try backgroundContext.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}\n```\n\n### Common Pitfalls & Edge Cases\n*   **Threading Violations**: An `NSManagedObjectContext` is NOT thread-safe. `viewContext` is for the main queue only. Accessing it from a background thread will cause crashes. Always use `context.perform { ... }` to ensure you're on the correct queue.\n*   **Passing Objects Between Contexts**: You cannot safely pass a managed object from one context to another. Instead, pass its `NSManagedObjectID` (which is thread-safe) and retrieve the object in the destination context using `context.object(with: objectID)`.\n*   **Blocking the Main Thread**: Performing large fetches or saves on the `viewContext` will freeze your UI. Offload these tasks to a background context using `performBackgroundTask`.\n\n### When to Use vs. Alternatives\n*   **`viewContext`**: Use for all UI-related work. It's configured for the main queue.\n*   **Background Contexts (`performBackgroundTask`)**: The standard for any non-trivial data processing, like server sync or batch updates. This keeps the UI responsive.\n*   **Parent/Child Contexts**: An advanced pattern for isolated editing sessions. A child context is a scratchpad for a parent (e.g., `viewContext`). Saving the child only pushes changes to the parent in memory. Perfect for an \"edit\" screen where the user can cancel by simply discarding the child context.",
      "code_example": null,
      "tags": [
        "core-data",
        "persistence",
        "concurrency",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "Describe a robust strategy for performing background data processing with Core Data, such as importing a large dataset. How do you ensure data integrity and a responsive UI?",
      "back": "The core principle for Core Data concurrency is that `NSManagedObjectContext` instances are not thread-safe and must be confined to a single queue. To maintain a responsive UI, long-running tasks like data imports or complex fetches must be performed on a background thread using a dedicated background context.\n\nThe modern, recommended approach uses `NSPersistentContainer`. The container's `viewContext` is associated with the main queue for UI-related work. For background tasks, you use `performBackgroundTask(_:)`.\n\nThis method provides a new, temporary `NSManagedObjectContext` that operates on a private background queue. You perform all your data creation, modification, or deletion within this block. When you call `save()` on this background context, the changes are pushed to the Persistent Store Coordinator. By default, the container's `viewContext` is configured with `automaticallyMergesChangesFromParent` set to `true`, so it automatically observes these saves and merges the changes on the main queue, allowing UI components like an `NSFetchedResultsController` to update seamlessly.\n\n```swift\n// Assume 'persistentContainer' is your configured NSPersistentContainer\nfunc importLargeDataset() {\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // This closure is executed on a background queue.\n        // 'backgroundContext' is a new, private context for this task.\n\n        // 1. Fetch or create data within this context\n        for i in 0..<1000 {\n            let newItem = Item(context: backgroundContext)\n            newItem.id = UUID()\n            newItem.timestamp = Date()\n            newItem.name = \"Item \\(i)\"\n        }\n\n        // 2. Save the background context to persist changes to the store\n        do {\n            try backgroundContext.save()\n        } catch {\n            // Handle the save error appropriately\n            // e.g., log it, retry, or present an error to the user later.\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Passing Managed Objects Between Threads:** Never pass an `NSManagedObject` fetched from one context to another. Instead, pass its thread-safe `NSManagedObjectID` and then retrieve the object in the target context using `context.object(with:)`.\n*   **Merge Conflicts:** If the `viewContext` and a background context modify the same object, a conflict will occur when the background context saves. You must set a merge policy on your contexts (e.g., `NSMergeByPropertyObjectTrumpMergePolicy`) to handle this automatically, otherwise the default `NSErrorMergePolicy` will cause the save to fail.\n*   **Blocking the Main Thread:** Do not use `viewContext.performAndWait` from a background thread if it might contend for the same resources, as this can lead to deadlocks.\n\n**When to Use vs. Alternatives:**\n*   **`performBackgroundTask`:** Ideal for discrete, short-to-medium-lived background tasks. The context is temporary and managed for you.\n*   **`container.newBackgroundContext()`:** Use this when you need a longer-lived background context that persists across multiple operations, perhaps for a dedicated sync engine. You are responsible for managing its lifecycle.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Data Persistence",
        "iOS"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "SwiftData is built on top of Core Data. Describe the key architectural abstractions it introduces, like @Model and ModelContext, and explain how they simplify or replace components of the traditional Core Data stack.",
      "back": "SwiftData provides a modern, Swift-native layer over the Core Data framework, fundamentally simplifying data persistence on Apple platforms.\n\n### Core Concept Explanation\n\nSwiftData's architecture replaces the main components of the Core Data stack with simpler, more integrated abstractions:\n\n1.  **`@Model` Macro vs. `.xcdatamodeld` & `NSManagedObject`**:\n    In Core Data, you define your data model in a visual editor (`.xcdatamodeld`) and generate `NSManagedObject` subclasses. SwiftData replaces this entire workflow with the `@Model` macro. By annotating a plain Swift class with `@Model`, the compiler automatically synthesizes the necessary code for persistence, change tracking, and relationship management. This eliminates context-switching, reduces boilerplate, and provides full compile-time type safety.\n\n2.  **`ModelContainer` vs. `NSPersistentContainer` / `NSPersistentStoreCoordinator`**:\n    The `ModelContainer` is the top-level object that sets up the entire persistence stack. You configure it once at app launch with your array of `@Model` types. It internally manages the store (e.g., SQLite), the coordinator, and the creation of contexts, completely hiding the complexity of `NSPersistentContainer` and `NSPersistentStoreCoordinator` setup.\n\n3.  **`ModelContext` vs. `NSManagedObjectContext`**:\n    The `ModelContext` is the equivalent of a `NSManagedObjectContext`. It's the 'scratchpad' where you work with your model objects. It tracks all inserts, updates, and deletes. However, it's designed for modern Swift concurrency, integrates seamlessly with SwiftUI's environment, and often handles saving automatically. The need for explicit `save()` calls is reduced, though still available for fine-grained control.\n\n### Practical Code Example\n\n```swift\nimport SwiftUI\nimport SwiftData\n\n// 1. Define a model using the @Model macro\n@Model\nfinal class TodoItem {\n    var title: String\n    var isCompleted: Bool\n    var creationDate: Date\n\n    init(title: String, isCompleted: Bool = false) {\n        self.title = title\n        self.isCompleted = isCompleted\n        self.creationDate = .now\n    }\n}\n\n// 2. Set up the container in the App's entry point\n@main\nstruct TodoApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        // The container is configured once for all TodoItem models.\n        .modelContainer(for: TodoItem.self)\n    }\n}\n\n// 3. Use ModelContext and @Query in a SwiftUI view\nstruct ContentView: View {\n    // Access the main context from the environment.\n    @Environment(\\.modelContext) private var modelContext\n\n    // @Query fetches data and keeps the view updated automatically.\n    @Query(sort: \\.creationDate, order: .reverse) private var items: [TodoItem]\n\n    var body: some View {\n        NavigationStack {\n            List(items) { item in\n                Text(item.title)\n            }\n            .toolbar {\n                Button(\"Add Item\") { addItem() }\n            }\n        }\n    }\n\n    private func addItem() {\n        let newItem = TodoItem(title: \"New Task \\(Date())\")\n        // Insert the object into the context. Saving is often automatic.\n        modelContext.insert(newItem)\n    }\n}\n```\n\n### Common Pitfalls or Edge Cases\n\n*   **Threading:** `ModelContext` is not thread-safe and is bound to its actor (typically the `@MainActor`). For background tasks, you must create a new context from the `ModelContainer` to avoid data corruption and crashes.\n*   **Over-reliance on Auto-save:** While convenient, auto-save can make it difficult to implement transactional patterns (e.g., a complex form where all changes are saved or discarded at once). In such cases, you must manage saving explicitly and potentially disable auto-save on the context.\n*   **Migration:** While SwiftData supports lightweight migrations, complex model migrations (renaming entities, complex relationship changes) can still be challenging and may require a deeper understanding of the underlying Core Data migration process.\n\n### When to Use vs. Alternatives\n\n*   **Use SwiftData:** For new apps targeting iOS 17+ that are primarily built with SwiftUI. Its simplicity and deep integration with the language and UI framework accelerate development significantly.\n*   **Stick with Core Data:** For projects that must support older iOS versions, are heavily invested in UIKit, or require advanced features not yet exposed in SwiftData's API (e.g., custom validation rules, fetched properties, multiple stores connected to one coordinator).\n*   **Consider Realm/Firebase:** When you need cross-platform support (Android, Web), real-time data synchronization, or built-in backend services.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "swiftdata",
        "core_data",
        "swiftui",
        "architecture"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "How does Core Data's multi-layered caching and faulting mechanism impact performance, and what strategies can you employ to optimize data retrieval?",
      "back": "Core Data's performance is heavily influenced by its sophisticated, multi-layered caching system and its lazy-loading mechanism known as faulting.\n\n**Core Concept Explanation:**\nCore Data maintains two primary in-memory caches to avoid expensive I/O operations with the persistent store (e.g., SQLite):\n1.  **`NSManagedObjectContext` (MOC):** This is the first-level cache, your transactional \"scratchpad.\" When you fetch an object, it's registered with a context. Subsequent requests for the same object within that context return the existing in-memory instance without hitting the store. This is called *uniquing*.\n2.  **`NSPersistentStoreCoordinator` (PSC):** This is a second-level cache that holds the raw row data fetched from the store. If one MOC faults an object, the PSC caches its data. If another MOC later needs the same object, it can be fulfilled from the PSC's cache instead of the store, which is significantly faster.\n\n*Faulting* is Core Data's lazy-loading strategy. When you fetch objects, they are often returned as 'faults'\u2014placeholders that only contain their object ID. Accessing any property on a faulted object triggers a \"fault fire,\" which retrieves its full data from the store (via the PSC). While efficient for single objects, this can lead to performance bottlenecks when accessing relationships on many objects in a loop, known as the N+1 query problem.\n\n**Practical Code Example:**\nConsider `Author` and `Book` entities with a to-many relationship. The following naive approach causes an N+1 query problem, firing a separate fetch for each author's books.\n\n```swift\n// Inefficient: Causes a separate fetch for each author's books\nlet fetchRequest: NSFetchRequest<Author> = Author.fetchRequest()\nlet authors = try context.fetch(fetchRequest)\n\nfor author in authors {\n    // FAULT FIRE: A new fetch is executed here for each author!\n    let bookCount = author.books?.count ?? 0\n    print(\"\\(author.name) has \\(bookCount) books.\")\n}\n\n// Efficient: Prefetching relationships\nlet optimizedRequest: NSFetchRequest<Author> = Author.fetchRequest()\n// Tells Core Data to fetch the 'books' relationship in the initial query\noptimizedRequest.relationshipKeyPathsForPrefetching = [\"books\"]\n\nlet optimizedAuthors = try context.fetch(optimizedRequest)\n\nfor author in optimizedAuthors {\n    // NO FAULT FIRE: The books are already in memory.\n    let bookCount = author.books?.count ?? 0\n    print(\"\\(author.name) has \\(bookCount) books.\")\n}\n```\n\n**Common Pitfalls:**\n*   **Ignoring Faulting:** Traversing relationships in a loop without prefetching is the most common Core Data performance mistake.\n*   **Over-fetching:** `relationshipKeyPathsForPrefetching` is powerful but can cause high memory usage if you prefetch large, complex object graphs that you don't end up using.\n*   **Frequent Small Saves:** Each save operation has overhead. Batch changes into logical units of work and save once, rather than saving after every minor change.\n\n**When to Use vs. Alternatives:**\n*   **Lazy Faulting (Default):** Use when displaying a detail view for a single object. You only pay the cost of fetching related data if the user navigates to it.\n*   **Prefetching (`relationshipKeyPathsForPrefetching`):** Use when displaying a list of items where each cell needs data from a related object (e.g., a list of authors and their book counts). This is the go-to solution for N+1 problems.\n*   **Batch Faulting (`returnsObjectsAsFaults = false`):** Use when you know you will need all attributes of all fetched objects immediately. This can be memory-intensive and is often less targeted than prefetching.",
      "code_example": null,
      "tags": [
        "coredata",
        "persistence",
        "caching",
        "performance",
        "ios"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "For a new, complex project, when would you advocate for using the mature Core Data framework over the modern SwiftData, and what key architectural trade-offs would you highlight to the team?",
      "back": "While SwiftData is the future for persistence in Swift-native apps, there are specific scenarios where Core Data's maturity and explicit control are advantageous.\n\n### Core Concept Explanation\n\nCore Data is a robust object graph management and persistence framework, not just an ORM. It provides granular control over the entire stack: managed object contexts, the persistent store coordinator, and store types. This control comes with complexity and boilerplate (e.g., managing contexts across threads).\n\nSwiftData is a modern, Swift-native wrapper built directly on top of Core Data. It leverages Swift features like macros (`@Model`) and Swift Concurrency to drastically reduce boilerplate and simplify the developer experience. It trades Core Data's explicit control for convention-over-configuration and a declarative API.\n\n### Practical Code Example\n\nNotice the boilerplate reduction and type-safety improvements in SwiftData.\n\n**Core Data (Conceptual + Code):**\nRequires `.xcdatamodeld` file for schema.\n```swift\n// In an NSManagedObject subclass for a 'Book' entity\npublic class Book: NSManagedObject {\n    @NSManaged public var title: String?\n    @NSManaged public var publicationYear: Int16\n    @NSManaged public var author: Author?\n}\n// Fetching is verbose\nlet fetchRequest: NSFetchRequest<Book> = Book.fetchRequest()\nfetchRequest.predicate = NSPredicate(format: \"publicationYear > %d\", 2000)\n```\n\n**SwiftData:**\nSchema is defined directly in code using macros.\n```swift\n@Model\nfinal class Book {\n    var title: String\n    var publicationYear: Int\n    @Relationship(inverse: \\Author.books)\n    var author: Author?\n\n    init(title: String, publicationYear: Int, author: Author? = nil) {\n        self.title = title\n        self.publicationYear = publicationYear\n        self.author = author\n    }\n}\n// Fetching is clean and type-safe\nlet predicate = #Predicate<Book> { $0.publicationYear > 2000 }\nlet fetchDescriptor = FetchDescriptor<Book>(predicate: predicate)\n```\n\n### Common Pitfalls & Trade-offs\n\n*   **Concurrency:** Core Data's primary pitfall. Mishandling `NSManagedObjectContext` across threads is a common source of crashes. You must use `perform` or `performAndWait` for thread safety. SwiftData integrates with Swift Concurrency and Actors, making it safer, but you still need to understand `ModelContext` and actor isolation.\n*   **Abstraction Leak:** Since SwiftData is built on Core Data, complex issues can sometimes require understanding the underlying Core Data mechanisms for debugging. The \"magic\" can sometimes obscure the root cause of a problem.\n*   **Maturity vs. Velocity:** Core Data is battle-tested with a vast amount of community knowledge. SwiftData is newer and may have limitations or bugs not yet discovered in complex, edge-case scenarios. The trade-off is stability vs. rapid development.\n\n### When to Use Core Data Over SwiftData\n\n1.  **Existing Projects:** For large, stable codebases already using Core Data, a full migration might not be cost-effective.\n2.  **Objective-C Interoperability:** If the project requires interaction between Swift and Objective-C models and persistence logic, Core Data is the only choice.\n3.  **Granular Control:** When you need fine-grained control over merge policies, multiple persistent stores with different configurations, or complex data validation rules that SwiftData doesn't yet support.\n4.  **Targeting Older OS Versions:** SwiftData requires iOS 17+, so Core Data is necessary for supporting older systems.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "architecture",
        "ios17"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "Describe how to securely store an OAuth token using the Keychain. What specific `SecItem` attributes are critical for security and accessibility, and why is Keychain superior to `UserDefaults` or an encrypted file for this task?",
      "back": "The Keychain is a secure, encrypted database managed by the OS for storing small, sensitive pieces of data like passwords, keys, and authentication tokens. It's superior to `UserDefaults` (which is unencrypted) or a custom encrypted file because it leverages hardware-backed security and system-level process isolation, making it significantly harder to compromise.\n\n**Core Concept:**\nTo store an item, you construct a query dictionary defining the item's attributes and then call `SecItemAdd`. The most critical attributes for an OAuth token are:\n- `kSecClass`: Specifies the type of data. For a generic secret like a token, `kSecClassGenericPassword` is appropriate.\n- `kSecAttrService`: A key defining the service the token is for (e.g., your app's bundle ID).\n- `kSecAttrAccount`: A key for the user's account name or ID associated with the token.\n- `kSecValueData`: The actual sensitive data (the token) as a `Data` object.\n- `kSecAttrAccessible`: This is paramount for security. It defines when the data can be read. A strong, common choice is `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`, which ensures the data is only accessible when the device is unlocked and cannot be migrated to a new device from a backup.\n\n**Practical Code Example:**\n```swift\nfunc saveToken(token: String, for account: String) -> Bool {\n    guard let tokenData = token.data(using: .utf8) else { return false }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        // Use a service name to uniquely identify the token within your app\n        kSecAttrService as String: \"com.yourapp.authtoken\",\n        // The actual secret data\n        kSecValueData as String: tokenData,\n        // Most critical security attribute: only available when device is unlocked\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n\n    // Delete any existing item before adding to prevent duplicates\n    SecItemDelete(query as CFDictionary)\n\n    let status = SecItemAdd(query as CFDictionary, nil)\n    return status == errSecSuccess\n}\n```\n**Common Pitfalls:**\n- **Default Accessibility:** Forgetting to set `kSecAttrAccessible` results in a less secure default that allows background access. Always be explicit.\n- **Data Persistence:** Keychain items persist after an app is uninstalled. This can be a feature (e.g., for seamless re-authentication) or a bug if stale data is not handled.\n- **Simulator vs. Device:** Keychain behavior, especially with biometrics (`SecAccessControl`), differs on the simulator. Always test on a physical device.\n- **Error Handling:** The `SecItem` APIs return `OSStatus` codes. Failing to check them (e.g., `errSecDuplicateItem`) can lead to silent failures.\n\n**When to Use vs. Alternatives:**\n- **Keychain:** Ideal for small secrets (< 4KB) like tokens, API keys, and user credentials.\n- **UserDefaults:** For non-sensitive user preferences (e.g., theme settings, feature flags). Data is not encrypted.\n- **Encrypted Core Data/Realm:** For large sets of sensitive, structured data. This requires managing encryption keys yourself, which should ideally be stored in the Keychain.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Your app requires a complex Core Data schema change. Describe lightweight vs. heavyweight migration, and explain when you'd use a custom mapping model with an `NSEntityMigrationPolicy`.",
      "back": "Core Data migration is the process of updating a data store to a new version of its data model. There are two main approaches:\n\n**1. Lightweight Migration:**\nThis is an automatic process that Core Data can perform for simple schema changes. You enable it by setting two flags on your `NSPersistentStoreDescription`. It can handle changes like:\n- Adding or removing an entity, attribute, or relationship.\n- Renaming an entity or attribute (by setting the `renamingIdentifier` in the model inspector).\n- Making an optional attribute non-optional with a default value.\n\n**2. Heavyweight Migration:**\nThis is a manual process required for complex changes not supported by lightweight migration, such as changing an attribute's type, splitting an entity, or merging entities. It involves creating a Mapping Model (`.xcmappingmodel`) that defines how to map data from the source model version to the destination.\n\nFor transformations that require custom logic, you subclass `NSEntityMigrationPolicy`.\n\n**Code Example (Custom Migration Policy):**\nImagine migrating a `User` entity from v1 (with `firstName`, `lastName`) to v2 (with a single `fullName` attribute).\n\n```swift\n// In UserMigrationPolicy.swift\nimport CoreData\n\nclass UserMigrationPolicy: NSEntityMigrationPolicy {\n    // This method is called to create the destination objects.\n    override func createDestinationInstances(forSource sInstance: NSManagedObject, \n                                             in mapping: NSEntityMapping, \n                                             manager: NSMigrationManager) throws {\n        // Call super to handle basic attribute mapping first.\n        try super.createDestinationInstances(forSource: sInstance, in: mapping, manager: manager)\n\n        // Get the destination instance created by super.\n        guard let destinationUser = manager.destinationInstances(forEntityMappingName: mapping.name, \n                                                                 sourceInstances: [sInstance]).first else { return }\n        \n        // Apply custom transformation logic.\n        let firstName = sInstance.value(forKey: \"firstName\") as? String ?? \"\"\n        let lastName = sInstance.value(forKey: \"lastName\") as? String ?? \"\"\n        destinationUser.setValue(\"\\(firstName) \\(lastName)\", forKey: \"fullName\")\n    }\n}\n```\nIn your mapping model, you would set the `Custom Policy` for the `User` entity mapping to `YourModule.UserMigrationPolicy`.\n\n**Common Pitfalls:**\n- **Blocking UI:** Large migrations on launch can block the main thread. Perform them asynchronously on a background queue.\n- **Forgetting Flags:** Not setting `shouldMigrateStoreAutomatically` and `shouldInferMappingModelAutomatically` to `true` for lightweight migration will cause a crash.\n- **Testing:** Insufficient testing can lead to data loss. Always test migrations with realistic data sets and across multiple model versions (e.g., v1 -> v3, not just v2 -> v3).\n\n**When to Use:**\n- **Lightweight:** Always the first choice for simple, additive schema changes.\n- **Heavyweight (Mapping Model):** When you need to merge/split entities or change relationships in a way lightweight can't handle, but the data mapping is direct.\n- **Heavyweight (Custom Policy):** When data requires programmatic transformation, formatting, or fetching related data during the migration.",
      "code_example": null,
      "tags": [
        "core_data",
        "data_persistence",
        "migration"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}