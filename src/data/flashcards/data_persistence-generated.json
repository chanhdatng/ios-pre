{
  "topic": "data_persistence",
  "generated_at": "2026-01-08T03:55:15.486198+00:00",
  "cards": [
    {
      "id": "data_persistence_0658a152705c",
      "front": "Explain the Core Data stack, including Managed Object Contexts, and how they interact. When would you use multiple contexts?",
      "back": "The Core Data stack consists of: Persistent Store Coordinator (PSC), Managed Object Context (MOC), and Persistent Store.\n\nThe PSC acts as a central point, connecting the MOC and Persistent Store.\n\nThe MOC manages object graphs, tracking changes to managed objects. Objects are tied to a specific MOC.\n\nThe Persistent Store handles reading/writing data to disk, often a SQLite database.\n\nUse multiple contexts for concurrency: a main-thread context for UI and background contexts for long-running operations to avoid blocking the UI. Changes can then be merged.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Persistence",
        "Concurrency",
        "Data Management"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "Explain the Core Data stack components and their responsibilities. How do they interact during a save operation?",
      "back": "The Core Data stack consists of: `NSManagedObjectContext` (tracks object changes), `NSPersistentStoreCoordinator` (mediates between context and store), and `NSPersistentStore` (interacts with the storage, often SQLite). On save, the context identifies changes, passes them to the coordinator, which then coordinates with the store to persist data. Validation also occurs during the save. Changes happen per context and can be problematic if separate stacks access the same SQLite database file.",
      "code_example": null,
      "tags": [
        "core data",
        "data persistence",
        "architecture",
        "interview"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Compare and contrast Core Data and SwiftData.  When might you choose one over the other?",
      "back": "Core Data: Mature, object graph management, supports complex relationships, requires boilerplate.  SwiftData: Simpler syntax, integrates with SwiftUI, built on top of Core Data (uses SQLite store under the hood).  Choose Core Data for existing projects, complex data models, or features not yet in SwiftData.  Choose SwiftData for new SwiftUI-centric projects or when ease of use is paramount. Core Data's fetch request API is more robust than SwiftData's initial implementation.",
      "code_example": null,
      "tags": [
        "data persistence",
        "core data",
        "swiftdata"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Describe strategies for migrating Core Data models.  What are the pros/cons of each approach?",
      "back": "Migration strategies include: \n\n1.  **Lightweight Migration**: Automatic schema changes. Simple, but limited to additive changes. Prone to failure with complex changes.\n2.  **Manual Migration**: Create mapping models in Xcode, offering fine-grained control.  Requires more code but handles complex scenarios.\n3.  **Custom Migration**:  Implement migration logic in code.  Most flexible but also most complex. Needed for significant data transformations or external dependencies.\n\nConsider using `shouldMigrateStoreAutomatically` and `mapTypeAutomatically` options for automation where possible.",
      "code_example": null,
      "tags": [
        "coredata",
        "migration",
        "datapersistence"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "How do you handle concurrency with Core Data to prevent data corruption or conflicts, especially in a multi-threaded environment?",
      "back": "Use `NSPersistentContainer`'s `performBackgroundTask` for background operations.  For inter-context communication, use `NSManagedObjectContextDidSave` notification to merge changes.  Handle conflicts by implementing merge policies in the `NSPersistentStoreCoordinator`, resolving conflicts based on timestamps or custom logic. Validate data before saving. Avoid sharing contexts between threads.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Multi-threading",
        "Data Persistence",
        "iOS"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Describe common caching strategies in iOS for data persistence, focusing on Core Data.  What are their pros/cons, and when would you choose one over another?",
      "back": "Core Data's caching happens at multiple levels:\n\n1.  **Managed Object Context (MOC) Cache:**  Objects are uniqued within a context. Fast access if present.\n\n2.  **Persistent Store Coordinator (PSC) Cache:** Stores recently accessed object values. Faster than disk access.\n\n3.  **SQLite/Disk:** Slowest. Avoid repeated fetches.\n\nStrategies:\n\n*   **Object Faulting:** Core Data fetches objects on demand. Good for large datasets, but can lead to many small queries if not handled carefully. Use `NSFetchRequest` to batch fetch.\n*   **Caching Results:** Cache results of fetch requests. Great for immutable or infrequently changing data. Invalidate cache on updates. Use `NSCache` or similar.\n*   **In-Memory Store:** Load entire database into memory. Fastest for read-heavy operations but consumes significant memory. Good for small, mostly static datasets.\n*   **External Caching:** Using Redis or Memcached for frequently accessed data can offload database operations and improve performance.",
      "code_example": null,
      "tags": [
        "coredata",
        "caching",
        "datapersistence",
        "performance"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "How do you securely store sensitive data, like API keys or user credentials, in an iOS app using the Keychain?",
      "back": "Keychain provides a secure way to store small chunks of data. Use `SecItemAdd`, `SecItemUpdate`, `SecItemCopyMatching`, and `SecItemDelete` to manage Keychain items.  Always specify appropriate access control attributes (`kSecAttrAccessible`) to control when the data can be accessed. Use `kSecUseAuthenticationUI` for user presence-based access. Be mindful of Keychain sharing between apps from the same developer by using App Groups.  Consider using a wrapper library for ease of use. Ensure proper error handling.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}