{
  "topic": "data_persistence",
  "generated_at": "2026-01-12T04:20:49.156901+00:00",
  "cards": [
    {
      "id": "data_persistence_df6a8453f934",
      "front": "You're diagnosing a slow Core Data object graph traversal. Describe the potential causes related to its multi-layered caching and faulting, and detail three strategies to optimize it.",
      "back": "The slowness stems from Core Data's lazy-loading mechanism, called faulting. Core Data has multiple caching layers: the `NSManagedObjectContext` (fastest, in-memory objects), the `NSPersistentStoreCoordinator`'s cache, and finally the persistent store (e.g., SQLite), which is the slowest. When you access a relationship on a managed object that hasn't been loaded, Core Data 'fires the fault,' potentially causing a database round-trip for each access. This leads to the classic 'N+1 query' problem, where one fetch for parent objects results in N subsequent fetches for their children.\n\nHere are three optimization strategies:\n\n1.  **Prefetching Relationships:** This is the most effective solution for the N+1 problem. You instruct the `NSFetchRequest` to fetch related objects in a single, subsequent batch request, hydrating the relationships efficiently.\n\n```swift\n// Inefficient: Causes a separate DB hit for each 'author' access\nlet fetchRequest: NSFetchRequest<Post> = Post.fetchRequest()\nlet posts = try context.fetch(fetchRequest)\nfor post in posts {\n    // This line fires a fault for each post, leading to N+1 queries\n    print(post.author.name)\n}\n\n// Efficient: Prefetches all authors in a second, optimized query\nlet efficientRequest: NSFetchRequest<Post> = Post.fetchRequest()\n// Tell Core Data to also fetch the 'author' for each Post\nefficientRequest.relationshipKeyPathsForPrefetching = [\"author\"]\nlet prefetchedPosts = try context.fetch(efficientRequest)\nfor post in prefetchedPosts {\n    // Access is now fast, as author data is already in memory\n    print(post.author.name)\n}\n```\n\n2.  **Setting a `fetchBatchSize`:** This doesn't reduce queries but controls memory usage for large datasets. It fetches the full set of object IDs but faults the actual objects in batches as you iterate through the results. This is ideal for populating a `UITableView` or `UICollectionView` without loading thousands of objects into memory at once.\n\n3.  **Setting `returnsObjectsAsFaults` to `false`:** This forces Core Data to fetch the full object data immediately, avoiding faulting entirely for that request. Use this with caution, as it can be memory-intensive. It's best for when you need to access properties of all fetched objects and the dataset is manageably small.\n\n**Common Pitfalls:**\n- **Over-prefetching:** Prefetching deep or wide relationship graphs (`user.posts.comments`) can load excessive data, negating the performance gain.\n- **Confusing `fetchBatchSize` with `relationshipKeyPathsForPrefetching`:** Remember, prefetching reduces database trips for relationships, while batch size manages memory by faulting in chunks.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Caching",
        "Performance",
        "Data Persistence",
        "Faulting"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "When storing sensitive data, how do you choose the appropriate `kSecAttrAccessible` attribute? Discuss the trade-offs for `kSecAttrAccessibleWhenUnlocked` vs. `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`.",
      "back": "The `kSecAttrAccessible` attribute is critical for defining the security posture of data stored in the Keychain. It dictates when the data can be decrypted and accessed, balancing security against application requirements like background processing.\n\n**Core Concept:**\nThis attribute creates a policy enforced by the OS and Secure Enclave. When your app attempts to read a Keychain item, the system checks its accessibility policy against the current device state (e.g., locked, unlocked, time since last unlock).\n\n- **`kSecAttrAccessibleWhenUnlocked`**: The item is only accessible when the device is unlocked. If the user locks the device, the data becomes inaccessible until the next unlock. This is highly secure and suitable for data that is only ever needed when the user is actively using the app in the foreground.\n\n- **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`**: The item becomes accessible after the user unlocks the device for the first time following a reboot. It then remains accessible even if the user locks the screen. This is essential for apps that need to perform background tasks (e.g., background fetch, silent push notifications) that require access to a secret like an API token. The `ThisDeviceOnly` suffix prevents the item from being synced via iCloud Keychain, which is crucial for device-specific secrets.\n\n**Practical Code Example:**\nThis function saves or updates a token, using `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` to allow background access.\n```swift\nimport Foundation\n\n// A robust function to save or update a Keychain item.\nfunc saveToken(_ token: String, for account: String) throws {\n    guard let tokenData = token.data(using: .utf8) else { return }\n    \n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"com.yourapp.api\", // A unique service identifier\n        kSecAttrAccount as String: account, // e.g., user's email or ID\n    ]\n\n    let attributes: [String: Any] = [\n        kSecValueData as String: tokenData,\n        // Allows access after first unlock, even if device is locked.\n        // Suffix 'ThisDeviceOnly' prevents iCloud sync.\n        kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly\n    ]\n\n    // SecItemUpdate returns errSecItemNotFound if the item does not exist.\n    let status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)\n\n    if status == errSecItemNotFound {\n        // Item not found, so we add it.\n        var newQuery = query\n        newQuery.merge(attributes) { (_, new) in new }\n        let addStatus = SecItemAdd(newQuery as CFDictionary, nil)\n        guard addStatus == errSecSuccess else { throw KeychainError.saveFailed(addStatus) }\n    } else if status != errSecSuccess {\n        // Another error occurred during update.\n        throw KeychainError.saveFailed(status)\n    }\n}\nenum KeychainError: Error { case saveFailed(OSStatus) }\n```\n\n**Common Pitfalls:**\n- **Using `kSecAttrAccessibleAlways`**: This is highly discouraged as it makes the data accessible even on a locked device without a passcode, offering minimal security.\n- **Not Handling Updates**: Calling `SecItemAdd` for an existing item fails with `errSecDuplicateItem`. A robust implementation must handle both adding new items and updating existing ones.\n- **Ignoring Background Needs**: Using `kSecAttrAccessibleWhenUnlocked` for a token needed by a background task will cause the task to fail when the device is locked.\n\n**When to Use vs. Alternatives:**\n- **Use Keychain For**: Small, highly sensitive data like passwords, API tokens, and cryptographic keys.\n- **Alternatives**:\n  - **`UserDefaults`**: Only for non-sensitive data like user settings. It's unencrypted and insecure.\n  - **Core Data/Realm with Encryption**: For large sets of structured data that need to be secured. The encryption key for the database itself should be stored in the Keychain.",
      "code_example": null,
      "tags": [
        "data persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "Despite SwiftData's modern approach, when would you architect a new iOS 17+ app using Core Data? Discuss the trade-offs in terms of control, complexity, and long-term maintainability.",
      "back": "While SwiftData is the future for persistence in Swift-centric apps, choosing Core Data for a new project is a deliberate architectural decision based on specific, complex requirements.\n\n**Core Concept Explanation:**\nCore Data is a mature, imperative framework for object graph management and persistence. It provides granular control over its entire stack: Managed Object Contexts (MOC), Persistent Store Coordinator (PSC), and Persistent Stores. This allows for complex configurations, like multiple stores of different types (e.g., SQLite and in-memory) coordinated together. SwiftData is a declarative, Swift-native wrapper built on Core Data's proven storage engine. It abstracts away the stack's complexity using modern language features like macros (`@Model`) and is deeply integrated with SwiftUI (`@Query`) and structured concurrency.\n\n**When to Choose Core Data over SwiftData:**\n1.  **Ultimate Control & Customization:** You need to manage multiple, distinct persistent stores, implement custom atomic operations, or have non-standard store configurations. SwiftData's simplified `ModelContainer` doesn't expose this level of control.\n2.  **Complex Data Migration:** Core Data offers robust, fine-grained control over data migrations with mapping models and custom migration policies. SwiftData's migration is more automated and may not handle complex schema transformations gracefully.\n3.  **Objective-C Interoperability:** If the new project must integrate deeply with an existing Objective-C codebase or libraries that rely on `NSManagedObject`.\n4.  **Proven Stability for Mission-Critical Apps:** For applications where stability is paramount and the risks of a v1.0 framework are unacceptable, Core Data's two decades of bug fixes and community knowledge are invaluable.\n\n**Code Example (Model Definition):**\n```swift\n// Core Data requires explicit NSManagedObject subclasses and a data model file.\n// Item+CoreDataClass.swift\npublic class CDItem: NSManagedObject { }\n\n// Item+CoreDataProperties.swift\nextension CDItem {\n    @NSManaged public var timestamp: Date?\n    @NSManaged public var name: String?\n}\n\n// SwiftData uses a simple Swift class with the @Model macro.\nimport SwiftData\n\n@Model\nfinal class SDItem {\n    var timestamp: Date\n    var name: String\n    \n    init(timestamp: Date, name: String) {\n        self.timestamp = timestamp\n        self.name = name\n    }\n}\n```\n\n**Common Pitfalls / Trade-offs:**\n*   **Core Data Pitfall:** The primary trade-off is complexity and boilerplate. Developers must manually manage `NSManagedObjectContext` threading, which is a common source of bugs and crashes. The learning curve is steep.\n*   **SwiftData Pitfall:** The abstraction is a double-edged sword. While it simplifies development, it can hide performance issues. Debugging the underlying Core Data stack is more difficult, and you are limited to the features it exposes. Its tight coupling with SwiftUI makes it a less natural fit for pure UIKit projects.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "architecture",
        "swiftui"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_0658a152705c",
      "front": "Explain the Core Data stack's architecture, focusing on the roles of the coordinator and contexts. How does this design facilitate thread safety and concurrency for background data processing?",
      "back": "The Core Data stack is a layered architecture designed to manage an object graph and its persistence. At its core is the `NSPersistentStoreCoordinator` (PSC), which acts as a hub connecting the `NSManagedObjectModel` (the data schema) to one or more `NSPersistentStore`s (the actual storage, e.g., a SQLite database).\n\nThe `NSManagedObjectContext` (MOC) is your primary interface. It's an in-memory 'scratchpad' where you create, fetch, and modify managed objects. Crucially, a context is not thread-safe; it must be used on a single, specific queue. The main context (`viewContext`) is tied to the main queue for UI updates.\n\nThis architecture facilitates concurrency by creating separate contexts for background work. These background contexts are tied to private queues. When you save a background context, its changes are sent to the PSC, which writes them to the persistent store. The PSC then notifies other contexts (like the `viewContext`) of the changes, allowing them to merge the updates and refresh the UI without blocking.\n\n```swift\n// In a data manager or AppDelegate\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n    let container: NSPersistentContainer\n\n    private init() {\n        container = NSPersistentContainer(name: \"MyApp\")\n        // The viewContext automatically receives updates from saves on other contexts\n        // that share the same persistent store coordinator.\n        container.viewContext.automaticallyMergesChangesFromParent = true\n        container.loadPersistentStores { description, error in\n            if let error = error {\n                fatalError(\"Unable to load persistent stores: \\(error)\")\n            }\n        }\n    }\n\n    func performBackgroundUpdate() {\n        // A convenience method that creates a private context and runs the block.\n        container.performBackgroundTask { backgroundContext in\n            let newItem = Item(context: backgroundContext)\n            newItem.timestamp = Date()\n            \n            do {\n                // This save occurs on a background thread.\n                // It pushes changes to the PSC, which then saves to the store.\n                try backgroundContext.save()\n            } catch {\n                // Handle save error\n                print(\"Failed to save background context: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n1.  **Context Hopping:** Accessing a managed object or its context from a different queue than the one it's bound to. This leads to crashes and data corruption. Always use `context.perform { ... }` or `context.performAndWait { ... }`.\n2.  **Passing `NSManagedObject`s:** Never pass a managed object from one context to another. Instead, pass its thread-safe `NSManagedObjectID` and re-fetch the object in the destination context.\n3.  **Blocking the Main Thread:** Performing long-running fetches or saves on the `viewContext` will freeze the UI. Offload these tasks to a background context created with `container.newBackgroundContext()` or `container.performBackgroundTask`.\n\n**When to Use vs. Alternatives:**\n- **Sibling Contexts (via `NSPersistentContainer`):** The modern, recommended approach. Background contexts are peers to the `viewContext`, both connected to the PSC. Ideal for network syncs and data processing. It's non-blocking and efficient.\n- **Parent-Child Contexts:** An older pattern where a background context is a child of the `viewContext`. Saving the child only pushes changes to the parent's memory, not to the store. The parent must then be saved. This is useful for discardable edits (e.g., a modal form) but can block the parent context during the child's save.",
      "code_example": null,
      "tags": [
        "core-data",
        "persistence",
        "concurrency",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Your app's Core Data model needs a significant change. How do you decide between a lightweight and heavyweight migration, and what are the key steps and risks involved in a heavyweight migration?",
      "back": "The choice between lightweight and heavyweight migration depends entirely on the complexity of the schema change.\n\n**Core Concept Explanation:**\n\n**Lightweight Migration** is the default and preferred approach. Core Data can automatically infer the mapping between model versions for simple changes like:\n- Adding/removing entities, attributes, or relationships.\n- Renaming entities or attributes (requires setting the 'Renaming ID' in the Xcode Data Model Inspector).\n- Making an attribute optional or required.\n- Changing a relationship's cardinality (to-one to to-many).\n\n**Heavyweight Migration** is required for complex changes that Core Data cannot infer, such as:\n- Changing an attribute's type in a non-standard way (e.g., String to a binary Transformable).\n- Splitting one entity into multiple entities (e.g., `User` -> `Profile` and `Account`).\n- Merging multiple entities into one.\n- Complex relationship modifications or data transformations.\n\nIt involves creating a Mapping Model (`.xcmappingmodel`) that explicitly defines how data from the source entity is transformed into the destination entity. For very complex logic, you may need to subclass `NSEntityMigrationPolicy` to perform custom data transformations in code.\n\n**Practical Code Example (Enabling Lightweight Migration):**\n```swift\n// In your Core Data stack setup\nlet container = NSPersistentContainer(name: \"MyModel\")\n\n// Get the default store description\nguard let description = container.persistentStoreDescriptions.first else {\n    fatalError(\"Failed to retrieve a persistent store description.\")\n}\n\n// Enable automatic migration options\ndescription.shouldMigrateStoreAutomatically = true\ndescription.shouldInferMappingModelAutomatically = true\n\ncontainer.loadPersistentStores { (storeDescription, error) in\n    if let error = error as NSError? {\n        fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n1.  **Forgetting to Version:** Before making any model changes, you must select the `.xcdatamodeld` file and go to `Editor > Add Model Version`. Forgetting this is the most common mistake.\n2.  **Performance:** Large migrations can take significant time, blocking the app's launch. You should perform migrations on a background thread and provide UI feedback to the user.\n3.  **Data Loss:** A poorly configured mapping model or a bug in a custom `NSEntityMigrationPolicy` can easily lead to data corruption or loss. Heavyweight migrations require extensive testing with realistic data sets.\n4.  **Renaming ID:** When renaming an entity or attribute for lightweight migration, you MUST set the 'Renaming ID' in the property's User Info in the Data Model Inspector to its original name. Otherwise, Core Data will treat it as adding a new property and deleting the old one, causing data loss.\n\n**When to Use vs. Alternatives:**\n-   **Use Lightweight:** For 95% of model changes. It's robust, tested, and requires minimal effort.\n-   **Use Heavyweight:** Only when a change is too complex for lightweight migration. It adds significant development and testing overhead.\n-   **Alternative (Nuke & Rebuild):** For non-critical, cache-like data, you can simply delete the persistent store and recreate it if migration fails. This is a poor user experience for critical data but acceptable for caches.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Data Persistence",
        "Migration",
        "Architecture"
      ],
      "sources": [
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "How does SwiftData simplify Core Data's persistence stack, and what are the implications of its actor-based concurrency model for data consistency?",
      "back": "SwiftData fundamentally streamlines Core Data's complex, multi-layered stack. It replaces the `NSPersistentStoreCoordinator`, `NSManagedObjectContext`, and data model file (`.xcdatamodeld`) with two primary components: `ModelContainer` and `ModelContext`.\n\n**Core Concept Explanation:**\n\n1.  **Simplified Stack:** The `ModelContainer` is a one-time setup object that configures the entire persistence layer, including the schema (inferred from your `@Model` classes) and the backing store (e.g., SQLite). The `ModelContext` is the modern equivalent of `NSManagedObjectContext`, acting as the in-memory scratchpad for creating, fetching, and modifying model objects. By default, the main context provided in the SwiftUI environment is bound to the `@MainActor`, eliminating a major source of Core Data's concurrency bugs.\n\n2.  **Actor-Based Concurrency:** SwiftData leverages Swift's modern concurrency model. Instead of manually creating background contexts and merging changes, you create a new `ModelContext` on a background actor. This isolates data manipulation, preventing race conditions. SwiftData handles change propagation and merging automatically. This model prevents passing model objects across actor boundaries, enforcing a safer pattern where you pass a model's `PersistentIdentifier` instead.\n\n**Practical Code Example:**\n\n```swift\n// 1. Define a model with the @Model macro\n@Model\nfinal class Trip {\n    var name: String\n    var destination: String\n    \n    init(name: String, destination: String) {\n        self.name = name\n        self.destination = destination\n    }\n}\n\n// 2. Setup container in the App or Scene\n@main\nstruct TravelApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .modelContainer(for: Trip.self)\n    }\n}\n\n// 3. Perform a background task safely using an actor\nactor TripImporter {\n    let modelContainer: ModelContainer\n    \n    init(modelContainer: ModelContainer) {\n        self.modelContainer = modelContainer\n    }\n    \n    func importTrip() async {\n        // Create a private context for this actor's work\n        let context = ModelContext(modelContainer)\n        let newTrip = Trip(name: \"Alpine Hike\", destination: \"Switzerland\")\n        context.insert(newTrip)\n        try? context.save() // Save changes on this background context\n    }\n}\n```\n\n**Common Pitfalls:**\n\n*   **Cross-Actor Access:** Passing a `ModelContext` or a managed model object from the main actor to a background actor will cause a runtime crash. Always pass the `ModelContainer` and create a new context, or pass a model's `PersistentIdentifier` to fetch a fresh instance on the background thread.\n*   **Over-reliance on Autosave:** The default `ModelContext` has autosave enabled. While convenient for simple UI interactions, this can lead to unintended data states during complex, multi-step operations. For transactional integrity, you can disable autosave and call `context.save()` explicitly.\n\n**When to use vs. Alternatives:**\n\n*   **SwiftData:** The default choice for new SwiftUI projects targeting iOS 17+. Its deep integration, type safety, and reduced boilerplate make development faster and safer.\n*   **Core Data:** Use for projects that must support older iOS versions, have a large existing Core Data implementation, or require advanced features not yet available in SwiftData (e.g., custom data transformations, multiple configurations).",
      "code_example": null,
      "tags": [
        "swiftdata",
        "persistence",
        "concurrency",
        "core data",
        "actors"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "You need to perform a large data import in the background while the user interacts with the UI. How would you architect this with Core Data to ensure data integrity, UI responsiveness, and prevent crashes? Discuss contexts, merging, and thread safety.",
      "back": "The fundamental rule of Core Data concurrency is that an `NSManagedObjectContext` is not thread-safe and must only be accessed from the queue it was created on. To perform background work, we use a separate background context that writes directly to the Persistent Store Coordinator. The `NSPersistentContainer` simplifies this greatly.\n\n**Core Concept Explanation:**\n1.  **`viewContext`:** This context is associated with the main queue (`.mainQueueConcurrencyType`) and is used for all UI-related data operations. It must never be blocked by long-running tasks.\n2.  **Background Context:** For tasks like imports, we use a background context with a private queue (`.privateQueueConcurrencyType`). `NSPersistentContainer.performBackgroundTask(_:)` is the modern, preferred way to do this. It provides a temporary background context, executes your work block, and handles cleanup.\n3.  **Merging Changes:** When the background context saves, changes are written to the persistent store. The `viewContext` is now out-of-date. To sync it, we set `viewContext.automaticallyMergesChangesFromParent = true`. This makes the `viewContext` automatically absorb saved changes from other contexts, which is crucial for updating the UI.\n\n**Practical Code Example:**\n```swift\n// In your Core Data stack setup\nlazy var persistentContainer: NSPersistentContainer = {\n    let container = NSPersistentContainer(name: \"MyAppModel\")\n    container.loadPersistentStores { ... }\n    // Crucial for UI updates from background saves\n    container.viewContext.automaticallyMergesChangesFromParent = true\n    // Set a merge policy to handle potential conflicts automatically\n    container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n    return container\n}()\n\nfunc importLargeDataset() {\n    // performBackgroundTask provides a temporary, private queue context.\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // This block executes on a background thread.\n        for itemData in largeDataset {\n            let newItem = Item(context: backgroundContext)\n            newItem.id = itemData.id\n            // ... configure other properties\n        }\n\n        do {\n            // Save the background context. This writes changes to the store.\n            try backgroundContext.save()\n        } catch {\n            // Handle the save error, e.g., log it.\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Passing `NSManagedObject`s Across Threads:** Never pass a managed object fetched on one context to another. This violates thread confinement and will cause crashes. Instead, pass its `NSManagedObjectID`, which is thread-safe, and use `context.object(with:)` to retrieve a valid instance of the object on the new context.\n*   **Merge Conflicts:** The default merge policy is `NSErrorMergePolicy`, which fails the save on conflict. You must set a policy like `NSMergeByPropertyObjectTrumpMergePolicy` (in-memory changes win) or `NSMergeByPropertyStoreTrumpMergePolicy` (disk changes win) on your contexts to automatically resolve conflicts.\n*   **Stale UI:** Forgetting to set `viewContext.automaticallyMergesChangesFromParent = true` is a common mistake. The UI will not reflect background changes until the next app launch or manual fetch.\n\n**When to Use vs. Alternatives:**\nThis `performBackgroundTask` pattern is ideal for most background data tasks. For more complex, long-lived background work, you could use `container.newBackgroundContext()`. The legacy parent/child context pattern is generally avoided now, as a child context's save can block its parent (often the `viewContext`), defeating the purpose of backgrounding.",
      "code_example": null,
      "tags": [
        "core-data",
        "concurrency",
        "persistence",
        "ios",
        "swift"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}