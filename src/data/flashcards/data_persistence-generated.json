{
  "topic": "data_persistence",
  "generated_at": "2026-01-09T07:04:34.069294+00:00",
  "cards": [
    {
      "id": "data_persistence_0658a152705c",
      "front": "Explain the roles of `NSPersistentContainer`, `NSManagedObjectContext`, and `NSPersistentStoreCoordinator` in a modern Core Data stack. How would you architect a safe, concurrent background data import?",
      "back": "In a modern Core Data stack, these components work in a clear hierarchy to manage the object graph and persistence.\n\n**Core Concepts:**\n- **`NSPersistentContainer`**: Introduced in iOS 10, this is a high-level wrapper that simplifies stack setup. It encapsulates the managed object model (`NSManagedObjectModel`), persistent store coordinator (`NSPersistentStoreCoordinator`), and the main queue managed object context (`viewContext`). Its primary role is to reduce boilerplate and provide convenient methods for common tasks.\n\n- **`NSPersistentStoreCoordinator` (PSC)**: This is the central hub of the stack. It connects the in-memory object graph (managed by contexts) to the persistent stores (e.g., an SQLite database). A single PSC can manage multiple stores and multiple contexts, acting as a gatekeeper to ensure data integrity.\n\n- **`NSManagedObjectContext` (MOC)**: This is your 'scratchpad' for working with managed objects. All fetches, creations, and modifications happen within a context. Crucially, a context is **not thread-safe** and is bound to a specific queue (`.mainQueueConcurrencyType` or `.privateQueueConcurrencyType`). Changes are isolated within a context until you explicitly save, which pushes the changes to the PSC.\n\n**Architecting a Concurrent Import:**\nThe safest and most modern approach is to use `NSPersistentContainer.performBackgroundTask(_:)`. This method handles the complexity of creating a private background context, executing work on the correct queue, saving, and merging changes back to the main `viewContext`.\n\n```swift\n// Assumes `container` is your app's NSPersistentContainer\nfunc importLargeDataset(from data: [DataType]) {\n    // This API creates a new private MOC on a background queue.\n    container.performBackgroundTask { privateContext in\n        // The container automatically sets the merge policy to handle conflicts.\n        privateContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n\n        for itemData in data {\n            // Perform fetch or create logic inside this private context.\n            let request: NSFetchRequest<Item> = Item.fetchRequest()\n            request.predicate = NSPredicate(format: \"id == %@\", itemData.id)\n\n            let item = (try? privateContext.fetch(request).first) ?? Item(context: privateContext)\n            item.update(with: itemData)\n        }\n\n        do {\n            // Save changes from the private context to the persistent store.\n            if privateContext.hasChanges {\n                try privateContext.save()\n            }\n        } catch {\n            // Handle the error, e.g., log to a crash reporting service.\n            print(\"Error saving background context: \\(error)\")\n        }\n        // Upon completion of this block, the container automatically merges\n        // these changes into the viewContext on the main thread.\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Violating Thread Confinement:** Never pass an `NSManagedObject` from one context to another. Instead, pass its thread-safe `NSManagedObjectID` and re-fetch the object in the destination context.\n- **Blocking the Main Thread:** Performing large fetches or saves directly on the `viewContext` will freeze the UI. Always offload heavy lifting to a background context.\n- **Manual Context Management:** Before `NSPersistentContainer`, developers manually created parent/child contexts. This is more complex and error-prone, requiring manual save propagation. While still useful for complex UI flows (e.g., a cancelable edit screen), `performBackgroundTask` is superior for most data processing tasks.",
      "code_example": null,
      "tags": [
        "core-data",
        "persistence",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Your app requires a complex Core Data schema change, like splitting a 'User' entity's `address` string into a new related 'Address' entity. Describe the migration strategies you would evaluate and your criteria for choosing one.",
      "back": "When faced with a complex Core Data schema change, I would evaluate three main strategies in order of complexity:\n\n1.  **Lightweight Migration**: This is the first and simplest option. I'd check if the changes fall within its automatic capabilities (adding/removing attributes/entities, renaming via `renamingIdentifier`, changing optionality). If the schema change is just adding a new 'Address' entity and a relationship, lightweight migration could handle it. However, it cannot populate the new entity by splitting the old `address` string. It's enabled by setting `shouldMigrateStoreAutomatically = true` and `shouldInferMappingModelAutomatically = true` on the `NSPersistentStoreDescription`.\n\n2.  **Heavyweight Migration with Mapping Model**: When lightweight migration is insufficient, the next step is a heavyweight migration using a custom mapping model (`.xcmappingmodel`). This allows explicit mapping from a source to a destination model. For splitting the `address` string, this would likely require a custom migration policy, which is the most powerful option.\n\n3.  **Custom Migration with `NSEntityMigrationPolicy`**: This is the most flexible and appropriate strategy for the described problem. You subclass `NSEntityMigrationPolicy` and implement custom logic in Swift. You associate this policy with the entity mapping in your `.xcmappingmodel`. This gives you full programmatic control to read the old `address` string, create a new `Address` managed object, parse and populate its properties, and then link it to the new `User` object.\n\n**Code Example (Custom Policy):**\n```swift\n// In the .xcmappingmodel, set the Custom Policy for the\n// User-to-User entity mapping to \"MyApp.UserAddressMigrationPolicy\"\n\nclass UserAddressMigrationPolicy: NSEntityMigrationPolicy {\n    // This method is called for each User instance being migrated.\n    override func createDestinationInstances(for sInstance: NSManagedObject, \n                                             in mapping: NSEntityMapping, \n                                             manager: NSMigrationManager) throws {\n        // 1. Let the manager create the destination User and handle simple mappings\n        try super.createDestinationInstances(for: sInstance, in: mapping, manager: manager)\n\n        // 2. Get the newly created destination User instance\n        guard let dInstance = manager.destinationInstances(forEntityMappingName: mapping.name, \n                                                               sourceInstances: [sInstance]).first else {\n            return\n        }\n\n        // 3. Perform custom logic: split address string into a new Address entity\n        if let oldAddress = sInstance.value(forKey: \"address\") as? String {\n            let newAddress = NSEntityDescription.insertNewObject(forEntityName: \"Address\", \n                                                                 into: manager.destinationContext)\n            // Example parsing logic\n            let components = oldAddress.components(separatedBy: \", \")\n            newAddress.setValue(components.first ?? \"\", forKey: \"street\")\n            newAddress.setValue(components.last ?? \"\", forKey: \"city\")\n\n            // 4. Establish the new relationship\n            dInstance.setValue(newAddress, forKey: \"addressRelationship\")\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Performance:** Heavy migrations on large databases can block the UI at launch. For very large datasets, consider a staged, manual migration where you move data in the background.\n*   **Configuration:** Forgetting to set `shouldInferMappingModelAutomatically = false` when using a custom mapping model.\n*   **Data Integrity:** Not handling edge cases (e.g., malformed `address` strings, `nil` values) in the custom policy can lead to data loss or crashes.\n\n**Decision Criteria:** I would choose the simplest strategy that meets the requirements. For the given scenario, a custom `NSEntityMigrationPolicy` is necessary because it involves business logic (parsing a string) and structural changes (creating and linking a new entity instance) that are beyond the scope of lightweight migration.",
      "code_example": null,
      "tags": [
        "core-data",
        "data-persistence",
        "migration"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "SwiftData is often called 'Core Data with a Swift-friendly API.' Beyond syntax, what are the fundamental architectural shifts it represents, and what are the key trade-offs a senior dev must consider when choosing it over Core Data for a new project?",
      "back": "SwiftData represents a fundamental architectural shift from imperative configuration to declarative, code-first modeling. While it uses Core Data's proven storage engine, its public API abstracts away the traditional stack, changing how developers interact with persistence.\n\n**Core Concept Explanation:**\n- **Core Data:** Relies on an explicit, manually configured stack: `NSManagedObjectModel` (defined in a `.xcdatamodeld` file), `NSPersistentStoreCoordinator` (to connect model to stores), and `NSManagedObjectContext` (for object graph management). This design offers immense flexibility but requires significant boilerplate and careful management, especially concerning threading (e.g., using `perform` blocks for context safety).\n- **SwiftData:** Replaces this with a declarative, macro-based approach. The `@Model` macro transforms a standard Swift class into a persistent model, inferring the schema at compile time. This eliminates the `.xcdatamodeld` file. The stack is simplified to a `ModelContainer` (one-time setup) and a `ModelContext` (for operations), which is deeply integrated with modern Swift features like Swift Concurrency and the Observation framework for seamless SwiftUI updates.\n\n**Practical Code Example:**\n```swift\n// --- Core Data (requires .xcdatamodeld setup) ---\n// In Item+CoreDataClass.swift\nclass Item: NSManagedObject { /* ... boilerplate ... */ }\n\n// In Item+CoreDataProperties.swift\npublic class Item: NSManagedObject {\n    @NSManaged public var name: String\n    @NSManaged public var timestamp: Date\n}\n\n// --- SwiftData (self-contained in one file) ---\nimport SwiftData\n\n@Model\nfinal class Item {\n    var name: String\n    var timestamp: Date\n    \n    // Uses a standard Swift initializer\n    init(name: String, timestamp: Date) {\n        self.name = name\n        self.timestamp = timestamp\n    }\n}\n```\n\n**Common Pitfalls or Edge Cases:**\n- **Core Data:** The primary pitfall is misuse of `NSManagedObjectContext` across threads, a classic source of crashes. The disconnect between the data model file and the `NSManagedObject` subclasses can also lead to runtime errors if they get out of sync.\n- **SwiftData:** Its main weakness is immaturity. It lacks some of Core Data's advanced features like fetch request templates, custom migration policies, and multiple store configurations. The macro \"magic\" can sometimes make debugging less transparent than Core Data's explicit nature.\n\n**When to Use vs. Alternatives:**\n- **Choose SwiftData** for new projects targeting iOS 17+ that are heavily invested in SwiftUI. It drastically reduces boilerplate and embraces modern Swift idioms, accelerating development.\n- **Stick with Core Data** for projects that must support older iOS versions (<17), have complex requirements (e.g., multiple stores, fetched properties), or involve migrating a large, existing Core Data codebase where a full rewrite is impractical.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "Core Data",
        "SwiftData",
        "architecture",
        "ios17"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "You need to securely store a user's OAuth token. Describe your strategy using Keychain, focusing on the security attributes, query structure, and handling updates.",
      "back": "The Keychain is a secure, encrypted database managed by the OS, separate from the app's sandbox, designed for small, sensitive data like credentials or keys.\n\n**Core Concept:**\nInteraction with Keychain is done via the C-style Security framework APIs. We build a query dictionary to define the item and the operation (add, find, update, delete). Key components of this query are:\n- `kSecClass`: The type of data. `kSecClassGenericPassword` is ideal for arbitrary data like an OAuth token.\n- `kSecAttrService`: A unique identifier for your app's service, often the bundle ID, to prevent collisions.\n- `kSecAttrAccount`: A key to identify the specific piece of data, like a user's ID or a token type.\n- `kSecValueData`: The actual sensitive data, encoded as `Data`.\n- `kSecAttrAccessible`: This is critical for security. `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` is a strong choice. It ensures the data is only accessible when the device is unlocked and is not migrated to new devices via backups, forcing re-authentication.\n\n**Practical Code Example:**\nThis example shows a robust save/update pattern.\n```swift\nfunc save(token: String, for account: String) -> OSStatus {\n    guard let data = token.data(using: .utf8) else { return errSecInvalidData }\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"com.myapp.tokenservice\", // Unique service identifier\n        kSecAttrAccount as String: account,\n        kSecValueData as String: data,\n        // Most secure: only available when unlocked, not in backups to other devices.\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n\n    // Delete any existing item first to ensure a clean state.\n    SecItemDelete(query as CFDictionary)\n\n    // Add the new item.\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Common Pitfalls:**\n1.  **Ignoring `OSStatus` return codes:** Not checking for `errSecSuccess`, `errSecItemNotFound`, or `errSecDuplicateItem` can lead to silent failures. A common pattern is to try adding an item, and if it fails with `errSecDuplicateItem`, then perform an update.\n2.  **Choosing weak accessibility attributes:** Using `kSecAttrAccessibleAlways` makes data readable even on a locked device, which is a major security risk for sensitive tokens.\n3.  **Storing large data:** Keychain is not designed for large data blobs. This can slow down device backups and iCloud Keychain sync.\n4.  **Simulator unreliability:** Keychain on the simulator has different security guarantees than on a real device. Always test Keychain logic on physical hardware.\n\n**When to Use vs. Alternatives:**\n- **Use Keychain for:** Small, highly sensitive data that must persist across app launches and even app reinstalls (e.g., credentials, cryptographic keys).\n- **Alternatives:**\n  - `UserDefaults`: For non-sensitive user preferences. It is unencrypted and easily readable.\n  - `Core Data`/`Realm`: For large sets of structured application data. While they can be encrypted, the security is managed by your app, not the OS at a low level.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Describe Core Data's multi-layered caching mechanism. How would you diagnose and resolve a performance bottleneck caused by repeated faulting when traversing a one-to-many relationship?",
      "back": "Core Data employs a sophisticated multi-layered caching strategy to balance memory usage and performance. Understanding these layers is key to optimization.\n\n**Core Concept Explanation:**\n1.  **`NSManagedObjectContext` (MOC) Cache:** This is the primary, in-memory object graph or \"scratchpad.\" It guarantees *uniquing*: for any given record in the persistent store, only one `NSManagedObject` instance will exist within a specific MOC. Accessing an object already registered in the MOC is extremely fast.\n2.  **`NSPersistentStoreCoordinator` (PSC) Cache:** Sits below the MOCs. It caches the raw row data (property values) retrieved from the persistent store. If a MOC requests an object that isn't in its own cache, it asks the PSC. If the PSC has the row data cached, it can fulfill the request without hitting the disk, which is significantly faster than a full fetch.\n3.  **`NSPersistentStore` (e.g., SQLite):** The disk-based store. This is the slowest layer. A cache miss at the PSC level results in an I/O operation (an SQL query) to retrieve the data.\n\n**Faulting and the N+1 Problem:**\nBy default, Core Data uses *faulting* (lazy loading). When you fetch objects, their relationships are represented by placeholder objects called faults. Accessing a faulted relationship triggers a separate fetch to the store to populate it. When you iterate over a list of `N` objects and access a relationship on each, you trigger `N` additional fetches, leading to the classic \"N+1 query problem,\" which is a major performance bottleneck.\n\n**Diagnosis and Resolution Code Example:**\nTo diagnose, enable the launch argument `-com.apple.CoreData.SQLDebug 1`. This will print all SQL queries to the console. You'll see one initial query followed by many individual queries in a loop.\n\nTo resolve this, use prefetching:\n\n```swift\n// Assume a 'Post' entity with a to-many relationship 'comments' to a 'Comment' entity.\n\nfunc fetchPostsWithComments(context: NSManagedObjectContext) -> [Post] {\n    let fetchRequest: NSFetchRequest<Post> = Post.fetchRequest()\n\n    // BAD: This will cause an N+1 problem when accessing post.comments in a loop.\n    // let posts = try? context.fetch(fetchRequest)\n\n    // GOOD: Prefetch the 'comments' relationship.\n    // Core Data will perform a more efficient join or a second query to fetch all\n    // necessary comments for the posts in one go.\n    fetchRequest.relationshipKeyPathsForPrefetching = [\"comments\"]\n\n    do {\n        let posts = try context.fetch(fetchRequest)\n        // Now, iterating through posts and accessing post.comments will not trigger\n        // individual fetches for each post's comments.\n        return posts\n    } catch {\n        print(\"Failed to fetch posts: \\(error)\")\n        return []\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Over-Prefetching:** Don't prefetch deep or wide relationship chains that you don't actually need. This can load excessive data into memory, negating the benefits of lazy loading and causing high memory pressure.\n*   **Confusing with `returnsObjectsAsFaults = false`:** Setting this to `false` fetches the full property values for the primary entity (`Post` in our example), but it does *not* fetch the related objects. It's used to avoid property-level faulting, not relationship faulting.\n\n**When to Use vs. Alternatives:**\n*   **Default Faulting (Lazy):** Ideal when displaying a list where the user will only interact with a few items to see details. It minimizes initial memory load.\n*   **Prefetching (Eager):** Use when you know you will access the relationship for most or all of the fetched objects, such as displaying a list of posts along with their comment counts.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "performance",
        "caching"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    }
  ]
}