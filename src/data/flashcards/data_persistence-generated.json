{
  "topic": "data_persistence",
  "generated_at": "2026-01-10T03:57:26.895050+00:00",
  "cards": [
    {
      "id": "data_persistence_df6a8453f934",
      "front": "Explain Core Data's multi-level caching mechanism. How would you architect a fetch to mitigate performance issues like the N+1 query problem when displaying a list of objects and their relationships?",
      "back": "Core Data employs a sophisticated two-level in-memory caching strategy to minimize expensive disk I/O. Understanding this is key to writing performant apps.\n\n**Core Concept Explanation:**\n1.  **`NSManagedObjectContext` (MOC) Cache:** This is the first-level cache, often called the \"scratchpad.\" It holds the managed objects you are actively working with. It ensures object uniquing, meaning for any given data record, only one managed object instance exists within that context. When you fetch or access an object, the MOC is checked first. This level is extremely fast.\n\n2.  **`NSPersistentStoreCoordinator` (PSC) Cache:** This is the second-level, shared cache. When a MOC needs data that isn't in its own cache, it asks the PSC. The PSC maintains a cache of the raw row data (snapshots) recently fetched from the persistent store (e.g., SQLite). If the PSC has the data, it can fulfill the request without hitting the disk, which is significantly faster than a full database query but slower than the MOC cache.\n\nWhen you access a relationship on a managed object that hasn't been loaded (a \"fault\"), Core Data traverses this chain: MOC -> PSC -> SQLite Store. The N+1 query problem occurs when you fetch N objects and then loop through them, accessing a fault for each one, resulting in 1 initial fetch + N subsequent fetches.\n\n**Practical Code Example:**\nTo solve the N+1 problem, we use prefetching. This tells Core Data to fetch the related objects in a single, more efficient follow-up query.\n\n```swift\n// Fetching artists and prefetching their albums to avoid N+1 faults\nlet fetchRequest: NSFetchRequest<Artist> = Artist.fetchRequest()\n\n// ** THE KEY OPTIMIZATION **\n// This tells the PSC to fetch all related 'albums' for the artists\n// in a single, optimized batch, populating the cache efficiently.\nfetchRequest.relationshipKeyPathsForPrefetching = [\"albums\"]\n\n// In a UITableView or SwiftUI List, you'd iterate through artists.\ndo {\n    let artists = try viewContext.fetch(fetchRequest)\n    for artist in artists {\n        // Accessing 'albums' is now fast. It hits the MOC cache because\n        // the data was pre-warmed by the fetch request.\n        // No new database trip is made inside this loop.\n        let albumCount = artist.albums?.count ?? 0\n        print(\"\\(artist.name) has \\(albumCount) albums.\")\n    }\n} catch {\n    print(\"Fetch failed: \\(error)\")\n}\n```\n\n**Common Pitfalls:**\n- **Forgetting to Prefetch:** The most common mistake is fetching a list of objects and then accessing a relationship inside a loop, causing a separate fetch for each object and ruining UI performance.\n- **Over-Prefetching:** Specifying too many or deeply nested keypaths in `relationshipKeyPathsForPrefetching` can cause a massive initial data load, consuming significant memory and time. Only prefetch what you need for the current view.\n- **Confusing Prefetching with `returnsObjectsAsFaults = false`:** Setting `returnsObjectsAsFaults` to `false` fetches all scalar properties for the primary objects, but it does *not* fetch related objects. Prefetching is specifically for relationships.\n\n**When to Use vs. Alternatives:**\n- **Use Prefetching:** The standard solution for displaying lists of objects with their related data. Ideal for `UITableView` and `UICollectionView` data sources.\n- **Use Manual Batch Faulting:** If objects are already in the context, you can execute a separate fetch request with a predicate like `NSPredicate(format: \"SELF IN %@\", objectsToFault)` to fire their faults in a batch.\n- **Use Dictionary Result Type:** For read-only, aggregate, or data-processing tasks where you don't need the overhead of the managed object graph. It's much faster as it bypasses object creation entirely.",
      "code_example": null,
      "tags": [
        "core-data",
        "persistence",
        "caching",
        "performance",
        "n+1"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_59337dbc4bff",
      "front": "Your app has an evolving Core Data model. Compare Lightweight and Heavyweight migrations, and describe a scenario where you would need to implement a progressive migration strategy.",
      "back": "Core Data migration is the process of updating a user's local database to match a new version of your app's data model.\n\n**Core Concepts:**\n\n1.  **Lightweight Migration**: This is an automatic process where Core Data infers the changes between the old and new data models. It's suitable for simple changes like adding/removing entities or attributes, renaming an entity/attribute (using the `renamingIdentifier` in the Xcode inspector), or adding/changing relationships. It is the preferred method due to its simplicity and reliability.\n\n2.  **Heavyweight Migration**: This is a manual process required for complex schema changes that Core Data cannot infer. Examples include splitting one entity into two, merging attributes, or changing an attribute's type in a non-trivial way (e.g., `String` to a transformable `Data` representation). It requires creating a Mapping Model (`.xcmappingmodel`) in Xcode and potentially a custom `NSEntityMigrationPolicy` subclass to define the transformation logic in code.\n\n3.  **Progressive Migration**: This is a strategy, not a type of migration. It's used when your app has many model versions. Instead of creating a single, complex mapping from a very old version (v1) to the latest (v5), you migrate the data incrementally: v1 -> v2, v2 -> v3, and so on. This is crucial for ensuring all users can upgrade successfully, as it simplifies each migration step to only handle adjacent version changes.\n\n**Practical Code Example:**\n```swift\n// 1. Enabling Lightweight Migration (most common)\nlet container = NSPersistentContainer(name: \"MyModel\")\nguard let description = container.persistentStoreDescriptions.first else {\n    fatalError(\"###<fatal>### Failed to retrieve a persistent store description.\")\n}\n\n// These two options enable automatic lightweight migration\ndescription.shouldInferMappingModelAutomatically = true\ndescription.shouldMigrateStoreAutomatically = true\n\ncontainer.loadPersistentStores { (storeDescription, error) in\n    if let error = error as NSError? {\n        // Handle migration or loading error\n        fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n    }\n}\n```\n\n**Common Pitfalls:**\n*   **Blocking UI**: Large migrations can take time and will freeze the app if run on the main thread. Always load persistent stores on a background queue.\n*   **Assuming Lightweight Works**: Underestimating a schema change and assuming lightweight migration will succeed when a heavyweight migration is needed. This can lead to crashes on launch for existing users.\n*   **Data Loss**: An improperly configured `NSEntityMigrationPolicy` can lead to data loss. Thoroughly test all migration paths with realistic data.\n*   **Forgetting to Version**: You must create a new model version in your `.xcdatamodeld` file for every schema change and set it as the active version.\n\n**When to Use vs. Alternatives:**\n*   **Use Lightweight** for all simple, supported schema changes. It's the default and most maintainable option.\n*   **Use Heavyweight** only when transformations are too complex for lightweight migration. It adds significant development and testing overhead.\n*   **Use Progressive Strategy** for apps with a long version history to ensure a reliable upgrade path for all users, avoiding the need to maintain complex mappings from every old version to the latest.\n*   **Alternative (Export/Re-import)**: For a complete schema overhaul, it can sometimes be simpler to export user data to a neutral format (like JSON), destroy and recreate the Core Data store, and then re-import the data. This avoids migration entirely but requires robust export/import logic.",
      "code_example": null,
      "tags": [
        "core-data",
        "data-persistence",
        "migration"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_bb47d01824a0",
      "front": "You need to store a user's sensitive API token. How would you use Keychain Services, and which `kSecAttrAccessible` attribute would you choose? Explain the trade-offs between security and user convenience for different options.",
      "back": "Keychain Services provides a secure, encrypted database for storing small amounts of sensitive user data, like passwords, keys, and tokens. It operates outside the app's sandbox, meaning data persists even if the app is deleted and is protected by the OS.\n\n**Core Concept:**\nThe core of using Keychain is constructing a query dictionary to perform C-style CRUD operations (`SecItemAdd`, `SecItemCopyMatching`, `SecItemUpdate`, `SecItemDelete`). The most critical attribute for security policy is `kSecAttrAccessible`. It defines *when* your app can access the stored item.\n\nFor an API token, `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` is an excellent choice. \n- `AfterFirstUnlock`: The data is accessible once the user unlocks their device for the first time after a reboot. It remains accessible even if the user locks their screen, allowing background tasks to refresh tokens.\n- `ThisDeviceOnly`: This suffix prevents the item from being backed up to iCloud or synced to other devices via iCloud Keychain, which is critical for tokens tied to a specific device instance.\n\n**Trade-offs:**\n- `.whenUnlockedThisDeviceOnly`: More secure, as data is inaccessible when the device is locked. However, this breaks background processes that might need the token while the device is locked.\n- `.afterFirstUnlockThisDeviceOnly`: The balanced choice. Securely stored, but available for background tasks after the initial unlock.\n- `.alwaysThisDeviceOnly`: Least secure. Accessible even on a locked device. Avoid unless absolutely necessary.\n\n**Code Example:**\n```swift\n// A simplified Keychain wrapper\nclass KeychainService {\n    static let service = \"com.yourapp.api\"\n\n    static func save(token: String, for account: String) -> Bool {\n        guard let data = token.data(using: .utf8) else { return false }\n\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrService as String: service,\n            kSecAttrAccount as String: account,\n            kSecValueData as String: data,\n            // Crucial security attribute\n            kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly\n        ]\n\n        // Clear any old item before saving\n        SecItemDelete(query as CFDictionary)\n\n        let status = SecItemAdd(query as CFDictionary, nil)\n        return status == errSecSuccess\n    }\n\n    static func load(for account: String) -> String? {\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrService as String: service,\n            kSecAttrAccount as String: account,\n            kSecReturnData as String: true, // We want the data back\n            kSecMatchLimit as String: kSecMatchLimitOne // We expect one result\n        ]\n\n        var dataTypeRef: AnyObject?\n        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)\n\n        if status == errSecSuccess,\n           let data = dataTypeRef as? Data,\n           let token = String(data: data, encoding: .utf8) {\n            return token\n        }\n        return nil\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Ignoring `OSStatus` codes:** Not handling `errSecItemNotFound` gracefully or other potential errors can lead to crashes or unexpected behavior.\n- **Storing Large Data:** Keychain is optimized for small secrets. Storing large data blobs (e.g., images) will degrade performance.\n- **Persistence on App Delete:** By default, Keychain items remain after an app is uninstalled. This can be a feature (e.g., preserving a pro-license) or a bug (e.g., leaving stale data). You may need to implement a 'first launch after install' check to wipe old data if desired.\n\n**Alternatives:**\n- **UserDefaults:** Only for non-sensitive data like user settings. It's stored unencrypted in a plist file within the app's sandbox.\n- **Encrypted File/Database:** For larger sensitive data, encrypt it with `CryptoKit` and store the file in the app's documents directory. The encryption key itself should then be stored in the Keychain.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "security",
        "keychain"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/"
      ]
    },
    {
      "id": "data_persistence_0658a152705c",
      "front": "Explain the modern Core Data stack for concurrent operations. Describe the roles of the main and background contexts, their relationship, and how you ensure thread safety and UI consistency when performing background data processing.",
      "back": "The modern Core Data stack, abstracted by `NSPersistentContainer`, is designed for safe concurrency. It provides a pre-configured stack with a main-queue context (`viewContext`) and methods to create background contexts.\n\n**Core Concept:**\nThe stack consists of:\n1.  **`NSPersistentContainer`**: The central object that encapsulates the entire stack.\n2.  **`viewContext`**: An `NSManagedObjectContext` associated with the main dispatch queue. It's intended for all UI-related data operations, such as fetching data for a table view with an `NSFetchedResultsController`.\n3.  **Background Contexts**: Created via `newBackgroundContext()` or `performBackgroundTask(_:)`. These are private-queue contexts that operate on a background thread. They are siblings to the `viewContext`, both connected to the same `NSPersistentStoreCoordinator`.\n\nThis architecture prevents blocking the UI. Heavy operations like data import, network sync, or complex processing are performed on a background context. When the background context is saved, its changes are written to the persistent store. To update the UI, the `viewContext` must merge these changes. Setting `viewContext.automaticallyMergesChangesFromParent = true` instructs the `viewContext` to automatically absorb saves from sibling contexts that share the same persistent store coordinator.\n\n**Practical Code Example:**\n```swift\n// Setup in your Core Data manager\nclass CoreDataManager {\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"MyAppModel\")\n        container.loadPersistentStores { _, error in /* handle error */ }\n\n        // Key for UI consistency: automatically merge changes\n        // from background contexts into the main UI context.\n        container.viewContext.automaticallyMergesChangesFromParent = true\n        return container\n    }()\n\n    func importLargeDataSet() {\n        // performBackgroundTask provides a temporary background context.\n        persistentContainer.performBackgroundTask { backgroundContext in\n            // This block executes on a private background queue.\n            for i in 0..<1000 {\n                let user = User(context: backgroundContext)\n                user.id = UUID()\n                user.name = \"User \\(i)\"\n            }\n            \n            do {\n                // Saving the background context writes changes to the\n                // persistent store. The viewContext will merge these changes.\n                try backgroundContext.save()\n            } catch {\n                print(\"Failed to save background context: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n- **Passing `NSManagedObject`s between threads:** This is the most common cause of crashes. A managed object is not thread-safe. Instead, pass its `NSManagedObjectID` and then fetch the object again in the destination context.\n- **Blocking the UI:** Performing a large save or a complex fetch on the `viewContext` will freeze the UI. Always offload this work.\n- **Stale UI Data:** Forgetting to set `viewContext.automaticallyMergesChangesFromParent = true` or manually merging changes. The UI will not reflect background updates until the next fetch or app relaunch.\n\n**When to use vs alternatives:**\nThis sibling-context model is the standard for most applications. The older parent/child context pattern is less common now but still useful for creating isolated \"scratchpads\". For instance, an edit screen can use a child context. If the user saves, the child context is saved (pushing changes to the parent `viewContext`); if they cancel, the child context is simply discarded without affecting the main data.",
      "code_example": null,
      "tags": [
        "core-data",
        "persistence",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_4ef0b438bba1",
      "front": "SwiftData abstracts the Core Data stack. Explain how `@Model`, `ModelContainer`, and `ModelContext` map to Core Data concepts and discuss the implications of this abstraction for concurrency and data management.",
      "back": "SwiftData is a modern, Swift-native persistence framework built on top of Core Data, abstracting away its complexities. Its components map directly to Core Data's stack, but with significant ergonomic and concurrency improvements.\n\n**Core Concept Mapping:**\n1.  **`@Model` Macro**: This is analogous to an `NSManagedObject` subclass and its corresponding `NSEntityDescription` in the data model editor. The macro synthesizes the necessary code to make a plain Swift class persistable, automatically handling property observation and change tracking.\n\n2.  **`ModelContainer`**: This maps to `NSPersistentContainer`. It's the central configuration point that sets up the entire persistence stack, including the schema (inferred from `@Model` classes), the backing store (e.g., SQLite), and options like CloudKit syncing. It manages what Core Data calls the `NSPersistentStoreCoordinator` and `NSPersistentStore` under the hood.\n\n3.  **`ModelContext`**: This is the direct equivalent of `NSManagedObjectContext` (MOC). It's the in-memory scratchpad for creating, fetching, updating, and deleting model objects. All operations are tracked by the context, which then saves changes to the persistent store.\n\n**Implications of Abstraction:**\n*   **Concurrency**: This is the most significant change. `ModelContext` is actor-bound, not just thread-confined. The main context, accessed via the environment, lives on the `@MainActor`. For background work, you must create a new context from the container and perform operations within a background actor. Passing model instances between actors is forbidden; you must pass their `PersistentIdentifier` and re-fetch them in the new context.\n*   **Data Management**: Setup is drastically simplified. There's no `.xcdatamodeld` file. The schema is generated from your Swift code. Saving can be automatic, though this can be disabled for explicit transactional control with `context.save()`.\n\n```swift\n// 1. @Model maps to NSManagedObject + Entity Description\n@Model\nfinal class Trip {\n    var name: String\n    var destination: String\n    @Relationship(deleteRule: .cascade) var buckets: [BucketItem]?\n\n    init(name: String, destination: String) {\n        self.name = name\n        self.destination = destination\n    }\n}\n\n// In your App struct:\n@main\nstruct TravelApp: App {\n    // 2. ModelContainer maps to NSPersistentContainer\n    let container = try! ModelContainer(for: Trip.self)\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .modelContainer(container) // Injects the container into the environment\n    }\n}\n\n// In your View:\nstruct ContentView: View {\n    // 3. ModelContext maps to NSManagedObjectContext\n    @Environment(\\.modelContext) private var modelContext\n    @Query private var trips: [Trip]\n\n    func addTrip() {\n        let newTrip = Trip(name: \"Honeymoon\", destination: \"Hawaii\")\n        modelContext.insert(newTrip) // Changes are tracked by the context\n        // By default, autosave is on. For manual control:\n        // try? modelContext.save()\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\n*   **Cross-Actor Model Access**: A common crash for newcomers is passing a fetched model object from the main actor to a background actor. Always pass the `PersistentIdentifier` instead.\n*   **Over-reliance on Autosave**: While convenient, autosave can hide transaction boundaries. For complex operations that must succeed or fail as a group, disable autosave for that context and use explicit `save()` calls within a `do-catch` block.\n\n**When to Use vs. Core Data:**\n*   **SwiftData**: The default choice for new projects targeting iOS 17+ that use SwiftUI. Its tight integration with Swift Concurrency and SwiftUI makes development faster and safer.\n*   **Core Data**: Use for projects supporting older iOS versions, or for existing, highly complex applications where a migration is not feasible. Core Data still offers more fine-grained control over certain advanced features like custom validation rules and fetched properties, which may be necessary in some enterprise-level apps.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "swiftdata",
        "core_data",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_2eb6ab885fc3",
      "front": "How do you implement a safe and efficient background data processing task in Core Data, ensuring the UI remains responsive and data integrity is maintained upon merging changes back to the main thread?",
      "back": "The core principle of Core Data concurrency is that a `NSManagedObjectContext` is bound to a specific queue and is not thread-safe. To perform background work, you must use a separate context on a background queue.\n\n**Core Concept:**\nThe modern approach uses `NSPersistentContainer`. The container's `viewContext` operates on the main queue for UI-related work. For background tasks, you can either create a new private context with `container.newBackgroundContext()` or use the convenience method `container.performBackgroundTask(_:)` which handles context creation and execution for you. \n\nWhen the background context is saved, its changes are committed to the `NSPersistentStore`. To reflect these changes in the UI, the `viewContext` must be updated. The easiest way is to set `viewContext.automaticallyMergesChangesFromParent = true`. This makes the `viewContext` listen for notifications from its persistent store coordinator and automatically merge in changes saved by other contexts.\n\n**Code Example:**\n```swift\n// In your Core Data stack setup (e.g., AppDelegate or a DataController)\nlazy var persistentContainer: NSPersistentContainer = {\n    let container = NSPersistentContainer(name: \"MyApp\")\n    container.loadPersistentStores { ... }\n    // Key step for automatic UI updates\n    container.viewContext.automaticallyMergesChangesFromParent = true\n    return container\n}()\n\n// Function to perform a background update\nfunc importLargeJSON() {\n    // performBackgroundTask provides a temporary, private queue context\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // You can configure the context further if needed\n        backgroundContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n\n        // Perform fetch, decode, and data insertion here\n        // This work happens entirely off the main thread\n        let request: NSFetchRequest<Item> = Item.fetchRequest()\n        if let itemsToUpdate = try? backgroundContext.fetch(request) {\n            itemsToUpdate.forEach { $0.lastUpdated = Date() }\n        }\n\n        // Save changes on the background context to persist them to the store\n        do {\n            try backgroundContext.save()\n        } catch {\n            // Handle the save error, e.g., log it\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}\n```\n\n**Common Pitfalls:**\n1.  **Passing `NSManagedObject`s between threads:** This will crash your app. `NSManagedObject` instances are not thread-safe. Instead, pass the thread-safe `NSManagedObjectID` and use `context.object(with:)` to retrieve the corresponding object on the correct context.\n2.  **Merge Conflicts:** If the same object is modified on both the main and background contexts, a conflict occurs upon saving. The default `NSErrorMergePolicy` will cause the save to fail. Set a different merge policy like `NSMergeByPropertyObjectTrumpMergePolicy` (in-memory changes win) or `NSMergeByPropertyStoreTrumpMergePolicy` (persistent store's version wins) to handle conflicts automatically.\n3.  **UI Not Updating:** Forgetting to set `viewContext.automaticallyMergesChangesFromParent = true` is a common mistake. The background save will succeed, but the UI (e.g., an `NSFetchedResultsController`) won't reflect the changes until the app is relaunched or the data is manually re-fetched.\n\n**When to use vs. Alternatives:**\nThis pattern is essential for any long-running data task, such as syncing with a server, importing/exporting large files, or performing complex data migrations. The alternative is doing work on the main `viewContext`, which is only acceptable for very quick, user-initiated changes that won't block the UI. For older projects not using `NSPersistentContainer`, you would manually create contexts and observe `NSManagedObjectContextDidSave` notifications to merge changes.",
      "code_example": null,
      "tags": [
        "Core Data",
        "Concurrency",
        "Persistence",
        "iOS"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    },
    {
      "id": "data_persistence_8b4d32ff8bcc",
      "front": "You're starting a new project. Justify choosing the mature Core Data framework over the modern SwiftData. What key architectural differences and trade-offs, especially concerning concurrency and data modeling, would drive this decision?",
      "back": "Choosing Core Data over SwiftData is a decision driven by the need for control, maturity, and compatibility over developer convenience and modernity.\n\n**Core Concept Explanation:**\nCore Data is a powerful object graph management framework, not just a persistence layer. Its architecture is explicit and complex, comprising the `NSManagedObjectModel`, `NSPersistentStoreCoordinator`, and `NSManagedObjectContext`. This granular structure provides deep control over storage, caching, and transactions. Its concurrency model is context-bound, requiring developers to manually manage thread safety using `perform(_:)` blocks on specific context queues.\n\nSwiftData, built on top of Core Data's engine, is a modern, Swift-native abstraction. It replaces the complex stack with a declarative API using macros (`@Model`) and a simplified `ModelContext`. It is designed for Swift Concurrency, integrating seamlessly with `Actor`s and making thread management far simpler and safer. The trade-off is a loss of the fine-grained control that Core Data offers; SwiftData is more opinionated.\n\n**Practical Code Example:**\n```swift\n// Core Data: Requires .xcdatamodeld setup and a generated subclass\n// Item+CoreDataClass.swift\npublic class Item: NSManagedObject { /* ... boilerplate ... */ }\n\n// Item+CoreDataProperties.swift\nextension Item {\n    @NSManaged public var name: String\n    @NSManaged public var timestamp: Date\n}\n\n// SwiftData: A single, simple Swift type definition\nimport SwiftData\n\n@Model\nfinal class Item {\n    var name: String\n    var timestamp: Date\n\n    init(name: String, timestamp: Date) {\n        self.name = name\n        self.timestamp = timestamp\n    }\n}\n```\n\n**Common Pitfalls & Edge Cases:**\nThe primary reason to stick with Core Data is to avoid SwiftData's current limitations. SwiftData (as of iOS 17) lacks support for some of Core Data's advanced features, such as multiple persistent stores per container, custom data transformers for non-Codable types, and fine-grained control over migration policies. If your project has complex, non-linear migration paths or needs to connect to multiple SQLite files simultaneously, Core Data is the only viable first-party option.\n\n**When to Use vs. Alternatives:**\n*   **Choose Core Data when:**\n    1.  **Complex Configurations:** You need multiple persistent stores (e.g., one read-only, one user-writable) managed by a single coordinator.\n    2.  **Heavyweight Migrations:** The app requires complex, multi-stage, or custom-coded data migrations.\n    3.  **Legacy Interoperability:** The project has a significant Objective-C codebase or relies on mature, battle-tested behavior.\n    4.  **Targeting Older OS:** The app must support OS versions prior to iOS 17.\n*   **Choose SwiftData when:**\n    1.  Starting a new, SwiftUI-centric app for iOS 17+.\n    2.  Prioritizing development speed and reduced boilerplate.\n    3.  A modern, `async/await`-based concurrency model is a primary architectural goal.",
      "code_example": null,
      "tags": [
        "data_persistence",
        "core_data",
        "swiftdata",
        "concurrency",
        "architecture"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/"
      ]
    }
  ]
}