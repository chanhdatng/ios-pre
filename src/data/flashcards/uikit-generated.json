{
  "topic": "uikit",
  "generated_at": "2026-01-08T03:55:15.486206+00:00",
  "cards": [
    {
      "id": "uikit_cbb58d70cd1a",
      "front": "Describe the UIViewController lifecycle. What responsibilities do you typically handle in each phase, and why? Discuss potential issues.",
      "back": "The lifecycle consists of: `loadView`, `viewDidLoad`, `viewWillAppear`, `viewDidAppear`, `viewWillDisappear`, `viewDidDisappear`, and `dealloc`. \n\n- `loadView`: Rarely overridden. Creates the view. Avoid heavy operations here.\n- `viewDidLoad`:  One-time setup, data initialization, UI configuration.  Avoid network requests that block UI.\n- `viewWillAppear`: Called before view appears. Good for refreshing data, hiding/unhiding elements.  Consider animation performance.\n- `viewDidAppear`: Called after view appears. Start animations, analytics tracking. Avoid long blocking operations.\n- `viewWillDisappear`:  Called before view disappears.  Save state, stop timers, remove observers.  Ensure timely cleanup.\n- `viewDidDisappear`: Called after view disappears. Release resources.  Clean up notifications.\n- `dealloc`:  Release retained objects to prevent memory leaks.  Unregister from notifications and KVO.\n\nPotential issues: Incorrect resource management in `dealloc`, blocking the main thread in `viewDidLoad`, forgetting to save/restore state.",
      "code_example": null,
      "tags": [
        "uikit",
        "viewcontroller",
        "lifecycle"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/"
      ]
    },
    {
      "id": "uikit_3907f47b5463",
      "front": "How do you programmatically create Auto Layout constraints in UIKit, and what are the advantages/disadvantages compared to using Storyboards?",
      "back": "Programmatically, create `NSLayoutConstraint` instances & activate them.  Crucially, `translatesAutoresizingMaskIntoConstraints = false` must be set on views using programmatic constraints.  Advantage: Code is explicit, easier to debug, merge conflicts are simpler. Disadvantage: More verbose, potentially harder to visualize layout initially. Example: `myView.topAnchor.constraint(equalTo: superview.topAnchor, constant: 20).isActive = true`. Can also use layout anchors.",
      "code_example": null,
      "tags": [
        "uikit",
        "autolayout",
        "programmatic",
        "constraints"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.hackingwithswift.com/articles/281/what-to-fix-in-ai-generated-swift-code",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "uikit_52abee5c8d09",
      "front": "How does `UICollectionViewCompositionalLayout` improve upon prior `UICollectionViewLayout` approaches? Explain its core components and benefits.",
      "back": "`Compositional Layout` allows creating complex layouts by composing smaller, reusable layout components. Key components are `NSCollectionLayoutItem`, `NSCollectionLayoutGroup`, and `NSCollectionLayoutSection`. Benefits include increased flexibility, easier code reuse, declarative layout definitions, and better performance compared to manual calculations in custom layouts. e.g. create a staggered grid layout, or a carousel without manual calculations.",
      "code_example": null,
      "tags": [
        "uikit",
        "collectionview",
        "compositional layout"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.hackingwithswift.com/articles/269/whats-new-in-swift-6",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "uikit_4f13a4d89b98",
      "front": "Explain the benefits of using Diffable Data Sources over older approaches like `reloadData()`.",
      "back": "Diffable Data Sources enhance performance by only updating changed cells instead of reloading the entire data set.  They also improve code clarity/reduce bugs by automatically managing data consistency between the data model and the UI. They remove the possibility of out-of-sync issues when using `reloadData()` incorrectly.",
      "code_example": null,
      "tags": [
        "UIKit",
        "DiffableDataSource",
        "Performance"
      ],
      "sources": [
        "https://www.objc.io/issues/4-core-data/core-data-overview/",
        "https://www.avanderlee.com/swift/core-data/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    },
    {
      "id": "uikit_022fbd7dc4a5",
      "front": "Discuss strategies for integrating SwiftUI views into existing UIKit apps. What are the tradeoffs?",
      "back": "Use `UIHostingController` to embed SwiftUI views in UIKit.  \nConsider: performance overhead of interop, managing data flow between frameworks (using Combine or delegation).  UIKit can also be used within SwiftUI via `UIViewRepresentable`. Careful planning is needed for navigation and state management.\nSwiftUI views might not fully respect existing UIKit theming.",
      "code_example": null,
      "tags": [
        "SwiftUI",
        "UIKit",
        "Interop",
        "UIHostingController",
        "UIViewRepresentable",
        "Combine"
      ],
      "sources": [
        "https://www.hackingwithswift.com/articles/258/whats-new-in-swift-5-9",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "uikit_5dc293584478",
      "front": "Describe the process of creating custom view controller transitions in UIKit. What key components are involved, and what protocols must you implement?",
      "back": "Custom transitions involve `UIViewControllerAnimatedTransitioning` (animation details), `UIViewControllerTransitioningDelegate` (provides the animator and interaction controller), and the presenting/presented view controllers. The delegate method `animationController(forPresented/Dismissed)` returns the animator object.  Interactive transitions use `UIPercentDrivenInteractiveTransition`.",
      "code_example": null,
      "tags": [
        "uikit",
        "transitions",
        "animation",
        "view controller"
      ],
      "sources": [
        "https://www.objc.io/issues/15-testing/xctest/",
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.hackingwithswift.com/articles/245/build-your-first-swiftui-app-with-swift-playgrounds"
      ]
    },
    {
      "id": "uikit_f81b8d0bd6a2",
      "front": "Explain the responder chain in UIKit. How does it work and why is it important?",
      "back": "The responder chain is a hierarchy of objects that can respond to events. When an event occurs (e.g., a touch), UIKit delivers it to the first responder (often the view where the touch occurred). If the first responder doesn't handle the event, it's passed up the chain to the next responder, typically the superview, then the view controller, the window, the app delegate, and finally the application object.  It's important because it allows events to be handled by the most appropriate object in the app, promoting separation of concerns.  E.g., a custom button subclass might handle a specific touch event, while the view controller handles more general events.",
      "code_example": null,
      "tags": [
        "uikit",
        "responder chain",
        "events",
        "ios"
      ],
      "sources": [
        "https://www.objc.io/issues/13-architecture/viper/",
        "https://www.objc.io/issues/15-testing/xctest/"
      ]
    }
  ]
}