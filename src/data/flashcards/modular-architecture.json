{
  "topic": "modular-architecture",
  "title": "Modular Architecture & Dependency Injection",
  "description": "Essential patterns for scalable iOS apps at FAANG companies",
  "cards": [
    {
      "id": "modular_001",
      "front": "Design a modular iOS app architecture for a team of 20+ engineers. How would you structure it to avoid merge conflicts and enable independent feature development?",
      "back": "**Modular Architecture for Large Teams:**\n\n**Structure:**\n```\nApp/\n├── Core/           # Shared utilities, extensions\n├── Domain/         # Business logic, entities\n├── Data/           # Repositories, networking\n├── Features/       # Independent feature modules\n│   ├── Auth/\n│   ├── Home/\n│   ├── Profile/\n│   └── Settings/\n└── App/            # App delegate, coordinator\n```\n\n**Key Principles:**\n1. **Feature modules are isolated** - Each feature has its own target/package\n2. **Dependency flows downward** - Features depend on Core/Domain, not each other\n3. **Protocol-based boundaries** - Features communicate via protocols defined in Domain\n4. **Independent compilation** - Each module can build separately\n\n**Implementation with SPM:**\n```swift\n// Package.swift\nlet package = Package(\n    name: \"MyApp\",\n    products: [\n        .library(name: \"Core\", targets: [\"Core\"]),\n        .library(name: \"AuthFeature\", targets: [\"AuthFeature\"]),\n    ],\n    targets: [\n        .target(name: \"Core\"),\n        .target(name: \"AuthFeature\", dependencies: [\"Core\"]),\n    ]\n)\n```\n\n**Benefits:**\n- Parallel development without merge conflicts\n- Faster build times (incremental compilation)\n- Clear ownership boundaries\n- Easier testing and code review",
      "tags": ["architecture", "modular", "scalability", "team"],
      "sources": ["https://developer.apple.com/documentation/xcode/organizing-your-code-with-local-packages"],
      "summary": "Use feature-based modules with SPM/Cocoapods, enforce downward dependencies, protocol boundaries between modules."
    },
    {
      "id": "modular_002",
      "front": "Explain the difference between initializer injection, property injection, and service locator patterns. When would you choose each?",
      "back": "**Dependency Injection Patterns:**\n\n**1. Initializer Injection (Recommended)**\n```swift\nclass PaymentService {\n    private let networkClient: NetworkClientProtocol\n    private let analytics: AnalyticsProtocol\n    \n    init(networkClient: NetworkClientProtocol, analytics: AnalyticsProtocol) {\n        self.networkClient = networkClient\n        self.analytics = analytics\n    }\n}\n```\n- **Pros:** Explicit dependencies, compile-time safety, easy testing\n- **Cons:** Can lead to long initializers\n- **Use when:** Dependencies are required and won't change\n\n**2. Property Injection**\n```swift\nclass ViewController: UIViewController {\n    var viewModel: ViewModelProtocol! // Injected after init\n}\n```\n- **Pros:** Works with UIKit's required initializers\n- **Cons:** Optional/implicitly unwrapped, runtime errors possible\n- **Use when:** Framework constraints (UIKit, Storyboards)\n\n**3. Service Locator**\n```swift\nclass ServiceLocator {\n    static let shared = ServiceLocator()\n    private var services: [String: Any] = [:]\n    \n    func register<T>(_ service: T) {\n        services[String(describing: T.self)] = service\n    }\n    \n    func resolve<T>() -> T {\n        services[String(describing: T.self)] as! T\n    }\n}\n\n// Usage\nlet network: NetworkClient = ServiceLocator.shared.resolve()\n```\n- **Pros:** Flexible, easy refactoring\n- **Cons:** Hidden dependencies, harder to test, runtime errors\n- **Use when:** Legacy code migration, gradual adoption\n\n**Recommendation:** Prefer initializer injection for new code. Use property injection for UIKit. Avoid service locator except for migrations.",
      "tags": ["dependency-injection", "design-patterns", "testing"],
      "sources": ["https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift/"],
      "summary": "Initializer injection is preferred (explicit, testable). Property injection for UIKit. Service locator only for legacy migrations."
    },
    {
      "id": "modular_003",
      "front": "You have a feature module that depends on authentication and network services. How would you invert dependencies to make the module independently testable?",
      "back": "**Dependency Inversion in Feature Modules:**\n\n**Problem:** Feature module directly depends on concrete implementations.\n```swift\n// Bad: Direct dependency\nclass ProfileFeature {\n    let authService = AuthService() // Concrete!\n    let networkClient = URLSessionClient() // Concrete!\n}\n```\n\n**Solution:** Define protocols in the feature module, inject implementations.\n\n**Step 1: Define protocols in Feature module**\n```swift\n// ProfileFeature/Protocols.swift\nprotocol AuthProviding {\n    var currentUser: User? { get }\n    func logout() async throws\n}\n\nprotocol NetworkProviding {\n    func fetch<T: Decodable>(_ endpoint: Endpoint) async throws -> T\n}\n```\n\n**Step 2: Feature uses protocols only**\n```swift\n// ProfileFeature/ProfileViewModel.swift\nclass ProfileViewModel {\n    private let auth: AuthProviding\n    private let network: NetworkProviding\n    \n    init(auth: AuthProviding, network: NetworkProviding) {\n        self.auth = auth\n        self.network = network\n    }\n}\n```\n\n**Step 3: App layer provides concrete implementations**\n```swift\n// App/DI/Container.swift\nextension AuthService: AuthProviding {}\nextension NetworkClient: NetworkProviding {}\n\nlet viewModel = ProfileViewModel(\n    auth: AuthService.shared,\n    network: NetworkClient.shared\n)\n```\n\n**Step 4: Tests use mocks**\n```swift\nclass MockAuth: AuthProviding {\n    var currentUser: User? = User.mock\n    func logout() async throws {}\n}\n\nfunc testProfile() {\n    let vm = ProfileViewModel(auth: MockAuth(), network: MockNetwork())\n    // Test without real auth/network!\n}\n```\n\n**Key Insight:** The feature module owns its protocol definitions. The app layer adapts concrete services to these protocols.",
      "tags": ["dependency-inversion", "SOLID", "testing", "protocols"],
      "sources": ["https://clean-swift.com/dependency-injection/"],
      "summary": "Feature defines protocols it needs. App layer adapts concrete implementations. Tests inject mocks. Feature never knows about concrete types."
    },
    {
      "id": "modular_004",
      "front": "What are the trade-offs between passing dependencies explicitly (initializer injection) vs. using @EnvironmentObject in SwiftUI?",
      "back": "**Initializer Injection vs. @EnvironmentObject:**\n\n**Initializer Injection:**\n```swift\nstruct ProfileView: View {\n    let viewModel: ProfileViewModel\n    \n    init(viewModel: ProfileViewModel) {\n        self.viewModel = viewModel\n    }\n}\n```\n\n| Pros | Cons |\n|------|------|\n| Explicit dependencies | Verbose prop drilling |\n| Compile-time safety | Must pass through all views |\n| Easy to test | Boilerplate in deep hierarchies |\n| Clear data flow | |\n\n**@EnvironmentObject:**\n```swift\nstruct ProfileView: View {\n    @EnvironmentObject var userStore: UserStore\n    \n    var body: some View { ... }\n}\n\n// Parent injects once\nContentView().environmentObject(UserStore())\n```\n\n| Pros | Cons |\n|------|------|\n| No prop drilling | Implicit dependencies |\n| Clean view signatures | Runtime crashes if missing |\n| Easy refactoring | Harder to test |\n| Good for app-wide state | Hidden coupling |\n\n**Best Practices:**\n\n1. **Use @EnvironmentObject for:**\n   - App-wide state (user session, theme, settings)\n   - Navigation coordinators\n   - Shared services used by many views\n\n2. **Use Initializer Injection for:**\n   - View-specific view models\n   - Feature-specific dependencies\n   - When testing is critical\n\n**Hybrid Approach:**\n```swift\nstruct FeatureView: View {\n    @EnvironmentObject var appState: AppState // App-wide\n    let viewModel: FeatureViewModel // Feature-specific\n    \n    init(viewModel: FeatureViewModel) {\n        self.viewModel = viewModel\n    }\n}\n```",
      "tags": ["swiftui", "dependency-injection", "environment-object"],
      "sources": ["https://developer.apple.com/documentation/swiftui/environmentobject"],
      "summary": "Initializer injection: explicit, testable, verbose. EnvironmentObject: implicit, convenient, runtime errors. Use hybrid approach."
    },
    {
      "id": "modular_005",
      "front": "Design a dependency container for an iOS app that scales to 100+ features. How do you handle lazy initialization and scoping?",
      "back": "**Scalable Dependency Container:**\n\n```swift\n// MARK: - Container Protocol\nprotocol DependencyContaining {\n    func resolve<T>() -> T\n    func register<T>(_ factory: @escaping () -> T, scope: Scope)\n}\n\nenum Scope {\n    case singleton    // One instance for app lifetime\n    case transient    // New instance each time\n    case scoped       // One instance per scope (e.g., per screen)\n}\n\n// MARK: - Implementation\nfinal class DependencyContainer: DependencyContaining {\n    private var factories: [String: () -> Any] = [:]\n    private var singletons: [String: Any] = [:]\n    private var scopes: [String: Scope] = [:]\n    private let lock = NSLock()\n    \n    func register<T>(_ factory: @escaping () -> T, scope: Scope = .transient) {\n        let key = String(describing: T.self)\n        lock.lock()\n        factories[key] = factory\n        scopes[key] = scope\n        lock.unlock()\n    }\n    \n    func resolve<T>() -> T {\n        let key = String(describing: T.self)\n        lock.lock()\n        defer { lock.unlock() }\n        \n        switch scopes[key] {\n        case .singleton:\n            if let existing = singletons[key] as? T {\n                return existing\n            }\n            let instance = factories[key]!() as! T\n            singletons[key] = instance\n            return instance\n            \n        case .transient, .none:\n            return factories[key]!() as! T\n            \n        case .scoped:\n            // Handle per-scope instances\n            return factories[key]!() as! T\n        }\n    }\n}\n\n// MARK: - Usage with Modules\nextension DependencyContainer {\n    func registerCoreServices() {\n        register({ NetworkClient() }, scope: .singleton)\n        register({ AnalyticsService() }, scope: .singleton)\n    }\n    \n    func registerAuthFeature() {\n        register({ AuthViewModel(network: self.resolve()) }, scope: .transient)\n    }\n}\n\n// MARK: - App Setup\nlet container = DependencyContainer()\ncontainer.registerCoreServices()\ncontainer.registerAuthFeature()\n```\n\n**For 100+ features:**\n- Each feature module has `registerXFeature()` method\n- Use property wrappers: `@Injected var service: ServiceProtocol`\n- Consider Swinject or Factory libraries for production",
      "tags": ["dependency-container", "di", "scalability", "design-patterns"],
      "sources": ["https://github.com/hmlongco/Factory"],
      "summary": "Container with singleton/transient/scoped lifetimes. Lazy initialization via factories. Thread-safe with NSLock. Module-based registration."
    }
  ]
}
